
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00040000 <_vector_start>:
   40000:	20023228 	.word	0x20023228
   40004:	000424e9 	.word	0x000424e9
   40008:	00047d79 	.word	0x00047d79
   4000c:	000424bd 	.word	0x000424bd
   40010:	000424bd 	.word	0x000424bd
   40014:	000424bd 	.word	0x000424bd
   40018:	000424bd 	.word	0x000424bd
   4001c:	000424bd 	.word	0x000424bd
	...
   4002c:	00041f65 	.word	0x00041f65
   40030:	000424bd 	.word	0x000424bd
   40034:	00000000 	.word	0x00000000
   40038:	00041f05 	.word	0x00041f05
   4003c:	000424bd 	.word	0x000424bd

00040040 <_irq_vector_table>:
   40040:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40050:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40060:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40070:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40080:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40090:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   400a0:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   400b0:	000438a5 00041fe9 00041fe9 00041fe9     .8..............
   400c0:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   400d0:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   400e0:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   400f0:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40100:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40110:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40120:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40130:	00041fe9 00041fe9 00041fe9 00041fe9     ................
   40140:	00041fe9                                ....

Disassembly of section text:

00040144 <__aeabi_uldivmod>:
   40144:	b953      	cbnz	r3, 4015c <__aeabi_uldivmod+0x18>
   40146:	b94a      	cbnz	r2, 4015c <__aeabi_uldivmod+0x18>
   40148:	2900      	cmp	r1, #0
   4014a:	bf08      	it	eq
   4014c:	2800      	cmpeq	r0, #0
   4014e:	bf1c      	itt	ne
   40150:	f04f 31ff 	movne.w	r1, #4294967295
   40154:	f04f 30ff 	movne.w	r0, #4294967295
   40158:	f000 b970 	b.w	4043c <__aeabi_idiv0>
   4015c:	f1ad 0c08 	sub.w	ip, sp, #8
   40160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   40164:	f000 f806 	bl	40174 <__udivmoddi4>
   40168:	f8dd e004 	ldr.w	lr, [sp, #4]
   4016c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   40170:	b004      	add	sp, #16
   40172:	4770      	bx	lr

00040174 <__udivmoddi4>:
   40174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   40178:	9e08      	ldr	r6, [sp, #32]
   4017a:	460d      	mov	r5, r1
   4017c:	4604      	mov	r4, r0
   4017e:	468a      	mov	sl, r1
   40180:	2b00      	cmp	r3, #0
   40182:	d17f      	bne.n	40284 <__udivmoddi4+0x110>
   40184:	428a      	cmp	r2, r1
   40186:	4617      	mov	r7, r2
   40188:	d941      	bls.n	4020e <__udivmoddi4+0x9a>
   4018a:	fab2 f282 	clz	r2, r2
   4018e:	b14a      	cbz	r2, 401a4 <__udivmoddi4+0x30>
   40190:	f1c2 0120 	rsb	r1, r2, #32
   40194:	fa05 f302 	lsl.w	r3, r5, r2
   40198:	4097      	lsls	r7, r2
   4019a:	4094      	lsls	r4, r2
   4019c:	fa20 f101 	lsr.w	r1, r0, r1
   401a0:	ea41 0a03 	orr.w	sl, r1, r3
   401a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
   401a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   401ac:	fa1f f987 	uxth.w	r9, r7
   401b0:	fbba fef8 	udiv	lr, sl, r8
   401b4:	fb08 a31e 	mls	r3, r8, lr, sl
   401b8:	fb0e f109 	mul.w	r1, lr, r9
   401bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   401c0:	4299      	cmp	r1, r3
   401c2:	d906      	bls.n	401d2 <__udivmoddi4+0x5e>
   401c4:	18fb      	adds	r3, r7, r3
   401c6:	d202      	bcs.n	401ce <__udivmoddi4+0x5a>
   401c8:	4299      	cmp	r1, r3
   401ca:	f200 8124 	bhi.w	40416 <__udivmoddi4+0x2a2>
   401ce:	f10e 3eff 	add.w	lr, lr, #4294967295
   401d2:	1a59      	subs	r1, r3, r1
   401d4:	b2a3      	uxth	r3, r4
   401d6:	fbb1 f0f8 	udiv	r0, r1, r8
   401da:	fb08 1110 	mls	r1, r8, r0, r1
   401de:	fb00 f909 	mul.w	r9, r0, r9
   401e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   401e6:	45a1      	cmp	r9, r4
   401e8:	d905      	bls.n	401f6 <__udivmoddi4+0x82>
   401ea:	193c      	adds	r4, r7, r4
   401ec:	d202      	bcs.n	401f4 <__udivmoddi4+0x80>
   401ee:	45a1      	cmp	r9, r4
   401f0:	f200 810e 	bhi.w	40410 <__udivmoddi4+0x29c>
   401f4:	3801      	subs	r0, #1
   401f6:	eba4 0409 	sub.w	r4, r4, r9
   401fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   401fe:	2100      	movs	r1, #0
   40200:	b11e      	cbz	r6, 4020a <__udivmoddi4+0x96>
   40202:	40d4      	lsrs	r4, r2
   40204:	2300      	movs	r3, #0
   40206:	e9c6 4300 	strd	r4, r3, [r6]
   4020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4020e:	b902      	cbnz	r2, 40212 <__udivmoddi4+0x9e>
   40210:	deff      	udf	#255	; 0xff
   40212:	fab2 f282 	clz	r2, r2
   40216:	2a00      	cmp	r2, #0
   40218:	d14f      	bne.n	402ba <__udivmoddi4+0x146>
   4021a:	1bcb      	subs	r3, r1, r7
   4021c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   40220:	fa1f f887 	uxth.w	r8, r7
   40224:	2101      	movs	r1, #1
   40226:	0c25      	lsrs	r5, r4, #16
   40228:	fbb3 fcfe 	udiv	ip, r3, lr
   4022c:	fb0e 301c 	mls	r0, lr, ip, r3
   40230:	462b      	mov	r3, r5
   40232:	fb08 f90c 	mul.w	r9, r8, ip
   40236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   4023a:	45a9      	cmp	r9, r5
   4023c:	d90a      	bls.n	40254 <__udivmoddi4+0xe0>
   4023e:	197d      	adds	r5, r7, r5
   40240:	bf2c      	ite	cs
   40242:	2301      	movcs	r3, #1
   40244:	2300      	movcc	r3, #0
   40246:	45a9      	cmp	r9, r5
   40248:	d902      	bls.n	40250 <__udivmoddi4+0xdc>
   4024a:	2b00      	cmp	r3, #0
   4024c:	f000 80d9 	beq.w	40402 <__udivmoddi4+0x28e>
   40250:	f10c 3cff 	add.w	ip, ip, #4294967295
   40254:	eba5 0509 	sub.w	r5, r5, r9
   40258:	b2a3      	uxth	r3, r4
   4025a:	fbb5 f0fe 	udiv	r0, r5, lr
   4025e:	fb0e 5510 	mls	r5, lr, r0, r5
   40262:	fb08 f800 	mul.w	r8, r8, r0
   40266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   4026a:	45a0      	cmp	r8, r4
   4026c:	d905      	bls.n	4027a <__udivmoddi4+0x106>
   4026e:	193c      	adds	r4, r7, r4
   40270:	d202      	bcs.n	40278 <__udivmoddi4+0x104>
   40272:	45a0      	cmp	r8, r4
   40274:	f200 80c9 	bhi.w	4040a <__udivmoddi4+0x296>
   40278:	3801      	subs	r0, #1
   4027a:	eba4 0408 	sub.w	r4, r4, r8
   4027e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   40282:	e7bd      	b.n	40200 <__udivmoddi4+0x8c>
   40284:	428b      	cmp	r3, r1
   40286:	d908      	bls.n	4029a <__udivmoddi4+0x126>
   40288:	2e00      	cmp	r6, #0
   4028a:	f000 80b1 	beq.w	403f0 <__udivmoddi4+0x27c>
   4028e:	2100      	movs	r1, #0
   40290:	e9c6 0500 	strd	r0, r5, [r6]
   40294:	4608      	mov	r0, r1
   40296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4029a:	fab3 f183 	clz	r1, r3
   4029e:	2900      	cmp	r1, #0
   402a0:	d146      	bne.n	40330 <__udivmoddi4+0x1bc>
   402a2:	42ab      	cmp	r3, r5
   402a4:	f0c0 80a7 	bcc.w	403f6 <__udivmoddi4+0x282>
   402a8:	4282      	cmp	r2, r0
   402aa:	f240 80a4 	bls.w	403f6 <__udivmoddi4+0x282>
   402ae:	4608      	mov	r0, r1
   402b0:	2e00      	cmp	r6, #0
   402b2:	d0aa      	beq.n	4020a <__udivmoddi4+0x96>
   402b4:	e9c6 4a00 	strd	r4, sl, [r6]
   402b8:	e7a7      	b.n	4020a <__udivmoddi4+0x96>
   402ba:	f1c2 0020 	rsb	r0, r2, #32
   402be:	4097      	lsls	r7, r2
   402c0:	fa01 f302 	lsl.w	r3, r1, r2
   402c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   402c8:	40c1      	lsrs	r1, r0
   402ca:	fa24 f500 	lsr.w	r5, r4, r0
   402ce:	fa1f f887 	uxth.w	r8, r7
   402d2:	4094      	lsls	r4, r2
   402d4:	431d      	orrs	r5, r3
   402d6:	fbb1 f0fe 	udiv	r0, r1, lr
   402da:	0c2b      	lsrs	r3, r5, #16
   402dc:	fb0e 1110 	mls	r1, lr, r0, r1
   402e0:	fb00 fc08 	mul.w	ip, r0, r8
   402e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   402e8:	459c      	cmp	ip, r3
   402ea:	d909      	bls.n	40300 <__udivmoddi4+0x18c>
   402ec:	18fb      	adds	r3, r7, r3
   402ee:	bf2c      	ite	cs
   402f0:	2101      	movcs	r1, #1
   402f2:	2100      	movcc	r1, #0
   402f4:	459c      	cmp	ip, r3
   402f6:	d902      	bls.n	402fe <__udivmoddi4+0x18a>
   402f8:	2900      	cmp	r1, #0
   402fa:	f000 8095 	beq.w	40428 <__udivmoddi4+0x2b4>
   402fe:	3801      	subs	r0, #1
   40300:	eba3 030c 	sub.w	r3, r3, ip
   40304:	b2ad      	uxth	r5, r5
   40306:	fbb3 f1fe 	udiv	r1, r3, lr
   4030a:	fb0e 3311 	mls	r3, lr, r1, r3
   4030e:	fb01 fc08 	mul.w	ip, r1, r8
   40312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   40316:	45ac      	cmp	ip, r5
   40318:	d905      	bls.n	40326 <__udivmoddi4+0x1b2>
   4031a:	197d      	adds	r5, r7, r5
   4031c:	d202      	bcs.n	40324 <__udivmoddi4+0x1b0>
   4031e:	45ac      	cmp	ip, r5
   40320:	f200 8089 	bhi.w	40436 <__udivmoddi4+0x2c2>
   40324:	3901      	subs	r1, #1
   40326:	eba5 030c 	sub.w	r3, r5, ip
   4032a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   4032e:	e77a      	b.n	40226 <__udivmoddi4+0xb2>
   40330:	f1c1 0420 	rsb	r4, r1, #32
   40334:	408b      	lsls	r3, r1
   40336:	fa02 f701 	lsl.w	r7, r2, r1
   4033a:	fa05 fc01 	lsl.w	ip, r5, r1
   4033e:	40e2      	lsrs	r2, r4
   40340:	fa20 f804 	lsr.w	r8, r0, r4
   40344:	40e5      	lsrs	r5, r4
   40346:	fa00 fe01 	lsl.w	lr, r0, r1
   4034a:	4313      	orrs	r3, r2
   4034c:	ea48 020c 	orr.w	r2, r8, ip
   40350:	ea4f 4813 	mov.w	r8, r3, lsr #16
   40354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   40358:	fa1f f983 	uxth.w	r9, r3
   4035c:	fbb5 faf8 	udiv	sl, r5, r8
   40360:	fb08 551a 	mls	r5, r8, sl, r5
   40364:	fb0a f009 	mul.w	r0, sl, r9
   40368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   4036c:	4560      	cmp	r0, ip
   4036e:	d90a      	bls.n	40386 <__udivmoddi4+0x212>
   40370:	eb13 0c0c 	adds.w	ip, r3, ip
   40374:	bf2c      	ite	cs
   40376:	2501      	movcs	r5, #1
   40378:	2500      	movcc	r5, #0
   4037a:	4560      	cmp	r0, ip
   4037c:	d901      	bls.n	40382 <__udivmoddi4+0x20e>
   4037e:	2d00      	cmp	r5, #0
   40380:	d055      	beq.n	4042e <__udivmoddi4+0x2ba>
   40382:	f10a 3aff 	add.w	sl, sl, #4294967295
   40386:	ebac 0c00 	sub.w	ip, ip, r0
   4038a:	b292      	uxth	r2, r2
   4038c:	fbbc f0f8 	udiv	r0, ip, r8
   40390:	fb08 cc10 	mls	ip, r8, r0, ip
   40394:	fb00 f909 	mul.w	r9, r0, r9
   40398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   4039c:	45e1      	cmp	r9, ip
   4039e:	d905      	bls.n	403ac <__udivmoddi4+0x238>
   403a0:	eb13 0c0c 	adds.w	ip, r3, ip
   403a4:	d201      	bcs.n	403aa <__udivmoddi4+0x236>
   403a6:	45e1      	cmp	r9, ip
   403a8:	d83b      	bhi.n	40422 <__udivmoddi4+0x2ae>
   403aa:	3801      	subs	r0, #1
   403ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   403b0:	ebac 0c09 	sub.w	ip, ip, r9
   403b4:	fba0 8907 	umull	r8, r9, r0, r7
   403b8:	45cc      	cmp	ip, r9
   403ba:	4645      	mov	r5, r8
   403bc:	464a      	mov	r2, r9
   403be:	d302      	bcc.n	403c6 <__udivmoddi4+0x252>
   403c0:	d106      	bne.n	403d0 <__udivmoddi4+0x25c>
   403c2:	45c6      	cmp	lr, r8
   403c4:	d204      	bcs.n	403d0 <__udivmoddi4+0x25c>
   403c6:	3801      	subs	r0, #1
   403c8:	ebb8 0507 	subs.w	r5, r8, r7
   403cc:	eb69 0203 	sbc.w	r2, r9, r3
   403d0:	b32e      	cbz	r6, 4041e <__udivmoddi4+0x2aa>
   403d2:	ebbe 0305 	subs.w	r3, lr, r5
   403d6:	eb6c 0c02 	sbc.w	ip, ip, r2
   403da:	fa23 f201 	lsr.w	r2, r3, r1
   403de:	fa0c f404 	lsl.w	r4, ip, r4
   403e2:	fa2c f301 	lsr.w	r3, ip, r1
   403e6:	2100      	movs	r1, #0
   403e8:	4314      	orrs	r4, r2
   403ea:	e9c6 4300 	strd	r4, r3, [r6]
   403ee:	e70c      	b.n	4020a <__udivmoddi4+0x96>
   403f0:	4631      	mov	r1, r6
   403f2:	4630      	mov	r0, r6
   403f4:	e709      	b.n	4020a <__udivmoddi4+0x96>
   403f6:	1a84      	subs	r4, r0, r2
   403f8:	eb65 0303 	sbc.w	r3, r5, r3
   403fc:	2001      	movs	r0, #1
   403fe:	469a      	mov	sl, r3
   40400:	e756      	b.n	402b0 <__udivmoddi4+0x13c>
   40402:	f1ac 0c02 	sub.w	ip, ip, #2
   40406:	443d      	add	r5, r7
   40408:	e724      	b.n	40254 <__udivmoddi4+0xe0>
   4040a:	3802      	subs	r0, #2
   4040c:	443c      	add	r4, r7
   4040e:	e734      	b.n	4027a <__udivmoddi4+0x106>
   40410:	3802      	subs	r0, #2
   40412:	443c      	add	r4, r7
   40414:	e6ef      	b.n	401f6 <__udivmoddi4+0x82>
   40416:	f1ae 0e02 	sub.w	lr, lr, #2
   4041a:	443b      	add	r3, r7
   4041c:	e6d9      	b.n	401d2 <__udivmoddi4+0x5e>
   4041e:	4631      	mov	r1, r6
   40420:	e6f3      	b.n	4020a <__udivmoddi4+0x96>
   40422:	3802      	subs	r0, #2
   40424:	449c      	add	ip, r3
   40426:	e7c1      	b.n	403ac <__udivmoddi4+0x238>
   40428:	3802      	subs	r0, #2
   4042a:	443b      	add	r3, r7
   4042c:	e768      	b.n	40300 <__udivmoddi4+0x18c>
   4042e:	f1aa 0a02 	sub.w	sl, sl, #2
   40432:	449c      	add	ip, r3
   40434:	e7a7      	b.n	40386 <__udivmoddi4+0x212>
   40436:	3902      	subs	r1, #2
   40438:	443d      	add	r5, r7
   4043a:	e774      	b.n	40326 <__udivmoddi4+0x1b2>

0004043c <__aeabi_idiv0>:
   4043c:	4770      	bx	lr
   4043e:	bf00      	nop

00040440 <main>:
     }
     printf("\n");
}

int main() {
  uint8_t rlpTx[2048] = {0};
   40440:	2100      	movs	r1, #0
int main() {
   40442:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   40446:	f5ad 6d00 	sub.w	sp, sp, #2048	; 0x800
  uint8_t rlpTx[2048] = {0};
   4044a:	f240 72fc 	movw	r2, #2044	; 0x7fc
   4044e:	a801      	add	r0, sp, #4
   40450:	9100      	str	r1, [sp, #0]
   40452:	f007 fd0f 	bl	47e74 <memset>
  int outputLen = 0;
  outputLen = rlp_encode_list(rlpTx, sizeof(rlpTx)/sizeof(rlpTx[0]), ethTxn, sizeof(ethTxn)/sizeof(ethTxn[0]));
   40456:	f44f 6100 	mov.w	r1, #2048	; 0x800
   4045a:	2309      	movs	r3, #9
   4045c:	4668      	mov	r0, sp
   4045e:	4a13      	ldr	r2, [pc, #76]	; (404ac <main+0x6c>)
   40460:	f006 fe08 	bl	47074 <rlp_encode_list>
  if(outputLen < 0)
   40464:	1e04      	subs	r4, r0, #0
    printf("error, return code: %d\r\n", outputLen);
   40466:	4621      	mov	r1, r4
  if(outputLen < 0)
   40468:	da07      	bge.n	4047a <main+0x3a>
    printf("error, return code: %d\r\n", outputLen);
   4046a:	4811      	ldr	r0, [pc, #68]	; (404b0 <main+0x70>)
   4046c:	f002 fa86 	bl	4297c <printf>
    debug_hexstring(rlpTx, outputLen);
  }

  return 0;

   40470:	2000      	movs	r0, #0
   40472:	f50d 6d00 	add.w	sp, sp, #2048	; 0x800
   40476:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    printf("RLP encoded eth txn [%d B]:\r\n", outputLen);
   4047a:	480e      	ldr	r0, [pc, #56]	; (404b4 <main+0x74>)
   4047c:	f002 fa7e 	bl	4297c <printf>
     if ((NULL == a) || (b <= 0)) return;
   40480:	2c00      	cmp	r4, #0
   40482:	d0f5      	beq.n	40470 <main+0x30>
   40484:	466d      	mov	r5, sp
     for (unsigned long int i = 1; i <= b; i++) {
   40486:	2601      	movs	r6, #1
          printf("%x",a[i-1]);
   40488:	4f0b      	ldr	r7, [pc, #44]	; (404b8 <main+0x78>)
          printf("0%x",a[i-1]);
   4048a:	f8df 8034 	ldr.w	r8, [pc, #52]	; 404c0 <main+0x80>
       if(a[i-1] < 0x10)
   4048e:	f815 1b01 	ldrb.w	r1, [r5], #1
     for (unsigned long int i = 1; i <= b; i++) {
   40492:	3601      	adds	r6, #1
       if(a[i-1] < 0x10)
   40494:	290f      	cmp	r1, #15
          printf("0%x",a[i-1]);
   40496:	bf94      	ite	ls
   40498:	4640      	movls	r0, r8
          printf("%x",a[i-1]);
   4049a:	4638      	movhi	r0, r7
   4049c:	f002 fa6e 	bl	4297c <printf>
     for (unsigned long int i = 1; i <= b; i++) {
   404a0:	42b4      	cmp	r4, r6
   404a2:	d2f4      	bcs.n	4048e <main+0x4e>
     printf("\n");
   404a4:	4805      	ldr	r0, [pc, #20]	; (404bc <main+0x7c>)
   404a6:	f002 fa69 	bl	4297c <printf>
   404aa:	e7e1      	b.n	40470 <main+0x30>
   404ac:	00048c18 	.word	0x00048c18
   404b0:	00048e1c 	.word	0x00048e1c
   404b4:	00048e35 	.word	0x00048e35
   404b8:	00048e54 	.word	0x00048e54
   404bc:	00048e51 	.word	0x00048e51
   404c0:	00048e53 	.word	0x00048e53

000404c4 <rlp_encode_element>:
  return ERR_RLP_EBADARG;
}

// Returns length of output in bytes, or a negative error value
int rlp_encode_element(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, const RlpElement_t *const rlpElement)
{
   404c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   404c6:	460d      	mov	r5, r1
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   404c8:	2800      	cmp	r0, #0
   404ca:	d06d      	beq.n	405a8 <rlp_encode_element+0xe4>
   404cc:	2a00      	cmp	r2, #0
   404ce:	d06b      	beq.n	405a8 <rlp_encode_element+0xe4>
   404d0:	2900      	cmp	r1, #0
   404d2:	d069      	beq.n	405a8 <rlp_encode_element+0xe4>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   404d4:	7811      	ldrb	r1, [r2, #0]
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   404d6:	2900      	cmp	r1, #0
   404d8:	d066      	beq.n	405a8 <rlp_encode_element+0xe4>
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   404da:	1e8c      	subs	r4, r1, #2
   404dc:	b2e4      	uxtb	r4, r4
   404de:	2c07      	cmp	r4, #7
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   404e0:	6853      	ldr	r3, [r2, #4]
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   404e2:	d82a      	bhi.n	4053a <rlp_encode_element+0x76>
      return buffSz == rlp_int_size_from_type(type);
   404e4:	4935      	ldr	r1, [pc, #212]	; (405bc <rlp_encode_element+0xf8>)
   404e6:	5d09      	ldrb	r1, [r1, r4]
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   404e8:	428b      	cmp	r3, r1
    else if (type == RLP_TYPE_BYTE_ARRAY)
   404ea:	d15d      	bne.n	405a8 <rlp_encode_element+0xe4>
    return ERR_RLP_EBADARG;
  if(rlpEncodedOutputLen < (rlpElement->len + 1)) // extra byte for rlp encoding tag
   404ec:	1c59      	adds	r1, r3, #1
   404ee:	42a9      	cmp	r1, r5
   404f0:	d860      	bhi.n	405b4 <rlp_encode_element+0xf0>
    return ERR_RLP_ENOMEM;
  if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElement->buff, rlpElement->len)) // No overlapping memory regions
   404f2:	6891      	ldr	r1, [r2, #8]
    if( (aAddr == bAddr) ||
   404f4:	4281      	cmp	r1, r0
   404f6:	d05a      	beq.n	405ae <rlp_encode_element+0xea>
   404f8:	d902      	bls.n	40500 <rlp_encode_element+0x3c>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   404fa:	1942      	adds	r2, r0, r5
   404fc:	4291      	cmp	r1, r2
   404fe:	d956      	bls.n	405ae <rlp_encode_element+0xea>
   40500:	4281      	cmp	r1, r0
   40502:	d202      	bcs.n	4050a <rlp_encode_element+0x46>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   40504:	18ca      	adds	r2, r1, r3
   40506:	4290      	cmp	r0, r2
   40508:	d951      	bls.n	405ae <rlp_encode_element+0xea>
  uint8_t *rlpOut = (uint8_t *)rlpEncodedOutput;
  uint8_t const *rlpElementBuff = (uint8_t *)rlpElement->buff;
  size_t rlpElementLen = rlpElement->len;
  size_t rlpEncodedLen = 0;

  if(RLP_TYPE_IS_INTEGER_TYPE(rlpElement->type)) {
   4050a:	2c07      	cmp	r4, #7
   4050c:	d81c      	bhi.n	40548 <rlp_encode_element+0x84>
   4050e:	460e      	mov	r6, r1
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40510:	461c      	mov	r4, r3
    const uint8_t *buffBase = rlpElement->buff;
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   40512:	2200      	movs	r2, #0
      if(buffBase[scanZero]) {
        rlpElementBuff = (buffBase + scanZero);
        rlpElementLen -= scanZero;
        break;
      } else if (scanZero == rlpElement->len - 1) {
   40514:	f103 3cff 	add.w	ip, r3, #4294967295
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   40518:	4293      	cmp	r3, r2
   4051a:	d008      	beq.n	4052e <rlp_encode_element+0x6a>
      if(buffBase[scanZero]) {
   4051c:	4637      	mov	r7, r6
   4051e:	f897 e000 	ldrb.w	lr, [r7]
   40522:	3601      	adds	r6, #1
   40524:	f1be 0f00 	cmp.w	lr, #0
   40528:	d009      	beq.n	4053e <rlp_encode_element+0x7a>
   4052a:	4639      	mov	r1, r7
        rlpElementLen -= scanZero;
   4052c:	1aa4      	subs	r4, r4, r2
        rlpElementLen = 0;
      }
    }
  }
  // Element Header Generation
  if(rlpElementLen == 0) {
   4052e:	b96c      	cbnz	r4, 4054c <rlp_encode_element+0x88>
    rlpEncodedLen = 1;
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   40530:	2380      	movs	r3, #128	; 0x80
    rlpEncodedLen = 1;
   40532:	2401      	movs	r4, #1
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   40534:	7003      	strb	r3, [r0, #0]
    }
    // Payload
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
  }
  return rlpEncodedLen; // all was successful, return encoded length.
   40536:	4620      	mov	r0, r4
}
   40538:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (type == RLP_TYPE_BYTE_ARRAY)
   4053a:	2901      	cmp	r1, #1
   4053c:	e7d5      	b.n	404ea <rlp_encode_element+0x26>
        rlpElementLen = 0;
   4053e:	4594      	cmp	ip, r2
   40540:	bf08      	it	eq
   40542:	2400      	moveq	r4, #0
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   40544:	3201      	adds	r2, #1
   40546:	e7e7      	b.n	40518 <rlp_encode_element+0x54>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40548:	461c      	mov	r4, r3
   4054a:	e7f0      	b.n	4052e <rlp_encode_element+0x6a>
  else if(rlpElementLen == 1 && (rlpElementBuff[0] == 0x00 || 
   4054c:	2c01      	cmp	r4, #1
   4054e:	d106      	bne.n	4055e <rlp_encode_element+0x9a>
   40550:	f991 2000 	ldrsb.w	r2, [r1]
   40554:	780b      	ldrb	r3, [r1, #0]
   40556:	2a00      	cmp	r2, #0
   40558:	db03      	blt.n	40562 <rlp_encode_element+0x9e>
    rlpOut[0] = rlpElementBuff[0];
   4055a:	7003      	strb	r3, [r0, #0]
   4055c:	e7eb      	b.n	40536 <rlp_encode_element+0x72>
  else if (rlpElementLen <= RLP_EXTENDED_LENGTH_THRESHOLD) {
   4055e:	2c37      	cmp	r4, #55	; 0x37
   40560:	d808      	bhi.n	40574 <rlp_encode_element+0xb0>
    uint8_t length = (uint8_t) (RLP_OFFSET_ITEM_SHORT + rlpElementLen);
   40562:	f1a4 0380 	sub.w	r3, r4, #128	; 0x80
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   40566:	4622      	mov	r2, r4
    rlpOut[0] = length;
   40568:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   4056c:	f007 fc77 	bl	47e5e <memcpy>
    rlpEncodedLen = rlpElementLen + 1;
   40570:	3401      	adds	r4, #1
   40572:	e7e0      	b.n	40536 <rlp_encode_element+0x72>
    int tmpLength = rlpElementLen;
   40574:	4622      	mov	r2, r4
   40576:	4627      	mov	r7, r4
    size_t lengthOfLength = (size_t) 0;
   40578:	2300      	movs	r3, #0
    while (tmpLength != 0) {
   4057a:	123f      	asrs	r7, r7, #8
   4057c:	461e      	mov	r6, r3
        ++lengthOfLength;
   4057e:	f103 0301 	add.w	r3, r3, #1
    while (tmpLength != 0) {
   40582:	d1fa      	bne.n	4057a <rlp_encode_element+0xb6>
    if(rlpEncodedOutputLen < (rlpElementLen + lengthOfLength + 1))
   40584:	3602      	adds	r6, #2
   40586:	4434      	add	r4, r6
   40588:	42ac      	cmp	r4, r5
   4058a:	d813      	bhi.n	405b4 <rlp_encode_element+0xf0>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_ITEM_LONG + lengthOfLength);
   4058c:	f1a3 0549 	sub.w	r5, r3, #73	; 0x49
   40590:	7005      	strb	r5, [r0, #0]
    for(int i = lengthOfLength; i > 0; --i) {
   40592:	2b00      	cmp	r3, #0
   40594:	dc04      	bgt.n	405a0 <rlp_encode_element+0xdc>
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
   40596:	4622      	mov	r2, r4
   40598:	4430      	add	r0, r6
   4059a:	f007 fc60 	bl	47e5e <memcpy>
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
   4059e:	e7ca      	b.n	40536 <rlp_encode_element+0x72>
      rlpOut[i] = (uint8_t) tmpLength;
   405a0:	54c2      	strb	r2, [r0, r3]
      tmpLength = tmpLength >> 8;
   405a2:	1212      	asrs	r2, r2, #8
    for(int i = lengthOfLength; i > 0; --i) {
   405a4:	3b01      	subs	r3, #1
   405a6:	e7f4      	b.n	40592 <rlp_encode_element+0xce>
    return ERR_RLP_EBADARG;
   405a8:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   405ac:	e7c4      	b.n	40538 <rlp_encode_element+0x74>
    return ERR_RLP_EILLEGALMEM;
   405ae:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   405b2:	e7c1      	b.n	40538 <rlp_encode_element+0x74>
    return ERR_RLP_ENOMEM;
   405b4:	f06f 007c 	mvn.w	r0, #124	; 0x7c
   405b8:	e7be      	b.n	40538 <rlp_encode_element+0x74>
   405ba:	bf00      	nop
   405bc:	00048e57 	.word	0x00048e57

000405c0 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   405c0:	680b      	ldr	r3, [r1, #0]
   405c2:	3301      	adds	r3, #1
   405c4:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   405c6:	4b01      	ldr	r3, [pc, #4]	; (405cc <char_out+0xc>)
   405c8:	681b      	ldr	r3, [r3, #0]
   405ca:	4718      	bx	r3
   405cc:	2001a56c 	.word	0x2001a56c

000405d0 <__printk_hook_install>:
	_char_out = fn;
   405d0:	4b01      	ldr	r3, [pc, #4]	; (405d8 <__printk_hook_install+0x8>)
   405d2:	6018      	str	r0, [r3, #0]
}
   405d4:	4770      	bx	lr
   405d6:	bf00      	nop
   405d8:	2001a56c 	.word	0x2001a56c

000405dc <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   405dc:	b507      	push	{r0, r1, r2, lr}
   405de:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   405e0:	2100      	movs	r1, #0
{
   405e2:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   405e4:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   405e6:	4803      	ldr	r0, [pc, #12]	; (405f4 <vprintk+0x18>)
   405e8:	a901      	add	r1, sp, #4
   405ea:	f000 f8ff 	bl	407ec <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   405ee:	b003      	add	sp, #12
   405f0:	f85d fb04 	ldr.w	pc, [sp], #4
   405f4:	000405c1 	.word	0x000405c1

000405f8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   405f8:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   405fa:	2500      	movs	r5, #0
{
   405fc:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   405fe:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   40602:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
   40604:	a901      	add	r1, sp, #4
   40606:	4805      	ldr	r0, [pc, #20]	; (4061c <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   40608:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
   4060a:	f000 f8ef 	bl	407ec <cbvprintf>

	if (ctx.count < ctx.max) {
   4060e:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   40612:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   40614:	bfb8      	it	lt
   40616:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   40618:	b005      	add	sp, #20
   4061a:	bd30      	pop	{r4, r5, pc}
   4061c:	0004718d 	.word	0x0004718d

00040620 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   40620:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40624:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   40628:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   4062a:	f019 0808 	ands.w	r8, r9, #8
{
   4062e:	4693      	mov	fp, r2
	if (processing) {
   40630:	d00d      	beq.n	4064e <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   40632:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   40634:	bf0c      	ite	eq
   40636:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   4063a:	f049 0920 	orrne.w	r9, r9, #32
   4063e:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   40642:	f38b 8811 	msr	BASEPRI, fp
   40646:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   4064a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4064e:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   40652:	2902      	cmp	r1, #2
   40654:	d107      	bne.n	40666 <process_event+0x46>
			evt = process_recheck(mgr);
   40656:	4620      	mov	r0, r4
   40658:	f006 fdc5 	bl	471e6 <process_recheck>
		if (evt == EVT_NOP) {
   4065c:	2800      	cmp	r0, #0
   4065e:	d0f0      	beq.n	40642 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   40660:	2801      	cmp	r0, #1
   40662:	8b23      	ldrh	r3, [r4, #24]
   40664:	d150      	bne.n	40708 <process_event+0xe8>
			res = mgr->last_res;
   40666:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40668:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   4066a:	2f00      	cmp	r7, #0
   4066c:	da15      	bge.n	4069a <process_event+0x7a>
		*clients = mgr->clients;
   4066e:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40670:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   40674:	e9c4 8800 	strd	r8, r8, [r4]
   40678:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   4067c:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   4067e:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   40680:	8b21      	ldrh	r1, [r4, #24]
   40682:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   40686:	45ca      	cmp	sl, r9
   40688:	d002      	beq.n	40690 <process_event+0x70>
		if (do_monitors
   4068a:	68a3      	ldr	r3, [r4, #8]
   4068c:	2b00      	cmp	r3, #0
   4068e:	d15c      	bne.n	4074a <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   40690:	b90d      	cbnz	r5, 40696 <process_event+0x76>
		    || (transit != NULL)) {
   40692:	2e00      	cmp	r6, #0
   40694:	d074      	beq.n	40780 <process_event+0x160>
   40696:	2300      	movs	r3, #0
   40698:	e058      	b.n	4074c <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4069a:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   4069e:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   406a0:	2a01      	cmp	r2, #1
   406a2:	d820      	bhi.n	406e6 <process_event+0xc6>
		*clients = mgr->clients;
   406a4:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   406a8:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   406aa:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   406ac:	b289      	uxth	r1, r1
	list->tail = NULL;
   406ae:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   406b2:	d10c      	bne.n	406ce <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   406b4:	2d00      	cmp	r5, #0
   406b6:	462b      	mov	r3, r5
   406b8:	bf38      	it	cc
   406ba:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   406bc:	b12b      	cbz	r3, 406ca <process_event+0xaa>
				mgr->refs += 1U;
   406be:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   406c0:	681b      	ldr	r3, [r3, #0]
   406c2:	3201      	adds	r2, #1
   406c4:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   406c6:	2b00      	cmp	r3, #0
   406c8:	d1f8      	bne.n	406bc <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   406ca:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   406ce:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   406d0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   406d2:	f006 fd88 	bl	471e6 <process_recheck>
   406d6:	4606      	mov	r6, r0
   406d8:	2800      	cmp	r0, #0
   406da:	d0d1      	beq.n	40680 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   406dc:	8b23      	ldrh	r3, [r4, #24]
   406de:	f043 0320 	orr.w	r3, r3, #32
   406e2:	8323      	strh	r3, [r4, #24]
   406e4:	e7cb      	b.n	4067e <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   406e6:	2b04      	cmp	r3, #4
   406e8:	d10c      	bne.n	40704 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   406ea:	f021 0107 	bic.w	r1, r1, #7
   406ee:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   406f0:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   406f2:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   406f4:	f006 fd77 	bl	471e6 <process_recheck>
   406f8:	4605      	mov	r5, r0
   406fa:	2800      	cmp	r0, #0
   406fc:	d0bf      	beq.n	4067e <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   406fe:	f041 0120 	orr.w	r1, r1, #32
   40702:	8321      	strh	r1, [r4, #24]
   40704:	2500      	movs	r5, #0
   40706:	e7ba      	b.n	4067e <process_event+0x5e>
		} else if (evt == EVT_START) {
   40708:	2803      	cmp	r0, #3
   4070a:	d109      	bne.n	40720 <process_event+0x100>
			transit = mgr->transitions->start;
   4070c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4070e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   40712:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40714:	f043 0306 	orr.w	r3, r3, #6
}
   40718:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   4071a:	8323      	strh	r3, [r4, #24]
		res = 0;
   4071c:	462f      	mov	r7, r5
   4071e:	e7af      	b.n	40680 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   40720:	2804      	cmp	r0, #4
   40722:	d106      	bne.n	40732 <process_event+0x112>
			transit = mgr->transitions->stop;
   40724:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40726:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   4072a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4072c:	f043 0304 	orr.w	r3, r3, #4
   40730:	e7f2      	b.n	40718 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   40732:	2805      	cmp	r0, #5
   40734:	d106      	bne.n	40744 <process_event+0x124>
			transit = mgr->transitions->reset;
   40736:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40738:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   4073c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4073e:	f043 0305 	orr.w	r3, r3, #5
   40742:	e7e9      	b.n	40718 <process_event+0xf8>
   40744:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   40746:	462e      	mov	r6, r5
   40748:	e7e8      	b.n	4071c <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   4074a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   4074c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   40750:	8321      	strh	r1, [r4, #24]
   40752:	f38b 8811 	msr	BASEPRI, fp
   40756:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   4075a:	bb03      	cbnz	r3, 4079e <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   4075c:	2d00      	cmp	r5, #0
   4075e:	d133      	bne.n	407c8 <process_event+0x1a8>
			if (transit != NULL) {
   40760:	b116      	cbz	r6, 40768 <process_event+0x148>
				transit(mgr, transition_complete);
   40762:	4620      	mov	r0, r4
   40764:	4920      	ldr	r1, [pc, #128]	; (407e8 <process_event+0x1c8>)
   40766:	47b0      	blx	r6
	__asm__ volatile(
   40768:	f04f 0320 	mov.w	r3, #32
   4076c:	f3ef 8b11 	mrs	fp, BASEPRI
   40770:	f383 8812 	msr	BASEPRI_MAX, r3
   40774:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   40778:	8b23      	ldrh	r3, [r4, #24]
   4077a:	f023 0308 	bic.w	r3, r3, #8
   4077e:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   40780:	8b23      	ldrh	r3, [r4, #24]
   40782:	06da      	lsls	r2, r3, #27
   40784:	d528      	bpl.n	407d8 <process_event+0x1b8>
			evt = EVT_COMPLETE;
   40786:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   40788:	f023 0310 	bic.w	r3, r3, #16
   4078c:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   4078e:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   40792:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   40796:	2900      	cmp	r1, #0
   40798:	f47f af5b 	bne.w	40652 <process_event+0x32>
out:
   4079c:	e751      	b.n	40642 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   4079e:	68a1      	ldr	r1, [r4, #8]
   407a0:	2900      	cmp	r1, #0
   407a2:	d0db      	beq.n	4075c <process_event+0x13c>
	return node->next;
   407a4:	680b      	ldr	r3, [r1, #0]
   407a6:	2b00      	cmp	r3, #0
   407a8:	bf38      	it	cc
   407aa:	2300      	movcc	r3, #0
   407ac:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   407ae:	4652      	mov	r2, sl
   407b0:	463b      	mov	r3, r7
   407b2:	4620      	mov	r0, r4
   407b4:	f8d1 b004 	ldr.w	fp, [r1, #4]
   407b8:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   407ba:	f1b9 0f00 	cmp.w	r9, #0
   407be:	d0cd      	beq.n	4075c <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   407c0:	4649      	mov	r1, r9
   407c2:	f8d9 3000 	ldr.w	r3, [r9]
   407c6:	e7ee      	b.n	407a6 <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   407c8:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   407ca:	463b      	mov	r3, r7
   407cc:	4652      	mov	r2, sl
   407ce:	4620      	mov	r0, r4
   407d0:	682d      	ldr	r5, [r5, #0]
   407d2:	f006 fd24 	bl	4721e <notify_one>
   407d6:	e7c1      	b.n	4075c <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   407d8:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   407dc:	bf1e      	ittt	ne
   407de:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   407e2:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   407e4:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   407e6:	e7d2      	b.n	4078e <process_event+0x16e>
   407e8:	0004724b 	.word	0x0004724b

000407ec <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   407ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   407f0:	468b      	mov	fp, r1
   407f2:	4692      	mov	sl, r2
   407f4:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   407f6:	2500      	movs	r5, #0
{
   407f8:	b091      	sub	sp, #68	; 0x44
   407fa:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   407fc:	f89a 0000 	ldrb.w	r0, [sl]
   40800:	b908      	cbnz	r0, 40806 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   40802:	4628      	mov	r0, r5
   40804:	e35e      	b.n	40ec4 <cbvprintf+0x6d8>
		if (*fp != '%') {
   40806:	2825      	cmp	r0, #37	; 0x25
   40808:	f10a 0701 	add.w	r7, sl, #1
   4080c:	d007      	beq.n	4081e <cbvprintf+0x32>
			OUTC('%');
   4080e:	4659      	mov	r1, fp
   40810:	9b02      	ldr	r3, [sp, #8]
   40812:	4798      	blx	r3
   40814:	2800      	cmp	r0, #0
   40816:	f2c0 8355 	blt.w	40ec4 <cbvprintf+0x6d8>
   4081a:	3501      	adds	r5, #1
			break;
   4081c:	e210      	b.n	40c40 <cbvprintf+0x454>
		} state = {
   4081e:	2218      	movs	r2, #24
   40820:	2100      	movs	r1, #0
   40822:	a80a      	add	r0, sp, #40	; 0x28
   40824:	f007 fb26 	bl	47e74 <memset>
	if (*sp == '%') {
   40828:	f89a 3001 	ldrb.w	r3, [sl, #1]
   4082c:	2b25      	cmp	r3, #37	; 0x25
   4082e:	d078      	beq.n	40922 <cbvprintf+0x136>
   40830:	2200      	movs	r2, #0
   40832:	4694      	mov	ip, r2
   40834:	4616      	mov	r6, r2
   40836:	4696      	mov	lr, r2
   40838:	4610      	mov	r0, r2
   4083a:	4639      	mov	r1, r7
		switch (*sp) {
   4083c:	f817 3b01 	ldrb.w	r3, [r7], #1
   40840:	2b2b      	cmp	r3, #43	; 0x2b
   40842:	f000 809d 	beq.w	40980 <cbvprintf+0x194>
   40846:	f200 8094 	bhi.w	40972 <cbvprintf+0x186>
   4084a:	2b20      	cmp	r3, #32
   4084c:	f000 809b 	beq.w	40986 <cbvprintf+0x19a>
   40850:	2b23      	cmp	r3, #35	; 0x23
   40852:	f000 809a 	beq.w	4098a <cbvprintf+0x19e>
   40856:	b128      	cbz	r0, 40864 <cbvprintf+0x78>
   40858:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   4085c:	f040 0004 	orr.w	r0, r0, #4
   40860:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40864:	f1be 0f00 	cmp.w	lr, #0
   40868:	d005      	beq.n	40876 <cbvprintf+0x8a>
   4086a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   4086e:	f040 0008 	orr.w	r0, r0, #8
   40872:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40876:	b12e      	cbz	r6, 40884 <cbvprintf+0x98>
   40878:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   4087c:	f040 0010 	orr.w	r0, r0, #16
   40880:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40884:	f1bc 0f00 	cmp.w	ip, #0
   40888:	d005      	beq.n	40896 <cbvprintf+0xaa>
   4088a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   4088e:	f040 0020 	orr.w	r0, r0, #32
   40892:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40896:	b12a      	cbz	r2, 408a4 <cbvprintf+0xb8>
   40898:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   4089c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   408a0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   408a4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   408a8:	f002 0044 	and.w	r0, r2, #68	; 0x44
   408ac:	2844      	cmp	r0, #68	; 0x44
   408ae:	d103      	bne.n	408b8 <cbvprintf+0xcc>
		conv->flag_zero = false;
   408b0:	f36f 1286 	bfc	r2, #6, #1
   408b4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   408b8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   408bc:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   408be:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   408c2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   408c6:	d17b      	bne.n	409c0 <cbvprintf+0x1d4>
		conv->width_star = true;
   408c8:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   408cc:	1c4b      	adds	r3, r1, #1
   408ce:	f042 0201 	orr.w	r2, r2, #1
   408d2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   408d6:	781a      	ldrb	r2, [r3, #0]
   408d8:	2a2e      	cmp	r2, #46	; 0x2e
   408da:	bf0c      	ite	eq
   408dc:	2101      	moveq	r1, #1
   408de:	2100      	movne	r1, #0
   408e0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   408e4:	f361 0241 	bfi	r2, r1, #1, #1
   408e8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   408ec:	d174      	bne.n	409d8 <cbvprintf+0x1ec>
	if (*sp == '*') {
   408ee:	785a      	ldrb	r2, [r3, #1]
   408f0:	2a2a      	cmp	r2, #42	; 0x2a
   408f2:	d06a      	beq.n	409ca <cbvprintf+0x1de>
	size_t val = 0;
   408f4:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   408f6:	260a      	movs	r6, #10
   408f8:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   408fa:	4618      	mov	r0, r3
   408fc:	f810 2b01 	ldrb.w	r2, [r0], #1
   40900:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40904:	2f09      	cmp	r7, #9
   40906:	f240 808e 	bls.w	40a26 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   4090a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   4090e:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   40910:	f3c2 0040 	ubfx	r0, r2, #1, #1
   40914:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   40918:	f361 0241 	bfi	r2, r1, #1, #1
   4091c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40920:	e05a      	b.n	409d8 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   40922:	f10a 0702 	add.w	r7, sl, #2
   40926:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   4092a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   4092e:	07d9      	lsls	r1, r3, #31
   40930:	f140 8149 	bpl.w	40bc6 <cbvprintf+0x3da>
			width = va_arg(ap, int);
   40934:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   40938:	f1b9 0f00 	cmp.w	r9, #0
   4093c:	da07      	bge.n	4094e <cbvprintf+0x162>
				conv->flag_dash = true;
   4093e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   40942:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   40946:	f042 0204 	orr.w	r2, r2, #4
   4094a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   4094e:	075a      	lsls	r2, r3, #29
   40950:	f140 8142 	bpl.w	40bd8 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   40954:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   40958:	f1b8 0f00 	cmp.w	r8, #0
   4095c:	f280 8141 	bge.w	40be2 <cbvprintf+0x3f6>
				conv->prec_present = false;
   40960:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40964:	f36f 0341 	bfc	r3, #1, #1
   40968:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   4096c:	f04f 38ff 	mov.w	r8, #4294967295
   40970:	e137      	b.n	40be2 <cbvprintf+0x3f6>
		switch (*sp) {
   40972:	2b2d      	cmp	r3, #45	; 0x2d
   40974:	d00c      	beq.n	40990 <cbvprintf+0x1a4>
   40976:	2b30      	cmp	r3, #48	; 0x30
   40978:	f47f af6d 	bne.w	40856 <cbvprintf+0x6a>
			conv->flag_zero = true;
   4097c:	2201      	movs	r2, #1
	} while (loop);
   4097e:	e75c      	b.n	4083a <cbvprintf+0x4e>
			conv->flag_plus = true;
   40980:	f04f 0e01 	mov.w	lr, #1
   40984:	e759      	b.n	4083a <cbvprintf+0x4e>
			conv->flag_space = true;
   40986:	2601      	movs	r6, #1
   40988:	e757      	b.n	4083a <cbvprintf+0x4e>
			conv->flag_hash = true;
   4098a:	f04f 0c01 	mov.w	ip, #1
   4098e:	e754      	b.n	4083a <cbvprintf+0x4e>
		switch (*sp) {
   40990:	2001      	movs	r0, #1
   40992:	e752      	b.n	4083a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   40994:	4633      	mov	r3, r6
   40996:	fb0c 0202 	mla	r2, ip, r2, r0
   4099a:	3a30      	subs	r2, #48	; 0x30
   4099c:	461e      	mov	r6, r3
   4099e:	f816 0b01 	ldrb.w	r0, [r6], #1
   409a2:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   409a6:	2f09      	cmp	r7, #9
   409a8:	d9f4      	bls.n	40994 <cbvprintf+0x1a8>
	if (sp != wp) {
   409aa:	4299      	cmp	r1, r3
   409ac:	d093      	beq.n	408d6 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   409ae:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   409b2:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   409b4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   409b6:	f362 0141 	bfi	r1, r2, #1, #1
   409ba:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   409be:	e78a      	b.n	408d6 <cbvprintf+0xea>
   409c0:	460b      	mov	r3, r1
	size_t val = 0;
   409c2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   409c4:	f04f 0c0a 	mov.w	ip, #10
   409c8:	e7e8      	b.n	4099c <cbvprintf+0x1b0>
		conv->prec_star = true;
   409ca:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   409ce:	3302      	adds	r3, #2
		conv->prec_star = true;
   409d0:	f042 0204 	orr.w	r2, r2, #4
   409d4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   409d8:	461f      	mov	r7, r3
   409da:	f817 2b01 	ldrb.w	r2, [r7], #1
   409de:	2a6c      	cmp	r2, #108	; 0x6c
   409e0:	d041      	beq.n	40a66 <cbvprintf+0x27a>
   409e2:	d825      	bhi.n	40a30 <cbvprintf+0x244>
   409e4:	2a68      	cmp	r2, #104	; 0x68
   409e6:	d02b      	beq.n	40a40 <cbvprintf+0x254>
   409e8:	2a6a      	cmp	r2, #106	; 0x6a
   409ea:	d046      	beq.n	40a7a <cbvprintf+0x28e>
   409ec:	2a4c      	cmp	r2, #76	; 0x4c
   409ee:	d04c      	beq.n	40a8a <cbvprintf+0x29e>
   409f0:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   409f2:	f817 2b01 	ldrb.w	r2, [r7], #1
   409f6:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   409fa:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   409fc:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   40a00:	f200 80d9 	bhi.w	40bb6 <cbvprintf+0x3ca>
   40a04:	2a57      	cmp	r2, #87	; 0x57
   40a06:	d84d      	bhi.n	40aa4 <cbvprintf+0x2b8>
   40a08:	2a41      	cmp	r2, #65	; 0x41
   40a0a:	d003      	beq.n	40a14 <cbvprintf+0x228>
   40a0c:	3a45      	subs	r2, #69	; 0x45
   40a0e:	2a02      	cmp	r2, #2
   40a10:	f200 80d1 	bhi.w	40bb6 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   40a14:	2204      	movs	r2, #4
   40a16:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40a1a:	f362 0302 	bfi	r3, r2, #0, #3
   40a1e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   40a22:	2301      	movs	r3, #1
			break;
   40a24:	e09e      	b.n	40b64 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   40a26:	fb06 2101 	mla	r1, r6, r1, r2
   40a2a:	4603      	mov	r3, r0
   40a2c:	3930      	subs	r1, #48	; 0x30
   40a2e:	e764      	b.n	408fa <cbvprintf+0x10e>
	switch (*sp) {
   40a30:	2a74      	cmp	r2, #116	; 0x74
   40a32:	d026      	beq.n	40a82 <cbvprintf+0x296>
   40a34:	2a7a      	cmp	r2, #122	; 0x7a
   40a36:	d1db      	bne.n	409f0 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   40a38:	2206      	movs	r2, #6
   40a3a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40a3e:	e00d      	b.n	40a5c <cbvprintf+0x270>
		if (*++sp == 'h') {
   40a40:	785a      	ldrb	r2, [r3, #1]
   40a42:	2a68      	cmp	r2, #104	; 0x68
   40a44:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40a48:	d106      	bne.n	40a58 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   40a4a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   40a4c:	f361 02c6 	bfi	r2, r1, #3, #4
   40a50:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   40a54:	1c9f      	adds	r7, r3, #2
   40a56:	e7cc      	b.n	409f2 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   40a58:	4613      	mov	r3, r2
   40a5a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   40a5c:	f362 03c6 	bfi	r3, r2, #3, #4
   40a60:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   40a64:	e7c5      	b.n	409f2 <cbvprintf+0x206>
		if (*++sp == 'l') {
   40a66:	785a      	ldrb	r2, [r3, #1]
   40a68:	2a6c      	cmp	r2, #108	; 0x6c
   40a6a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40a6e:	d101      	bne.n	40a74 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   40a70:	2104      	movs	r1, #4
   40a72:	e7eb      	b.n	40a4c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   40a74:	4613      	mov	r3, r2
   40a76:	2203      	movs	r2, #3
   40a78:	e7f0      	b.n	40a5c <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   40a7a:	2205      	movs	r2, #5
   40a7c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40a80:	e7ec      	b.n	40a5c <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   40a82:	2207      	movs	r2, #7
   40a84:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40a88:	e7e8      	b.n	40a5c <cbvprintf+0x270>
		conv->unsupported = true;
   40a8a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   40a8e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   40a92:	f023 0302 	bic.w	r3, r3, #2
   40a96:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   40a9a:	f043 0302 	orr.w	r3, r3, #2
   40a9e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   40aa2:	e7a6      	b.n	409f2 <cbvprintf+0x206>
   40aa4:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   40aa8:	2920      	cmp	r1, #32
   40aaa:	f200 8084 	bhi.w	40bb6 <cbvprintf+0x3ca>
   40aae:	a001      	add	r0, pc, #4	; (adr r0, 40ab4 <cbvprintf+0x2c8>)
   40ab0:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   40ab4:	00040b79 	.word	0x00040b79
   40ab8:	00040bb7 	.word	0x00040bb7
   40abc:	00040bb7 	.word	0x00040bb7
   40ac0:	00040bb7 	.word	0x00040bb7
   40ac4:	00040bb7 	.word	0x00040bb7
   40ac8:	00040bb7 	.word	0x00040bb7
   40acc:	00040bb7 	.word	0x00040bb7
   40ad0:	00040bb7 	.word	0x00040bb7
   40ad4:	00040bb7 	.word	0x00040bb7
   40ad8:	00040a15 	.word	0x00040a15
   40adc:	00040bb7 	.word	0x00040bb7
   40ae0:	00040b79 	.word	0x00040b79
   40ae4:	00040b39 	.word	0x00040b39
   40ae8:	00040a15 	.word	0x00040a15
   40aec:	00040a15 	.word	0x00040a15
   40af0:	00040a15 	.word	0x00040a15
   40af4:	00040bb7 	.word	0x00040bb7
   40af8:	00040b39 	.word	0x00040b39
   40afc:	00040bb7 	.word	0x00040bb7
   40b00:	00040bb7 	.word	0x00040bb7
   40b04:	00040bb7 	.word	0x00040bb7
   40b08:	00040bb7 	.word	0x00040bb7
   40b0c:	00040b81 	.word	0x00040b81
   40b10:	00040b79 	.word	0x00040b79
   40b14:	00040b9d 	.word	0x00040b9d
   40b18:	00040bb7 	.word	0x00040bb7
   40b1c:	00040bb7 	.word	0x00040bb7
   40b20:	00040b9d 	.word	0x00040b9d
   40b24:	00040bb7 	.word	0x00040bb7
   40b28:	00040b79 	.word	0x00040b79
   40b2c:	00040bb7 	.word	0x00040bb7
   40b30:	00040bb7 	.word	0x00040bb7
   40b34:	00040b79 	.word	0x00040b79
		conv->specifier_cat = SPECIFIER_SINT;
   40b38:	2001      	movs	r0, #1
   40b3a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40b3e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   40b42:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40b46:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   40b48:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   40b4c:	bf02      	ittt	eq
   40b4e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   40b52:	f041 0101 	orreq.w	r1, r1, #1
   40b56:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   40b5a:	2a63      	cmp	r2, #99	; 0x63
   40b5c:	d131      	bne.n	40bc2 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   40b5e:	3b00      	subs	r3, #0
   40b60:	bf18      	it	ne
   40b62:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   40b64:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40b68:	f3c2 0140 	ubfx	r1, r2, #1, #1
   40b6c:	430b      	orrs	r3, r1
   40b6e:	f363 0241 	bfi	r2, r3, #1, #1
   40b72:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40b76:	e6d8      	b.n	4092a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   40b78:	2002      	movs	r0, #2
   40b7a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   40b7e:	e7de      	b.n	40b3e <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   40b80:	2103      	movs	r1, #3
   40b82:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40b86:	f003 0378 	and.w	r3, r3, #120	; 0x78
   40b8a:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   40b8e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40b92:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   40b94:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40b98:	4143      	adcs	r3, r0
   40b9a:	e7e3      	b.n	40b64 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   40b9c:	2103      	movs	r1, #3
   40b9e:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40ba2:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   40ba6:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   40baa:	bf14      	ite	ne
   40bac:	2301      	movne	r3, #1
   40bae:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   40bb0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40bb4:	e7d6      	b.n	40b64 <cbvprintf+0x378>
		conv->invalid = true;
   40bb6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40bba:	f043 0301 	orr.w	r3, r3, #1
   40bbe:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   40bc2:	2300      	movs	r3, #0
   40bc4:	e7ce      	b.n	40b64 <cbvprintf+0x378>
		} else if (conv->width_present) {
   40bc6:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   40bca:	2a00      	cmp	r2, #0
		int width = -1;
   40bcc:	bfac      	ite	ge
   40bce:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
   40bd2:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   40bd6:	e6ba      	b.n	4094e <cbvprintf+0x162>
		} else if (conv->prec_present) {
   40bd8:	079b      	lsls	r3, r3, #30
   40bda:	f57f aec7 	bpl.w	4096c <cbvprintf+0x180>
			precision = conv->prec_value;
   40bde:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   40be2:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   40be4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   40be8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   40bec:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   40bf0:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   40bf4:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   40bf6:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   40bfa:	d136      	bne.n	40c6a <cbvprintf+0x47e>
			switch (length_mod) {
   40bfc:	1ed3      	subs	r3, r2, #3
   40bfe:	2b04      	cmp	r3, #4
   40c00:	d820      	bhi.n	40c44 <cbvprintf+0x458>
   40c02:	e8df f003 	tbb	[pc, r3]
   40c06:	0703      	.short	0x0703
   40c08:	1f07      	.short	0x1f07
   40c0a:	1f          	.byte	0x1f
   40c0b:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   40c0c:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   40c10:	17c1      	asrs	r1, r0, #31
   40c12:	e004      	b.n	40c1e <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   40c14:	3407      	adds	r4, #7
   40c16:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   40c1a:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   40c1e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   40c22:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40c26:	f013 0603 	ands.w	r6, r3, #3
   40c2a:	d054      	beq.n	40cd6 <cbvprintf+0x4ea>
			OUTS(sp, fp);
   40c2c:	463b      	mov	r3, r7
   40c2e:	4652      	mov	r2, sl
   40c30:	4659      	mov	r1, fp
   40c32:	9802      	ldr	r0, [sp, #8]
   40c34:	f006 fd9c 	bl	47770 <outs>
   40c38:	2800      	cmp	r0, #0
   40c3a:	f2c0 8143 	blt.w	40ec4 <cbvprintf+0x6d8>
   40c3e:	4405      	add	r5, r0
			continue;
   40c40:	46ba      	mov	sl, r7
   40c42:	e5db      	b.n	407fc <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40c44:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   40c48:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40c4a:	ea4f 71e0 	mov.w	r1, r0, asr #31
   40c4e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   40c52:	d105      	bne.n	40c60 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   40c54:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   40c58:	930a      	str	r3, [sp, #40]	; 0x28
   40c5a:	2300      	movs	r3, #0
   40c5c:	930b      	str	r3, [sp, #44]	; 0x2c
   40c5e:	e7e0      	b.n	40c22 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   40c60:	2a02      	cmp	r2, #2
   40c62:	d1de      	bne.n	40c22 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   40c64:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   40c68:	e7d2      	b.n	40c10 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   40c6a:	2b02      	cmp	r3, #2
   40c6c:	d123      	bne.n	40cb6 <cbvprintf+0x4ca>
			switch (length_mod) {
   40c6e:	1ed3      	subs	r3, r2, #3
   40c70:	2b04      	cmp	r3, #4
   40c72:	d813      	bhi.n	40c9c <cbvprintf+0x4b0>
   40c74:	e8df f003 	tbb	[pc, r3]
   40c78:	120a0a03 	.word	0x120a0a03
   40c7c:	12          	.byte	0x12
   40c7d:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   40c7e:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   40c80:	6820      	ldr	r0, [r4, #0]
   40c82:	1d23      	adds	r3, r4, #4
   40c84:	900a      	str	r0, [sp, #40]	; 0x28
   40c86:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   40c88:	461c      	mov	r4, r3
   40c8a:	e7ca      	b.n	40c22 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   40c8c:	3407      	adds	r4, #7
   40c8e:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   40c92:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   40c96:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   40c9a:	e7f5      	b.n	40c88 <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   40c9c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   40ca0:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   40ca2:	930a      	str	r3, [sp, #40]	; 0x28
   40ca4:	f04f 0300 	mov.w	r3, #0
   40ca8:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   40caa:	d0d3      	beq.n	40c54 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   40cac:	2a02      	cmp	r2, #2
   40cae:	d1b8      	bne.n	40c22 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   40cb0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   40cb4:	e7d0      	b.n	40c58 <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   40cb6:	2b04      	cmp	r3, #4
   40cb8:	d107      	bne.n	40cca <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   40cba:	3407      	adds	r4, #7
   40cbc:	f024 0407 	bic.w	r4, r4, #7
   40cc0:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   40cc4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   40cc8:	e7ab      	b.n	40c22 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   40cca:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   40ccc:	bf04      	itt	eq
   40cce:	f854 3b04 	ldreq.w	r3, [r4], #4
   40cd2:	930a      	streq	r3, [sp, #40]	; 0x28
   40cd4:	e7a5      	b.n	40c22 <cbvprintf+0x436>
		switch (conv->specifier) {
   40cd6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   40cda:	2878      	cmp	r0, #120	; 0x78
   40cdc:	d8b0      	bhi.n	40c40 <cbvprintf+0x454>
   40cde:	2862      	cmp	r0, #98	; 0x62
   40ce0:	d822      	bhi.n	40d28 <cbvprintf+0x53c>
   40ce2:	2825      	cmp	r0, #37	; 0x25
   40ce4:	f43f ad93 	beq.w	4080e <cbvprintf+0x22>
   40ce8:	2858      	cmp	r0, #88	; 0x58
   40cea:	d1a9      	bne.n	40c40 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   40cec:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   40cf0:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40cf4:	9300      	str	r3, [sp, #0]
   40cf6:	aa0c      	add	r2, sp, #48	; 0x30
   40cf8:	ab04      	add	r3, sp, #16
   40cfa:	f006 fcee 	bl	476da <encode_uint>
   40cfe:	4682      	mov	sl, r0
			if (precision >= 0) {
   40d00:	f1b8 0f00 	cmp.w	r8, #0
   40d04:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   40d08:	db0c      	blt.n	40d24 <cbvprintf+0x538>
				conv->flag_zero = false;
   40d0a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   40d0e:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   40d12:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   40d16:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   40d18:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   40d1c:	d902      	bls.n	40d24 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   40d1e:	eba8 0303 	sub.w	r3, r8, r3
   40d22:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   40d24:	4680      	mov	r8, r0
   40d26:	e03d      	b.n	40da4 <cbvprintf+0x5b8>
   40d28:	3863      	subs	r0, #99	; 0x63
   40d2a:	2815      	cmp	r0, #21
   40d2c:	d888      	bhi.n	40c40 <cbvprintf+0x454>
   40d2e:	a101      	add	r1, pc, #4	; (adr r1, 40d34 <cbvprintf+0x548>)
   40d30:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   40d34:	00040db5 	.word	0x00040db5
   40d38:	00040e19 	.word	0x00040e19
   40d3c:	00040c41 	.word	0x00040c41
   40d40:	00040c41 	.word	0x00040c41
   40d44:	00040c41 	.word	0x00040c41
   40d48:	00040c41 	.word	0x00040c41
   40d4c:	00040e19 	.word	0x00040e19
   40d50:	00040c41 	.word	0x00040c41
   40d54:	00040c41 	.word	0x00040c41
   40d58:	00040c41 	.word	0x00040c41
   40d5c:	00040c41 	.word	0x00040c41
   40d60:	00040e77 	.word	0x00040e77
   40d64:	00040e45 	.word	0x00040e45
   40d68:	00040e49 	.word	0x00040e49
   40d6c:	00040c41 	.word	0x00040c41
   40d70:	00040c41 	.word	0x00040c41
   40d74:	00040d8d 	.word	0x00040d8d
   40d78:	00040c41 	.word	0x00040c41
   40d7c:	00040e45 	.word	0x00040e45
   40d80:	00040c41 	.word	0x00040c41
   40d84:	00040c41 	.word	0x00040c41
   40d88:	00040e45 	.word	0x00040e45
			if (precision >= 0) {
   40d8c:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   40d90:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   40d94:	db0a      	blt.n	40dac <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   40d96:	4641      	mov	r1, r8
   40d98:	4650      	mov	r0, sl
   40d9a:	f007 f857 	bl	47e4c <strnlen>
		char sign = 0;
   40d9e:	2600      	movs	r6, #0
			bpe = bps + len;
   40da0:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   40da4:	f1ba 0f00 	cmp.w	sl, #0
   40da8:	d10c      	bne.n	40dc4 <cbvprintf+0x5d8>
   40daa:	e749      	b.n	40c40 <cbvprintf+0x454>
				len = strlen(bps);
   40dac:	4650      	mov	r0, sl
   40dae:	f007 f846 	bl	47e3e <strlen>
   40db2:	e7f4      	b.n	40d9e <cbvprintf+0x5b2>
			break;
   40db4:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40db6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   40db8:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40dbc:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   40dc0:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   40dc4:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   40dc8:	b106      	cbz	r6, 40dcc <cbvprintf+0x5e0>
			nj_len += 1U;
   40dca:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   40dcc:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   40dd0:	06d0      	lsls	r0, r2, #27
   40dd2:	d56b      	bpl.n	40eac <cbvprintf+0x6c0>
			nj_len += 2U;
   40dd4:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   40dd6:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   40dd8:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   40dda:	bf48      	it	mi
   40ddc:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   40dde:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   40de0:	bf48      	it	mi
   40de2:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   40de4:	f1b9 0f00 	cmp.w	r9, #0
   40de8:	dd79      	ble.n	40ede <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   40dea:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   40dee:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   40df2:	f3c2 0380 	ubfx	r3, r2, #2, #1
   40df6:	9303      	str	r3, [sp, #12]
   40df8:	0753      	lsls	r3, r2, #29
   40dfa:	d470      	bmi.n	40ede <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   40dfc:	0650      	lsls	r0, r2, #25
   40dfe:	d564      	bpl.n	40eca <cbvprintf+0x6de>
					if (sign != 0) {
   40e00:	b146      	cbz	r6, 40e14 <cbvprintf+0x628>
						OUTC(sign);
   40e02:	4659      	mov	r1, fp
   40e04:	4630      	mov	r0, r6
   40e06:	9b02      	ldr	r3, [sp, #8]
   40e08:	4798      	blx	r3
   40e0a:	2800      	cmp	r0, #0
   40e0c:	db5a      	blt.n	40ec4 <cbvprintf+0x6d8>
						sign = 0;
   40e0e:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   40e10:	3501      	adds	r5, #1
						sign = 0;
   40e12:	461e      	mov	r6, r3
					pad = '0';
   40e14:	2330      	movs	r3, #48	; 0x30
   40e16:	e059      	b.n	40ecc <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   40e18:	071e      	lsls	r6, r3, #28
   40e1a:	d411      	bmi.n	40e40 <cbvprintf+0x654>
				sign = ' ';
   40e1c:	f013 0610 	ands.w	r6, r3, #16
   40e20:	bf18      	it	ne
   40e22:	2620      	movne	r6, #32
			sint = value->sint;
   40e24:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   40e28:	2a00      	cmp	r2, #0
   40e2a:	f173 0100 	sbcs.w	r1, r3, #0
   40e2e:	f6bf af5d 	bge.w	40cec <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   40e32:	4252      	negs	r2, r2
   40e34:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   40e38:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   40e3a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   40e3e:	e755      	b.n	40cec <cbvprintf+0x500>
				sign = '+';
   40e40:	262b      	movs	r6, #43	; 0x2b
   40e42:	e7ef      	b.n	40e24 <cbvprintf+0x638>
		switch (conv->specifier) {
   40e44:	2600      	movs	r6, #0
   40e46:	e751      	b.n	40cec <cbvprintf+0x500>
			if (value->ptr != NULL) {
   40e48:	980a      	ldr	r0, [sp, #40]	; 0x28
   40e4a:	b348      	cbz	r0, 40ea0 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   40e4c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40e50:	9300      	str	r3, [sp, #0]
   40e52:	2100      	movs	r1, #0
   40e54:	ab04      	add	r3, sp, #16
   40e56:	aa0c      	add	r2, sp, #48	; 0x30
   40e58:	f006 fc3f 	bl	476da <encode_uint>
				conv->altform_0c = true;
   40e5c:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   40e60:	4682      	mov	sl, r0
				conv->altform_0c = true;
   40e62:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   40e66:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   40e6a:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   40e6e:	2600      	movs	r6, #0
				conv->altform_0c = true;
   40e70:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   40e74:	e744      	b.n	40d00 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   40e76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   40e78:	2a07      	cmp	r2, #7
   40e7a:	f63f aee1 	bhi.w	40c40 <cbvprintf+0x454>
   40e7e:	e8df f002 	tbb	[pc, r2]
   40e82:	040d      	.short	0x040d
   40e84:	08080d06 	.word	0x08080d06
   40e88:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   40e8a:	701d      	strb	r5, [r3, #0]
		break;
   40e8c:	e6d8      	b.n	40c40 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   40e8e:	801d      	strh	r5, [r3, #0]
		break;
   40e90:	e6d6      	b.n	40c40 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   40e92:	4628      	mov	r0, r5
   40e94:	17e9      	asrs	r1, r5, #31
   40e96:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   40e9a:	e6d1      	b.n	40c40 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   40e9c:	601d      	str	r5, [r3, #0]
		break;
   40e9e:	e6cf      	b.n	40c40 <cbvprintf+0x454>
			bpe = bps + 5;
   40ea0:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 40f68 <cbvprintf+0x77c>
   40ea4:	4606      	mov	r6, r0
			bps = "(nil)";
   40ea6:	f1a8 0a05 	sub.w	sl, r8, #5
   40eaa:	e78b      	b.n	40dc4 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   40eac:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   40eae:	bf48      	it	mi
   40eb0:	3301      	addmi	r3, #1
   40eb2:	e790      	b.n	40dd6 <cbvprintf+0x5ea>
					OUTC(pad);
   40eb4:	4618      	mov	r0, r3
   40eb6:	9303      	str	r3, [sp, #12]
   40eb8:	4659      	mov	r1, fp
   40eba:	9b02      	ldr	r3, [sp, #8]
   40ebc:	4798      	blx	r3
   40ebe:	2800      	cmp	r0, #0
   40ec0:	9b03      	ldr	r3, [sp, #12]
   40ec2:	da04      	bge.n	40ece <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   40ec4:	b011      	add	sp, #68	; 0x44
   40ec6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   40eca:	2320      	movs	r3, #32
   40ecc:	444d      	add	r5, r9
   40ece:	464a      	mov	r2, r9
				while (width-- > 0) {
   40ed0:	2a00      	cmp	r2, #0
   40ed2:	eba5 0109 	sub.w	r1, r5, r9
   40ed6:	f109 39ff 	add.w	r9, r9, #4294967295
   40eda:	dceb      	bgt.n	40eb4 <cbvprintf+0x6c8>
   40edc:	460d      	mov	r5, r1
		if (sign != 0) {
   40ede:	b136      	cbz	r6, 40eee <cbvprintf+0x702>
			OUTC(sign);
   40ee0:	4659      	mov	r1, fp
   40ee2:	4630      	mov	r0, r6
   40ee4:	9b02      	ldr	r3, [sp, #8]
   40ee6:	4798      	blx	r3
   40ee8:	2800      	cmp	r0, #0
   40eea:	dbeb      	blt.n	40ec4 <cbvprintf+0x6d8>
   40eec:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   40eee:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40ef2:	06d9      	lsls	r1, r3, #27
   40ef4:	d401      	bmi.n	40efa <cbvprintf+0x70e>
   40ef6:	071a      	lsls	r2, r3, #28
   40ef8:	d506      	bpl.n	40f08 <cbvprintf+0x71c>
				OUTC('0');
   40efa:	4659      	mov	r1, fp
   40efc:	2030      	movs	r0, #48	; 0x30
   40efe:	9b02      	ldr	r3, [sp, #8]
   40f00:	4798      	blx	r3
   40f02:	2800      	cmp	r0, #0
   40f04:	dbde      	blt.n	40ec4 <cbvprintf+0x6d8>
   40f06:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   40f08:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40f0c:	06db      	lsls	r3, r3, #27
   40f0e:	d507      	bpl.n	40f20 <cbvprintf+0x734>
				OUTC(conv->specifier);
   40f10:	4659      	mov	r1, fp
   40f12:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   40f16:	9b02      	ldr	r3, [sp, #8]
   40f18:	4798      	blx	r3
   40f1a:	2800      	cmp	r0, #0
   40f1c:	dbd2      	blt.n	40ec4 <cbvprintf+0x6d8>
   40f1e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   40f20:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   40f22:	442e      	add	r6, r5
   40f24:	1b73      	subs	r3, r6, r5
   40f26:	2b00      	cmp	r3, #0
   40f28:	dc16      	bgt.n	40f58 <cbvprintf+0x76c>
			OUTS(bps, bpe);
   40f2a:	4643      	mov	r3, r8
   40f2c:	4652      	mov	r2, sl
   40f2e:	4659      	mov	r1, fp
   40f30:	9802      	ldr	r0, [sp, #8]
   40f32:	f006 fc1d 	bl	47770 <outs>
   40f36:	2800      	cmp	r0, #0
   40f38:	dbc4      	blt.n	40ec4 <cbvprintf+0x6d8>
   40f3a:	4405      	add	r5, r0
		while (width > 0) {
   40f3c:	44a9      	add	r9, r5
   40f3e:	eba9 0305 	sub.w	r3, r9, r5
   40f42:	2b00      	cmp	r3, #0
   40f44:	f77f ae7c 	ble.w	40c40 <cbvprintf+0x454>
			OUTC(' ');
   40f48:	4659      	mov	r1, fp
   40f4a:	2020      	movs	r0, #32
   40f4c:	9b02      	ldr	r3, [sp, #8]
   40f4e:	4798      	blx	r3
   40f50:	2800      	cmp	r0, #0
   40f52:	dbb7      	blt.n	40ec4 <cbvprintf+0x6d8>
   40f54:	3501      	adds	r5, #1
			--width;
   40f56:	e7f2      	b.n	40f3e <cbvprintf+0x752>
				OUTC('0');
   40f58:	4659      	mov	r1, fp
   40f5a:	2030      	movs	r0, #48	; 0x30
   40f5c:	9b02      	ldr	r3, [sp, #8]
   40f5e:	4798      	blx	r3
   40f60:	2800      	cmp	r0, #0
   40f62:	dbaf      	blt.n	40ec4 <cbvprintf+0x6d8>
   40f64:	3501      	adds	r5, #1
   40f66:	e7dd      	b.n	40f24 <cbvprintf+0x738>
   40f68:	00048e64 	.word	0x00048e64

00040f6c <nordicsemi_nrf91_init>:
   40f6c:	f04f 0220 	mov.w	r2, #32
   40f70:	f3ef 8311 	mrs	r3, BASEPRI
   40f74:	f382 8812 	msr	BASEPRI_MAX, r2
   40f78:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   40f7c:	2101      	movs	r1, #1
   40f7e:	4a04      	ldr	r2, [pc, #16]	; (40f90 <nordicsemi_nrf91_init+0x24>)
   40f80:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   40f84:	f383 8811 	msr	BASEPRI, r3
   40f88:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   40f8c:	2000      	movs	r0, #0
   40f8e:	4770      	bx	lr
   40f90:	40039000 	.word	0x40039000

00040f94 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   40f94:	b120      	cbz	r0, 40fa0 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   40f96:	4b03      	ldr	r3, [pc, #12]	; (40fa4 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   40f98:	0180      	lsls	r0, r0, #6
   40f9a:	f043 0301 	orr.w	r3, r3, #1
   40f9e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   40fa0:	4770      	bx	lr
   40fa2:	bf00      	nop
   40fa4:	00048c10 	.word	0x00048c10

00040fa8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
   40fa8:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   40faa:	2200      	movs	r2, #0
{
   40fac:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
   40fae:	490f      	ldr	r1, [pc, #60]	; (40fec <enable_logger+0x44>)
   40fb0:	480f      	ldr	r0, [pc, #60]	; (40ff0 <enable_logger+0x48>)
   40fb2:	f007 fc4a 	bl	4884a <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   40fb6:	2200      	movs	r2, #0
   40fb8:	2300      	movs	r3, #0
   40fba:	2400      	movs	r4, #0
   40fbc:	e9cd 2306 	strd	r2, r3, [sp, #24]
   40fc0:	230e      	movs	r3, #14
   40fc2:	4d0c      	ldr	r5, [pc, #48]	; (40ff4 <enable_logger+0x4c>)
   40fc4:	e9cd 3403 	strd	r3, r4, [sp, #12]
   40fc8:	f44f 7240 	mov.w	r2, #768	; 0x300
   40fcc:	4628      	mov	r0, r5
   40fce:	e9cd 4401 	strd	r4, r4, [sp, #4]
   40fd2:	4b09      	ldr	r3, [pc, #36]	; (40ff8 <enable_logger+0x50>)
   40fd4:	4909      	ldr	r1, [pc, #36]	; (40ffc <enable_logger+0x54>)
   40fd6:	9400      	str	r4, [sp, #0]
   40fd8:	f005 f918 	bl	4620c <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
   40fdc:	4908      	ldr	r1, [pc, #32]	; (41000 <enable_logger+0x58>)
   40fde:	4628      	mov	r0, r5
   40fe0:	f007 faaf 	bl	48542 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   40fe4:	4620      	mov	r0, r4
   40fe6:	b009      	add	sp, #36	; 0x24
   40fe8:	bd30      	pop	{r4, r5, pc}
   40fea:	bf00      	nop
   40fec:	00041005 	.word	0x00041005
   40ff0:	2001a678 	.word	0x2001a678
   40ff4:	2001a6b0 	.word	0x2001a6b0
   40ff8:	000413e5 	.word	0x000413e5
   40ffc:	20020b28 	.word	0x20020b28
   41000:	00048e69 	.word	0x00048e69

00041004 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   41004:	4801      	ldr	r0, [pc, #4]	; (4100c <log_process_thread_timer_expiry_fn+0x8>)
   41006:	f005 ba4f 	b.w	464a8 <z_impl_k_sem_give>
   4100a:	bf00      	nop
   4100c:	2001a668 	.word	0x2001a668

00041010 <log_core_init>:
	panic_mode = false;
   41010:	2300      	movs	r3, #0
   41012:	4a0c      	ldr	r2, [pc, #48]	; (41044 <log_core_init+0x34>)
{
   41014:	b510      	push	{r4, lr}
	panic_mode = false;
   41016:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
   41018:	4a0b      	ldr	r2, [pc, #44]	; (41048 <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
   4101a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	dropped_cnt = 0;
   4101e:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
   41020:	4b0a      	ldr	r3, [pc, #40]	; (4104c <log_core_init+0x3c>)
   41022:	4a0b      	ldr	r2, [pc, #44]	; (41050 <log_core_init+0x40>)
   41024:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   41026:	f000 fcb5 	bl	41994 <log_output_timestamp_freq_set>
		log_msg_pool_init();
   4102a:	f000 fa55 	bl	414d8 <log_msg_pool_init>
		log_list_init(&list);
   4102e:	4809      	ldr	r0, [pc, #36]	; (41054 <log_core_init+0x44>)
   41030:	f006 fbd3 	bl	477da <log_list_init>
}
   41034:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   41038:	2304      	movs	r3, #4
   4103a:	2228      	movs	r2, #40	; 0x28
   4103c:	4906      	ldr	r1, [pc, #24]	; (41058 <log_core_init+0x48>)
   4103e:	4807      	ldr	r0, [pc, #28]	; (4105c <log_core_init+0x4c>)
   41040:	f007 ba35 	b.w	484ae <k_mem_slab_init>
   41044:	2001adcb 	.word	0x2001adcb
   41048:	2001a874 	.word	0x2001a874
   4104c:	2001a570 	.word	0x2001a570
   41050:	00047819 	.word	0x00047819
   41054:	2001a87c 	.word	0x2001a87c
   41058:	20023b68 	.word	0x20023b68
   4105c:	2001a884 	.word	0x2001a884

00041060 <log_init>:
{
   41060:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   41062:	4b10      	ldr	r3, [pc, #64]	; (410a4 <log_init+0x44>)
   41064:	e8d3 5fef 	ldaex	r5, [r3]
   41068:	1c6a      	adds	r2, r5, #1
   4106a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4106e:	2900      	cmp	r1, #0
   41070:	d1f8      	bne.n	41064 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
   41072:	b92d      	cbnz	r5, 41080 <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   41074:	4c0c      	ldr	r4, [pc, #48]	; (410a8 <log_init+0x48>)
   41076:	4e0d      	ldr	r6, [pc, #52]	; (410ac <log_init+0x4c>)
   41078:	1b36      	subs	r6, r6, r4
   4107a:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   4107c:	42b5      	cmp	r5, r6
   4107e:	db00      	blt.n	41082 <log_init+0x22>
}
   41080:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   41082:	7b23      	ldrb	r3, [r4, #12]
   41084:	b153      	cbz	r3, 4109c <log_init+0x3c>
			if (backend->api->init != NULL) {
   41086:	6823      	ldr	r3, [r4, #0]
   41088:	699b      	ldr	r3, [r3, #24]
   4108a:	b10b      	cbz	r3, 41090 <log_init+0x30>
				backend->api->init(backend);
   4108c:	4620      	mov	r0, r4
   4108e:	4798      	blx	r3
			log_backend_enable(backend,
   41090:	6863      	ldr	r3, [r4, #4]
   41092:	2204      	movs	r2, #4
   41094:	4620      	mov	r0, r4
   41096:	6819      	ldr	r1, [r3, #0]
   41098:	f000 fa10 	bl	414bc <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   4109c:	3501      	adds	r5, #1
   4109e:	3410      	adds	r4, #16
   410a0:	e7ec      	b.n	4107c <log_init+0x1c>
   410a2:	bf00      	nop
   410a4:	2001a878 	.word	0x2001a878
   410a8:	00048bd8 	.word	0x00048bd8
   410ac:	00048bf8 	.word	0x00048bf8

000410b0 <get_msg>:
{
   410b0:	b510      	push	{r4, lr}
	__asm__ volatile(
   410b2:	f04f 0320 	mov.w	r3, #32
   410b6:	f3ef 8411 	mrs	r4, BASEPRI
   410ba:	f383 8812 	msr	BASEPRI_MAX, r3
   410be:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
   410c2:	4804      	ldr	r0, [pc, #16]	; (410d4 <get_msg+0x24>)
   410c4:	f006 fb99 	bl	477fa <log_list_head_get>
	__asm__ volatile(
   410c8:	f384 8811 	msr	BASEPRI, r4
   410cc:	f3bf 8f6f 	isb	sy
}
   410d0:	bd10      	pop	{r4, pc}
   410d2:	bf00      	nop
   410d4:	2001a87c 	.word	0x2001a87c

000410d8 <z_log_notify_backend_enabled>:
{
   410d8:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
   410da:	4c04      	ldr	r4, [pc, #16]	; (410ec <z_log_notify_backend_enabled+0x14>)
   410dc:	7822      	ldrb	r2, [r4, #0]
   410de:	b912      	cbnz	r2, 410e6 <z_log_notify_backend_enabled+0xe>
   410e0:	4803      	ldr	r0, [pc, #12]	; (410f0 <z_log_notify_backend_enabled+0x18>)
   410e2:	f005 f9e1 	bl	464a8 <z_impl_k_sem_give>
	backend_attached = true;
   410e6:	2301      	movs	r3, #1
   410e8:	7023      	strb	r3, [r4, #0]
}
   410ea:	bd10      	pop	{r4, pc}
   410ec:	2001adca 	.word	0x2001adca
   410f0:	2001a668 	.word	0x2001a668

000410f4 <z_log_dropped>:
   410f4:	4b08      	ldr	r3, [pc, #32]	; (41118 <z_log_dropped+0x24>)
   410f6:	e8d3 2fef 	ldaex	r2, [r3]
   410fa:	3201      	adds	r2, #1
   410fc:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41100:	2900      	cmp	r1, #0
   41102:	d1f8      	bne.n	410f6 <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41104:	4b05      	ldr	r3, [pc, #20]	; (4111c <z_log_dropped+0x28>)
   41106:	e8d3 2fef 	ldaex	r2, [r3]
   4110a:	3a01      	subs	r2, #1
   4110c:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41110:	2900      	cmp	r1, #0
   41112:	d1f8      	bne.n	41106 <z_log_dropped+0x12>
}
   41114:	4770      	bx	lr
   41116:	bf00      	nop
   41118:	2001a874 	.word	0x2001a874
   4111c:	2001a870 	.word	0x2001a870

00041120 <z_log_dropped_read_and_clear>:
}
   41120:	2000      	movs	r0, #0
   41122:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   41124:	4b03      	ldr	r3, [pc, #12]	; (41134 <z_log_dropped_read_and_clear+0x14>)
   41126:	e8d3 0fef 	ldaex	r0, [r3]
   4112a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4112e:	2900      	cmp	r1, #0
   41130:	d1f9      	bne.n	41126 <z_log_dropped_read_and_clear+0x6>
   41132:	4770      	bx	lr
   41134:	2001a874 	.word	0x2001a874

00041138 <dropped_notify>:
{
   41138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
   4113a:	f7ff fff1 	bl	41120 <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
   4113e:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
   41140:	4607      	mov	r7, r0
   41142:	4c09      	ldr	r4, [pc, #36]	; (41168 <dropped_notify+0x30>)
   41144:	4d09      	ldr	r5, [pc, #36]	; (4116c <dropped_notify+0x34>)
   41146:	1b2d      	subs	r5, r5, r4
   41148:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   4114a:	42ae      	cmp	r6, r5
   4114c:	db00      	blt.n	41150 <dropped_notify+0x18>
}
   4114e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   41150:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41152:	795b      	ldrb	r3, [r3, #5]
   41154:	b12b      	cbz	r3, 41162 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
   41156:	6823      	ldr	r3, [r4, #0]
   41158:	691b      	ldr	r3, [r3, #16]
   4115a:	b113      	cbz	r3, 41162 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
   4115c:	4639      	mov	r1, r7
   4115e:	4620      	mov	r0, r4
   41160:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41162:	3601      	adds	r6, #1
   41164:	3410      	adds	r4, #16
   41166:	e7f0      	b.n	4114a <dropped_notify+0x12>
   41168:	00048bd8 	.word	0x00048bd8
   4116c:	00048bf8 	.word	0x00048bf8

00041170 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   41170:	4b14      	ldr	r3, [pc, #80]	; (411c4 <z_log_strdup+0x54>)
{
   41172:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
   41174:	4298      	cmp	r0, r3
{
   41176:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41178:	d302      	bcc.n	41180 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   4117a:	4b13      	ldr	r3, [pc, #76]	; (411c8 <z_log_strdup+0x58>)
   4117c:	4298      	cmp	r0, r3
   4117e:	d31c      	bcc.n	411ba <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   41180:	2200      	movs	r2, #0
   41182:	2300      	movs	r3, #0
   41184:	4811      	ldr	r0, [pc, #68]	; (411cc <z_log_strdup+0x5c>)
   41186:	a901      	add	r1, sp, #4
   41188:	f004 ffe0 	bl	4614c <k_mem_slab_alloc>
	if (err != 0) {
   4118c:	4605      	mov	r5, r0
   4118e:	b9b8      	cbnz	r0, 411c0 <z_log_strdup+0x50>
   41190:	2201      	movs	r2, #1
   41192:	9b01      	ldr	r3, [sp, #4]
   41194:	e8d3 1fef 	ldaex	r1, [r3]
   41198:	e8c3 2fe0 	stlex	r0, r2, [r3]
   4119c:	2800      	cmp	r0, #0
   4119e:	d1f9      	bne.n	41194 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   411a0:	9801      	ldr	r0, [sp, #4]
   411a2:	4621      	mov	r1, r4
   411a4:	221f      	movs	r2, #31
   411a6:	3004      	adds	r0, #4
   411a8:	f006 fe36 	bl	47e18 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   411ac:	237e      	movs	r3, #126	; 0x7e
   411ae:	9c01      	ldr	r4, [sp, #4]
   411b0:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   411b4:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   411b8:	3404      	adds	r4, #4
}
   411ba:	4620      	mov	r0, r4
   411bc:	b003      	add	sp, #12
   411be:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   411c0:	4c03      	ldr	r4, [pc, #12]	; (411d0 <z_log_strdup+0x60>)
   411c2:	e7fa      	b.n	411ba <z_log_strdup+0x4a>
   411c4:	000488b0 	.word	0x000488b0
   411c8:	00049658 	.word	0x00049658
   411cc:	2001a884 	.word	0x2001a884
   411d0:	00048e71 	.word	0x00048e71

000411d4 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
   411d4:	b148      	cbz	r0, 411ea <log_is_strdup+0x16>
   411d6:	4b05      	ldr	r3, [pc, #20]	; (411ec <log_is_strdup+0x18>)
   411d8:	4298      	cmp	r0, r3
   411da:	d305      	bcc.n	411e8 <log_is_strdup+0x14>
   411dc:	33a0      	adds	r3, #160	; 0xa0
   411de:	4298      	cmp	r0, r3
   411e0:	bf2c      	ite	cs
   411e2:	2000      	movcs	r0, #0
   411e4:	2001      	movcc	r0, #1
   411e6:	4770      	bx	lr
   411e8:	2000      	movs	r0, #0
}
   411ea:	4770      	bx	lr
   411ec:	20023b68 	.word	0x20023b68

000411f0 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
   411f0:	4b41      	ldr	r3, [pc, #260]	; (412f8 <z_impl_log_process+0x108>)
{
   411f2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   411f6:	781b      	ldrb	r3, [r3, #0]
{
   411f8:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   411fa:	b903      	cbnz	r3, 411fe <z_impl_log_process+0xe>
   411fc:	b1a0      	cbz	r0, 41228 <z_impl_log_process+0x38>
	msg = get_msg();
   411fe:	f7ff ff57 	bl	410b0 <get_msg>
	if (msg.msg) {
   41202:	4605      	mov	r5, r0
   41204:	b118      	cbz	r0, 4120e <z_impl_log_process+0x1e>
		if (!bypass) {
   41206:	b19c      	cbz	r4, 41230 <z_impl_log_process+0x40>
			log_msg_put(msg.msg);
   41208:	4628      	mov	r0, r5
   4120a:	f006 fc02 	bl	47a12 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
   4120e:	b92c      	cbnz	r4, 4121c <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
   41210:	4b3a      	ldr	r3, [pc, #232]	; (412fc <z_impl_log_process+0x10c>)
	if (!bypass && z_log_dropped_pending()) {
   41212:	681b      	ldr	r3, [r3, #0]
   41214:	2b00      	cmp	r3, #0
   41216:	dd01      	ble.n	4121c <z_impl_log_process+0x2c>
		dropped_notify();
   41218:	f7ff ff8e 	bl	41138 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   4121c:	4838      	ldr	r0, [pc, #224]	; (41300 <z_impl_log_process+0x110>)
   4121e:	f006 faea 	bl	477f6 <log_list_head_peek>
   41222:	1e04      	subs	r4, r0, #0
   41224:	bf18      	it	ne
   41226:	2401      	movne	r4, #1
}
   41228:	4620      	mov	r0, r4
   4122a:	b003      	add	sp, #12
   4122c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41230:	4b34      	ldr	r3, [pc, #208]	; (41304 <z_impl_log_process+0x114>)
   41232:	e8d3 2fef 	ldaex	r2, [r3]
   41236:	3a01      	subs	r2, #1
   41238:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4123c:	2900      	cmp	r1, #0
   4123e:	d1f8      	bne.n	41232 <z_impl_log_process+0x42>
		    !panic_mode) {
   41240:	4b31      	ldr	r3, [pc, #196]	; (41308 <z_impl_log_process+0x118>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
   41242:	781b      	ldrb	r3, [r3, #0]
   41244:	b9bb      	cbnz	r3, 41276 <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41246:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   41248:	07db      	lsls	r3, r3, #31
   4124a:	d414      	bmi.n	41276 <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
   4124c:	f006 fbf0 	bl	47a30 <log_msg_str_get>
   41250:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
   41252:	4628      	mov	r0, r5
   41254:	f006 fbbb 	bl	479ce <log_msg_nargs_get>
   41258:	4601      	mov	r1, r0
   4125a:	4640      	mov	r0, r8
   4125c:	f006 fae0 	bl	47820 <z_log_get_s_mask>
   41260:	4606      	mov	r6, r0
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
   41262:	4b2a      	ldr	r3, [pc, #168]	; (4130c <z_impl_log_process+0x11c>)
   41264:	4a2a      	ldr	r2, [pc, #168]	; (41310 <z_impl_log_process+0x120>)
		if (!is_rodata(str) && !log_is_strdup(str) &&
   41266:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 41324 <z_impl_log_process+0x134>
   4126a:	1a9b      	subs	r3, r3, r2
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   4126c:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 41328 <z_impl_log_process+0x138>
   41270:	ea4f 09d3 	mov.w	r9, r3, lsr #3
	while (mask) {
   41274:	b936      	cbnz	r6, 41284 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
   41276:	4e27      	ldr	r6, [pc, #156]	; (41314 <z_impl_log_process+0x124>)
   41278:	4f27      	ldr	r7, [pc, #156]	; (41318 <z_impl_log_process+0x128>)
   4127a:	f04f 0800 	mov.w	r8, #0
   4127e:	1bbf      	subs	r7, r7, r6
   41280:	113f      	asrs	r7, r7, #4
   41282:	e036      	b.n	412f2 <z_impl_log_process+0x102>
		idx = 31 - __builtin_clz(mask);
   41284:	fab6 f786 	clz	r7, r6
   41288:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   4128c:	4639      	mov	r1, r7
   4128e:	4628      	mov	r0, r5
   41290:	f006 fba0 	bl	479d4 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   41294:	4b21      	ldr	r3, [pc, #132]	; (4131c <z_impl_log_process+0x12c>)
		str = (const char *)log_msg_arg_get(msg, idx);
   41296:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41298:	4298      	cmp	r0, r3
   4129a:	d302      	bcc.n	412a2 <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   4129c:	4b20      	ldr	r3, [pc, #128]	; (41320 <z_impl_log_process+0x130>)
   4129e:	4298      	cmp	r0, r3
   412a0:	d316      	bcc.n	412d0 <z_impl_log_process+0xe0>
   412a2:	4610      	mov	r0, r2
   412a4:	f7ff ff96 	bl	411d4 <log_is_strdup>
   412a8:	b990      	cbnz	r0, 412d0 <z_impl_log_process+0xe0>
   412aa:	4552      	cmp	r2, sl
   412ac:	d010      	beq.n	412d0 <z_impl_log_process+0xe0>
	return msg->hdr.ids.source_id;
   412ae:	8969      	ldrh	r1, [r5, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   412b0:	f3c1 1189 	ubfx	r1, r1, #6, #10
   412b4:	f000 f8f4 	bl	414a0 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   412b8:	ea4f 1389 	mov.w	r3, r9, lsl #6
   412bc:	f043 0301 	orr.w	r3, r3, #1
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   412c0:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   412c2:	f8ad 3000 	strh.w	r3, [sp]
   412c6:	4639      	mov	r1, r7
   412c8:	4643      	mov	r3, r8
   412ca:	4658      	mov	r0, fp
   412cc:	f006 fb02 	bl	478d4 <log_3>
		mask &= ~BIT(idx);
   412d0:	2301      	movs	r3, #1
   412d2:	fa03 f707 	lsl.w	r7, r3, r7
   412d6:	ea26 0607 	bic.w	r6, r6, r7
   412da:	e7cb      	b.n	41274 <z_impl_log_process+0x84>
	return backend->cb->active;
   412dc:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
   412de:	795b      	ldrb	r3, [r3, #5]
   412e0:	b123      	cbz	r3, 412ec <z_impl_log_process+0xfc>
	backend->api->put(backend, msg);
   412e2:	6833      	ldr	r3, [r6, #0]
   412e4:	4629      	mov	r1, r5
   412e6:	4630      	mov	r0, r6
   412e8:	685b      	ldr	r3, [r3, #4]
   412ea:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   412ec:	f108 0801 	add.w	r8, r8, #1
   412f0:	3610      	adds	r6, #16
   412f2:	45b8      	cmp	r8, r7
   412f4:	dbf2      	blt.n	412dc <z_impl_log_process+0xec>
   412f6:	e787      	b.n	41208 <z_impl_log_process+0x18>
   412f8:	2001adca 	.word	0x2001adca
   412fc:	2001a874 	.word	0x2001a874
   41300:	2001a87c 	.word	0x2001a87c
   41304:	2001a870 	.word	0x2001a870
   41308:	2001adcb 	.word	0x2001adcb
   4130c:	00048b98 	.word	0x00048b98
   41310:	00048b88 	.word	0x00048b88
   41314:	00048bd8 	.word	0x00048bd8
   41318:	00048bf8 	.word	0x00048bf8
   4131c:	000488b0 	.word	0x000488b0
   41320:	00049658 	.word	0x00049658
   41324:	00048e71 	.word	0x00048e71
   41328:	00048e8b 	.word	0x00048e8b

0004132c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   4132c:	4b26      	ldr	r3, [pc, #152]	; (413c8 <msg_finalize+0x9c>)
{
   4132e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
   41330:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   41332:	8141      	strh	r1, [r0, #10]
{
   41334:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
   41336:	4798      	blx	r3
   41338:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4133a:	f04f 0320 	mov.w	r3, #32
   4133e:	f3ef 8511 	mrs	r5, BASEPRI
   41342:	f383 8812 	msr	BASEPRI_MAX, r3
   41346:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   4134a:	4820      	ldr	r0, [pc, #128]	; (413cc <msg_finalize+0xa0>)
   4134c:	4621      	mov	r1, r4
   4134e:	f006 fa48 	bl	477e2 <log_list_add_tail>
	__asm__ volatile(
   41352:	f385 8811 	msr	BASEPRI, r5
   41356:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4135a:	4b1d      	ldr	r3, [pc, #116]	; (413d0 <msg_finalize+0xa4>)
   4135c:	e8d3 2fef 	ldaex	r2, [r3]
   41360:	1c51      	adds	r1, r2, #1
   41362:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41366:	2800      	cmp	r0, #0
   41368:	d1f8      	bne.n	4135c <msg_finalize+0x30>
	if (panic_mode) {
   4136a:	4b1a      	ldr	r3, [pc, #104]	; (413d4 <msg_finalize+0xa8>)
   4136c:	781b      	ldrb	r3, [r3, #0]
   4136e:	b183      	cbz	r3, 41392 <msg_finalize+0x66>
	__asm__ volatile(
   41370:	f04f 0320 	mov.w	r3, #32
   41374:	f3ef 8411 	mrs	r4, BASEPRI
   41378:	f383 8812 	msr	BASEPRI_MAX, r3
   4137c:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   41380:	2000      	movs	r0, #0
   41382:	f7ff ff35 	bl	411f0 <z_impl_log_process>
	__asm__ volatile(
   41386:	f384 8811 	msr	BASEPRI, r4
   4138a:	f3bf 8f6f 	isb	sy
}
   4138e:	b003      	add	sp, #12
   41390:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && cnt == 0) {
   41392:	4b11      	ldr	r3, [pc, #68]	; (413d8 <msg_finalize+0xac>)
   41394:	681b      	ldr	r3, [r3, #0]
   41396:	2b00      	cmp	r3, #0
   41398:	d0f9      	beq.n	4138e <msg_finalize+0x62>
   4139a:	b952      	cbnz	r2, 413b2 <msg_finalize+0x86>
	z_impl_k_timer_start(timer, duration, period);
   4139c:	2200      	movs	r2, #0
   4139e:	2300      	movs	r3, #0
   413a0:	480e      	ldr	r0, [pc, #56]	; (413dc <msg_finalize+0xb0>)
   413a2:	e9cd 2300 	strd	r2, r3, [sp]
   413a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   413aa:	2300      	movs	r3, #0
   413ac:	f005 fdc8 	bl	46f40 <z_impl_k_timer_start>
   413b0:	e7ed      	b.n	4138e <msg_finalize+0x62>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   413b2:	2a0a      	cmp	r2, #10
   413b4:	d1eb      	bne.n	4138e <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
   413b6:	4809      	ldr	r0, [pc, #36]	; (413dc <msg_finalize+0xb0>)
   413b8:	f007 fa53 	bl	48862 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   413bc:	4808      	ldr	r0, [pc, #32]	; (413e0 <msg_finalize+0xb4>)
}
   413be:	b003      	add	sp, #12
   413c0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   413c4:	f005 b870 	b.w	464a8 <z_impl_k_sem_give>
   413c8:	2001a570 	.word	0x2001a570
   413cc:	2001a87c 	.word	0x2001a87c
   413d0:	2001a870 	.word	0x2001a870
   413d4:	2001adcb 	.word	0x2001adcb
   413d8:	2001a8a0 	.word	0x2001a8a0
   413dc:	2001a678 	.word	0x2001a678
   413e0:	2001a668 	.word	0x2001a668

000413e4 <log_process_thread_func>:
{
   413e4:	b510      	push	{r4, lr}
	log_init();
   413e6:	f7ff fe3b 	bl	41060 <log_init>
	return z_impl_z_current_get();
   413ea:	f005 fb97 	bl	46b1c <z_impl_z_current_get>
	proc_tid = process_tid;
   413ee:	4b0c      	ldr	r3, [pc, #48]	; (41420 <log_process_thread_func+0x3c>)
   413f0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   413f2:	b130      	cbz	r0, 41402 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   413f4:	4b0b      	ldr	r3, [pc, #44]	; (41424 <log_process_thread_func+0x40>)
	    process_tid &&
   413f6:	681b      	ldr	r3, [r3, #0]
   413f8:	2b09      	cmp	r3, #9
   413fa:	dd02      	ble.n	41402 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   413fc:	480a      	ldr	r0, [pc, #40]	; (41428 <log_process_thread_func+0x44>)
   413fe:	f005 f853 	bl	464a8 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   41402:	4c09      	ldr	r4, [pc, #36]	; (41428 <log_process_thread_func+0x44>)
   41404:	2000      	movs	r0, #0
   41406:	f7ff fef3 	bl	411f0 <z_impl_log_process>
		if (log_process(false) == false) {
   4140a:	2800      	cmp	r0, #0
   4140c:	d1fa      	bne.n	41404 <log_process_thread_func+0x20>
   4140e:	f04f 32ff 	mov.w	r2, #4294967295
   41412:	f04f 33ff 	mov.w	r3, #4294967295
   41416:	4620      	mov	r0, r4
   41418:	f005 f866 	bl	464e8 <z_impl_k_sem_take>
   4141c:	e7f2      	b.n	41404 <log_process_thread_func+0x20>
   4141e:	bf00      	nop
   41420:	2001a8a0 	.word	0x2001a8a0
   41424:	2001a870 	.word	0x2001a870
   41428:	2001a668 	.word	0x2001a668

0004142c <z_impl_log_panic>:
{
   4142c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   4142e:	4f0e      	ldr	r7, [pc, #56]	; (41468 <z_impl_log_panic+0x3c>)
   41430:	783d      	ldrb	r5, [r7, #0]
   41432:	b975      	cbnz	r5, 41452 <z_impl_log_panic+0x26>
	log_init();
   41434:	f7ff fe14 	bl	41060 <log_init>
	return __log_backends_end - __log_backends_start;
   41438:	4c0c      	ldr	r4, [pc, #48]	; (4146c <z_impl_log_panic+0x40>)
   4143a:	4e0d      	ldr	r6, [pc, #52]	; (41470 <z_impl_log_panic+0x44>)
   4143c:	1b36      	subs	r6, r6, r4
   4143e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   41440:	42b5      	cmp	r5, r6
   41442:	db07      	blt.n	41454 <z_impl_log_panic+0x28>
   41444:	2000      	movs	r0, #0
   41446:	f7ff fed3 	bl	411f0 <z_impl_log_process>
		while (log_process(false) == true) {
   4144a:	2800      	cmp	r0, #0
   4144c:	d1fa      	bne.n	41444 <z_impl_log_panic+0x18>
	panic_mode = true;
   4144e:	2301      	movs	r3, #1
   41450:	703b      	strb	r3, [r7, #0]
}
   41452:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   41454:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41456:	795b      	ldrb	r3, [r3, #5]
   41458:	b11b      	cbz	r3, 41462 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   4145a:	6823      	ldr	r3, [r4, #0]
   4145c:	4620      	mov	r0, r4
   4145e:	695b      	ldr	r3, [r3, #20]
   41460:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41462:	3501      	adds	r5, #1
   41464:	3410      	adds	r4, #16
   41466:	e7eb      	b.n	41440 <z_impl_log_panic+0x14>
   41468:	2001adcb 	.word	0x2001adcb
   4146c:	00048bd8 	.word	0x00048bd8
   41470:	00048bf8 	.word	0x00048bf8

00041474 <z_log_free>:
{
   41474:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   41476:	3804      	subs	r0, #4
   41478:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4147a:	e8d0 3fef 	ldaex	r3, [r0]
   4147e:	1e5a      	subs	r2, r3, #1
   41480:	e8c0 2fe1 	stlex	r1, r2, [r0]
   41484:	2900      	cmp	r1, #0
   41486:	d1f8      	bne.n	4147a <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
   41488:	2b01      	cmp	r3, #1
   4148a:	d103      	bne.n	41494 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   4148c:	4803      	ldr	r0, [pc, #12]	; (4149c <z_log_free+0x28>)
   4148e:	a901      	add	r1, sp, #4
   41490:	f007 f828 	bl	484e4 <k_mem_slab_free>
}
   41494:	b003      	add	sp, #12
   41496:	f85d fb04 	ldr.w	pc, [sp], #4
   4149a:	bf00      	nop
   4149c:	2001a884 	.word	0x2001a884

000414a0 <log_source_name_get>:
   414a0:	4a04      	ldr	r2, [pc, #16]	; (414b4 <log_source_name_get+0x14>)
   414a2:	4b05      	ldr	r3, [pc, #20]	; (414b8 <log_source_name_get+0x18>)
   414a4:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   414a6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   414aa:	bf34      	ite	cc
   414ac:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   414b0:	2000      	movcs	r0, #0
}
   414b2:	4770      	bx	lr
   414b4:	00048b88 	.word	0x00048b88
   414b8:	00048bd8 	.word	0x00048bd8

000414bc <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   414bc:	4b05      	ldr	r3, [pc, #20]	; (414d4 <log_backend_enable+0x18>)

	log_backend_id_set(backend, id);
   414be:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
   414c0:	1ac3      	subs	r3, r0, r3
   414c2:	111b      	asrs	r3, r3, #4
   414c4:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   414c6:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
   414c8:	2201      	movs	r2, #1
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);
   414ca:	6843      	ldr	r3, [r0, #4]
	backend->cb->ctx = ctx;
   414cc:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
   414ce:	715a      	strb	r2, [r3, #5]

	z_log_notify_backend_enabled();
   414d0:	f7ff be02 	b.w	410d8 <z_log_notify_backend_enabled>
   414d4:	00048bd8 	.word	0x00048bd8

000414d8 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   414d8:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   414dc:	2220      	movs	r2, #32
   414de:	4902      	ldr	r1, [pc, #8]	; (414e8 <log_msg_pool_init+0x10>)
   414e0:	4802      	ldr	r0, [pc, #8]	; (414ec <log_msg_pool_init+0x14>)
   414e2:	f006 bfe4 	b.w	484ae <k_mem_slab_init>
   414e6:	bf00      	nop
   414e8:	20023c08 	.word	0x20023c08
   414ec:	2001a8a4 	.word	0x2001a8a4

000414f0 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
   414f0:	2300      	movs	r3, #0
{
   414f2:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   414f4:	4d09      	ldr	r5, [pc, #36]	; (4151c <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   414f6:	9301      	str	r3, [sp, #4]
   414f8:	2001      	movs	r0, #1
   414fa:	f7ff fe79 	bl	411f0 <z_impl_log_process>
   414fe:	4604      	mov	r4, r0
			z_log_dropped();
   41500:	f7ff fdf8 	bl	410f4 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   41504:	2200      	movs	r2, #0
   41506:	2300      	movs	r3, #0
   41508:	4628      	mov	r0, r5
   4150a:	a901      	add	r1, sp, #4
   4150c:	f004 fe1e 	bl	4614c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   41510:	b108      	cbz	r0, 41516 <log_msg_no_space_handle+0x26>
   41512:	2c00      	cmp	r4, #0
   41514:	d1f0      	bne.n	414f8 <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
   41516:	9801      	ldr	r0, [sp, #4]
   41518:	b003      	add	sp, #12
   4151a:	bd30      	pop	{r4, r5, pc}
   4151c:	2001a8a4 	.word	0x2001a8a4

00041520 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
   41520:	2300      	movs	r3, #0
{
   41522:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41524:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
   41526:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41528:	4806      	ldr	r0, [pc, #24]	; (41544 <log_msg_chunk_alloc+0x24>)
   4152a:	2300      	movs	r3, #0
   4152c:	a901      	add	r1, sp, #4
   4152e:	f004 fe0d 	bl	4614c <k_mem_slab_alloc>
	if (err != 0) {
   41532:	b110      	cbz	r0, 4153a <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
   41534:	f7ff ffdc 	bl	414f0 <log_msg_no_space_handle>
   41538:	9001      	str	r0, [sp, #4]
}
   4153a:	9801      	ldr	r0, [sp, #4]
   4153c:	b003      	add	sp, #12
   4153e:	f85d fb04 	ldr.w	pc, [sp], #4
   41542:	bf00      	nop
   41544:	2001a8a4 	.word	0x2001a8a4

00041548 <msg_free>:
{
   41548:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4154a:	7a03      	ldrb	r3, [r0, #8]
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
   4154c:	7a45      	ldrb	r5, [r0, #9]
{
   4154e:	b085      	sub	sp, #20
   41550:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   41552:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
   41554:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   41558:	d41c      	bmi.n	41594 <msg_free+0x4c>
   4155a:	b1dd      	cbz	r5, 41594 <msg_free+0x4c>
		uint32_t smask = 0U;
   4155c:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
   4155e:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
   41560:	4631      	mov	r1, r6
   41562:	9801      	ldr	r0, [sp, #4]
   41564:	f006 fa36 	bl	479d4 <log_msg_arg_get>
   41568:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
   4156a:	f7ff fe33 	bl	411d4 <log_is_strdup>
   4156e:	b170      	cbz	r0, 4158e <msg_free+0x46>
				if (smask == 0U) {
   41570:	b934      	cbnz	r4, 41580 <msg_free+0x38>
					smask = z_log_get_s_mask(
   41572:	9b01      	ldr	r3, [sp, #4]
   41574:	4629      	mov	r1, r5
   41576:	6918      	ldr	r0, [r3, #16]
   41578:	f006 f952 	bl	47820 <z_log_get_s_mask>
					if (smask == 0U) {
   4157c:	4604      	mov	r4, r0
   4157e:	b148      	cbz	r0, 41594 <msg_free+0x4c>
				if (smask & BIT(i)) {
   41580:	fa24 f306 	lsr.w	r3, r4, r6
   41584:	07d9      	lsls	r1, r3, #31
   41586:	d502      	bpl.n	4158e <msg_free+0x46>
					z_log_free(buf);
   41588:	4638      	mov	r0, r7
   4158a:	f7ff ff73 	bl	41474 <z_log_free>
		for (i = 0U; i < nargs; i++) {
   4158e:	3601      	adds	r6, #1
   41590:	42ae      	cmp	r6, r5
   41592:	d3e5      	bcc.n	41560 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
   41594:	9b01      	ldr	r3, [sp, #4]
   41596:	7a1a      	ldrb	r2, [r3, #8]
   41598:	0792      	lsls	r2, r2, #30
   4159a:	d504      	bpl.n	415a6 <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
   4159c:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   4159e:	4c08      	ldr	r4, [pc, #32]	; (415c0 <msg_free+0x78>)
   415a0:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   415a2:	9b03      	ldr	r3, [sp, #12]
   415a4:	b92b      	cbnz	r3, 415b2 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   415a6:	4806      	ldr	r0, [pc, #24]	; (415c0 <msg_free+0x78>)
   415a8:	a901      	add	r1, sp, #4
   415aa:	f006 ff9b 	bl	484e4 <k_mem_slab_free>
}
   415ae:	b005      	add	sp, #20
   415b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
   415b2:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   415b4:	4620      	mov	r0, r4
   415b6:	a903      	add	r1, sp, #12
   415b8:	f006 ff94 	bl	484e4 <k_mem_slab_free>
		cont = next;
   415bc:	9503      	str	r5, [sp, #12]
   415be:	e7f0      	b.n	415a2 <msg_free+0x5a>
   415c0:	2001a8a4 	.word	0x2001a8a4

000415c4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
   415c4:	b40e      	push	{r1, r2, r3}
   415c6:	b503      	push	{r0, r1, lr}
   415c8:	ab03      	add	r3, sp, #12
   415ca:	f853 2b04 	ldr.w	r2, [r3], #4
   415ce:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
   415d0:	4804      	ldr	r0, [pc, #16]	; (415e4 <print_formatted+0x20>)
	va_start(args, fmt);
   415d2:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
   415d4:	f7ff f90a 	bl	407ec <cbvprintf>
	va_end(args);

	return length;
}
   415d8:	b002      	add	sp, #8
   415da:	f85d eb04 	ldr.w	lr, [sp], #4
   415de:	b003      	add	sp, #12
   415e0:	4770      	bx	lr
   415e2:	bf00      	nop
   415e4:	00047d31 	.word	0x00047d31

000415e8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
   415e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   415ec:	461f      	mov	r7, r3
   415ee:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   415f0:	f001 0301 	and.w	r3, r1, #1
{
   415f4:	9205      	str	r2, [sp, #20]
   415f6:	4606      	mov	r6, r0
   415f8:	4688      	mov	r8, r1
   415fa:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
   415fe:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   41602:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   41606:	9304      	str	r3, [sp, #16]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   41608:	f001 0508 	and.w	r5, r1, #8
	const char *tag = z_log_get_tag();
   4160c:	f006 f97e 	bl	4790c <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
   41610:	4602      	mov	r2, r0
   41612:	2800      	cmp	r0, #0
   41614:	d044      	beq.n	416a0 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
   41616:	4630      	mov	r0, r6
   41618:	4938      	ldr	r1, [pc, #224]	; (416fc <prefix_print+0x114>)
   4161a:	f7ff ffd3 	bl	415c4 <print_formatted>
   4161e:	4604      	mov	r4, r0
	}

	if (stamp) {
   41620:	f1bb 0f00 	cmp.w	fp, #0
   41624:	d008      	beq.n	41638 <prefix_print+0x50>
	if (!format) {
   41626:	f018 0f44 	tst.w	r8, #68	; 0x44
   4162a:	d13b      	bne.n	416a4 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
   4162c:	463a      	mov	r2, r7
   4162e:	4630      	mov	r0, r6
   41630:	4933      	ldr	r1, [pc, #204]	; (41700 <prefix_print+0x118>)
   41632:	f7ff ffc7 	bl	415c4 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
   41636:	4404      	add	r4, r0
	if (color) {
   41638:	9b04      	ldr	r3, [sp, #16]
   4163a:	b153      	cbz	r3, 41652 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
   4163c:	4b31      	ldr	r3, [pc, #196]	; (41704 <prefix_print+0x11c>)
		print_formatted(output, "%s", log_color);
   4163e:	4630      	mov	r0, r6
		const char *log_color = start && (colors[level] != NULL) ?
   41640:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
   41644:	4b30      	ldr	r3, [pc, #192]	; (41708 <prefix_print+0x120>)
   41646:	4931      	ldr	r1, [pc, #196]	; (4170c <prefix_print+0x124>)
   41648:	2a00      	cmp	r2, #0
   4164a:	bf08      	it	eq
   4164c:	461a      	moveq	r2, r3
   4164e:	f7ff ffb9 	bl	415c4 <print_formatted>
	if (level_on) {
   41652:	b13d      	cbz	r5, 41664 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
   41654:	4b2e      	ldr	r3, [pc, #184]	; (41710 <prefix_print+0x128>)
   41656:	4630      	mov	r0, r6
   41658:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   4165c:	492d      	ldr	r1, [pc, #180]	; (41714 <prefix_print+0x12c>)
   4165e:	f7ff ffb1 	bl	415c4 <print_formatted>
   41662:	4605      	mov	r5, r0
	if (source_id >= 0) {
   41664:	f1ba 0f00 	cmp.w	sl, #0
   41668:	db16      	blt.n	41698 <prefix_print+0xb0>
		total += print_formatted(output,
   4166a:	9b05      	ldr	r3, [sp, #20]
   4166c:	2b00      	cmp	r3, #0
   4166e:	d043      	beq.n	416f8 <prefix_print+0x110>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   41670:	2301      	movs	r3, #1
   41672:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
   41676:	4b28      	ldr	r3, [pc, #160]	; (41718 <prefix_print+0x130>)
   41678:	f019 0f10 	tst.w	r9, #16
   4167c:	4f27      	ldr	r7, [pc, #156]	; (4171c <prefix_print+0x134>)
   4167e:	bf18      	it	ne
   41680:	461f      	movne	r7, r3
   41682:	4651      	mov	r1, sl
   41684:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
   41688:	f7ff ff0a 	bl	414a0 <log_source_name_get>
   4168c:	4639      	mov	r1, r7
   4168e:	4602      	mov	r2, r0
   41690:	4630      	mov	r0, r6
   41692:	f7ff ff97 	bl	415c4 <print_formatted>
   41696:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
   41698:	1928      	adds	r0, r5, r4
   4169a:	b007      	add	sp, #28
   4169c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
   416a0:	4604      	mov	r4, r0
   416a2:	e7bd      	b.n	41620 <prefix_print+0x38>
	} else if (freq != 0U) {
   416a4:	4b1e      	ldr	r3, [pc, #120]	; (41720 <prefix_print+0x138>)
   416a6:	6818      	ldr	r0, [r3, #0]
   416a8:	2800      	cmp	r0, #0
   416aa:	d0c4      	beq.n	41636 <prefix_print+0x4e>
		timestamp /= timestamp_div;
   416ac:	4b1d      	ldr	r3, [pc, #116]	; (41724 <prefix_print+0x13c>)
   416ae:	f44f 6c61 	mov.w	ip, #3600	; 0xe10
   416b2:	6819      	ldr	r1, [r3, #0]
		mins = seconds / 60U;
   416b4:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
		timestamp /= timestamp_div;
   416b8:	fbb7 f7f1 	udiv	r7, r7, r1
		total_seconds = timestamp / freq;
   416bc:	fbb7 f1f0 	udiv	r1, r7, r0
		seconds -= hours * 3600U;
   416c0:	fbb1 f2fc 	udiv	r2, r1, ip
		remainder = timestamp % freq;
   416c4:	fb00 7711 	mls	r7, r0, r1, r7
   416c8:	fb0c 1c12 	mls	ip, ip, r2, r1
		ms = (remainder * 1000U) / freq;
   416cc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   416d0:	434f      	muls	r7, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   416d2:	fbb7 f8f0 	udiv	r8, r7, r0
   416d6:	fb00 7718 	mls	r7, r0, r8, r7
		mins = seconds / 60U;
   416da:	fbbc f3fe 	udiv	r3, ip, lr
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   416de:	434f      	muls	r7, r1
   416e0:	fbb7 f0f0 	udiv	r0, r7, r0
			length = print_formatted(output,
   416e4:	fb0e c113 	mls	r1, lr, r3, ip
   416e8:	e9cd 8001 	strd	r8, r0, [sp, #4]
   416ec:	9100      	str	r1, [sp, #0]
   416ee:	4630      	mov	r0, r6
   416f0:	490d      	ldr	r1, [pc, #52]	; (41728 <prefix_print+0x140>)
   416f2:	f7ff ff67 	bl	415c4 <print_formatted>
   416f6:	e79e      	b.n	41636 <prefix_print+0x4e>
		total += print_formatted(output,
   416f8:	4f08      	ldr	r7, [pc, #32]	; (4171c <prefix_print+0x134>)
   416fa:	e7c2      	b.n	41682 <prefix_print+0x9a>
   416fc:	00048edd 	.word	0x00048edd
   41700:	00048ee1 	.word	0x00048ee1
   41704:	00048c3c 	.word	0x00048c3c
   41708:	00048ecf 	.word	0x00048ecf
   4170c:	00048f06 	.word	0x00048f06
   41710:	00048c50 	.word	0x00048c50
   41714:	00048f09 	.word	0x00048f09
   41718:	00048ed9 	.word	0x00048ed9
   4171c:	00048ed4 	.word	0x00048ed4
   41720:	2001a8c0 	.word	0x2001a8c0
   41724:	2001a8c4 	.word	0x2001a8c4
   41728:	00048eea 	.word	0x00048eea

0004172c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
   4172c:	b538      	push	{r3, r4, r5, lr}
   4172e:	460c      	mov	r4, r1
	if (color) {
   41730:	07e1      	lsls	r1, r4, #31
{
   41732:	4605      	mov	r5, r0
	if (color) {
   41734:	d503      	bpl.n	4173e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
   41736:	4a08      	ldr	r2, [pc, #32]	; (41758 <postfix_print+0x2c>)
   41738:	4908      	ldr	r1, [pc, #32]	; (4175c <postfix_print+0x30>)
   4173a:	f7ff ff43 	bl	415c4 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   4173e:	06e2      	lsls	r2, r4, #27
   41740:	d408      	bmi.n	41754 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41742:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   41744:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
   41746:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   4174a:	bf4c      	ite	mi
   4174c:	4904      	ldrmi	r1, [pc, #16]	; (41760 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   4174e:	4905      	ldrpl	r1, [pc, #20]	; (41764 <postfix_print+0x38>)
   41750:	f7ff bf38 	b.w	415c4 <print_formatted>
}
   41754:	bd38      	pop	{r3, r4, r5, pc}
   41756:	bf00      	nop
   41758:	00048ecf 	.word	0x00048ecf
   4175c:	00048f06 	.word	0x00048f06
   41760:	00048e51 	.word	0x00048e51
   41764:	00048e50 	.word	0x00048e50

00041768 <hexdump_line_print>:
{
   41768:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4176c:	461d      	mov	r5, r3
   4176e:	9b08      	ldr	r3, [sp, #32]
   41770:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41772:	06da      	lsls	r2, r3, #27
{
   41774:	4604      	mov	r4, r0
   41776:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41778:	d405      	bmi.n	41786 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   4177a:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   4177c:	bf4c      	ite	mi
   4177e:	492a      	ldrmi	r1, [pc, #168]	; (41828 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   41780:	492a      	ldrpl	r1, [pc, #168]	; (4182c <hexdump_line_print+0xc4>)
   41782:	f7ff ff1f 	bl	415c4 <print_formatted>
{
   41786:	f04f 0800 	mov.w	r8, #0
		print_formatted(output, " ");
   4178a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 41834 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   4178e:	45a8      	cmp	r8, r5
   41790:	db2a      	blt.n	417e8 <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41792:	2500      	movs	r5, #0
			print_formatted(output, "   ");
   41794:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 41838 <hexdump_line_print+0xd0>
			print_formatted(output, "%02x ", data[i]);
   41798:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 4183c <hexdump_line_print+0xd4>
			print_formatted(output, " ");
   4179c:	f8df a094 	ldr.w	sl, [pc, #148]	; 41834 <hexdump_line_print+0xcc>
		if (i < length) {
   417a0:	42bd      	cmp	r5, r7
   417a2:	d22f      	bcs.n	41804 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
   417a4:	4649      	mov	r1, r9
   417a6:	4620      	mov	r0, r4
   417a8:	5d72      	ldrb	r2, [r6, r5]
   417aa:	f7ff ff0b 	bl	415c4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   417ae:	3501      	adds	r5, #1
   417b0:	2d10      	cmp	r5, #16
   417b2:	d120      	bne.n	417f6 <hexdump_line_print+0x8e>
	print_formatted(output, "|");
   417b4:	4620      	mov	r0, r4
   417b6:	491e      	ldr	r1, [pc, #120]	; (41830 <hexdump_line_print+0xc8>)
   417b8:	f7ff ff04 	bl	415c4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   417bc:	2500      	movs	r5, #0
			print_formatted(output, " ");
   417be:	f8df 8074 	ldr.w	r8, [pc, #116]	; 41834 <hexdump_line_print+0xcc>
			print_formatted(output, "%c",
   417c2:	f8df 907c 	ldr.w	r9, [pc, #124]	; 41840 <hexdump_line_print+0xd8>
		if (i < length) {
   417c6:	42af      	cmp	r7, r5
   417c8:	d928      	bls.n	4181c <hexdump_line_print+0xb4>
			char c = (char)data[i];
   417ca:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
   417cc:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
   417ce:	f1a2 0320 	sub.w	r3, r2, #32
   417d2:	2b5f      	cmp	r3, #95	; 0x5f
   417d4:	bf28      	it	cs
   417d6:	222e      	movcs	r2, #46	; 0x2e
   417d8:	4620      	mov	r0, r4
   417da:	f7ff fef3 	bl	415c4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   417de:	3501      	adds	r5, #1
   417e0:	2d10      	cmp	r5, #16
   417e2:	d114      	bne.n	4180e <hexdump_line_print+0xa6>
}
   417e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
   417e8:	4649      	mov	r1, r9
   417ea:	4620      	mov	r0, r4
   417ec:	f7ff feea 	bl	415c4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   417f0:	f108 0801 	add.w	r8, r8, #1
   417f4:	e7cb      	b.n	4178e <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
   417f6:	076a      	lsls	r2, r5, #29
   417f8:	d1d2      	bne.n	417a0 <hexdump_line_print+0x38>
			print_formatted(output, " ");
   417fa:	4651      	mov	r1, sl
   417fc:	4620      	mov	r0, r4
   417fe:	f7ff fee1 	bl	415c4 <print_formatted>
   41802:	e7cd      	b.n	417a0 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
   41804:	4641      	mov	r1, r8
   41806:	4620      	mov	r0, r4
   41808:	f7ff fedc 	bl	415c4 <print_formatted>
   4180c:	e7cf      	b.n	417ae <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
   4180e:	076b      	lsls	r3, r5, #29
   41810:	d1d9      	bne.n	417c6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41812:	4641      	mov	r1, r8
   41814:	4620      	mov	r0, r4
   41816:	f7ff fed5 	bl	415c4 <print_formatted>
   4181a:	e7d4      	b.n	417c6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   4181c:	4641      	mov	r1, r8
   4181e:	4620      	mov	r0, r4
   41820:	f7ff fed0 	bl	415c4 <print_formatted>
   41824:	e7db      	b.n	417de <hexdump_line_print+0x76>
   41826:	bf00      	nop
   41828:	00048e51 	.word	0x00048e51
   4182c:	00048e50 	.word	0x00048e50
   41830:	00048f19 	.word	0x00048f19
   41834:	00048f17 	.word	0x00048f17
   41838:	00048f15 	.word	0x00048f15
   4183c:	00048f0f 	.word	0x00048f0f
   41840:	00048f1b 	.word	0x00048f1b

00041844 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
   41844:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   41848:	7a8b      	ldrb	r3, [r1, #10]
   4184a:	4617      	mov	r7, r2
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
   4184c:	f013 0807 	ands.w	r8, r3, #7
{
   41850:	4605      	mov	r5, r0
   41852:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41854:	7a0a      	ldrb	r2, [r1, #8]
   41856:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
   41858:	d021      	beq.n	4189e <log_output_msg_process+0x5a>
   4185a:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
   4185c:	8949      	ldrh	r1, [r1, #10]
   4185e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   41862:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41866:	e9cd 8300 	strd	r8, r3, [sp]
   4186a:	9102      	str	r1, [sp, #8]
   4186c:	68f3      	ldr	r3, [r6, #12]
   4186e:	4639      	mov	r1, r7
   41870:	f002 0201 	and.w	r2, r2, #1
   41874:	f7ff feb8 	bl	415e8 <prefix_print>
   41878:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4187a:	7a34      	ldrb	r4, [r6, #8]
   4187c:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   4187e:	f014 0401 	ands.w	r4, r4, #1
   41882:	d00e      	beq.n	418a2 <log_output_msg_process+0x5e>
		std_print(msg, output);
   41884:	4629      	mov	r1, r5
   41886:	4630      	mov	r0, r6
   41888:	f006 f8e8 	bl	47a5c <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
   4188c:	f1b8 0f00 	cmp.w	r8, #0
   41890:	d02b      	beq.n	418ea <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
   41892:	4642      	mov	r2, r8
   41894:	4639      	mov	r1, r7
   41896:	4628      	mov	r0, r5
   41898:	f7ff ff48 	bl	4172c <postfix_print>
   4189c:	e025      	b.n	418ea <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
   4189e:	46c1      	mov	r9, r8
   418a0:	e7eb      	b.n	4187a <log_output_msg_process+0x36>
	} else if (raw_string) {
   418a2:	f1b8 0f00 	cmp.w	r8, #0
   418a6:	d126      	bne.n	418f6 <log_output_msg_process+0xb2>
	size_t offset = 0;
   418a8:	4627      	mov	r7, r4
		length = output->size;
   418aa:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   418ac:	aa06      	add	r2, sp, #24
		length = output->size;
   418ae:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   418b0:	4630      	mov	r0, r6
   418b2:	463b      	mov	r3, r7
   418b4:	68a9      	ldr	r1, [r5, #8]
   418b6:	f006 f8bd 	bl	47a34 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
   418ba:	9a06      	ldr	r2, [sp, #24]
   418bc:	686b      	ldr	r3, [r5, #4]
   418be:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   418c0:	b13a      	cbz	r2, 418d2 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
   418c2:	68ab      	ldr	r3, [r5, #8]
   418c4:	4413      	add	r3, r2
   418c6:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   418ca:	f1a4 030a 	sub.w	r3, r4, #10
   418ce:	425c      	negs	r4, r3
   418d0:	415c      	adcs	r4, r3
		log_output_flush(output);
   418d2:	4628      	mov	r0, r5
   418d4:	f006 fa1f 	bl	47d16 <log_output_flush>
		offset += length;
   418d8:	9b06      	ldr	r3, [sp, #24]
   418da:	441f      	add	r7, r3
	} while (length > 0);
   418dc:	2b00      	cmp	r3, #0
   418de:	d1e4      	bne.n	418aa <log_output_msg_process+0x66>
	if (eol) {
   418e0:	b11c      	cbz	r4, 418ea <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
   418e2:	4628      	mov	r0, r5
   418e4:	4913      	ldr	r1, [pc, #76]	; (41934 <log_output_msg_process+0xf0>)
   418e6:	f7ff fe6d 	bl	415c4 <print_formatted>
	}

	log_output_flush(output);
   418ea:	4628      	mov	r0, r5
   418ec:	f006 fa13 	bl	47d16 <log_output_flush>
}
   418f0:	b00a      	add	sp, #40	; 0x28
   418f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(output, "%s", log_msg_str_get(msg));
   418f6:	4630      	mov	r0, r6
   418f8:	f006 f89a 	bl	47a30 <log_msg_str_get>
   418fc:	490e      	ldr	r1, [pc, #56]	; (41938 <log_output_msg_process+0xf4>)
   418fe:	4602      	mov	r2, r0
   41900:	4628      	mov	r0, r5
   41902:	f7ff fe5f 	bl	415c4 <print_formatted>
		length = sizeof(buf);
   41906:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   4190a:	aa05      	add	r2, sp, #20
   4190c:	4623      	mov	r3, r4
   4190e:	4630      	mov	r0, r6
   41910:	a906      	add	r1, sp, #24
		length = sizeof(buf);
   41912:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41916:	f006 f88d 	bl	47a34 <log_msg_hexdump_data_get>
		if (length) {
   4191a:	9a05      	ldr	r2, [sp, #20]
   4191c:	2a00      	cmp	r2, #0
   4191e:	d0b8      	beq.n	41892 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
   41920:	464b      	mov	r3, r9
   41922:	4628      	mov	r0, r5
   41924:	9700      	str	r7, [sp, #0]
   41926:	a906      	add	r1, sp, #24
   41928:	f7ff ff1e 	bl	41768 <hexdump_line_print>
			offset += length;
   4192c:	9b05      	ldr	r3, [sp, #20]
   4192e:	441c      	add	r4, r3
		length = sizeof(buf);
   41930:	e7eb      	b.n	4190a <log_output_msg_process+0xc6>
   41932:	bf00      	nop
   41934:	00048f1e 	.word	0x00048f1e
   41938:	00048f06 	.word	0x00048f06

0004193c <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   4193c:	f242 730f 	movw	r3, #9999	; 0x270f
{
   41940:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41942:	428b      	cmp	r3, r1
   41944:	bf28      	it	cs
   41946:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
   41948:	6805      	ldr	r5, [r0, #0]
{
   4194a:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   4194c:	2105      	movs	r1, #5
   4194e:	4668      	mov	r0, sp
   41950:	4a0d      	ldr	r2, [pc, #52]	; (41988 <log_output_dropped_process+0x4c>)
   41952:	f005 fc3b 	bl	471cc <snprintk>
   41956:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
   41958:	6863      	ldr	r3, [r4, #4]
   4195a:	4628      	mov	r0, r5
   4195c:	220b      	movs	r2, #11
   4195e:	685b      	ldr	r3, [r3, #4]
   41960:	490a      	ldr	r1, [pc, #40]	; (4198c <log_output_dropped_process+0x50>)
   41962:	f006 f86e 	bl	47a42 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
   41966:	6863      	ldr	r3, [r4, #4]
   41968:	4632      	mov	r2, r6
   4196a:	4669      	mov	r1, sp
   4196c:	4628      	mov	r0, r5
   4196e:	685b      	ldr	r3, [r3, #4]
   41970:	f006 f867 	bl	47a42 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
   41974:	6863      	ldr	r3, [r4, #4]
   41976:	221b      	movs	r2, #27
   41978:	4628      	mov	r0, r5
   4197a:	685b      	ldr	r3, [r3, #4]
   4197c:	4904      	ldr	r1, [pc, #16]	; (41990 <log_output_dropped_process+0x54>)
   4197e:	f006 f860 	bl	47a42 <buffer_write>
		     output->control_block->ctx);
}
   41982:	b002      	add	sp, #8
   41984:	bd70      	pop	{r4, r5, r6, pc}
   41986:	bf00      	nop
   41988:	00049595 	.word	0x00049595
   4198c:	00048f5c 	.word	0x00048f5c
   41990:	00048f40 	.word	0x00048f40

00041994 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
   41994:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   41996:	2100      	movs	r1, #0
	timestamp_div = 1U;
   41998:	4a07      	ldr	r2, [pc, #28]	; (419b8 <log_output_timestamp_freq_set+0x24>)
{
   4199a:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   4199c:	4c07      	ldr	r4, [pc, #28]	; (419bc <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   4199e:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   419a0:	42a0      	cmp	r0, r4
   419a2:	d804      	bhi.n	419ae <log_output_timestamp_freq_set+0x1a>
   419a4:	b101      	cbz	r1, 419a8 <log_output_timestamp_freq_set+0x14>
   419a6:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   419a8:	4b05      	ldr	r3, [pc, #20]	; (419c0 <log_output_timestamp_freq_set+0x2c>)
   419aa:	6018      	str	r0, [r3, #0]
}
   419ac:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
   419ae:	2101      	movs	r1, #1
		frequency /= 2U;
   419b0:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   419b2:	005b      	lsls	r3, r3, #1
   419b4:	e7f4      	b.n	419a0 <log_output_timestamp_freq_set+0xc>
   419b6:	bf00      	nop
   419b8:	2001a8c4 	.word	0x2001a8c4
   419bc:	000f4240 	.word	0x000f4240
   419c0:	2001a8c0 	.word	0x2001a8c0

000419c4 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
   419c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   419c6:	460d      	mov	r5, r1
   419c8:	4604      	mov	r4, r0
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
   419ca:	4f06      	ldr	r7, [pc, #24]	; (419e4 <char_out+0x20>)
   419cc:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
   419ce:	42b4      	cmp	r4, r6
   419d0:	d101      	bne.n	419d6 <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
   419d2:	4628      	mov	r0, r5
   419d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
   419d6:	6838      	ldr	r0, [r7, #0]
   419d8:	f814 1b01 	ldrb.w	r1, [r4], #1
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   419dc:	6883      	ldr	r3, [r0, #8]
   419de:	685b      	ldr	r3, [r3, #4]
   419e0:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
   419e2:	e7f4      	b.n	419ce <char_out+0xa>
   419e4:	2001a8dc 	.word	0x2001a8dc

000419e8 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   419e8:	4b01      	ldr	r3, [pc, #4]	; (419f0 <log_backend_uart_init+0x8>)
   419ea:	4a02      	ldr	r2, [pc, #8]	; (419f4 <log_backend_uart_init+0xc>)
   419ec:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
   419ee:	4770      	bx	lr
   419f0:	2001a8dc 	.word	0x2001a8dc
   419f4:	00048968 	.word	0x00048968

000419f8 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
   419f8:	2201      	movs	r2, #1
   419fa:	4b02      	ldr	r3, [pc, #8]	; (41a04 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
   419fc:	4802      	ldr	r0, [pc, #8]	; (41a08 <panic+0x10>)
   419fe:	701a      	strb	r2, [r3, #0]
   41a00:	f006 b989 	b.w	47d16 <log_output_flush>
   41a04:	2001adcc 	.word	0x2001adcc
   41a08:	00048c80 	.word	0x00048c80

00041a0c <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
   41a0c:	4801      	ldr	r0, [pc, #4]	; (41a14 <dropped+0x8>)
   41a0e:	f7ff bf95 	b.w	4193c <log_output_dropped_process>
   41a12:	bf00      	nop
   41a14:	00048c80 	.word	0x00048c80

00041a18 <put>:
{
   41a18:	b510      	push	{r4, lr}
   41a1a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41a1c:	4608      	mov	r0, r1
   41a1e:	f005 ffcd 	bl	479bc <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41a22:	4621      	mov	r1, r4
   41a24:	4804      	ldr	r0, [pc, #16]	; (41a38 <put+0x20>)
   41a26:	220f      	movs	r2, #15
   41a28:	f7ff ff0c 	bl	41844 <log_output_msg_process>
	log_msg_put(msg);
   41a2c:	4620      	mov	r0, r4
}
   41a2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41a32:	f005 bfee 	b.w	47a12 <log_msg_put>
   41a36:	bf00      	nop
   41a38:	00048c80 	.word	0x00048c80

00041a3c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   41a3c:	2201      	movs	r2, #1
   41a3e:	4b01      	ldr	r3, [pc, #4]	; (41a44 <log_backend_rtt_init+0x8>)
   41a40:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   41a42:	4770      	bx	lr
   41a44:	2001adde 	.word	0x2001adde

00041a48 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
   41a48:	2201      	movs	r2, #1
   41a4a:	4b02      	ldr	r3, [pc, #8]	; (41a54 <panic+0xc>)
	log_output_flush(output);
   41a4c:	4802      	ldr	r0, [pc, #8]	; (41a58 <panic+0x10>)
   41a4e:	701a      	strb	r2, [r3, #0]
   41a50:	f006 b961 	b.w	47d16 <log_output_flush>
   41a54:	2001addf 	.word	0x2001addf
   41a58:	00048cac 	.word	0x00048cac

00041a5c <dropped>:
	log_output_dropped_process(output, cnt);
   41a5c:	4801      	ldr	r0, [pc, #4]	; (41a64 <dropped+0x8>)
   41a5e:	f7ff bf6d 	b.w	4193c <log_output_dropped_process>
   41a62:	bf00      	nop
   41a64:	00048cac 	.word	0x00048cac

00041a68 <put>:
{
   41a68:	b510      	push	{r4, lr}
   41a6a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41a6c:	4608      	mov	r0, r1
   41a6e:	f005 ffa5 	bl	479bc <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41a72:	4621      	mov	r1, r4
   41a74:	4804      	ldr	r0, [pc, #16]	; (41a88 <put+0x20>)
   41a76:	220f      	movs	r2, #15
   41a78:	f7ff fee4 	bl	41844 <log_output_msg_process>
	log_msg_put(msg);
   41a7c:	4620      	mov	r0, r4
}
   41a7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41a82:	f005 bfc6 	b.w	47a12 <log_msg_put>
   41a86:	bf00      	nop
   41a88:	00048cac 	.word	0x00048cac

00041a8c <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41a8c:	4b05      	ldr	r3, [pc, #20]	; (41aa4 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
   41a8e:	781b      	ldrb	r3, [r3, #0]
   41a90:	b11b      	cbz	r3, 41a9a <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
   41a92:	f241 3088 	movw	r0, #5000	; 0x1388
   41a96:	f006 beab 	b.w	487f0 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
   41a9a:	2005      	movs	r0, #5
   41a9c:	2100      	movs	r1, #0
   41a9e:	f005 b829 	b.w	46af4 <z_impl_k_sleep>
   41aa2:	bf00      	nop
   41aa4:	2001addf 	.word	0x2001addf

00041aa8 <data_out_block_mode>:
{
   41aa8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41aac:	f8df 9094 	ldr.w	r9, [pc, #148]	; 41b44 <data_out_block_mode+0x9c>
{
   41ab0:	4680      	mov	r8, r0
   41ab2:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
   41ab4:	2404      	movs	r4, #4
   41ab6:	46cb      	mov	fp, r9
	return z_impl_k_mutex_lock(mutex, timeout);
   41ab8:	f8df a08c 	ldr.w	sl, [pc, #140]	; 41b48 <data_out_block_mode+0xa0>
		if (!is_sync_mode()) {
   41abc:	f899 5000 	ldrb.w	r5, [r9]
   41ac0:	b9cd      	cbnz	r5, 41af6 <data_out_block_mode+0x4e>
   41ac2:	f04f 33ff 	mov.w	r3, #4294967295
   41ac6:	f04f 32ff 	mov.w	r2, #4294967295
   41aca:	4650      	mov	r0, sl
   41acc:	f004 fc28 	bl	46320 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41ad0:	463a      	mov	r2, r7
   41ad2:	4641      	mov	r1, r8
   41ad4:	4628      	mov	r0, r5
   41ad6:	f002 fd51 	bl	4457c <SEGGER_RTT_WriteSkipNoLock>
   41ada:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   41adc:	4650      	mov	r0, sl
   41ade:	f004 fc9d 	bl	4641c <z_impl_k_mutex_unlock>
		if (ret) {
   41ae2:	4d17      	ldr	r5, [pc, #92]	; (41b40 <data_out_block_mode+0x98>)
   41ae4:	b1fe      	cbz	r6, 41b26 <data_out_block_mode+0x7e>
	host_present = true;
   41ae6:	2301      	movs	r3, #1
   41ae8:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
   41aea:	f89b 3000 	ldrb.w	r3, [fp]
   41aee:	b96b      	cbnz	r3, 41b0c <data_out_block_mode+0x64>
}
   41af0:	4638      	mov	r0, r7
   41af2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41af6:	463a      	mov	r2, r7
   41af8:	4641      	mov	r1, r8
   41afa:	2000      	movs	r0, #0
   41afc:	f002 fd3e 	bl	4457c <SEGGER_RTT_WriteSkipNoLock>
   41b00:	4606      	mov	r6, r0
   41b02:	e7ee      	b.n	41ae2 <data_out_block_mode+0x3a>
	if (retry_cnt == 0) {
   41b04:	b95c      	cbnz	r4, 41b1e <data_out_block_mode+0x76>
		host_present = false;
   41b06:	702c      	strb	r4, [r5, #0]
   41b08:	f04f 34ff 	mov.w	r4, #4294967295
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   41b0c:	2000      	movs	r0, #0
   41b0e:	f002 fd81 	bl	44614 <SEGGER_RTT_HasDataUp>
   41b12:	2800      	cmp	r0, #0
   41b14:	d0ec      	beq.n	41af0 <data_out_block_mode+0x48>
   41b16:	782b      	ldrb	r3, [r5, #0]
   41b18:	2b00      	cmp	r3, #0
   41b1a:	d1f3      	bne.n	41b04 <data_out_block_mode+0x5c>
   41b1c:	e7e8      	b.n	41af0 <data_out_block_mode+0x48>
			on_failed_write(retry_cnt--);
   41b1e:	3c01      	subs	r4, #1
   41b20:	f7ff ffb4 	bl	41a8c <on_failed_write.part.0>
   41b24:	e7f2      	b.n	41b0c <data_out_block_mode+0x64>
		} else if (host_present) {
   41b26:	782b      	ldrb	r3, [r5, #0]
   41b28:	b113      	cbz	r3, 41b30 <data_out_block_mode+0x88>
	if (retry_cnt == 0) {
   41b2a:	3c01      	subs	r4, #1
   41b2c:	d104      	bne.n	41b38 <data_out_block_mode+0x90>
		host_present = false;
   41b2e:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   41b30:	782b      	ldrb	r3, [r5, #0]
   41b32:	2b00      	cmp	r3, #0
   41b34:	d1c2      	bne.n	41abc <data_out_block_mode+0x14>
   41b36:	e7db      	b.n	41af0 <data_out_block_mode+0x48>
   41b38:	f7ff ffa8 	bl	41a8c <on_failed_write.part.0>
   41b3c:	e7f8      	b.n	41b30 <data_out_block_mode+0x88>
   41b3e:	bf00      	nop
   41b40:	2001adde 	.word	0x2001adde
   41b44:	2001addf 	.word	0x2001addf
   41b48:	2001a640 	.word	0x2001a640

00041b4c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   41b4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   41b50:	4605      	mov	r5, r0
	__asm__ volatile(
   41b52:	f04f 0320 	mov.w	r3, #32
   41b56:	f3ef 8611 	mrs	r6, BASEPRI
   41b5a:	f383 8812 	msr	BASEPRI_MAX, r3
   41b5e:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41b62:	4b10      	ldr	r3, [pc, #64]	; (41ba4 <pm_state_notify+0x58>)
   41b64:	681c      	ldr	r4, [r3, #0]
   41b66:	2c00      	cmp	r4, #0
   41b68:	bf38      	it	cc
   41b6a:	2400      	movcc	r4, #0
   41b6c:	b19c      	cbz	r4, 41b96 <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   41b6e:	f04f 090c 	mov.w	r9, #12
   41b72:	4f0d      	ldr	r7, [pc, #52]	; (41ba8 <pm_state_notify+0x5c>)
   41b74:	f8df 8034 	ldr.w	r8, [pc, #52]	; 41bac <pm_state_notify+0x60>
			callback = notifier->state_exit;
   41b78:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   41b7c:	2d00      	cmp	r5, #0
   41b7e:	bf08      	it	eq
   41b80:	4613      	moveq	r3, r2
		if (callback) {
   41b82:	b12b      	cbz	r3, 41b90 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   41b84:	f898 2014 	ldrb.w	r2, [r8, #20]
   41b88:	fb09 f202 	mul.w	r2, r9, r2
   41b8c:	5cb8      	ldrb	r0, [r7, r2]
   41b8e:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   41b90:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41b92:	2c00      	cmp	r4, #0
   41b94:	d1f0      	bne.n	41b78 <pm_state_notify+0x2c>
	__asm__ volatile(
   41b96:	f386 8811 	msr	BASEPRI, r6
   41b9a:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   41b9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   41ba2:	bf00      	nop
   41ba4:	2001a8f4 	.word	0x2001a8f4
   41ba8:	2001a900 	.word	0x2001a900
   41bac:	2001ad84 	.word	0x2001ad84

00041bb0 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41bb0:	2201      	movs	r2, #1
   41bb2:	f000 031f 	and.w	r3, r0, #31
   41bb6:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41bb8:	4b08      	ldr	r3, [pc, #32]	; (41bdc <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   41bba:	0940      	lsrs	r0, r0, #5
   41bbc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   41bc0:	e8d0 3fef 	ldaex	r3, [r0]
   41bc4:	ea43 0102 	orr.w	r1, r3, r2
   41bc8:	e8c0 1fec 	stlex	ip, r1, [r0]
   41bcc:	f1bc 0f00 	cmp.w	ip, #0
   41bd0:	d1f6      	bne.n	41bc0 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   41bd2:	421a      	tst	r2, r3
}
   41bd4:	bf14      	ite	ne
   41bd6:	2001      	movne	r0, #1
   41bd8:	2000      	moveq	r0, #0
   41bda:	4770      	bx	lr
   41bdc:	2001a90c 	.word	0x2001a90c

00041be0 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   41be0:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   41be2:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   41be4:	4b1a      	ldr	r3, [pc, #104]	; (41c50 <pm_system_resume+0x70>)
{
   41be6:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   41be8:	7d1d      	ldrb	r5, [r3, #20]
   41bea:	f005 031f 	and.w	r3, r5, #31
   41bee:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41bf0:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41bf2:	4b18      	ldr	r3, [pc, #96]	; (41c54 <pm_system_resume+0x74>)
   41bf4:	0969      	lsrs	r1, r5, #5
   41bf6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   41bfa:	e8d3 1fef 	ldaex	r1, [r3]
   41bfe:	ea01 0400 	and.w	r4, r1, r0
   41c02:	e8c3 4fec 	stlex	ip, r4, [r3]
   41c06:	f1bc 0f00 	cmp.w	ip, #0
   41c0a:	d1f6      	bne.n	41bfa <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   41c0c:	4211      	tst	r1, r2
   41c0e:	d017      	beq.n	41c40 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   41c10:	220c      	movs	r2, #12
   41c12:	4c11      	ldr	r4, [pc, #68]	; (41c58 <pm_system_resume+0x78>)
   41c14:	ab01      	add	r3, sp, #4
   41c16:	fb02 4205 	mla	r2, r2, r5, r4
   41c1a:	ca07      	ldmia	r2, {r0, r1, r2}
   41c1c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   41c20:	4a0e      	ldr	r2, [pc, #56]	; (41c5c <pm_system_resume+0x7c>)
   41c22:	b17a      	cbz	r2, 41c44 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   41c24:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41c28:	f005 fdcc 	bl	477c4 <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   41c2c:	2000      	movs	r0, #0
   41c2e:	f7ff ff8d 	bl	41b4c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   41c32:	230c      	movs	r3, #12
   41c34:	2200      	movs	r2, #0
   41c36:	436b      	muls	r3, r5
   41c38:	18e1      	adds	r1, r4, r3
   41c3a:	50e2      	str	r2, [r4, r3]
   41c3c:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   41c40:	b005      	add	sp, #20
   41c42:	bd30      	pop	{r4, r5, pc}
   41c44:	f382 8811 	msr	BASEPRI, r2
   41c48:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   41c4c:	e7ee      	b.n	41c2c <pm_system_resume+0x4c>
   41c4e:	bf00      	nop
   41c50:	2001ad84 	.word	0x2001ad84
   41c54:	2001a8fc 	.word	0x2001a8fc
   41c58:	2001a900 	.word	0x2001a900
   41c5c:	000477c5 	.word	0x000477c5

00041c60 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   41c60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   41c64:	4b39      	ldr	r3, [pc, #228]	; (41d4c <pm_system_suspend+0xec>)
{
   41c66:	4605      	mov	r5, r0
	uint8_t id = _current_cpu->id;
   41c68:	7d1c      	ldrb	r4, [r3, #20]
{
   41c6a:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   41c6c:	4620      	mov	r0, r4
   41c6e:	f7ff ff9f 	bl	41bb0 <atomic_test_and_set_bit.constprop.0>
   41c72:	4e37      	ldr	r6, [pc, #220]	; (41d50 <pm_system_suspend+0xf0>)
   41c74:	b960      	cbnz	r0, 41c90 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   41c76:	270c      	movs	r7, #12
   41c78:	46e8      	mov	r8, sp
   41c7a:	fb07 6704 	mla	r7, r7, r4, r6
   41c7e:	462a      	mov	r2, r5
   41c80:	4621      	mov	r1, r4
   41c82:	4640      	mov	r0, r8
   41c84:	f006 f86b 	bl	47d5e <pm_policy_next_state>
   41c88:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
   41c8c:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   41c90:	230c      	movs	r3, #12
   41c92:	4363      	muls	r3, r4
   41c94:	5cf0      	ldrb	r0, [r6, r3]
   41c96:	18f2      	adds	r2, r6, r3
   41c98:	0967      	lsrs	r7, r4, #5
   41c9a:	f004 081f 	and.w	r8, r4, #31
   41c9e:	2800      	cmp	r0, #0
   41ca0:	d03b      	beq.n	41d1a <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   41ca2:	1c6b      	adds	r3, r5, #1
   41ca4:	d014      	beq.n	41cd0 <pm_system_suspend+0x70>
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
   41ca6:	f240 30e7 	movw	r0, #999	; 0x3e7
   41caa:	2100      	movs	r1, #0
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
		     k_us_to_ticks_ceil32(
   41cac:	6893      	ldr	r3, [r2, #8]
   41cae:	18c0      	adds	r0, r0, r3
   41cb0:	f141 0100 	adc.w	r1, r1, #0
		if (result32 && (t < BIT64(32))) {
   41cb4:	2901      	cmp	r1, #1
   41cb6:	bf08      	it	eq
   41cb8:	2800      	cmpeq	r0, #0
   41cba:	d241      	bcs.n	41d40 <pm_system_suspend+0xe0>
			return ((uint32_t)t) / (from_hz / to_hz);
   41cbc:	f203 30e7 	addw	r0, r3, #999	; 0x3e7
   41cc0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   41cc4:	fbb0 f0f3 	udiv	r0, r0, r3
		z_set_timeout_expiry(ticks -
   41cc8:	2101      	movs	r1, #1
   41cca:	1a28      	subs	r0, r5, r0
   41ccc:	f006 fd70 	bl	487b0 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   41cd0:	f004 fc80 	bl	465d4 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   41cd4:	2001      	movs	r0, #1
   41cd6:	f7ff ff39 	bl	41b4c <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41cda:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41cdc:	4b1d      	ldr	r3, [pc, #116]	; (41d54 <pm_system_suspend+0xf4>)
   41cde:	fa02 f208 	lsl.w	r2, r2, r8
   41ce2:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   41ce6:	e8d3 1fef 	ldaex	r1, [r3]
   41cea:	4311      	orrs	r1, r2
   41cec:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41cf0:	2800      	cmp	r0, #0
   41cf2:	d1f8      	bne.n	41ce6 <pm_system_suspend+0x86>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   41cf4:	230c      	movs	r3, #12
   41cf6:	fb03 6404 	mla	r4, r3, r4, r6
   41cfa:	ab05      	add	r3, sp, #20
   41cfc:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   41d00:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   41d04:	4a14      	ldr	r2, [pc, #80]	; (41d58 <pm_system_suspend+0xf8>)
   41d06:	b11a      	cbz	r2, 41d10 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
   41d08:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41d0c:	f005 fd47 	bl	4779e <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   41d10:	f7ff ff66 	bl	41be0 <pm_system_resume>
	k_sched_unlock();
   41d14:	f004 fe38 	bl	46988 <k_sched_unlock>
	bool ret = true;
   41d18:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   41d1a:	2301      	movs	r3, #1
   41d1c:	fa03 f808 	lsl.w	r8, r3, r8
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41d20:	ea6f 0808 	mvn.w	r8, r8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41d24:	4b0d      	ldr	r3, [pc, #52]	; (41d5c <pm_system_suspend+0xfc>)
   41d26:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   41d2a:	e8d7 3fef 	ldaex	r3, [r7]
   41d2e:	ea03 0308 	and.w	r3, r3, r8
   41d32:	e8c7 3fe2 	stlex	r2, r3, [r7]
   41d36:	2a00      	cmp	r2, #0
   41d38:	d1f7      	bne.n	41d2a <pm_system_suspend+0xca>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   41d3a:	b008      	add	sp, #32
   41d3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else {
			return t / ((uint64_t)from_hz / to_hz);
   41d40:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   41d44:	2300      	movs	r3, #0
   41d46:	f7fe f9fd 	bl	40144 <__aeabi_uldivmod>
   41d4a:	e7bd      	b.n	41cc8 <pm_system_suspend+0x68>
   41d4c:	2001ad84 	.word	0x2001ad84
   41d50:	2001a900 	.word	0x2001a900
   41d54:	2001a8fc 	.word	0x2001a8fc
   41d58:	0004779f 	.word	0x0004779f
   41d5c:	2001a90c 	.word	0x2001a90c

00041d60 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   41d60:	4901      	ldr	r1, [pc, #4]	; (41d68 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   41d62:	2210      	movs	r2, #16
	str	r2, [r1]
   41d64:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   41d66:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   41d68:	e000ed10 	.word	0xe000ed10

00041d6c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   41d6c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   41d6e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   41d70:	f380 8811 	msr	BASEPRI, r0
	isb
   41d74:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   41d78:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   41d7c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   41d7e:	b662      	cpsie	i
	isb
   41d80:	f3bf 8f6f 	isb	sy

	bx	lr
   41d84:	4770      	bx	lr
   41d86:	bf00      	nop

00041d88 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   41d88:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   41d8a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   41d8c:	f381 8811 	msr	BASEPRI, r1

	wfe
   41d90:	bf20      	wfe

	msr	BASEPRI, r0
   41d92:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   41d96:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   41d98:	4770      	bx	lr
   41d9a:	bf00      	nop

00041d9c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   41d9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   41d9e:	4606      	mov	r6, r0

	if (esf != NULL) {
   41da0:	460c      	mov	r4, r1
   41da2:	b301      	cbz	r1, 41de6 <z_arm_fatal_error+0x4a>
   41da4:	4b13      	ldr	r3, [pc, #76]	; (41df4 <z_arm_fatal_error+0x58>)
   41da6:	4d14      	ldr	r5, [pc, #80]	; (41df8 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   41da8:	4814      	ldr	r0, [pc, #80]	; (41dfc <z_arm_fatal_error+0x60>)
   41daa:	1aed      	subs	r5, r5, r3
   41dac:	08ed      	lsrs	r5, r5, #3
   41dae:	01ad      	lsls	r5, r5, #6
   41db0:	f045 0501 	orr.w	r5, r5, #1
   41db4:	f8ad 5000 	strh.w	r5, [sp]
   41db8:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   41dbc:	6809      	ldr	r1, [r1, #0]
   41dbe:	f005 fd89 	bl	478d4 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   41dc2:	f8ad 5000 	strh.w	r5, [sp]
   41dc6:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   41dca:	68e1      	ldr	r1, [r4, #12]
   41dcc:	480c      	ldr	r0, [pc, #48]	; (41e00 <z_arm_fatal_error+0x64>)
   41dce:	f005 fd81 	bl	478d4 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   41dd2:	462a      	mov	r2, r5
   41dd4:	69e1      	ldr	r1, [r4, #28]
   41dd6:	480b      	ldr	r0, [pc, #44]	; (41e04 <z_arm_fatal_error+0x68>)
   41dd8:	f005 fd4f 	bl	4787a <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   41ddc:	462a      	mov	r2, r5
   41dde:	69a1      	ldr	r1, [r4, #24]
   41de0:	4809      	ldr	r0, [pc, #36]	; (41e08 <z_arm_fatal_error+0x6c>)
   41de2:	f005 fd4a 	bl	4787a <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   41de6:	4621      	mov	r1, r4
   41de8:	4630      	mov	r0, r6
}
   41dea:	b002      	add	sp, #8
   41dec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
   41df0:	f004 b854 	b.w	45e9c <z_fatal_error>
   41df4:	00048b88 	.word	0x00048b88
   41df8:	00048bb8 	.word	0x00048bb8
   41dfc:	00048f95 	.word	0x00048f95
   41e00:	00048fc4 	.word	0x00048fc4
   41e04:	00048ff3 	.word	0x00048ff3
   41e08:	00049002 	.word	0x00049002

00041e0c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   41e0c:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   41e0e:	2b00      	cmp	r3, #0
   41e10:	db08      	blt.n	41e24 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   41e12:	2201      	movs	r2, #1
   41e14:	f000 001f 	and.w	r0, r0, #31
   41e18:	fa02 f000 	lsl.w	r0, r2, r0
   41e1c:	4a02      	ldr	r2, [pc, #8]	; (41e28 <arch_irq_enable+0x1c>)
   41e1e:	095b      	lsrs	r3, r3, #5
   41e20:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   41e24:	4770      	bx	lr
   41e26:	bf00      	nop
   41e28:	e000e100 	.word	0xe000e100

00041e2c <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   41e2c:	4b05      	ldr	r3, [pc, #20]	; (41e44 <arch_irq_is_enabled+0x18>)
   41e2e:	0942      	lsrs	r2, r0, #5
   41e30:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   41e34:	2301      	movs	r3, #1
   41e36:	f000 001f 	and.w	r0, r0, #31
   41e3a:	fa03 f000 	lsl.w	r0, r3, r0
}
   41e3e:	4010      	ands	r0, r2
   41e40:	4770      	bx	lr
   41e42:	bf00      	nop
   41e44:	e000e100 	.word	0xe000e100

00041e48 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   41e48:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   41e4a:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   41e4c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e50:	bfac      	ite	ge
   41e52:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e56:	4b06      	ldrlt	r3, [pc, #24]	; (41e70 <z_arm_irq_priority_set+0x28>)
   41e58:	ea4f 1141 	mov.w	r1, r1, lsl #5
   41e5c:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e5e:	bfab      	itete	ge
   41e60:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e64:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e68:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41e6c:	5419      	strblt	r1, [r3, r0]
}
   41e6e:	4770      	bx	lr
   41e70:	e000ed14 	.word	0xe000ed14

00041e74 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   41e74:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   41e76:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   41e78:	4b04      	ldr	r3, [pc, #16]	; (41e8c <_arch_isr_direct_pm+0x18>)
   41e7a:	699a      	ldr	r2, [r3, #24]
   41e7c:	b11a      	cbz	r2, 41e86 <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   41e7e:	2200      	movs	r2, #0
   41e80:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   41e82:	f006 fb63 	bl	4854c <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   41e86:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   41e88:	bd08      	pop	{r3, pc}
   41e8a:	bf00      	nop
   41e8c:	2001ad84 	.word	0x2001ad84

00041e90 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   41e90:	bf30      	wfi
    b z_SysNmiOnReset
   41e92:	f7ff bffd 	b.w	41e90 <z_SysNmiOnReset>
   41e96:	bf00      	nop

00041e98 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   41e98:	4a0b      	ldr	r2, [pc, #44]	; (41ec8 <z_arm_prep_c+0x30>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   41e9a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   41e9c:	4b0b      	ldr	r3, [pc, #44]	; (41ecc <z_arm_prep_c+0x34>)
   41e9e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   41ea2:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   41ea4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   41ea8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   41eac:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   41eb0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   41eb4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   41eb8:	f004 f896 	bl	45fe8 <z_bss_zero>
	z_data_copy();
   41ebc:	f004 fe86 	bl	46bcc <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   41ec0:	f000 fb06 	bl	424d0 <z_arm_interrupt_init>
	z_cstart();
   41ec4:	f004 f89a 	bl	45ffc <z_cstart>
   41ec8:	00040000 	.word	0x00040000
   41ecc:	e000ed00 	.word	0xe000ed00

00041ed0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   41ed0:	4a09      	ldr	r2, [pc, #36]	; (41ef8 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   41ed2:	490a      	ldr	r1, [pc, #40]	; (41efc <arch_swap+0x2c>)
	_current->arch.basepri = key;
   41ed4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   41ed6:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   41ed8:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   41eda:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   41edc:	4908      	ldr	r1, [pc, #32]	; (41f00 <arch_swap+0x30>)
   41ede:	684b      	ldr	r3, [r1, #4]
   41ee0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   41ee4:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   41ee6:	2300      	movs	r3, #0
   41ee8:	f383 8811 	msr	BASEPRI, r3
   41eec:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   41ef0:	6893      	ldr	r3, [r2, #8]
}
   41ef2:	6f98      	ldr	r0, [r3, #120]	; 0x78
   41ef4:	4770      	bx	lr
   41ef6:	bf00      	nop
   41ef8:	2001ad84 	.word	0x2001ad84
   41efc:	00048e04 	.word	0x00048e04
   41f00:	e000ed00 	.word	0xe000ed00

00041f04 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   41f04:	4915      	ldr	r1, [pc, #84]	; (41f5c <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   41f06:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   41f08:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   41f0c:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   41f10:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   41f12:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   41f16:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   41f1a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   41f1c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   41f20:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   41f24:	4f0e      	ldr	r7, [pc, #56]	; (41f60 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   41f26:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   41f2a:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   41f2c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   41f2e:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   41f30:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   41f34:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   41f36:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   41f38:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   41f3a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   41f3e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   41f42:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   41f46:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   41f4a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   41f4e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   41f50:	f005 ff19 	bl	47d86 <configure_builtin_stack_guard>
    pop {r2, lr}
   41f54:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   41f58:	4770      	bx	lr
   41f5a:	0000      	.short	0x0000
    ldr r1, =_kernel
   41f5c:	2001ad84 	.word	0x2001ad84
    ldr v4, =_SCS_ICSR
   41f60:	e000ed04 	.word	0xe000ed04

00041f64 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   41f64:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   41f68:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   41f6a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   41f6e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   41f72:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   41f74:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   41f78:	2902      	cmp	r1, #2
    beq _oops
   41f7a:	d0ff      	beq.n	41f7c <_oops>

00041f7c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   41f7c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   41f7e:	f005 fef3 	bl	47d68 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   41f82:	bd01      	pop	{r0, pc}

00041f84 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   41f84:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   41f88:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   41f8a:	490c      	ldr	r1, [pc, #48]	; (41fbc <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   41f8c:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   41f90:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   41f92:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   41f96:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   41f9a:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   41f9c:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   41fa0:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   41fa4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   41fa8:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   41fac:	2300      	movs	r3, #0
   41fae:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   41fb0:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   41fb4:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   41fb6:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   41fb8:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   41fba:	4770      	bx	lr
   41fbc:	0004733d 	.word	0x0004733d

00041fc0 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   41fc0:	4b08      	ldr	r3, [pc, #32]	; (41fe4 <arch_switch_to_main_thread+0x24>)
   41fc2:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   41fc4:	6e43      	ldr	r3, [r0, #100]	; 0x64
   41fc6:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   41fca:	4610      	mov	r0, r2
   41fcc:	f381 8809 	msr	PSP, r1
   41fd0:	2100      	movs	r1, #0
   41fd2:	b663      	cpsie	if
   41fd4:	f381 8811 	msr	BASEPRI, r1
   41fd8:	f3bf 8f6f 	isb	sy
   41fdc:	2200      	movs	r2, #0
   41fde:	2300      	movs	r3, #0
   41fe0:	f005 f9ac 	bl	4733c <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   41fe4:	2001ad84 	.word	0x2001ad84

00041fe8 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   41fe8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   41fea:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   41fec:	4a0b      	ldr	r2, [pc, #44]	; (4201c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   41fee:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   41ff0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   41ff2:	bf1e      	ittt	ne
	movne	r1, #0
   41ff4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   41ff6:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   41ff8:	f006 faa8 	blne	4854c <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   41ffc:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   41ffe:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   42002:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   42006:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   4200a:	4905      	ldr	r1, [pc, #20]	; (42020 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   4200c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   4200e:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   42010:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   42012:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   42016:	4903      	ldr	r1, [pc, #12]	; (42024 <_isr_wrapper+0x3c>)
	bx r1
   42018:	4708      	bx	r1
   4201a:	0000      	.short	0x0000
	ldr r2, =_kernel
   4201c:	2001ad84 	.word	0x2001ad84
	ldr r1, =_sw_isr_table
   42020:	00048980 	.word	0x00048980
	ldr r1, =z_arm_int_exit
   42024:	00042029 	.word	0x00042029

00042028 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   42028:	4b04      	ldr	r3, [pc, #16]	; (4203c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   4202a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   4202c:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   4202e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   42030:	d003      	beq.n	4203a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   42032:	4903      	ldr	r1, [pc, #12]	; (42040 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   42034:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   42038:	600a      	str	r2, [r1, #0]

0004203a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   4203a:	4770      	bx	lr
	ldr r3, =_kernel
   4203c:	2001ad84 	.word	0x2001ad84
	ldr r1, =_SCS_ICSR
   42040:	e000ed04 	.word	0xe000ed04

00042044 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
   42044:	b570      	push	{r4, r5, r6, lr}
   42046:	4b28      	ldr	r3, [pc, #160]	; (420e8 <usage_fault.isra.0+0xa4>)
   42048:	4c28      	ldr	r4, [pc, #160]	; (420ec <usage_fault.isra.0+0xa8>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4204a:	4d29      	ldr	r5, [pc, #164]	; (420f0 <usage_fault.isra.0+0xac>)
   4204c:	1ae4      	subs	r4, r4, r3
   4204e:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
   42050:	01a4      	lsls	r4, r4, #6
   42052:	f044 0601 	orr.w	r6, r4, #1
   42056:	4631      	mov	r1, r6
   42058:	4826      	ldr	r0, [pc, #152]	; (420f4 <usage_fault.isra.0+0xb0>)
   4205a:	f005 fc01 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4205e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42060:	0193      	lsls	r3, r2, #6
   42062:	d503      	bpl.n	4206c <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
   42064:	4631      	mov	r1, r6
   42066:	4824      	ldr	r0, [pc, #144]	; (420f8 <usage_fault.isra.0+0xb4>)
   42068:	f005 fbfa 	bl	47860 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   4206c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4206e:	01dd      	lsls	r5, r3, #7
   42070:	d504      	bpl.n	4207c <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
   42072:	4822      	ldr	r0, [pc, #136]	; (420fc <usage_fault.isra.0+0xb8>)
   42074:	f044 0101 	orr.w	r1, r4, #1
   42078:	f005 fbf2 	bl	47860 <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   4207c:	4d1c      	ldr	r5, [pc, #112]	; (420f0 <usage_fault.isra.0+0xac>)
   4207e:	6aae      	ldr	r6, [r5, #40]	; 0x28
   42080:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   42084:	d005      	beq.n	42092 <usage_fault.isra.0+0x4e>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   42086:	481e      	ldr	r0, [pc, #120]	; (42100 <usage_fault.isra.0+0xbc>)
   42088:	f044 0101 	orr.w	r1, r4, #1
   4208c:	f005 fbe8 	bl	47860 <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   42090:	2602      	movs	r6, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   42092:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42094:	0318      	lsls	r0, r3, #12
   42096:	d504      	bpl.n	420a2 <usage_fault.isra.0+0x5e>
		PR_FAULT_INFO("  No coprocessor instructions");
   42098:	481a      	ldr	r0, [pc, #104]	; (42104 <usage_fault.isra.0+0xc0>)
   4209a:	f044 0101 	orr.w	r1, r4, #1
   4209e:	f005 fbdf 	bl	47860 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   420a2:	4d13      	ldr	r5, [pc, #76]	; (420f0 <usage_fault.isra.0+0xac>)
   420a4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   420a6:	0351      	lsls	r1, r2, #13
   420a8:	d504      	bpl.n	420b4 <usage_fault.isra.0+0x70>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   420aa:	4817      	ldr	r0, [pc, #92]	; (42108 <usage_fault.isra.0+0xc4>)
   420ac:	f044 0101 	orr.w	r1, r4, #1
   420b0:	f005 fbd6 	bl	47860 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   420b4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   420b6:	039a      	lsls	r2, r3, #14
   420b8:	d504      	bpl.n	420c4 <usage_fault.isra.0+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   420ba:	4814      	ldr	r0, [pc, #80]	; (4210c <usage_fault.isra.0+0xc8>)
   420bc:	f044 0101 	orr.w	r1, r4, #1
   420c0:	f005 fbce 	bl	47860 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   420c4:	4d0a      	ldr	r5, [pc, #40]	; (420f0 <usage_fault.isra.0+0xac>)
   420c6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   420c8:	03db      	lsls	r3, r3, #15
   420ca:	d504      	bpl.n	420d6 <usage_fault.isra.0+0x92>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   420cc:	4810      	ldr	r0, [pc, #64]	; (42110 <usage_fault.isra.0+0xcc>)
   420ce:	f044 0101 	orr.w	r1, r4, #1
   420d2:	f005 fbc5 	bl	47860 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   420d6:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
   420d8:	4630      	mov	r0, r6
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   420da:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   420de:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   420e2:	62ab      	str	r3, [r5, #40]	; 0x28
}
   420e4:	bd70      	pop	{r4, r5, r6, pc}
   420e6:	bf00      	nop
   420e8:	00048b88 	.word	0x00048b88
   420ec:	00048bb8 	.word	0x00048bb8
   420f0:	e000ed00 	.word	0xe000ed00
   420f4:	00049030 	.word	0x00049030
   420f8:	00049048 	.word	0x00049048
   420fc:	0004905b 	.word	0x0004905b
   42100:	00049075 	.word	0x00049075
   42104:	0004909f 	.word	0x0004909f
   42108:	000490bd 	.word	0x000490bd
   4210c:	000490e2 	.word	0x000490e2
   42110:	000490fc 	.word	0x000490fc

00042114 <mem_manage_fault.isra.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42114:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   42118:	4b28      	ldr	r3, [pc, #160]	; (421bc <mem_manage_fault.isra.0+0xa8>)
   4211a:	4c29      	ldr	r4, [pc, #164]	; (421c0 <mem_manage_fault.isra.0+0xac>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   4211c:	4d29      	ldr	r5, [pc, #164]	; (421c4 <mem_manage_fault.isra.0+0xb0>)
   4211e:	1ae4      	subs	r4, r4, r3
   42120:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
   42122:	01a4      	lsls	r4, r4, #6
   42124:	f044 0801 	orr.w	r8, r4, #1
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42128:	4607      	mov	r7, r0
   4212a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   4212c:	4826      	ldr	r0, [pc, #152]	; (421c8 <mem_manage_fault.isra.0+0xb4>)
   4212e:	4641      	mov	r1, r8
   42130:	f005 fb96 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42134:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42136:	06d0      	lsls	r0, r2, #27
   42138:	d503      	bpl.n	42142 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
   4213a:	4641      	mov	r1, r8
   4213c:	4823      	ldr	r0, [pc, #140]	; (421cc <mem_manage_fault.isra.0+0xb8>)
   4213e:	f005 fb8f 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   42142:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42144:	0719      	lsls	r1, r3, #28
   42146:	d504      	bpl.n	42152 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42148:	4821      	ldr	r0, [pc, #132]	; (421d0 <mem_manage_fault.isra.0+0xbc>)
   4214a:	f044 0101 	orr.w	r1, r4, #1
   4214e:	f005 fb87 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   42152:	4d1c      	ldr	r5, [pc, #112]	; (421c4 <mem_manage_fault.isra.0+0xb0>)
   42154:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42156:	079a      	lsls	r2, r3, #30
   42158:	d512      	bpl.n	42180 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
   4215a:	f044 0801 	orr.w	r8, r4, #1
   4215e:	4641      	mov	r1, r8
   42160:	481c      	ldr	r0, [pc, #112]	; (421d4 <mem_manage_fault.isra.0+0xc0>)
   42162:	f005 fb7d 	bl	47860 <log_0>
		uint32_t temp = SCB->MMFAR;
   42166:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   42168:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4216a:	061b      	lsls	r3, r3, #24
   4216c:	d508      	bpl.n	42180 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   4216e:	4642      	mov	r2, r8
   42170:	4819      	ldr	r0, [pc, #100]	; (421d8 <mem_manage_fault.isra.0+0xc4>)
   42172:	f005 fb82 	bl	4787a <log_1>
			if (from_hard_fault != 0) {
   42176:	b11f      	cbz	r7, 42180 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   42178:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4217a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   4217e:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   42180:	4d10      	ldr	r5, [pc, #64]	; (421c4 <mem_manage_fault.isra.0+0xb0>)
   42182:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42184:	07d0      	lsls	r0, r2, #31
   42186:	d504      	bpl.n	42192 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
   42188:	4814      	ldr	r0, [pc, #80]	; (421dc <mem_manage_fault.isra.0+0xc8>)
   4218a:	f044 0101 	orr.w	r1, r4, #1
   4218e:	f005 fb67 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   42192:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42194:	0699      	lsls	r1, r3, #26
   42196:	d504      	bpl.n	421a2 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
   42198:	4811      	ldr	r0, [pc, #68]	; (421e0 <mem_manage_fault.isra.0+0xcc>)
   4219a:	f044 0101 	orr.w	r1, r4, #1
   4219e:	f005 fb5f 	bl	47860 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   421a2:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   421a4:	4b07      	ldr	r3, [pc, #28]	; (421c4 <mem_manage_fault.isra.0+0xb0>)
   421a6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   421a8:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   421aa:	bf58      	it	pl
   421ac:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   421ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   421b0:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   421b4:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   421b6:	7030      	strb	r0, [r6, #0]
}
   421b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   421bc:	00048b88 	.word	0x00048b88
   421c0:	00048bb8 	.word	0x00048bb8
   421c4:	e000ed00 	.word	0xe000ed00
   421c8:	00049127 	.word	0x00049127
   421cc:	0004913d 	.word	0x0004913d
   421d0:	00049170 	.word	0x00049170
   421d4:	00049183 	.word	0x00049183
   421d8:	0004919b 	.word	0x0004919b
   421dc:	000491b1 	.word	0x000491b1
   421e0:	000491d0 	.word	0x000491d0

000421e4 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   421e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   421e8:	4b2a      	ldr	r3, [pc, #168]	; (42294 <bus_fault.isra.0+0xb0>)
   421ea:	4c2b      	ldr	r4, [pc, #172]	; (42298 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   421ec:	4d2b      	ldr	r5, [pc, #172]	; (4229c <bus_fault.isra.0+0xb8>)
   421ee:	1ae4      	subs	r4, r4, r3
   421f0:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
   421f2:	01a4      	lsls	r4, r4, #6
   421f4:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   421f8:	4607      	mov	r7, r0
   421fa:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   421fc:	4828      	ldr	r0, [pc, #160]	; (422a0 <bus_fault.isra.0+0xbc>)
   421fe:	4641      	mov	r1, r8
   42200:	f005 fb2e 	bl	47860 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   42204:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42206:	04d1      	lsls	r1, r2, #19
   42208:	d503      	bpl.n	42212 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
   4220a:	4641      	mov	r1, r8
   4220c:	4825      	ldr	r0, [pc, #148]	; (422a4 <bus_fault.isra.0+0xc0>)
   4220e:	f005 fb27 	bl	47860 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   42212:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42214:	051a      	lsls	r2, r3, #20
   42216:	d504      	bpl.n	42222 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42218:	4823      	ldr	r0, [pc, #140]	; (422a8 <bus_fault.isra.0+0xc4>)
   4221a:	f044 0101 	orr.w	r1, r4, #1
   4221e:	f005 fb1f 	bl	47860 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   42222:	4d1e      	ldr	r5, [pc, #120]	; (4229c <bus_fault.isra.0+0xb8>)
   42224:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42226:	059b      	lsls	r3, r3, #22
   42228:	d512      	bpl.n	42250 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
   4222a:	f044 0801 	orr.w	r8, r4, #1
   4222e:	4641      	mov	r1, r8
   42230:	481e      	ldr	r0, [pc, #120]	; (422ac <bus_fault.isra.0+0xc8>)
   42232:	f005 fb15 	bl	47860 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   42236:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   42238:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4223a:	0418      	lsls	r0, r3, #16
   4223c:	d508      	bpl.n	42250 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   4223e:	4642      	mov	r2, r8
   42240:	481b      	ldr	r0, [pc, #108]	; (422b0 <bus_fault.isra.0+0xcc>)
   42242:	f005 fb1a 	bl	4787a <log_1>
			if (from_hard_fault != 0) {
   42246:	b11f      	cbz	r7, 42250 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   42248:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4224a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   4224e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   42250:	4d12      	ldr	r5, [pc, #72]	; (4229c <bus_fault.isra.0+0xb8>)
   42252:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42254:	0559      	lsls	r1, r3, #21
   42256:	d504      	bpl.n	42262 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
   42258:	4816      	ldr	r0, [pc, #88]	; (422b4 <bus_fault.isra.0+0xd0>)
   4225a:	f044 0101 	orr.w	r1, r4, #1
   4225e:	f005 faff 	bl	47860 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   42262:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42264:	05da      	lsls	r2, r3, #23
   42266:	d50d      	bpl.n	42284 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
   42268:	4813      	ldr	r0, [pc, #76]	; (422b8 <bus_fault.isra.0+0xd4>)
   4226a:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4226e:	f005 faf7 	bl	47860 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   42272:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   42274:	4a09      	ldr	r2, [pc, #36]	; (4229c <bus_fault.isra.0+0xb8>)
   42276:	6a93      	ldr	r3, [r2, #40]	; 0x28
   42278:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   4227c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   4227e:	7030      	strb	r0, [r6, #0]
}
   42280:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   42284:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42286:	049b      	lsls	r3, r3, #18
   42288:	d5f3      	bpl.n	42272 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4228a:	480c      	ldr	r0, [pc, #48]	; (422bc <bus_fault.isra.0+0xd8>)
   4228c:	f044 0101 	orr.w	r1, r4, #1
   42290:	e7ed      	b.n	4226e <bus_fault.isra.0+0x8a>
   42292:	bf00      	nop
   42294:	00048b88 	.word	0x00048b88
   42298:	00048bb8 	.word	0x00048bb8
   4229c:	e000ed00 	.word	0xe000ed00
   422a0:	000491ff 	.word	0x000491ff
   422a4:	00049215 	.word	0x00049215
   422a8:	00049170 	.word	0x00049170
   422ac:	00049226 	.word	0x00049226
   422b0:	0004923f 	.word	0x0004923f
   422b4:	00049254 	.word	0x00049254
   422b8:	0004926f 	.word	0x0004926f
   422bc:	000491d0 	.word	0x000491d0

000422c0 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   422c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   422c4:	4b68      	ldr	r3, [pc, #416]	; (42468 <z_arm_fault+0x1a8>)
{
   422c6:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   422c8:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   422cc:	4689      	mov	r9, r1
   422ce:	4614      	mov	r4, r2
   422d0:	2700      	movs	r7, #0
   422d2:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   422d4:	f3c8 0608 	ubfx	r6, r8, #0, #9
   422d8:	f387 8811 	msr	BASEPRI, r7
   422dc:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   422e0:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   422e4:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   422e8:	d124      	bne.n	42334 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   422ea:	07d0      	lsls	r0, r2, #31
   422ec:	d422      	bmi.n	42334 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   422ee:	0651      	lsls	r1, r2, #25
   422f0:	d403      	bmi.n	422fa <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   422f2:	0722      	lsls	r2, r4, #28
   422f4:	d40e      	bmi.n	42314 <z_arm_fault+0x54>
			*nested_exc = true;
   422f6:	2701      	movs	r7, #1
   422f8:	e00e      	b.n	42318 <z_arm_fault+0x58>
   422fa:	495c      	ldr	r1, [pc, #368]	; (4246c <z_arm_fault+0x1ac>)
   422fc:	4b5c      	ldr	r3, [pc, #368]	; (42470 <z_arm_fault+0x1b0>)
		PR_FAULT_INFO("Exception occurred in Secure State");
   422fe:	485d      	ldr	r0, [pc, #372]	; (42474 <z_arm_fault+0x1b4>)
   42300:	1a5b      	subs	r3, r3, r1
   42302:	08db      	lsrs	r3, r3, #3
   42304:	019b      	lsls	r3, r3, #6
   42306:	f043 0101 	orr.w	r1, r3, #1
   4230a:	f005 faa9 	bl	47860 <log_0>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   4230e:	f014 0704 	ands.w	r7, r4, #4
   42312:	d001      	beq.n	42318 <z_arm_fault+0x58>
			ptr_esf = (z_arch_esf_t *)psp;
   42314:	464d      	mov	r5, r9
	*nested_exc = false;
   42316:	2700      	movs	r7, #0
	*recoverable = false;
   42318:	2300      	movs	r3, #0
   4231a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   4231e:	1ef3      	subs	r3, r6, #3
   42320:	2b09      	cmp	r3, #9
   42322:	f200 8088 	bhi.w	42436 <z_arm_fault+0x176>
   42326:	e8df f003 	tbb	[pc, r3]
   4232a:	7507      	.short	0x7507
   4232c:	86867279 	.word	0x86867279
   42330:	7d868686 	.word	0x7d868686
		return NULL;
   42334:	463d      	mov	r5, r7
   42336:	e7ef      	b.n	42318 <z_arm_fault+0x58>
	*recoverable = false;
   42338:	f04f 0800 	mov.w	r8, #0
   4233c:	4a4b      	ldr	r2, [pc, #300]	; (4246c <z_arm_fault+0x1ac>)
   4233e:	4e4c      	ldr	r6, [pc, #304]	; (42470 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** HARD FAULT *****");
   42340:	484d      	ldr	r0, [pc, #308]	; (42478 <z_arm_fault+0x1b8>)
   42342:	1ab6      	subs	r6, r6, r2
   42344:	08f6      	lsrs	r6, r6, #3
   42346:	01b6      	lsls	r6, r6, #6
   42348:	f046 0601 	orr.w	r6, r6, #1
   4234c:	4631      	mov	r1, r6
   4234e:	f005 fa87 	bl	47860 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42352:	4b45      	ldr	r3, [pc, #276]	; (42468 <z_arm_fault+0x1a8>)
	*recoverable = false;
   42354:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42358:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   4235a:	f014 0402 	ands.w	r4, r4, #2
   4235e:	d005      	beq.n	4236c <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
   42360:	4631      	mov	r1, r6
   42362:	4846      	ldr	r0, [pc, #280]	; (4247c <z_arm_fault+0x1bc>)
	PR_FAULT_INFO(
   42364:	f005 fa7c 	bl	47860 <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   42368:	2400      	movs	r4, #0
}
   4236a:	e006      	b.n	4237a <z_arm_fault+0xba>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   4236c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   4236e:	2a00      	cmp	r2, #0
   42370:	da1d      	bge.n	423ae <z_arm_fault+0xee>
		PR_EXC("  Debug event");
   42372:	4631      	mov	r1, r6
   42374:	4842      	ldr	r0, [pc, #264]	; (42480 <z_arm_fault+0x1c0>)
   42376:	f005 fa73 	bl	47860 <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   4237a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   4237e:	b99b      	cbnz	r3, 423a8 <z_arm_fault+0xe8>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   42380:	2220      	movs	r2, #32
   42382:	4629      	mov	r1, r5
   42384:	a802      	add	r0, sp, #8
   42386:	f005 fd6a 	bl	47e5e <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   4238a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   4238c:	2f00      	cmp	r7, #0
   4238e:	d066      	beq.n	4245e <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   42390:	f3c3 0208 	ubfx	r2, r3, #0, #9
   42394:	b922      	cbnz	r2, 423a0 <z_arm_fault+0xe0>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   42396:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   4239a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4239e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   423a0:	4620      	mov	r0, r4
   423a2:	a902      	add	r1, sp, #8
   423a4:	f7ff fcfa 	bl	41d9c <z_arm_fatal_error>
}
   423a8:	b00b      	add	sp, #44	; 0x2c
   423aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   423ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   423b0:	005b      	lsls	r3, r3, #1
   423b2:	d5e2      	bpl.n	4237a <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   423b4:	4631      	mov	r1, r6
   423b6:	4833      	ldr	r0, [pc, #204]	; (42484 <z_arm_fault+0x1c4>)
   423b8:	f005 fa52 	bl	47860 <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
   423bc:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   423be:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   423c2:	f64d 7302 	movw	r3, #57090	; 0xdf02
   423c6:	429a      	cmp	r2, r3
   423c8:	d00c      	beq.n	423e4 <z_arm_fault+0x124>
		} else if (SCB_MMFSR != 0) {
   423ca:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   423ce:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   423d2:	781b      	ldrb	r3, [r3, #0]
   423d4:	b16b      	cbz	r3, 423f2 <z_arm_fault+0x132>
			reason = mem_manage_fault(esf, 1, recoverable);
   423d6:	2001      	movs	r0, #1
   423d8:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   423dc:	f7ff fe9a 	bl	42114 <mem_manage_fault.isra.0>
   423e0:	4604      	mov	r4, r0
		break;
   423e2:	e7ca      	b.n	4237a <z_arm_fault+0xba>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   423e4:	4632      	mov	r2, r6
   423e6:	6829      	ldr	r1, [r5, #0]
   423e8:	4827      	ldr	r0, [pc, #156]	; (42488 <z_arm_fault+0x1c8>)
   423ea:	f005 fa46 	bl	4787a <log_1>
			reason = esf->basic.r0;
   423ee:	682c      	ldr	r4, [r5, #0]
   423f0:	e7c3      	b.n	4237a <z_arm_fault+0xba>
		} else if (SCB_BFSR != 0) {
   423f2:	4b26      	ldr	r3, [pc, #152]	; (4248c <z_arm_fault+0x1cc>)
   423f4:	781b      	ldrb	r3, [r3, #0]
   423f6:	b12b      	cbz	r3, 42404 <z_arm_fault+0x144>
			reason = bus_fault(esf, 1, recoverable);
   423f8:	2001      	movs	r0, #1
   423fa:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   423fe:	f7ff fef1 	bl	421e4 <bus_fault.isra.0>
   42402:	e7ed      	b.n	423e0 <z_arm_fault+0x120>
		} else if (SCB_UFSR != 0) {
   42404:	4b22      	ldr	r3, [pc, #136]	; (42490 <z_arm_fault+0x1d0>)
   42406:	881b      	ldrh	r3, [r3, #0]
   42408:	b29b      	uxth	r3, r3
   4240a:	2b00      	cmp	r3, #0
   4240c:	d0b5      	beq.n	4237a <z_arm_fault+0xba>
		reason = usage_fault(esf);
   4240e:	f7ff fe19 	bl	42044 <usage_fault.isra.0>
   42412:	e7e5      	b.n	423e0 <z_arm_fault+0x120>
		reason = mem_manage_fault(esf, 0, recoverable);
   42414:	2000      	movs	r0, #0
   42416:	f10d 0107 	add.w	r1, sp, #7
   4241a:	e7df      	b.n	423dc <z_arm_fault+0x11c>
		reason = bus_fault(esf, 0, recoverable);
   4241c:	2000      	movs	r0, #0
   4241e:	f10d 0107 	add.w	r1, sp, #7
   42422:	e7ec      	b.n	423fe <z_arm_fault+0x13e>
   42424:	4912      	ldr	r1, [pc, #72]	; (42470 <z_arm_fault+0x1b0>)
   42426:	4b11      	ldr	r3, [pc, #68]	; (4246c <z_arm_fault+0x1ac>)
	PR_FAULT_INFO(
   42428:	481a      	ldr	r0, [pc, #104]	; (42494 <z_arm_fault+0x1d4>)
   4242a:	1ac9      	subs	r1, r1, r3
   4242c:	08c9      	lsrs	r1, r1, #3
   4242e:	0189      	lsls	r1, r1, #6
   42430:	f041 0101 	orr.w	r1, r1, #1
   42434:	e796      	b.n	42364 <z_arm_fault+0xa4>
   42436:	4a0d      	ldr	r2, [pc, #52]	; (4246c <z_arm_fault+0x1ac>)
   42438:	4b0d      	ldr	r3, [pc, #52]	; (42470 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** %s %d) *****",
   4243a:	4817      	ldr	r0, [pc, #92]	; (42498 <z_arm_fault+0x1d8>)
   4243c:	1a9b      	subs	r3, r3, r2
   4243e:	08db      	lsrs	r3, r3, #3
   42440:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   42444:	ea4f 1383 	mov.w	r3, r3, lsl #6
   42448:	4914      	ldr	r1, [pc, #80]	; (4249c <z_arm_fault+0x1dc>)
   4244a:	f043 0301 	orr.w	r3, r3, #1
   4244e:	bf18      	it	ne
   42450:	4601      	movne	r1, r0
   42452:	f1a6 0210 	sub.w	r2, r6, #16
   42456:	4812      	ldr	r0, [pc, #72]	; (424a0 <z_arm_fault+0x1e0>)
   42458:	f005 fa23 	bl	478a2 <log_2>
   4245c:	e784      	b.n	42368 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4245e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   42462:	f023 0301 	bic.w	r3, r3, #1
   42466:	e79a      	b.n	4239e <z_arm_fault+0xde>
   42468:	e000ed00 	.word	0xe000ed00
   4246c:	00048b88 	.word	0x00048b88
   42470:	00048bb8 	.word	0x00048bb8
   42474:	00049287 	.word	0x00049287
   42478:	000492aa 	.word	0x000492aa
   4247c:	000492c1 	.word	0x000492c1
   42480:	000492e2 	.word	0x000492e2
   42484:	000492f0 	.word	0x000492f0
   42488:	0004930f 	.word	0x0004930f
   4248c:	e000ed29 	.word	0xe000ed29
   42490:	e000ed2a 	.word	0xe000ed2a
   42494:	0004932b 	.word	0x0004932b
   42498:	00049364 	.word	0x00049364
   4249c:	0004934f 	.word	0x0004934f
   424a0:	0004937d 	.word	0x0004937d

000424a4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   424a4:	4b04      	ldr	r3, [pc, #16]	; (424b8 <z_arm_fault_init+0x14>)
   424a6:	695a      	ldr	r2, [r3, #20]
   424a8:	f042 0210 	orr.w	r2, r2, #16
   424ac:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   424ae:	695a      	ldr	r2, [r3, #20]
   424b0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   424b4:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   424b6:	4770      	bx	lr
   424b8:	e000ed00 	.word	0xe000ed00

000424bc <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   424bc:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   424c0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   424c4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   424c6:	4672      	mov	r2, lr
	bl z_arm_fault
   424c8:	f7ff fefa 	bl	422c0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   424cc:	bd01      	pop	{r0, pc}
   424ce:	bf00      	nop

000424d0 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   424d0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424d2:	2120      	movs	r1, #32
   424d4:	4803      	ldr	r0, [pc, #12]	; (424e4 <z_arm_interrupt_init+0x14>)
   424d6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   424d8:	3301      	adds	r3, #1
   424da:	2b41      	cmp	r3, #65	; 0x41
   424dc:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   424e0:	d1f9      	bne.n	424d6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   424e2:	4770      	bx	lr
   424e4:	e000e100 	.word	0xe000e100

000424e8 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   424e8:	2000      	movs	r0, #0
    msr CONTROL, r0
   424ea:	f380 8814 	msr	CONTROL, r0
    isb
   424ee:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   424f2:	2000      	movs	r0, #0
    msr MSPLIM, r0
   424f4:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   424f8:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   424fc:	f006 f9d2 	bl	488a4 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   42500:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   42502:	490e      	ldr	r1, [pc, #56]	; (4253c <__start+0x54>)
    str r0, [r1]
   42504:	6008      	str	r0, [r1, #0]
    dsb
   42506:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   4250a:	480d      	ldr	r0, [pc, #52]	; (42540 <__start+0x58>)
    msr msp, r0
   4250c:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   42510:	f000 f82a 	bl	42568 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   42514:	2020      	movs	r0, #32
    msr BASEPRI, r0
   42516:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   4251a:	480a      	ldr	r0, [pc, #40]	; (42544 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   4251c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   42520:	1840      	adds	r0, r0, r1
    msr PSP, r0
   42522:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   42526:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   4252a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   4252c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   4252e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   42532:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   42536:	f7ff fcaf 	bl	41e98 <z_arm_prep_c>
   4253a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   4253c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42540:	20023228 	.word	0x20023228
    ldr r0, =z_interrupt_stacks
   42544:	20023368 	.word	0x20023368

00042548 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   42548:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   4254a:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   4254c:	4a05      	ldr	r2, [pc, #20]	; (42564 <z_arm_clear_arm_mpu_config+0x1c>)
   4254e:	6811      	ldr	r1, [r2, #0]
	int num_regions =
   42550:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
   42554:	428b      	cmp	r3, r1
   42556:	d100      	bne.n	4255a <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
   42558:	4770      	bx	lr
  mpu->RNR = rnr;
   4255a:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   4255c:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
   4255e:	3301      	adds	r3, #1
   42560:	e7f8      	b.n	42554 <z_arm_clear_arm_mpu_config+0xc>
   42562:	bf00      	nop
   42564:	e000ed90 	.word	0xe000ed90

00042568 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
   42568:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   4256a:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   4256c:	2400      	movs	r4, #0
   4256e:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   42572:	f7ff ffe9 	bl	42548 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   42576:	4a0e      	ldr	r2, [pc, #56]	; (425b0 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
   42578:	4623      	mov	r3, r4
   4257a:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
   4257c:	f04f 34ff 	mov.w	r4, #4294967295
   42580:	f103 0020 	add.w	r0, r3, #32
   42584:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   42586:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   42588:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   4258c:	d1f8      	bne.n	42580 <z_arm_init_arch_hw_at_boot+0x18>
   4258e:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   42590:	f04f 30ff 	mov.w	r0, #4294967295
   42594:	f103 0260 	add.w	r2, r3, #96	; 0x60
   42598:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   4259a:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   4259c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   425a0:	d1f8      	bne.n	42594 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   425a2:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   425a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   425a8:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   425ac:	bd10      	pop	{r4, pc}
   425ae:	bf00      	nop
   425b0:	e000e100 	.word	0xe000e100

000425b4 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   425b4:	4b06      	ldr	r3, [pc, #24]	; (425d0 <z_impl_k_thread_abort+0x1c>)
   425b6:	689b      	ldr	r3, [r3, #8]
   425b8:	4283      	cmp	r3, r0
   425ba:	d107      	bne.n	425cc <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   425bc:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   425c0:	b123      	cbz	r3, 425cc <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   425c2:	4a04      	ldr	r2, [pc, #16]	; (425d4 <z_impl_k_thread_abort+0x20>)
   425c4:	6853      	ldr	r3, [r2, #4]
   425c6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   425ca:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   425cc:	f004 baac 	b.w	46b28 <z_thread_abort>
   425d0:	2001ad84 	.word	0x2001ad84
   425d4:	e000ed00 	.word	0xe000ed00

000425d8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   425d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   425da:	4c09      	ldr	r4, [pc, #36]	; (42600 <z_arm_configure_static_mpu_regions+0x28>)
   425dc:	4a09      	ldr	r2, [pc, #36]	; (42604 <z_arm_configure_static_mpu_regions+0x2c>)
   425de:	4623      	mov	r3, r4
   425e0:	2101      	movs	r1, #1
   425e2:	4809      	ldr	r0, [pc, #36]	; (42608 <z_arm_configure_static_mpu_regions+0x30>)
   425e4:	f000 f912 	bl	4280c <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   425e8:	2300      	movs	r3, #0
   425ea:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   425ec:	4b07      	ldr	r3, [pc, #28]	; (4260c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   425ee:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   425f0:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   425f2:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   425f4:	9301      	str	r3, [sp, #4]
   425f6:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   425f8:	f000 f912 	bl	42820 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   425fc:	b004      	add	sp, #16
   425fe:	bd10      	pop	{r4, pc}
   42600:	20040000 	.word	0x20040000
   42604:	2001a500 	.word	0x2001a500
   42608:	00048cbc 	.word	0x00048cbc
   4260c:	2001a678 	.word	0x2001a678

00042610 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   42610:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42612:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   42614:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42616:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   4261a:	f004 031f 	and.w	r3, r4, #31
   4261e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42620:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42622:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42624:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   42628:	4904      	ldr	r1, [pc, #16]	; (4263c <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   4262a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   4262e:	f043 0301 	orr.w	r3, r3, #1
   42632:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   42634:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   42636:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   42638:	bd10      	pop	{r4, pc}
   4263a:	bf00      	nop
   4263c:	e000ed90 	.word	0xe000ed90

00042640 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   42640:	280f      	cmp	r0, #15
{
   42642:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
   42644:	d90d      	bls.n	42662 <region_allocate_and_init+0x22>
   42646:	4b08      	ldr	r3, [pc, #32]	; (42668 <region_allocate_and_init+0x28>)
   42648:	4a08      	ldr	r2, [pc, #32]	; (4266c <region_allocate_and_init+0x2c>)

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   4264a:	4601      	mov	r1, r0
   4264c:	1ad2      	subs	r2, r2, r3
   4264e:	08d2      	lsrs	r2, r2, #3
   42650:	0192      	lsls	r2, r2, #6
   42652:	4807      	ldr	r0, [pc, #28]	; (42670 <region_allocate_and_init+0x30>)
   42654:	f042 0201 	orr.w	r2, r2, #1
   42658:	f005 f90f 	bl	4787a <log_1>
		return -EINVAL;
   4265c:	f06f 0015 	mvn.w	r0, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   42660:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   42662:	f7ff ffd5 	bl	42610 <region_init>
	return index;
   42666:	e7fb      	b.n	42660 <region_allocate_and_init+0x20>
   42668:	00048b88 	.word	0x00048b88
   4266c:	00048ba8 	.word	0x00048ba8
   42670:	00049394 	.word	0x00049394

00042674 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42674:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42678:	4689      	mov	r9, r1
   4267a:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   4267c:	4606      	mov	r6, r0
   4267e:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
   42682:	4d54      	ldr	r5, [pc, #336]	; (427d4 <mpu_configure_regions_and_partition.constprop.0+0x160>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42684:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   42686:	45c8      	cmp	r8, r9
   42688:	da33      	bge.n	426f2 <mpu_configure_regions_and_partition.constprop.0+0x7e>
		if (regions[i].size == 0U) {
   4268a:	f8d6 a004 	ldr.w	sl, [r6, #4]
   4268e:	f1ba 0f00 	cmp.w	sl, #0
   42692:	d04d      	beq.n	42730 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		&&
   42694:	f1ba 0f1f 	cmp.w	sl, #31
   42698:	d91e      	bls.n	426d8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		&&
   4269a:	f01a 0f1f 	tst.w	sl, #31
   4269e:	d11b      	bne.n	426d8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		((part->start &
   426a0:	f8d6 b000 	ldr.w	fp, [r6]
		&&
   426a4:	f01b 0f1f 	tst.w	fp, #31
   426a8:	d116      	bne.n	426d8 <mpu_configure_regions_and_partition.constprop.0+0x64>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   426aa:	4658      	mov	r0, fp
   426ac:	f005 fb71 	bl	47d92 <arm_cmse_mpu_region_get>
   426b0:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   426b2:	eb0a 000b 	add.w	r0, sl, fp
   426b6:	3801      	subs	r0, #1
   426b8:	f005 fb6b 	bl	47d92 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   426bc:	4287      	cmp	r7, r0
   426be:	d01c      	beq.n	426fa <mpu_configure_regions_and_partition.constprop.0+0x86>
	return -EINVAL;
   426c0:	f06f 0715 	mvn.w	r7, #21
   426c4:	4a44      	ldr	r2, [pc, #272]	; (427d8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   426c6:	4b45      	ldr	r3, [pc, #276]	; (427dc <mpu_configure_regions_and_partition.constprop.0+0x168>)
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   426c8:	4639      	mov	r1, r7
   426ca:	1ad2      	subs	r2, r2, r3
   426cc:	08d2      	lsrs	r2, r2, #3
   426ce:	0192      	lsls	r2, r2, #6
   426d0:	4843      	ldr	r0, [pc, #268]	; (427e0 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
   426d2:	f042 0201 	orr.w	r2, r2, #1
   426d6:	e008      	b.n	426ea <mpu_configure_regions_and_partition.constprop.0+0x76>
			LOG_ERR("Partition %u: sanity check failed.", i);
   426d8:	4641      	mov	r1, r8
   426da:	4a3f      	ldr	r2, [pc, #252]	; (427d8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   426dc:	4b3f      	ldr	r3, [pc, #252]	; (427dc <mpu_configure_regions_and_partition.constprop.0+0x168>)
   426de:	4841      	ldr	r0, [pc, #260]	; (427e4 <mpu_configure_regions_and_partition.constprop.0+0x170>)
   426e0:	1ad2      	subs	r2, r2, r3
   426e2:	08d2      	lsrs	r2, r2, #3
   426e4:	0192      	lsls	r2, r2, #6
   426e6:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
   426ea:	f005 f8c6 	bl	4787a <log_1>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   426ee:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   426f2:	4620      	mov	r0, r4
   426f4:	b005      	add	sp, #20
   426f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   426fa:	f117 0f16 	cmn.w	r7, #22
   426fe:	d0e1      	beq.n	426c4 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
   42700:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   42702:	42bb      	cmp	r3, r7
   42704:	dbde      	blt.n	426c4 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
   42706:	60af      	str	r7, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   42708:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   4270a:	60af      	str	r7, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   4270c:	692b      	ldr	r3, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   4270e:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42712:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42716:	e9d6 3200 	ldrd	r3, r2, [r6]
   4271a:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   4271c:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   4271e:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
   42722:	d11a      	bne.n	4275a <mpu_configure_regions_and_partition.constprop.0+0xe6>
   42724:	45d3      	cmp	fp, sl
   42726:	d107      	bne.n	42738 <mpu_configure_regions_and_partition.constprop.0+0xc4>
			mpu_configure_region(u_reg_index, &regions[i]);
   42728:	4631      	mov	r1, r6
   4272a:	b2f8      	uxtb	r0, r7
   4272c:	f005 fb3a 	bl	47da4 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   42730:	f108 0801 	add.w	r8, r8, #1
   42734:	360c      	adds	r6, #12
   42736:	e7a6      	b.n	42686 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   42738:	4631      	mov	r1, r6
	MPU->RNR = index;
   4273a:	60af      	str	r7, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   4273c:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   4273e:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42742:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   42746:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42748:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   4274a:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   4274c:	f005 fb2a 	bl	47da4 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42750:	f110 0f16 	cmn.w	r0, #22
   42754:	d0cb      	beq.n	426ee <mpu_configure_regions_and_partition.constprop.0+0x7a>
			reg_index++;
   42756:	1c44      	adds	r4, r0, #1
   42758:	e7ea      	b.n	42730 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		} else if (reg_last == u_reg_last) {
   4275a:	3b01      	subs	r3, #1
   4275c:	45d3      	cmp	fp, sl
   4275e:	b2e0      	uxtb	r0, r4
   42760:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   42764:	60af      	str	r7, [r5, #8]
		} else if (reg_last == u_reg_last) {
   42766:	d106      	bne.n	42776 <mpu_configure_regions_and_partition.constprop.0+0x102>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42768:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   4276a:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   4276c:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42770:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42772:	612b      	str	r3, [r5, #16]
			reg_index =
   42774:	e7ea      	b.n	4274c <mpu_configure_regions_and_partition.constprop.0+0xd8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42776:	6929      	ldr	r1, [r5, #16]
   42778:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   4277c:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   4277e:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42780:	4631      	mov	r1, r6
   42782:	f005 fb0f 	bl	47da4 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42786:	f110 0f16 	cmn.w	r0, #22
   4278a:	d0b0      	beq.n	426ee <mpu_configure_regions_and_partition.constprop.0+0x7a>
	MPU->RNR = index;
   4278c:	60af      	str	r7, [r5, #8]
	attr->rbar = MPU->RBAR &
   4278e:	68ea      	ldr	r2, [r5, #12]
   42790:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   42794:	f10b 3bff 	add.w	fp, fp, #4294967295
	attr->rbar = MPU->RBAR &
   42798:	f362 0304 	bfi	r3, r2, #0, #5
   4279c:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   427a0:	692b      	ldr	r3, [r5, #16]
   427a2:	f89d 2008 	ldrb.w	r2, [sp, #8]
   427a6:	085b      	lsrs	r3, r3, #1
   427a8:	f363 1247 	bfi	r2, r3, #5, #3
   427ac:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   427b0:	e9d6 3200 	ldrd	r3, r2, [r6]
   427b4:	4413      	add	r3, r2
   427b6:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   427b8:	f023 031f 	bic.w	r3, r3, #31
   427bc:	445b      	add	r3, fp
   427be:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
   427c2:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   427c4:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   427c8:	4669      	mov	r1, sp
   427ca:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   427cc:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   427ce:	f7ff ff37 	bl	42640 <region_allocate_and_init>
   427d2:	e7bd      	b.n	42750 <mpu_configure_regions_and_partition.constprop.0+0xdc>
   427d4:	e000ed90 	.word	0xe000ed90
   427d8:	00048ba8 	.word	0x00048ba8
   427dc:	00048b88 	.word	0x00048b88
   427e0:	000493dd 	.word	0x000493dd
   427e4:	000493ba 	.word	0x000493ba

000427e8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   427e8:	2205      	movs	r2, #5
   427ea:	4b03      	ldr	r3, [pc, #12]	; (427f8 <arm_core_mpu_enable+0x10>)
   427ec:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   427ee:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   427f2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   427f6:	4770      	bx	lr
   427f8:	e000ed90 	.word	0xe000ed90

000427fc <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   427fc:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   42800:	2200      	movs	r2, #0
   42802:	4b01      	ldr	r3, [pc, #4]	; (42808 <arm_core_mpu_disable+0xc>)
   42804:	605a      	str	r2, [r3, #4]
}
   42806:	4770      	bx	lr
   42808:	e000ed90 	.word	0xe000ed90

0004280c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   4280c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   4280e:	4c03      	ldr	r4, [pc, #12]	; (4281c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   42810:	7822      	ldrb	r2, [r4, #0]
   42812:	f7ff ff2f 	bl	42674 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   42816:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   42818:	bd10      	pop	{r4, pc}
   4281a:	bf00      	nop
   4281c:	2001ade0 	.word	0x2001ade0

00042820 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   42820:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42824:	4d26      	ldr	r5, [pc, #152]	; (428c0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   42826:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42828:	4606      	mov	r6, r0
   4282a:	f04f 0800 	mov.w	r8, #0
   4282e:	46ab      	mov	fp, r5
	MPU->RNR = index;
   42830:	4f24      	ldr	r7, [pc, #144]	; (428c4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42832:	45d0      	cmp	r8, sl
   42834:	da1b      	bge.n	4286e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   42836:	f8d6 9004 	ldr.w	r9, [r6, #4]
   4283a:	f1b9 0f00 	cmp.w	r9, #0
   4283e:	d039      	beq.n	428b4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   42840:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42842:	4608      	mov	r0, r1
   42844:	9101      	str	r1, [sp, #4]
   42846:	f005 faa4 	bl	47d92 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   4284a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   4284c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   4284e:	eb09 0001 	add.w	r0, r9, r1
   42852:	3801      	subs	r0, #1
   42854:	f005 fa9d 	bl	47d92 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   42858:	4284      	cmp	r4, r0
   4285a:	f04f 0214 	mov.w	r2, #20
   4285e:	4b1a      	ldr	r3, [pc, #104]	; (428c8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   42860:	d008      	beq.n	42874 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   42862:	f06f 0315 	mvn.w	r3, #21
   42866:	fb02 f808 	mul.w	r8, r2, r8
   4286a:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   4286e:	b003      	add	sp, #12
   42870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   42874:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   42878:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   4287a:	d0f8      	beq.n	4286e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   4287c:	7819      	ldrb	r1, [r3, #0]
   4287e:	42a1      	cmp	r1, r4
   42880:	ddf5      	ble.n	4286e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   42882:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   42886:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   42888:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   4288a:	68fc      	ldr	r4, [r7, #12]
   4288c:	f100 0108 	add.w	r1, r0, #8
   42890:	7b00      	ldrb	r0, [r0, #12]
   42892:	f364 0004 	bfi	r0, r4, #0, #5
   42896:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42898:	6938      	ldr	r0, [r7, #16]
   4289a:	790c      	ldrb	r4, [r1, #4]
   4289c:	0840      	lsrs	r0, r0, #1
   4289e:	f360 1447 	bfi	r4, r0, #5, #3
   428a2:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   428a4:	68f9      	ldr	r1, [r7, #12]
   428a6:	f021 011f 	bic.w	r1, r1, #31
   428aa:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   428ac:	6939      	ldr	r1, [r7, #16]
   428ae:	f021 011f 	bic.w	r1, r1, #31
   428b2:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   428b4:	f108 0801 	add.w	r8, r8, #1
   428b8:	3514      	adds	r5, #20
   428ba:	360c      	adds	r6, #12
   428bc:	e7b9      	b.n	42832 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   428be:	bf00      	nop
   428c0:	2001a910 	.word	0x2001a910
   428c4:	e000ed90 	.word	0xe000ed90
   428c8:	2001ade0 	.word	0x2001ade0

000428cc <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   428cc:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   428ce:	4c0e      	ldr	r4, [pc, #56]	; (42908 <z_arm_mpu_init+0x3c>)
   428d0:	6825      	ldr	r5, [r4, #0]
   428d2:	2d10      	cmp	r5, #16
   428d4:	d814      	bhi.n	42900 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   428d6:	f7ff ff91 	bl	427fc <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   428da:	2000      	movs	r0, #0
	MPU->MAIR0 =
   428dc:	4b0b      	ldr	r3, [pc, #44]	; (4290c <z_arm_mpu_init+0x40>)
   428de:	4a0c      	ldr	r2, [pc, #48]	; (42910 <z_arm_mpu_init+0x44>)
   428e0:	631a      	str	r2, [r3, #48]	; 0x30
   428e2:	4285      	cmp	r5, r0
   428e4:	d105      	bne.n	428f2 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   428e6:	4b0b      	ldr	r3, [pc, #44]	; (42914 <z_arm_mpu_init+0x48>)
   428e8:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   428ea:	f7ff ff7d 	bl	427e8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   428ee:	2000      	movs	r0, #0
}
   428f0:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   428f2:	6861      	ldr	r1, [r4, #4]
   428f4:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   428f8:	f7ff fe8a 	bl	42610 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   428fc:	3001      	adds	r0, #1
   428fe:	e7f0      	b.n	428e2 <z_arm_mpu_init+0x16>
		return -1;
   42900:	f04f 30ff 	mov.w	r0, #4294967295
   42904:	e7f4      	b.n	428f0 <z_arm_mpu_init+0x24>
   42906:	bf00      	nop
   42908:	00048cc8 	.word	0x00048cc8
   4290c:	e000ed90 	.word	0xe000ed90
   42910:	0044ffaa 	.word	0x0044ffaa
   42914:	2001ade0 	.word	0x2001ade0

00042918 <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   42918:	b508      	push	{r3, lr}
   4291a:	4908      	ldr	r1, [pc, #32]	; (4293c <malloc+0x24>)
   4291c:	4b08      	ldr	r3, [pc, #32]	; (42940 <malloc+0x28>)
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
   4291e:	4809      	ldr	r0, [pc, #36]	; (42944 <malloc+0x2c>)
   42920:	1ac9      	subs	r1, r1, r3
   42922:	08c9      	lsrs	r1, r1, #3
   42924:	0189      	lsls	r1, r1, #6
   42926:	f041 0101 	orr.w	r1, r1, #1
   4292a:	f004 ff99 	bl	47860 <log_0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   4292e:	f003 faaf 	bl	45e90 <z_impl_z_errno>
	errno = ENOMEM;
   42932:	230c      	movs	r3, #12
   42934:	6003      	str	r3, [r0, #0]

	return NULL;
}
   42936:	2000      	movs	r0, #0
   42938:	bd08      	pop	{r3, pc}
   4293a:	bf00      	nop
   4293c:	00048bb8 	.word	0x00048bb8
   42940:	00048b88 	.word	0x00048b88
   42944:	00049400 	.word	0x00049400

00042948 <_exit>:

#include <stdlib.h>
#include <zephyr.h>

void _exit(int status)
{
   42948:	b508      	push	{r3, lr}
	printk("exit\n");
   4294a:	4802      	ldr	r0, [pc, #8]	; (42954 <_exit+0xc>)
   4294c:	f004 fc31 	bl	471b2 <printk>
	while (1) {
   42950:	e7fe      	b.n	42950 <_exit+0x8>
   42952:	bf00      	nop
   42954:	0004942b 	.word	0x0004942b

00042958 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   42958:	4b01      	ldr	r3, [pc, #4]	; (42960 <__stdout_hook_install+0x8>)
   4295a:	6018      	str	r0, [r3, #0]
}
   4295c:	4770      	bx	lr
   4295e:	bf00      	nop
   42960:	2001a574 	.word	0x2001a574

00042964 <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
   42964:	3902      	subs	r1, #2
   42966:	2901      	cmp	r1, #1
   42968:	d802      	bhi.n	42970 <z_impl_zephyr_fputc+0xc>
   4296a:	4b03      	ldr	r3, [pc, #12]	; (42978 <z_impl_zephyr_fputc+0x14>)
   4296c:	681b      	ldr	r3, [r3, #0]
   4296e:	4718      	bx	r3
}
   42970:	f04f 30ff 	mov.w	r0, #4294967295
   42974:	4770      	bx	lr
   42976:	bf00      	nop
   42978:	2001a574 	.word	0x2001a574

0004297c <printf>:

	return r;
}

int printf(const char *ZRESTRICT format, ...)
{
   4297c:	b40f      	push	{r0, r1, r2, r3}
   4297e:	b507      	push	{r0, r1, r2, lr}
   42980:	ab04      	add	r3, sp, #16
   42982:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   42986:	2102      	movs	r1, #2
   42988:	4804      	ldr	r0, [pc, #16]	; (4299c <printf+0x20>)
	va_start(vargs, format);
   4298a:	9301      	str	r3, [sp, #4]
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   4298c:	f7fd ff2e 	bl	407ec <cbvprintf>
	va_end(vargs);

	return r;
}
   42990:	b003      	add	sp, #12
   42992:	f85d eb04 	ldr.w	lr, [sp], #4
   42996:	b004      	add	sp, #16
   42998:	4770      	bx	lr
   4299a:	bf00      	nop
   4299c:	00047e8d 	.word	0x00047e8d

000429a0 <onoff_stop>:
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   429a0:	b570      	push	{r4, r5, r6, lr}
   429a2:	4604      	mov	r4, r0
	err = set_off_state(&subdata->flags, ctx);
   429a4:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   429a6:	480d      	ldr	r0, [pc, #52]	; (429dc <onoff_stop+0x3c>)
{
   429a8:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
   429aa:	1a23      	subs	r3, r4, r0
   429ac:	109a      	asrs	r2, r3, #2
   429ae:	4b0c      	ldr	r3, [pc, #48]	; (429e0 <onoff_stop+0x40>)
	err = set_off_state(&subdata->flags, ctx);
   429b0:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   429b2:	4353      	muls	r3, r2
   429b4:	b2db      	uxtb	r3, r3
	err = set_off_state(&subdata->flags, ctx);
   429b6:	435d      	muls	r5, r3
   429b8:	f105 0340 	add.w	r3, r5, #64	; 0x40
   429bc:	4418      	add	r0, r3
   429be:	f005 fa70 	bl	47ea2 <set_off_state>
	if (err < 0) {
   429c2:	1e01      	subs	r1, r0, #0
   429c4:	db04      	blt.n	429d0 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   429c6:	4b07      	ldr	r3, [pc, #28]	; (429e4 <onoff_stop+0x44>)
   429c8:	442b      	add	r3, r5
   429ca:	685b      	ldr	r3, [r3, #4]
   429cc:	4798      	blx	r3
	return 0;
   429ce:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   429d0:	4620      	mov	r0, r4
   429d2:	4633      	mov	r3, r6
}
   429d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   429d8:	4718      	bx	r3
   429da:	bf00      	nop
   429dc:	2001a934 	.word	0x2001a934
   429e0:	b6db6db7 	.word	0xb6db6db7
   429e4:	00048d08 	.word	0x00048d08

000429e8 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   429e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   429ec:	4c0f      	ldr	r4, [pc, #60]	; (42a2c <onoff_start+0x44>)
   429ee:	4d10      	ldr	r5, [pc, #64]	; (42a30 <onoff_start+0x48>)
   429f0:	1b03      	subs	r3, r0, r4
   429f2:	109b      	asrs	r3, r3, #2
   429f4:	435d      	muls	r5, r3
   429f6:	b2eb      	uxtb	r3, r5
	err = set_starting_state(&subdata->flags, ctx);
   429f8:	250c      	movs	r5, #12
   429fa:	435d      	muls	r5, r3
{
   429fc:	4607      	mov	r7, r0
	err = set_starting_state(&subdata->flags, ctx);
   429fe:	f105 0040 	add.w	r0, r5, #64	; 0x40
{
   42a02:	460e      	mov	r6, r1
	err = set_starting_state(&subdata->flags, ctx);
   42a04:	4420      	add	r0, r4
   42a06:	2140      	movs	r1, #64	; 0x40
   42a08:	f005 fa64 	bl	47ed4 <set_starting_state>
	if (err < 0) {
   42a0c:	1e01      	subs	r1, r0, #0
   42a0e:	db08      	blt.n	42a22 <onoff_start+0x3a>
	subdata->cb = cb;
   42a10:	4b08      	ldr	r3, [pc, #32]	; (42a34 <onoff_start+0x4c>)
   42a12:	442c      	add	r4, r5
	subdata->user_data = user_data;
   42a14:	e9c4 360e 	strd	r3, r6, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   42a18:	4b07      	ldr	r3, [pc, #28]	; (42a38 <onoff_start+0x50>)
   42a1a:	595b      	ldr	r3, [r3, r5]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   42a1c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   42a20:	4718      	bx	r3
		notify(mgr, err);
   42a22:	4638      	mov	r0, r7
   42a24:	4633      	mov	r3, r6
}
   42a26:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   42a2a:	4718      	bx	r3
   42a2c:	2001a934 	.word	0x2001a934
   42a30:	b6db6db7 	.word	0xb6db6db7
   42a34:	00047f37 	.word	0x00047f37
   42a38:	00048d08 	.word	0x00048d08

00042a3c <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   42a3c:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42a3e:	2200      	movs	r2, #0
   42a40:	2101      	movs	r1, #1
{
   42a42:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42a44:	2005      	movs	r0, #5
   42a46:	f7ff f9ff 	bl	41e48 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   42a4a:	2005      	movs	r0, #5
   42a4c:	f7ff f9de 	bl	41e0c <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   42a50:	480f      	ldr	r0, [pc, #60]	; (42a90 <clk_init+0x54>)
   42a52:	f001 f8ef 	bl	43c34 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   42a56:	4b0f      	ldr	r3, [pc, #60]	; (42a94 <clk_init+0x58>)
   42a58:	4298      	cmp	r0, r3
   42a5a:	d115      	bne.n	42a88 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   42a5c:	f005 fba5 	bl	481aa <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   42a60:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   42a62:	490d      	ldr	r1, [pc, #52]	; (42a98 <clk_init+0x5c>)
   42a64:	4630      	mov	r0, r6
   42a66:	f004 fc0d 	bl	47284 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   42a6a:	2800      	cmp	r0, #0
   42a6c:	db0b      	blt.n	42a86 <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42a6e:	2501      	movs	r5, #1
   42a70:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   42a72:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   42a74:	4908      	ldr	r1, [pc, #32]	; (42a98 <clk_init+0x5c>)
   42a76:	f104 001c 	add.w	r0, r4, #28
   42a7a:	f004 fc03 	bl	47284 <onoff_manager_init>
		if (err < 0) {
   42a7e:	2800      	cmp	r0, #0
   42a80:	db01      	blt.n	42a86 <clk_init+0x4a>
	}

	return 0;
   42a82:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42a84:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   42a86:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   42a88:	f06f 0004 	mvn.w	r0, #4
   42a8c:	e7fb      	b.n	42a86 <clk_init+0x4a>
   42a8e:	bf00      	nop
   42a90:	00042ad1 	.word	0x00042ad1
   42a94:	0bad0000 	.word	0x0bad0000
   42a98:	00048d20 	.word	0x00048d20

00042a9c <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   42a9c:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   42a9e:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   42aa0:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   42aa2:	434b      	muls	r3, r1
   42aa4:	4808      	ldr	r0, [pc, #32]	; (42ac8 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   42aa6:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   42aa8:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   42aaa:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   42aac:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42ab0:	4418      	add	r0, r3
	sub_data->cb = NULL;
   42ab2:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42ab4:	f005 fa2c 	bl	47f10 <set_on_state>
	if (callback) {
   42ab8:	b12d      	cbz	r5, 42ac6 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   42aba:	4632      	mov	r2, r6
   42abc:	462b      	mov	r3, r5
}
   42abe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   42ac2:	4802      	ldr	r0, [pc, #8]	; (42acc <clkstarted_handle.constprop.0+0x30>)
   42ac4:	4718      	bx	r3
}
   42ac6:	bd70      	pop	{r4, r5, r6, pc}
   42ac8:	2001a934 	.word	0x2001a934
   42acc:	00048920 	.word	0x00048920

00042ad0 <clock_event_handler>:
	switch (event) {
   42ad0:	b110      	cbz	r0, 42ad8 <clock_event_handler+0x8>
   42ad2:	2801      	cmp	r0, #1
   42ad4:	d004      	beq.n	42ae0 <clock_event_handler+0x10>
   42ad6:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   42ad8:	4b03      	ldr	r3, [pc, #12]	; (42ae8 <clock_event_handler+0x18>)
   42ada:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   42adc:	075b      	lsls	r3, r3, #29
   42ade:	d101      	bne.n	42ae4 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   42ae0:	f7ff bfdc 	b.w	42a9c <clkstarted_handle.constprop.0>
}
   42ae4:	4770      	bx	lr
   42ae6:	bf00      	nop
   42ae8:	2001a934 	.word	0x2001a934

00042aec <generic_hfclk_start>:
{
   42aec:	b508      	push	{r3, lr}
	__asm__ volatile(
   42aee:	f04f 0320 	mov.w	r3, #32
   42af2:	f3ef 8111 	mrs	r1, BASEPRI
   42af6:	f383 8812 	msr	BASEPRI_MAX, r3
   42afa:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   42afe:	4a11      	ldr	r2, [pc, #68]	; (42b44 <generic_hfclk_start+0x58>)
   42b00:	6813      	ldr	r3, [r2, #0]
   42b02:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   42b06:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   42b0a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   42b0c:	d00b      	beq.n	42b26 <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   42b0e:	4a0e      	ldr	r2, [pc, #56]	; (42b48 <generic_hfclk_start+0x5c>)
   42b10:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   42b14:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   42b18:	f013 0301 	ands.w	r3, r3, #1
   42b1c:	d003      	beq.n	42b26 <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   42b1e:	480b      	ldr	r0, [pc, #44]	; (42b4c <generic_hfclk_start+0x60>)
   42b20:	f005 f9f6 	bl	47f10 <set_on_state>
			already_started = true;
   42b24:	2301      	movs	r3, #1
	__asm__ volatile(
   42b26:	f381 8811 	msr	BASEPRI, r1
   42b2a:	f3bf 8f6f 	isb	sy
	if (already_started) {
   42b2e:	b123      	cbz	r3, 42b3a <generic_hfclk_start+0x4e>
}
   42b30:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   42b34:	2000      	movs	r0, #0
   42b36:	f7ff bfb1 	b.w	42a9c <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   42b3a:	2001      	movs	r0, #1
}
   42b3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   42b40:	f001 b888 	b.w	43c54 <nrfx_clock_start>
   42b44:	2001a984 	.word	0x2001a984
   42b48:	40005000 	.word	0x40005000
   42b4c:	2001a974 	.word	0x2001a974

00042b50 <generic_hfclk_stop>:
   42b50:	4b07      	ldr	r3, [pc, #28]	; (42b70 <generic_hfclk_stop+0x20>)
   42b52:	e8d3 2fef 	ldaex	r2, [r3]
   42b56:	f022 0102 	bic.w	r1, r2, #2
   42b5a:	e8c3 1fe0 	stlex	r0, r1, [r3]
   42b5e:	2800      	cmp	r0, #0
   42b60:	d1f7      	bne.n	42b52 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   42b62:	07d3      	lsls	r3, r2, #31
   42b64:	d402      	bmi.n	42b6c <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   42b66:	2001      	movs	r0, #1
   42b68:	f001 b8a6 	b.w	43cb8 <nrfx_clock_stop>
}
   42b6c:	4770      	bx	lr
   42b6e:	bf00      	nop
   42b70:	2001a984 	.word	0x2001a984

00042b74 <api_blocking_start>:
{
   42b74:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42b76:	2200      	movs	r2, #0
   42b78:	2301      	movs	r3, #1
   42b7a:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42b7e:	466b      	mov	r3, sp
   42b80:	4a08      	ldr	r2, [pc, #32]	; (42ba4 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42b82:	f8cd d000 	str.w	sp, [sp]
   42b86:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42b8a:	f005 f9fa 	bl	47f82 <api_start>
	if (err < 0) {
   42b8e:	2800      	cmp	r0, #0
   42b90:	db05      	blt.n	42b9e <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   42b92:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   42b96:	2300      	movs	r3, #0
   42b98:	4668      	mov	r0, sp
   42b9a:	f003 fca5 	bl	464e8 <z_impl_k_sem_take>
}
   42b9e:	b005      	add	sp, #20
   42ba0:	f85d fb04 	ldr.w	pc, [sp], #4
   42ba4:	00047f55 	.word	0x00047f55

00042ba8 <z_nrf_clock_control_lf_on>:
{
   42ba8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   42bac:	2201      	movs	r2, #1
   42bae:	4607      	mov	r7, r0
   42bb0:	4936      	ldr	r1, [pc, #216]	; (42c8c <z_nrf_clock_control_lf_on+0xe4>)
   42bb2:	e8d1 3fef 	ldaex	r3, [r1]
   42bb6:	e8c1 2fe0 	stlex	r0, r2, [r1]
   42bba:	2800      	cmp	r0, #0
   42bbc:	d1f9      	bne.n	42bb2 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   42bbe:	b933      	cbnz	r3, 42bce <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   42bc0:	4933      	ldr	r1, [pc, #204]	; (42c90 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   42bc2:	4834      	ldr	r0, [pc, #208]	; (42c94 <z_nrf_clock_control_lf_on+0xec>)
   42bc4:	604b      	str	r3, [r1, #4]
   42bc6:	60cb      	str	r3, [r1, #12]
   42bc8:	608a      	str	r2, [r1, #8]
   42bca:	f004 fb6e 	bl	472aa <onoff_request>
	switch (start_mode) {
   42bce:	1e7b      	subs	r3, r7, #1
   42bd0:	2b01      	cmp	r3, #1
   42bd2:	d82e      	bhi.n	42c32 <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   42bd4:	2f01      	cmp	r7, #1
   42bd6:	d106      	bne.n	42be6 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   42bd8:	4b2f      	ldr	r3, [pc, #188]	; (42c98 <z_nrf_clock_control_lf_on+0xf0>)
   42bda:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   42bde:	f003 0303 	and.w	r3, r3, #3
   42be2:	2b02      	cmp	r3, #2
   42be4:	d025      	beq.n	42c32 <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   42be6:	f005 fca6 	bl	48536 <k_is_in_isr>
   42bea:	4604      	mov	r4, r0
   42bec:	b918      	cbnz	r0, 42bf6 <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   42bee:	4b2b      	ldr	r3, [pc, #172]	; (42c9c <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   42bf0:	781b      	ldrb	r3, [r3, #0]
   42bf2:	2b00      	cmp	r3, #0
   42bf4:	d144      	bne.n	42c80 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   42bf6:	f04f 0320 	mov.w	r3, #32
   42bfa:	f3ef 8611 	mrs	r6, BASEPRI
   42bfe:	f383 8812 	msr	BASEPRI_MAX, r3
   42c02:	f3bf 8f6f 	isb	sy
   42c06:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42c08:	4d23      	ldr	r5, [pc, #140]	; (42c98 <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42c0a:	f8df 809c 	ldr.w	r8, [pc, #156]	; 42ca8 <z_nrf_clock_control_lf_on+0x100>
   42c0e:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42c10:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   42c14:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   42c18:	03d2      	lsls	r2, r2, #15
   42c1a:	d50c      	bpl.n	42c36 <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   42c1c:	f003 0303 	and.w	r3, r3, #3
   42c20:	2b02      	cmp	r3, #2
   42c22:	d001      	beq.n	42c28 <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   42c24:	2f01      	cmp	r7, #1
   42c26:	d106      	bne.n	42c36 <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   42c28:	b334      	cbz	r4, 42c78 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   42c2a:	f386 8811 	msr	BASEPRI, r6
   42c2e:	f3bf 8f6f 	isb	sy
}
   42c32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   42c36:	b1d4      	cbz	r4, 42c6e <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   42c38:	4630      	mov	r0, r6
   42c3a:	f7ff f8a5 	bl	41d88 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   42c3e:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   42c42:	b2db      	uxtb	r3, r3
   42c44:	2b01      	cmp	r3, #1
   42c46:	d1e3      	bne.n	42c10 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42c48:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   42c4c:	2a00      	cmp	r2, #0
   42c4e:	d0df      	beq.n	42c10 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   42c50:	2200      	movs	r2, #0
   42c52:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   42c56:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   42c5a:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42c5c:	2120      	movs	r1, #32
   42c5e:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   42c62:	4a0f      	ldr	r2, [pc, #60]	; (42ca0 <z_nrf_clock_control_lf_on+0xf8>)
   42c64:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42c68:	4a0e      	ldr	r2, [pc, #56]	; (42ca4 <z_nrf_clock_control_lf_on+0xfc>)
   42c6a:	6013      	str	r3, [r2, #0]
}
   42c6c:	e7d0      	b.n	42c10 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   42c6e:	2100      	movs	r1, #0
   42c70:	2001      	movs	r0, #1
   42c72:	f003 ff3f 	bl	46af4 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   42c76:	e7e2      	b.n	42c3e <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   42c78:	2302      	movs	r3, #2
   42c7a:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   42c7e:	e7d8      	b.n	42c32 <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   42c80:	2202      	movs	r2, #2
   42c82:	4b05      	ldr	r3, [pc, #20]	; (42c98 <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   42c84:	4606      	mov	r6, r0
   42c86:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   42c8a:	e7bd      	b.n	42c08 <z_nrf_clock_control_lf_on+0x60>
   42c8c:	2001a988 	.word	0x2001a988
   42c90:	2001a924 	.word	0x2001a924
   42c94:	2001a950 	.word	0x2001a950
   42c98:	40005000 	.word	0x40005000
   42c9c:	20020b22 	.word	0x20020b22
   42ca0:	e000e100 	.word	0xe000e100
   42ca4:	40005008 	.word	0x40005008
   42ca8:	40005104 	.word	0x40005104

00042cac <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   42cac:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   42cae:	4808      	ldr	r0, [pc, #32]	; (42cd0 <uart_console_init+0x24>)
   42cb0:	4b08      	ldr	r3, [pc, #32]	; (42cd4 <uart_console_init+0x28>)
   42cb2:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   42cb4:	f005 fb7b 	bl	483ae <z_device_ready>
   42cb8:	b138      	cbz	r0, 42cca <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   42cba:	4807      	ldr	r0, [pc, #28]	; (42cd8 <uart_console_init+0x2c>)
   42cbc:	f7ff fe4c 	bl	42958 <__stdout_hook_install>
	__printk_hook_install(console_out);
   42cc0:	4805      	ldr	r0, [pc, #20]	; (42cd8 <uart_console_init+0x2c>)
   42cc2:	f7fd fc85 	bl	405d0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   42cc6:	2000      	movs	r0, #0
}
   42cc8:	bd08      	pop	{r3, pc}
		return -ENODEV;
   42cca:	f06f 0012 	mvn.w	r0, #18
   42cce:	e7fb      	b.n	42cc8 <uart_console_init+0x1c>
   42cd0:	00048968 	.word	0x00048968
   42cd4:	2001a98c 	.word	0x2001a98c
   42cd8:	00042cdd 	.word	0x00042cdd

00042cdc <console_out>:
	if ('\n' == c) {
   42cdc:	280a      	cmp	r0, #10
{
   42cde:	b538      	push	{r3, r4, r5, lr}
   42ce0:	4604      	mov	r4, r0
   42ce2:	4d07      	ldr	r5, [pc, #28]	; (42d00 <console_out+0x24>)
	if ('\n' == c) {
   42ce4:	d104      	bne.n	42cf0 <console_out+0x14>
   42ce6:	6828      	ldr	r0, [r5, #0]
   42ce8:	6883      	ldr	r3, [r0, #8]
   42cea:	210d      	movs	r1, #13
   42cec:	685b      	ldr	r3, [r3, #4]
   42cee:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   42cf0:	6828      	ldr	r0, [r5, #0]
   42cf2:	6883      	ldr	r3, [r0, #8]
   42cf4:	b2e1      	uxtb	r1, r4
   42cf6:	685b      	ldr	r3, [r3, #4]
   42cf8:	4798      	blx	r3
}
   42cfa:	4620      	mov	r0, r4
   42cfc:	bd38      	pop	{r3, r4, r5, pc}
   42cfe:	bf00      	nop
   42d00:	2001a98c 	.word	0x2001a98c

00042d04 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   42d04:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42d06:	6840      	ldr	r0, [r0, #4]
   42d08:	f001 051f 	and.w	r5, r1, #31
   42d0c:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   42d0e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42d12:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   42d16:	b085      	sub	sp, #20
   42d18:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   42d1c:	d104      	bne.n	42d28 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   42d1e:	4628      	mov	r0, r5
   42d20:	f001 fa88 	bl	44234 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   42d24:	2000      	movs	r0, #0
   42d26:	e02c      	b.n	42d82 <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   42d28:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   42d2c:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   42d30:	d129      	bne.n	42d86 <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   42d32:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42d36:	bf0c      	ite	eq
   42d38:	2304      	moveq	r3, #4
   42d3a:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   42d3c:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   42d40:	6883      	ldr	r3, [r0, #8]
   42d42:	fa23 f101 	lsr.w	r1, r3, r1
   42d46:	07c9      	lsls	r1, r1, #31
   42d48:	d429      	bmi.n	42d9e <gpio_nrfx_pin_interrupt_configure+0x9a>
   42d4a:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   42d4e:	d126      	bne.n	42d9e <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42d50:	4a1b      	ldr	r2, [pc, #108]	; (42dc0 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   42d52:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42d56:	3380      	adds	r3, #128	; 0x80
   42d58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   42d5c:	07db      	lsls	r3, r3, #31
   42d5e:	d41e      	bmi.n	42d9e <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   42d60:	f10d 0407 	add.w	r4, sp, #7
   42d64:	4621      	mov	r1, r4
   42d66:	4628      	mov	r0, r5
   42d68:	f001 f9d4 	bl	44114 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   42d6c:	4b15      	ldr	r3, [pc, #84]	; (42dc4 <gpio_nrfx_pin_interrupt_configure+0xc0>)
   42d6e:	4298      	cmp	r0, r3
   42d70:	d114      	bne.n	42d9c <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   42d72:	4620      	mov	r0, r4
   42d74:	f001 fa18 	bl	441a8 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   42d78:	4b13      	ldr	r3, [pc, #76]	; (42dc8 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42d7a:	4298      	cmp	r0, r3
   42d7c:	d00e      	beq.n	42d9c <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   42d7e:	f06f 000b 	mvn.w	r0, #11
}
   42d82:	b005      	add	sp, #20
   42d84:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   42d86:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   42d8a:	d005      	beq.n	42d98 <gpio_nrfx_pin_interrupt_configure+0x94>
   42d8c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42d90:	bf0c      	ite	eq
   42d92:	2302      	moveq	r3, #2
   42d94:	2301      	movne	r3, #1
   42d96:	e7d1      	b.n	42d3c <gpio_nrfx_pin_interrupt_configure+0x38>
   42d98:	2303      	movs	r3, #3
   42d9a:	e7cf      	b.n	42d3c <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   42d9c:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42d9e:	2300      	movs	r3, #0
   42da0:	4628      	mov	r0, r5
   42da2:	4619      	mov	r1, r3
   42da4:	aa02      	add	r2, sp, #8
   42da6:	f001 f875 	bl	43e94 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   42daa:	4b07      	ldr	r3, [pc, #28]	; (42dc8 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42dac:	4298      	cmp	r0, r3
   42dae:	d104      	bne.n	42dba <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   42db0:	2101      	movs	r1, #1
   42db2:	4628      	mov	r0, r5
   42db4:	f001 f9fe 	bl	441b4 <nrfx_gpiote_trigger_enable>
   42db8:	e7b4      	b.n	42d24 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   42dba:	f06f 0004 	mvn.w	r0, #4
   42dbe:	e7e0      	b.n	42d82 <gpio_nrfx_pin_interrupt_configure+0x7e>
   42dc0:	40842500 	.word	0x40842500
   42dc4:	0bad0004 	.word	0x0bad0004
   42dc8:	0bad0000 	.word	0x0bad0000

00042dcc <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   42dcc:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   42dce:	f001 f9db 	bl	44188 <nrfx_gpiote_is_init>
   42dd2:	4604      	mov	r4, r0
   42dd4:	b968      	cbnz	r0, 42df2 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   42dd6:	f001 f9af 	bl	44138 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   42dda:	4b08      	ldr	r3, [pc, #32]	; (42dfc <gpio_nrfx_init+0x30>)
   42ddc:	4298      	cmp	r0, r3
   42dde:	d10a      	bne.n	42df6 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   42de0:	4621      	mov	r1, r4
   42de2:	4807      	ldr	r0, [pc, #28]	; (42e00 <gpio_nrfx_init+0x34>)
   42de4:	f001 f990 	bl	44108 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   42de8:	4622      	mov	r2, r4
   42dea:	2105      	movs	r1, #5
   42dec:	2031      	movs	r0, #49	; 0x31
   42dee:	f7ff f82b 	bl	41e48 <z_arm_irq_priority_set>
		return 0;
   42df2:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   42df4:	bd10      	pop	{r4, pc}
		return -EIO;
   42df6:	f06f 0004 	mvn.w	r0, #4
   42dfa:	e7fb      	b.n	42df4 <gpio_nrfx_init+0x28>
   42dfc:	0bad0000 	.word	0x0bad0000
   42e00:	00042e05 	.word	0x00042e05

00042e04 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42e04:	0943      	lsrs	r3, r0, #5
{
   42e06:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42e08:	d117      	bne.n	42e3a <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42e0a:	4b0c      	ldr	r3, [pc, #48]	; (42e3c <nrfx_gpio_handler+0x38>)
   42e0c:	6859      	ldr	r1, [r3, #4]
   42e0e:	b1a1      	cbz	r1, 42e3a <nrfx_gpio_handler+0x36>
   42e10:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   42e12:	2501      	movs	r5, #1
   42e14:	2c00      	cmp	r4, #0
   42e16:	bf38      	it	cc
   42e18:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   42e1a:	4e09      	ldr	r6, [pc, #36]	; (42e40 <nrfx_gpio_handler+0x3c>)
   42e1c:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   42e1e:	688a      	ldr	r2, [r1, #8]
   42e20:	402a      	ands	r2, r5
   42e22:	d002      	beq.n	42e2a <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   42e24:	4630      	mov	r0, r6
   42e26:	684b      	ldr	r3, [r1, #4]
   42e28:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42e2a:	b134      	cbz	r4, 42e3a <nrfx_gpio_handler+0x36>
	return node->next;
   42e2c:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   42e2e:	4621      	mov	r1, r4
   42e30:	2b00      	cmp	r3, #0
   42e32:	bf38      	it	cc
   42e34:	2300      	movcc	r3, #0
   42e36:	461c      	mov	r4, r3
   42e38:	e7f1      	b.n	42e1e <nrfx_gpio_handler+0x1a>
}
   42e3a:	bd70      	pop	{r4, r5, r6, pc}
   42e3c:	2001a990 	.word	0x2001a990
   42e40:	00048938 	.word	0x00048938

00042e44 <gpio_nrfx_pin_configure>:
{
   42e44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   42e48:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   42e4a:	f001 051f 	and.w	r5, r1, #31
   42e4e:	7b3b      	ldrb	r3, [r7, #12]
{
   42e50:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   42e52:	4614      	mov	r4, r2
{
   42e54:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   42e56:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   42e5a:	b9ca      	cbnz	r2, 42e90 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   42e5c:	a902      	add	r1, sp, #8
   42e5e:	4628      	mov	r0, r5
   42e60:	f001 f958 	bl	44114 <nrfx_gpiote_channel_get>
   42e64:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   42e66:	4628      	mov	r0, r5
   42e68:	f001 fa06 	bl	44278 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   42e6c:	4b47      	ldr	r3, [pc, #284]	; (42f8c <gpio_nrfx_pin_configure+0x148>)
   42e6e:	4298      	cmp	r0, r3
   42e70:	d004      	beq.n	42e7c <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   42e72:	f06f 0004 	mvn.w	r0, #4
}
   42e76:	b005      	add	sp, #20
   42e78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   42e7c:	4284      	cmp	r4, r0
   42e7e:	d105      	bne.n	42e8c <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   42e80:	f89d 0008 	ldrb.w	r0, [sp, #8]
   42e84:	f001 f98a 	bl	4419c <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   42e88:	42a0      	cmp	r0, r4
   42e8a:	d1f2      	bne.n	42e72 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   42e8c:	2000      	movs	r0, #0
   42e8e:	e7f2      	b.n	42e76 <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   42e90:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   42e94:	f10d 0103 	add.w	r1, sp, #3
   42e98:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   42e9a:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   42e9e:	f001 f939 	bl	44114 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42ea2:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   42ea4:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42ea6:	4649      	mov	r1, r9
   42ea8:	4628      	mov	r0, r5
   42eaa:	aa02      	add	r2, sp, #8
   42eac:	f000 fff2 	bl	43e94 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   42eb0:	4b36      	ldr	r3, [pc, #216]	; (42f8c <gpio_nrfx_pin_configure+0x148>)
   42eb2:	4298      	cmp	r0, r3
   42eb4:	d002      	beq.n	42ebc <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   42eb6:	f06f 0015 	mvn.w	r0, #21
   42eba:	e7dc      	b.n	42e76 <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   42ebc:	4580      	cmp	r8, r0
   42ebe:	d103      	bne.n	42ec8 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   42ec0:	f89d 0003 	ldrb.w	r0, [sp, #3]
   42ec4:	f001 f96a 	bl	4419c <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   42ec8:	05a3      	lsls	r3, r4, #22
   42eca:	d54c      	bpl.n	42f66 <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   42ecc:	4b30      	ldr	r3, [pc, #192]	; (42f90 <gpio_nrfx_pin_configure+0x14c>)
   42ece:	4a31      	ldr	r2, [pc, #196]	; (42f94 <gpio_nrfx_pin_configure+0x150>)
   42ed0:	4023      	ands	r3, r4
   42ed2:	4293      	cmp	r3, r2
   42ed4:	d039      	beq.n	42f4a <gpio_nrfx_pin_configure+0x106>
   42ed6:	d80c      	bhi.n	42ef2 <gpio_nrfx_pin_configure+0xae>
   42ed8:	2b06      	cmp	r3, #6
   42eda:	d014      	beq.n	42f06 <gpio_nrfx_pin_configure+0xc2>
   42edc:	d804      	bhi.n	42ee8 <gpio_nrfx_pin_configure+0xa4>
   42ede:	b193      	cbz	r3, 42f06 <gpio_nrfx_pin_configure+0xc2>
   42ee0:	2b02      	cmp	r3, #2
   42ee2:	d1e8      	bne.n	42eb6 <gpio_nrfx_pin_configure+0x72>
   42ee4:	2304      	movs	r3, #4
   42ee6:	e00e      	b.n	42f06 <gpio_nrfx_pin_configure+0xc2>
   42ee8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   42eec:	d1e3      	bne.n	42eb6 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   42eee:	2301      	movs	r3, #1
   42ef0:	e009      	b.n	42f06 <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   42ef2:	4a29      	ldr	r2, [pc, #164]	; (42f98 <gpio_nrfx_pin_configure+0x154>)
   42ef4:	4293      	cmp	r3, r2
   42ef6:	d02a      	beq.n	42f4e <gpio_nrfx_pin_configure+0x10a>
   42ef8:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   42efc:	d029      	beq.n	42f52 <gpio_nrfx_pin_configure+0x10e>
   42efe:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   42f02:	d1d8      	bne.n	42eb6 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   42f04:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   42f06:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   42f0a:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   42f0e:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   42f12:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   42f14:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   42f18:	bf4c      	ite	mi
   42f1a:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   42f1c:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   42f20:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   42f22:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   42f26:	d516      	bpl.n	42f56 <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   42f28:	2101      	movs	r1, #1
   42f2a:	687b      	ldr	r3, [r7, #4]
   42f2c:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   42f30:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   42f32:	2200      	movs	r2, #0
   42f34:	4628      	mov	r0, r5
   42f36:	a901      	add	r1, sp, #4
   42f38:	f001 f852 	bl	43fe0 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   42f3c:	4b13      	ldr	r3, [pc, #76]	; (42f8c <gpio_nrfx_pin_configure+0x148>)
   42f3e:	4298      	cmp	r0, r3
   42f40:	bf14      	ite	ne
   42f42:	f06f 0015 	mvnne.w	r0, #21
   42f46:	2000      	moveq	r0, #0
   42f48:	e795      	b.n	42e76 <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   42f4a:	2307      	movs	r3, #7
   42f4c:	e7db      	b.n	42f06 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   42f4e:	2305      	movs	r3, #5
   42f50:	e7d9      	b.n	42f06 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   42f52:	2303      	movs	r3, #3
   42f54:	e7d7      	b.n	42f06 <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   42f56:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   42f58:	bf41      	itttt	mi
   42f5a:	2101      	movmi	r1, #1
   42f5c:	687b      	ldrmi	r3, [r7, #4]
   42f5e:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   42f62:	60de      	strmi	r6, [r3, #12]
}
   42f64:	e7e5      	b.n	42f32 <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   42f66:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   42f68:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   42f6c:	bf4c      	ite	mi
   42f6e:	2403      	movmi	r4, #3
   42f70:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   42f74:	461a      	mov	r2, r3
   42f76:	4628      	mov	r0, r5
   42f78:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   42f7a:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   42f7e:	f000 ff89 	bl	43e94 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   42f82:	4b02      	ldr	r3, [pc, #8]	; (42f8c <gpio_nrfx_pin_configure+0x148>)
   42f84:	4298      	cmp	r0, r3
   42f86:	d081      	beq.n	42e8c <gpio_nrfx_pin_configure+0x48>
   42f88:	e795      	b.n	42eb6 <gpio_nrfx_pin_configure+0x72>
   42f8a:	bf00      	nop
   42f8c:	0bad0000 	.word	0x0bad0000
   42f90:	00f00006 	.word	0x00f00006
   42f94:	00100006 	.word	0x00100006
   42f98:	00400002 	.word	0x00400002

00042f9c <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   42f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   42f9e:	794b      	ldrb	r3, [r1, #5]
   42fa0:	2b01      	cmp	r3, #1
   42fa2:	d026      	beq.n	42ff2 <uarte_nrfx_configure+0x56>
   42fa4:	2b03      	cmp	r3, #3
   42fa6:	d121      	bne.n	42fec <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   42fa8:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   42faa:	798b      	ldrb	r3, [r1, #6]
   42fac:	2b03      	cmp	r3, #3
   42fae:	d11d      	bne.n	42fec <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   42fb0:	79cc      	ldrb	r4, [r1, #7]
   42fb2:	b10c      	cbz	r4, 42fb8 <uarte_nrfx_configure+0x1c>
   42fb4:	2c01      	cmp	r4, #1
   42fb6:	d119      	bne.n	42fec <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   42fb8:	790a      	ldrb	r2, [r1, #4]
   42fba:	b112      	cbz	r2, 42fc2 <uarte_nrfx_configure+0x26>
   42fbc:	2a02      	cmp	r2, #2
   42fbe:	d115      	bne.n	42fec <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   42fc0:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   42fc2:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   42fc4:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   42fc6:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   42fca:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   42fcc:	d065      	beq.n	4309a <uarte_nrfx_configure+0xfe>
   42fce:	d82d      	bhi.n	4302c <uarte_nrfx_configure+0x90>
   42fd0:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   42fd4:	d064      	beq.n	430a0 <uarte_nrfx_configure+0x104>
   42fd6:	d816      	bhi.n	43006 <uarte_nrfx_configure+0x6a>
   42fd8:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   42fdc:	d062      	beq.n	430a4 <uarte_nrfx_configure+0x108>
   42fde:	d80a      	bhi.n	42ff6 <uarte_nrfx_configure+0x5a>
   42fe0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   42fe4:	d061      	beq.n	430aa <uarte_nrfx_configure+0x10e>
   42fe6:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   42fea:	d061      	beq.n	430b0 <uarte_nrfx_configure+0x114>
   42fec:	f06f 0085 	mvn.w	r0, #133	; 0x85
   42ff0:	e052      	b.n	43098 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   42ff2:	2600      	movs	r6, #0
   42ff4:	e7d9      	b.n	42faa <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   42ff6:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   42ffa:	d05c      	beq.n	430b6 <uarte_nrfx_configure+0x11a>
   42ffc:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   43000:	d1f4      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   43002:	4b37      	ldr	r3, [pc, #220]	; (430e0 <uarte_nrfx_configure+0x144>)
   43004:	e03c      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43006:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   4300a:	d057      	beq.n	430bc <uarte_nrfx_configure+0x120>
   4300c:	d807      	bhi.n	4301e <uarte_nrfx_configure+0x82>
   4300e:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   43012:	d055      	beq.n	430c0 <uarte_nrfx_configure+0x124>
   43014:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   43018:	d1e8      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   4301a:	4b32      	ldr	r3, [pc, #200]	; (430e4 <uarte_nrfx_configure+0x148>)
   4301c:	e030      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4301e:	f647 2712 	movw	r7, #31250	; 0x7a12
   43022:	42bb      	cmp	r3, r7
   43024:	d1e2      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   43026:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   4302a:	e029      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4302c:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   43030:	d048      	beq.n	430c4 <uarte_nrfx_configure+0x128>
   43032:	d813      	bhi.n	4305c <uarte_nrfx_configure+0xc0>
   43034:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   43038:	d047      	beq.n	430ca <uarte_nrfx_configure+0x12e>
   4303a:	d809      	bhi.n	43050 <uarte_nrfx_configure+0xb4>
   4303c:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   43040:	42bb      	cmp	r3, r7
   43042:	d044      	beq.n	430ce <uarte_nrfx_configure+0x132>
   43044:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   43048:	d1d0      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   4304a:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   4304e:	e017      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43050:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   43054:	d1ca      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   43056:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   4305a:	e011      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4305c:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   43060:	d038      	beq.n	430d4 <uarte_nrfx_configure+0x138>
   43062:	d808      	bhi.n	43076 <uarte_nrfx_configure+0xda>
   43064:	4f20      	ldr	r7, [pc, #128]	; (430e8 <uarte_nrfx_configure+0x14c>)
   43066:	42bb      	cmp	r3, r7
   43068:	d037      	beq.n	430da <uarte_nrfx_configure+0x13e>
   4306a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   4306e:	d1bd      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   43070:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   43074:	e004      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43076:	4f1d      	ldr	r7, [pc, #116]	; (430ec <uarte_nrfx_configure+0x150>)
   43078:	42bb      	cmp	r3, r7
   4307a:	d1b7      	bne.n	42fec <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   4307c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   43080:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   43084:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   43086:	4334      	orrs	r4, r6
   43088:	4322      	orrs	r2, r4
   4308a:	3304      	adds	r3, #4
   4308c:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   4308e:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   43092:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   43096:	2000      	movs	r0, #0
}
   43098:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   4309a:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   4309e:	e7ef      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   430a0:	4b13      	ldr	r3, [pc, #76]	; (430f0 <uarte_nrfx_configure+0x154>)
   430a2:	e7ed      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   430a4:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   430a8:	e7ea      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   430aa:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   430ae:	e7e7      	b.n	43080 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   430b0:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   430b4:	e7e4      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   430b6:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   430ba:	e7e1      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   430bc:	4b0d      	ldr	r3, [pc, #52]	; (430f4 <uarte_nrfx_configure+0x158>)
   430be:	e7df      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   430c0:	4b0d      	ldr	r3, [pc, #52]	; (430f8 <uarte_nrfx_configure+0x15c>)
   430c2:	e7dd      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   430c4:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   430c8:	e7da      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   430ca:	4b0c      	ldr	r3, [pc, #48]	; (430fc <uarte_nrfx_configure+0x160>)
   430cc:	e7d8      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   430ce:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   430d2:	e7d5      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   430d4:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   430d8:	e7d2      	b.n	43080 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   430da:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   430de:	e7cf      	b.n	43080 <uarte_nrfx_configure+0xe4>
   430e0:	0013b000 	.word	0x0013b000
   430e4:	004ea000 	.word	0x004ea000
   430e8:	0003d090 	.word	0x0003d090
   430ec:	000f4240 	.word	0x000f4240
   430f0:	00275000 	.word	0x00275000
   430f4:	0075c000 	.word	0x0075c000
   430f8:	003af000 	.word	0x003af000
   430fc:	013a9000 	.word	0x013a9000

00043100 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   43100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   43102:	4605      	mov	r5, r0
   43104:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   43106:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   43108:	f005 fa15 	bl	48536 <k_is_in_isr>
   4310c:	b910      	cbnz	r0, 43114 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   4310e:	4b2c      	ldr	r3, [pc, #176]	; (431c0 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   43110:	781b      	ldrb	r3, [r3, #0]
   43112:	b983      	cbnz	r3, 43136 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43114:	f04f 0320 	mov.w	r3, #32
   43118:	f3ef 8411 	mrs	r4, BASEPRI
   4311c:	f383 8812 	msr	BASEPRI_MAX, r3
   43120:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   43124:	4628      	mov	r0, r5
   43126:	f004 ffda 	bl	480de <is_tx_ready>
   4312a:	bb28      	cbnz	r0, 43178 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   4312c:	f384 8811 	msr	BASEPRI, r4
   43130:	f3bf 8f6f 	isb	sy
}
   43134:	e7ee      	b.n	43114 <uarte_nrfx_poll_out+0x14>
{
   43136:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   43138:	4628      	mov	r0, r5
   4313a:	f004 ffd0 	bl	480de <is_tx_ready>
   4313e:	b970      	cbnz	r0, 4315e <uarte_nrfx_poll_out+0x5e>
   43140:	2001      	movs	r0, #1
   43142:	f005 f830 	bl	481a6 <nrfx_busy_wait>
   43146:	3c01      	subs	r4, #1
   43148:	d1f6      	bne.n	43138 <uarte_nrfx_poll_out+0x38>
   4314a:	2100      	movs	r1, #0
   4314c:	2001      	movs	r0, #1
   4314e:	f003 fcd1 	bl	46af4 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   43152:	e7f0      	b.n	43136 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43154:	f384 8811 	msr	BASEPRI, r4
   43158:	f3bf 8f6f 	isb	sy
}
   4315c:	e7f5      	b.n	4314a <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   4315e:	f04f 0320 	mov.w	r3, #32
   43162:	f3ef 8411 	mrs	r4, BASEPRI
   43166:	f383 8812 	msr	BASEPRI_MAX, r3
   4316a:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   4316e:	4628      	mov	r0, r5
   43170:	f004 ffb5 	bl	480de <is_tx_ready>
   43174:	2800      	cmp	r0, #0
   43176:	d0ed      	beq.n	43154 <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   43178:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   4317a:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   4317e:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   43180:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43182:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   43186:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4318a:	2200      	movs	r2, #0
   4318c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   43190:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   43194:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   43198:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   4319c:	684a      	ldr	r2, [r1, #4]
   4319e:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   431a0:	bf41      	itttt	mi
   431a2:	2208      	movmi	r2, #8
   431a4:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   431a8:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   431ac:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   431b0:	2201      	movs	r2, #1
   431b2:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   431b4:	f384 8811 	msr	BASEPRI, r4
   431b8:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   431bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   431be:	bf00      	nop
   431c0:	20020b22 	.word	0x20020b22

000431c4 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   431c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   431c8:	4606      	mov	r6, r0
   431ca:	2101      	movs	r1, #1
   431cc:	2200      	movs	r2, #0
   431ce:	2008      	movs	r0, #8
   431d0:	f7fe fe3a 	bl	41e48 <z_arm_irq_priority_set>
   431d4:	2008      	movs	r0, #8
   431d6:	f7fe fe19 	bl	41e0c <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   431da:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   431dc:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   431de:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   431e0:	683c      	ldr	r4, [r7, #0]
   431e2:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   431e6:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   431e8:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   431ea:	68d8      	ldr	r0, [r3, #12]
   431ec:	1c41      	adds	r1, r0, #1
   431ee:	d00b      	beq.n	43208 <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   431f0:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   431f2:	f8df c154 	ldr.w	ip, [pc, #340]	; 43348 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   431f6:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   431fa:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   431fc:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43200:	2103      	movs	r1, #3
   43202:	3280      	adds	r2, #128	; 0x80
   43204:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43208:	6919      	ldr	r1, [r3, #16]
   4320a:	1c4a      	adds	r2, r1, #1
   4320c:	d00d      	beq.n	4322a <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   4320e:	7f1a      	ldrb	r2, [r3, #28]
   43210:	f8df c134 	ldr.w	ip, [pc, #308]	; 43348 <uarte_0_init+0x184>
   43214:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43216:	bf14      	ite	ne
   43218:	f04f 0e0c 	movne.w	lr, #12
   4321c:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   43220:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   43224:	3280      	adds	r2, #128	; 0x80
   43226:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4322a:	f8d3 c014 	ldr.w	ip, [r3, #20]
   4322e:	f1bc 3fff 	cmp.w	ip, #4294967295
   43232:	d00e      	beq.n	43252 <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43234:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   43238:	f8df 810c 	ldr.w	r8, [pc, #268]	; 43348 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   4323c:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43240:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   43244:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43248:	f04f 0e03 	mov.w	lr, #3
   4324c:	3280      	adds	r2, #128	; 0x80
   4324e:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43252:	f8d3 e018 	ldr.w	lr, [r3, #24]
   43256:	f1be 3fff 	cmp.w	lr, #4294967295
   4325a:	d00d      	beq.n	43278 <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   4325c:	7f5a      	ldrb	r2, [r3, #29]
   4325e:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 43348 <uarte_0_init+0x184>
   43262:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43264:	bf14      	ite	ne
   43266:	f04f 090c 	movne.w	r9, #12
   4326a:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   4326e:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   43272:	3280      	adds	r2, #128	; 0x80
   43274:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   43278:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   4327a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   4327e:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   43282:	6931      	ldr	r1, [r6, #16]
   43284:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   43286:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   4328a:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   4328c:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   43290:	f7ff fe84 	bl	42f9c <uarte_nrfx_configure>
	if (err) {
   43294:	4606      	mov	r6, r0
   43296:	b9a8      	cbnz	r0, 432c4 <uarte_0_init+0x100>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   43298:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   4329a:	0799      	lsls	r1, r3, #30
   4329c:	d522      	bpl.n	432e4 <uarte_0_init+0x120>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   4329e:	f105 0012 	add.w	r0, r5, #18
   432a2:	f000 fd7d 	bl	43da0 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   432a6:	4b23      	ldr	r3, [pc, #140]	; (43334 <uarte_0_init+0x170>)
   432a8:	4298      	cmp	r0, r3
   432aa:	d00e      	beq.n	432ca <uarte_0_init+0x106>
   432ac:	4b22      	ldr	r3, [pc, #136]	; (43338 <uarte_0_init+0x174>)
   432ae:	4923      	ldr	r1, [pc, #140]	; (4333c <uarte_0_init+0x178>)
		LOG_ERR("Failed to allocate PPI Channel");
   432b0:	4823      	ldr	r0, [pc, #140]	; (43340 <uarte_0_init+0x17c>)
   432b2:	1ac9      	subs	r1, r1, r3
   432b4:	08c9      	lsrs	r1, r1, #3
   432b6:	0189      	lsls	r1, r1, #6
   432b8:	f041 0101 	orr.w	r1, r1, #1
   432bc:	f004 fad0 	bl	47860 <log_0>
		return -EIO;
   432c0:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   432c4:	4630      	mov	r0, r6
   432c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   432ca:	7cab      	ldrb	r3, [r5, #18]
   432cc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   432d0:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   432d4:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   432d8:	2301      	movs	r3, #1
   432da:	7caa      	ldrb	r2, [r5, #18]
   432dc:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   432de:	4a19      	ldr	r2, [pc, #100]	; (43344 <uarte_0_init+0x180>)
   432e0:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   432e4:	2308      	movs	r3, #8
   432e6:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   432ea:	7a3b      	ldrb	r3, [r7, #8]
   432ec:	b95b      	cbnz	r3, 43306 <uarte_0_init+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   432ee:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   432f2:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   432f6:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   432fa:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   432fe:	2301      	movs	r3, #1
   43300:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43304:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   43306:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   43308:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   4330a:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   4330c:	bf5c      	itt	pl
   4330e:	f44f 7280 	movpl.w	r2, #256	; 0x100
   43312:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   43316:	06db      	lsls	r3, r3, #27
   43318:	bf44      	itt	mi
   4331a:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   4331e:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   43322:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43324:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   43328:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4332c:	2301      	movs	r3, #1
   4332e:	60a3      	str	r3, [r4, #8]
   43330:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   43332:	e7c7      	b.n	432c4 <uarte_0_init+0x100>
   43334:	0bad0000 	.word	0x0bad0000
   43338:	00048b88 	.word	0x00048b88
   4333c:	00048bd0 	.word	0x00048bd0
   43340:	00049467 	.word	0x00049467
   43344:	40017000 	.word	0x40017000
   43348:	40842500 	.word	0x40842500

0004334c <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   4334c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4334e:	4e20      	ldr	r6, [pc, #128]	; (433d0 <sys_clock_timeout_handler+0x84>)
	return absolute_time & COUNTER_MAX;
   43350:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43354:	e9d6 ce00 	ldrd	ip, lr, [r6]
   43358:	ebb2 020c 	subs.w	r2, r2, ip

	last_count += dticks * CYC_PER_TICK;
   4335c:	f022 011f 	bic.w	r1, r2, #31
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43360:	eb63 030e 	sbc.w	r3, r3, lr
{
   43364:	4604      	mov	r4, r0
	last_count += dticks * CYC_PER_TICK;
   43366:	eb11 010c 	adds.w	r1, r1, ip
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4336a:	ea4f 1052 	mov.w	r0, r2, lsr #5
	last_count += dticks * CYC_PER_TICK;
   4336e:	eb43 070e 	adc.w	r7, r3, lr
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43372:	ea40 60c3 	orr.w	r0, r0, r3, lsl #27
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   43376:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   4337a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
	last_count += dticks * CYC_PER_TICK;
   4337e:	e9c6 1700 	strd	r1, r7, [r6]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   43382:	f04f 0600 	mov.w	r6, #0
	if (in_anchor_range(cc_value)) {
   43386:	d20a      	bcs.n	4339e <sys_clock_timeout_handler+0x52>
		return true;
   43388:	2601      	movs	r6, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   4338a:	4b12      	ldr	r3, [pc, #72]	; (433d4 <sys_clock_timeout_handler+0x88>)
   4338c:	6819      	ldr	r1, [r3, #0]
   4338e:	060a      	lsls	r2, r1, #24
   43390:	0a0b      	lsrs	r3, r1, #8
   43392:	1952      	adds	r2, r2, r5
   43394:	4910      	ldr	r1, [pc, #64]	; (433d8 <sys_clock_timeout_handler+0x8c>)
   43396:	f143 0300 	adc.w	r3, r3, #0
   4339a:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   4339e:	f003 fd07 	bl	46db0 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   433a2:	00a3      	lsls	r3, r4, #2
   433a4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   433a8:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   433ac:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   433b0:	42aa      	cmp	r2, r5
   433b2:	d10b      	bne.n	433cc <sys_clock_timeout_handler+0x80>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   433b4:	b91e      	cbnz	r6, 433be <sys_clock_timeout_handler+0x72>
    p_reg->CC[ch] = cc_val;
   433b6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   433ba:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   433be:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   433c2:	4b06      	ldr	r3, [pc, #24]	; (433dc <sys_clock_timeout_handler+0x90>)
   433c4:	fa00 f404 	lsl.w	r4, r0, r4
   433c8:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   433cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   433ce:	bf00      	nop
   433d0:	2001a748 	.word	0x2001a748
   433d4:	2001a9a4 	.word	0x2001a9a4
   433d8:	2001a730 	.word	0x2001a730
   433dc:	40015000 	.word	0x40015000

000433e0 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   433e0:	2301      	movs	r3, #1
   433e2:	4083      	lsls	r3, r0
{
   433e4:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   433e6:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   433e8:	4a0c      	ldr	r2, [pc, #48]	; (4341c <compare_int_lock+0x3c>)
   433ea:	e8d2 1fef 	ldaex	r1, [r2]
   433ee:	ea01 0c04 	and.w	ip, r1, r4
   433f2:	e8c2 cfee 	stlex	lr, ip, [r2]
   433f6:	f1be 0f00 	cmp.w	lr, #0
   433fa:	d1f6      	bne.n	433ea <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   433fc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   43400:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   43404:	4a06      	ldr	r2, [pc, #24]	; (43420 <compare_int_lock+0x40>)
   43406:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   4340a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   4340e:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   43412:	420b      	tst	r3, r1
}
   43414:	bf14      	ite	ne
   43416:	2001      	movne	r0, #1
   43418:	2000      	moveq	r0, #0
   4341a:	bd10      	pop	{r4, pc}
   4341c:	2001a9a0 	.word	0x2001a9a0
   43420:	40015000 	.word	0x40015000

00043424 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   43424:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43426:	4a0e      	ldr	r2, [pc, #56]	; (43460 <compare_int_unlock.part.0+0x3c>)
   43428:	4083      	lsls	r3, r0
   4342a:	e8d2 1fef 	ldaex	r1, [r2]
   4342e:	4319      	orrs	r1, r3
   43430:	e8c2 1fec 	stlex	ip, r1, [r2]
   43434:	f1bc 0f00 	cmp.w	ip, #0
   43438:	d1f7      	bne.n	4342a <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4343a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   4343e:	4a09      	ldr	r2, [pc, #36]	; (43464 <compare_int_unlock.part.0+0x40>)
   43440:	4083      	lsls	r3, r0
   43442:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   43446:	4b08      	ldr	r3, [pc, #32]	; (43468 <compare_int_unlock.part.0+0x44>)
   43448:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   4344c:	fa23 f000 	lsr.w	r0, r3, r0
   43450:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43452:	bf42      	ittt	mi
   43454:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   43458:	4b04      	ldrmi	r3, [pc, #16]	; (4346c <compare_int_unlock.part.0+0x48>)
   4345a:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   4345e:	4770      	bx	lr
   43460:	2001a9a0 	.word	0x2001a9a0
   43464:	40015000 	.word	0x40015000
   43468:	2001a99c 	.word	0x2001a99c
   4346c:	e000e100 	.word	0xe000e100

00043470 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   43470:	4b0d      	ldr	r3, [pc, #52]	; (434a8 <z_nrf_rtc_timer_read+0x38>)
   43472:	681b      	ldr	r3, [r3, #0]
   43474:	0a19      	lsrs	r1, r3, #8
   43476:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   43478:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   4347c:	4b0b      	ldr	r3, [pc, #44]	; (434ac <z_nrf_rtc_timer_read+0x3c>)
   4347e:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   43482:	18c0      	adds	r0, r0, r3
   43484:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   43488:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   4348c:	d20a      	bcs.n	434a4 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   4348e:	4b08      	ldr	r3, [pc, #32]	; (434b0 <z_nrf_rtc_timer_read+0x40>)
   43490:	e9d3 2300 	ldrd	r2, r3, [r3]
   43494:	4299      	cmp	r1, r3
   43496:	bf08      	it	eq
   43498:	4290      	cmpeq	r0, r2
   4349a:	d203      	bcs.n	434a4 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   4349c:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   434a0:	f141 0100 	adc.w	r1, r1, #0
}
   434a4:	4770      	bx	lr
   434a6:	bf00      	nop
   434a8:	2001a9a4 	.word	0x2001a9a4
   434ac:	40015000 	.word	0x40015000
   434b0:	2001a730 	.word	0x2001a730

000434b4 <compare_set>:
{
   434b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   434b8:	4616      	mov	r6, r2
   434ba:	461f      	mov	r7, r3
   434bc:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   434be:	f7ff ff8f 	bl	433e0 <compare_int_lock>
   434c2:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   434c4:	f7ff ffd4 	bl	43470 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   434c8:	42b9      	cmp	r1, r7
   434ca:	bf08      	it	eq
   434cc:	42b0      	cmpeq	r0, r6
   434ce:	d27b      	bcs.n	435c8 <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   434d0:	2300      	movs	r3, #0
   434d2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   434d6:	ebb6 0800 	subs.w	r8, r6, r0
   434da:	eb67 0901 	sbc.w	r9, r7, r1
   434de:	454b      	cmp	r3, r9
   434e0:	bf08      	it	eq
   434e2:	4542      	cmpeq	r2, r8
   434e4:	d37d      	bcc.n	435e2 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   434e6:	4b40      	ldr	r3, [pc, #256]	; (435e8 <compare_set+0x134>)
   434e8:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   434ec:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   434f0:	429f      	cmp	r7, r3
   434f2:	bf08      	it	eq
   434f4:	4296      	cmpeq	r6, r2
   434f6:	d051      	beq.n	4359c <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   434f8:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   434fc:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   43500:	4614      	mov	r4, r2
   43502:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   43506:	f105 0850 	add.w	r8, r5, #80	; 0x50
   4350a:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   4350e:	ea4f 0888 	mov.w	r8, r8, lsl #2
   43512:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43516:	fa1f f888 	uxth.w	r8, r8
   4351a:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   4351e:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   43522:	4b32      	ldr	r3, [pc, #200]	; (435ec <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43524:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43528:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   4352c:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   43530:	eba0 000a 	sub.w	r0, r0, sl
   43534:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43538:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   4353c:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   4353e:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   43542:	d105      	bne.n	43550 <compare_set+0x9c>
   43544:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   43546:	2013      	movs	r0, #19
   43548:	f005 f952 	bl	487f0 <z_impl_k_busy_wait>
   4354c:	4b27      	ldr	r3, [pc, #156]	; (435ec <compare_set+0x138>)
   4354e:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   43550:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   43554:	eba4 000c 	sub.w	r0, r4, ip
   43558:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   4355c:	2100      	movs	r1, #0
			cc_val = now + 2;
   4355e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43562:	bf88      	it	hi
   43564:	4664      	movhi	r4, ip
   43566:	f8c8 1000 	str.w	r1, [r8]
   4356a:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   4356e:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   43572:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   43576:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   4357a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   4357e:	4582      	cmp	sl, r0
   43580:	d006      	beq.n	43590 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   43582:	1a20      	subs	r0, r4, r0
   43584:	3802      	subs	r0, #2
   43586:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   4358a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   4358e:	d819      	bhi.n	435c4 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   43590:	1aa4      	subs	r4, r4, r2
   43592:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   43596:	1932      	adds	r2, r6, r4
   43598:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   4359c:	4c12      	ldr	r4, [pc, #72]	; (435e8 <compare_set+0x134>)
   4359e:	0129      	lsls	r1, r5, #4
   435a0:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   435a4:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   435a8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   435aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   435ac:	5062      	str	r2, [r4, r1]
	return ret;
   435ae:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   435b0:	6043      	str	r3, [r0, #4]
	if (key) {
   435b2:	9b00      	ldr	r3, [sp, #0]
   435b4:	b113      	cbz	r3, 435bc <compare_set+0x108>
   435b6:	4628      	mov	r0, r5
   435b8:	f7ff ff34 	bl	43424 <compare_int_unlock.part.0>
}
   435bc:	4620      	mov	r0, r4
   435be:	b003      	add	sp, #12
   435c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   435c4:	4620      	mov	r0, r4
   435c6:	e7b1      	b.n	4352c <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   435c8:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   435ca:	4a09      	ldr	r2, [pc, #36]	; (435f0 <compare_set+0x13c>)
   435cc:	40ab      	lsls	r3, r5
   435ce:	e8d2 1fef 	ldaex	r1, [r2]
   435d2:	4319      	orrs	r1, r3
   435d4:	e8c2 1fe0 	stlex	r0, r1, [r2]
   435d8:	2800      	cmp	r0, #0
   435da:	d1f8      	bne.n	435ce <compare_set+0x11a>
   435dc:	4632      	mov	r2, r6
   435de:	463b      	mov	r3, r7
   435e0:	e7dc      	b.n	4359c <compare_set+0xe8>
			return -EINVAL;
   435e2:	f06f 0415 	mvn.w	r4, #21
   435e6:	e7e4      	b.n	435b2 <compare_set+0xfe>
   435e8:	2001a738 	.word	0x2001a738
   435ec:	40015000 	.word	0x40015000
   435f0:	2001a99c 	.word	0x2001a99c

000435f4 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   435f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   435f6:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   435f8:	f04f 30ff 	mov.w	r0, #4294967295
   435fc:	f04f 31ff 	mov.w	r1, #4294967295
   43600:	4d16      	ldr	r5, [pc, #88]	; (4365c <sys_clock_driver_init+0x68>)
   43602:	4b17      	ldr	r3, [pc, #92]	; (43660 <sys_clock_driver_init+0x6c>)
   43604:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   43608:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   4360c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   43610:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43612:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   43616:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   4361a:	4b12      	ldr	r3, [pc, #72]	; (43664 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   4361c:	2101      	movs	r1, #1
   4361e:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   43622:	2015      	movs	r0, #21
   43624:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   43628:	4622      	mov	r2, r4
   4362a:	f7fe fc0d 	bl	41e48 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   4362e:	2015      	movs	r0, #21
   43630:	f7fe fbec 	bl	41e0c <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   43634:	2301      	movs	r3, #1
   43636:	4a0c      	ldr	r2, [pc, #48]	; (43668 <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43638:	4620      	mov	r0, r4
   4363a:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   4363c:	4a0b      	ldr	r2, [pc, #44]	; (4366c <sys_clock_driver_init+0x78>)
   4363e:	602b      	str	r3, [r5, #0]
   43640:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43642:	4b0b      	ldr	r3, [pc, #44]	; (43670 <sys_clock_driver_init+0x7c>)
   43644:	4a0b      	ldr	r2, [pc, #44]	; (43674 <sys_clock_driver_init+0x80>)
   43646:	9300      	str	r3, [sp, #0]
   43648:	9401      	str	r4, [sp, #4]
   4364a:	2300      	movs	r3, #0
   4364c:	f7ff ff32 	bl	434b4 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   43650:	4630      	mov	r0, r6
   43652:	f7ff faa9 	bl	42ba8 <z_nrf_clock_control_lf_on>

	return 0;
}
   43656:	4620      	mov	r0, r4
   43658:	b002      	add	sp, #8
   4365a:	bd70      	pop	{r4, r5, r6, pc}
   4365c:	40015000 	.word	0x40015000
   43660:	2001a738 	.word	0x2001a738
   43664:	e000e100 	.word	0xe000e100
   43668:	40015008 	.word	0x40015008
   4366c:	2001a9a0 	.word	0x2001a9a0
   43670:	0004334d 	.word	0x0004334d
   43674:	007fffff 	.word	0x007fffff

00043678 <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   43678:	4b33      	ldr	r3, [pc, #204]	; (43748 <rtc_nrf_isr+0xd0>)
{
   4367a:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   4367e:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   43682:	079a      	lsls	r2, r3, #30
   43684:	d509      	bpl.n	4369a <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   43686:	4b31      	ldr	r3, [pc, #196]	; (4374c <rtc_nrf_isr+0xd4>)
   43688:	681a      	ldr	r2, [r3, #0]
   4368a:	b132      	cbz	r2, 4369a <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   4368c:	2200      	movs	r2, #0
   4368e:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   43690:	4a2f      	ldr	r2, [pc, #188]	; (43750 <rtc_nrf_isr+0xd8>)
   43692:	681b      	ldr	r3, [r3, #0]
   43694:	6813      	ldr	r3, [r2, #0]
   43696:	3301      	adds	r3, #1
   43698:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   4369a:	f04f 0320 	mov.w	r3, #32
   4369e:	f3ef 8211 	mrs	r2, BASEPRI
   436a2:	f383 8812 	msr	BASEPRI_MAX, r3
   436a6:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   436aa:	4b27      	ldr	r3, [pc, #156]	; (43748 <rtc_nrf_isr+0xd0>)
   436ac:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   436b0:	03db      	lsls	r3, r3, #15
   436b2:	d50e      	bpl.n	436d2 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   436b4:	4b27      	ldr	r3, [pc, #156]	; (43754 <rtc_nrf_isr+0xdc>)
   436b6:	e8d3 1fef 	ldaex	r1, [r3]
   436ba:	f021 0001 	bic.w	r0, r1, #1
   436be:	e8c3 0fe4 	stlex	r4, r0, [r3]
   436c2:	2c00      	cmp	r4, #0
   436c4:	d1f7      	bne.n	436b6 <rtc_nrf_isr+0x3e>
   436c6:	4b24      	ldr	r3, [pc, #144]	; (43758 <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   436c8:	2900      	cmp	r1, #0
   436ca:	d136      	bne.n	4373a <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   436cc:	6819      	ldr	r1, [r3, #0]
		if (result) {
   436ce:	2900      	cmp	r1, #0
   436d0:	d133      	bne.n	4373a <rtc_nrf_isr+0xc2>
{
   436d2:	2300      	movs	r3, #0
	__asm__ volatile(
   436d4:	f382 8811 	msr	BASEPRI, r2
   436d8:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   436dc:	b353      	cbz	r3, 43734 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   436de:	f7ff fec7 	bl	43470 <z_nrf_rtc_timer_read>
   436e2:	4604      	mov	r4, r0
	__asm__ volatile(
   436e4:	f04f 0320 	mov.w	r3, #32
   436e8:	f3ef 8011 	mrs	r0, BASEPRI
   436ec:	f383 8812 	msr	BASEPRI_MAX, r3
   436f0:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   436f4:	4b19      	ldr	r3, [pc, #100]	; (4375c <rtc_nrf_isr+0xe4>)
   436f6:	2200      	movs	r2, #0
   436f8:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   436fc:	4549      	cmp	r1, r9
   436fe:	bf08      	it	eq
   43700:	4544      	cmpeq	r4, r8
   43702:	d31f      	bcc.n	43744 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   43704:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43708:	f04f 34ff 	mov.w	r4, #4294967295
   4370c:	f04f 35ff 	mov.w	r5, #4294967295
			cc_data[chan].callback = NULL;
   43710:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   43712:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43716:	e9c3 4502 	strd	r4, r5, [r3, #8]
   4371a:	4b0b      	ldr	r3, [pc, #44]	; (43748 <rtc_nrf_isr+0xd0>)
   4371c:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   43720:	f380 8811 	msr	BASEPRI, r0
   43724:	f3bf 8f6f 	isb	sy
		if (handler) {
   43728:	b121      	cbz	r1, 43734 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   4372a:	4642      	mov	r2, r8
   4372c:	464b      	mov	r3, r9
   4372e:	2000      	movs	r0, #0
   43730:	9600      	str	r6, [sp, #0]
   43732:	4788      	blx	r1
}
   43734:	b002      	add	sp, #8
   43736:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   4373a:	2100      	movs	r1, #0
   4373c:	6019      	str	r1, [r3, #0]
   4373e:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43740:	2301      	movs	r3, #1
}
   43742:	e7c7      	b.n	436d4 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   43744:	4611      	mov	r1, r2
   43746:	e7eb      	b.n	43720 <rtc_nrf_isr+0xa8>
   43748:	40015000 	.word	0x40015000
   4374c:	40015104 	.word	0x40015104
   43750:	2001a9a4 	.word	0x2001a9a4
   43754:	2001a99c 	.word	0x2001a99c
   43758:	40015140 	.word	0x40015140
   4375c:	2001a738 	.word	0x2001a738

00043760 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43760:	4b15      	ldr	r3, [pc, #84]	; (437b8 <sys_clock_set_timeout+0x58>)
{
   43762:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43764:	f1b0 3fff 	cmp.w	r0, #4294967295
   43768:	bf08      	it	eq
   4376a:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   4376c:	1e46      	subs	r6, r0, #1
   4376e:	2e00      	cmp	r6, #0
   43770:	dd20      	ble.n	437b4 <sys_clock_set_timeout+0x54>
   43772:	429e      	cmp	r6, r3
   43774:	bfa8      	it	ge
   43776:	461e      	movge	r6, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   43778:	f7ff fe7a 	bl	43470 <z_nrf_rtc_timer_read>
   4377c:	4b0f      	ldr	r3, [pc, #60]	; (437bc <sys_clock_set_timeout+0x5c>)
   4377e:	e9d3 4500 	ldrd	r4, r5, [r3]
   43782:	1b00      	subs	r0, r0, r4
		ticks = 0;
   43784:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43788:	bf28      	it	cs
   4378a:	2600      	movcs	r6, #0
	cyc += (CYC_PER_TICK - 1);
   4378c:	3020      	adds	r0, #32
   4378e:	eb00 1246 	add.w	r2, r0, r6, lsl #5
	uint64_t target_time = cyc + last_count;
   43792:	480b      	ldr	r0, [pc, #44]	; (437c0 <sys_clock_set_timeout+0x60>)
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
   43794:	f022 021f 	bic.w	r2, r2, #31
	uint64_t target_time = cyc + last_count;
   43798:	4282      	cmp	r2, r0
   4379a:	bf28      	it	cs
   4379c:	4602      	movcs	r2, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   4379e:	2000      	movs	r0, #0
   437a0:	4b08      	ldr	r3, [pc, #32]	; (437c4 <sys_clock_set_timeout+0x64>)
   437a2:	18a2      	adds	r2, r4, r2
   437a4:	9300      	str	r3, [sp, #0]
   437a6:	9001      	str	r0, [sp, #4]
   437a8:	f145 0300 	adc.w	r3, r5, #0
   437ac:	f7ff fe82 	bl	434b4 <compare_set>
}
   437b0:	b002      	add	sp, #8
   437b2:	bd70      	pop	{r4, r5, r6, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   437b4:	2600      	movs	r6, #0
   437b6:	e7df      	b.n	43778 <sys_clock_set_timeout+0x18>
   437b8:	0003ffff 	.word	0x0003ffff
   437bc:	2001a748 	.word	0x2001a748
   437c0:	007fffe0 	.word	0x007fffe0
   437c4:	0004334d 	.word	0x0004334d

000437c8 <sys_clock_elapsed>:
{
   437c8:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   437ca:	f7ff fe51 	bl	43470 <z_nrf_rtc_timer_read>
   437ce:	4a05      	ldr	r2, [pc, #20]	; (437e4 <sys_clock_elapsed+0x1c>)
   437d0:	e9d2 3200 	ldrd	r3, r2, [r2]
   437d4:	1ac0      	subs	r0, r0, r3
   437d6:	eb61 0102 	sbc.w	r1, r1, r2
   437da:	0940      	lsrs	r0, r0, #5
}
   437dc:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
   437e0:	bd08      	pop	{r3, pc}
   437e2:	bf00      	nop
   437e4:	2001a748 	.word	0x2001a748

000437e8 <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   437e8:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   437ea:	4d19      	ldr	r5, [pc, #100]	; (43850 <_nrf_modem_lib_init+0x68>)
   437ec:	4c19      	ldr	r4, [pc, #100]	; (43854 <_nrf_modem_lib_init+0x6c>)
   437ee:	782b      	ldrb	r3, [r5, #0]
   437f0:	b933      	cbnz	r3, 43800 <_nrf_modem_lib_init+0x18>
	list->tail = NULL;
   437f2:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   437f6:	4818      	ldr	r0, [pc, #96]	; (43858 <_nrf_modem_lib_init+0x70>)
   437f8:	f004 feaf 	bl	4855a <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   437fc:	2301      	movs	r3, #1
   437fe:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   43800:	2200      	movs	r2, #0
   43802:	202a      	movs	r0, #42	; 0x2a
   43804:	4611      	mov	r1, r2
   43806:	f7fe fb1f 	bl	41e48 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   4380a:	2100      	movs	r1, #0
   4380c:	4813      	ldr	r0, [pc, #76]	; (4385c <_nrf_modem_lib_init+0x74>)
   4380e:	f002 f965 	bl	45adc <nrf_modem_init>
   43812:	4b13      	ldr	r3, [pc, #76]	; (43860 <_nrf_modem_lib_init+0x78>)
   43814:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   43816:	f04f 32ff 	mov.w	r2, #4294967295
   4381a:	f04f 33ff 	mov.w	r3, #4294967295
   4381e:	480e      	ldr	r0, [pc, #56]	; (43858 <_nrf_modem_lib_init+0x70>)
   43820:	f002 fd7e 	bl	46320 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   43824:	6820      	ldr	r0, [r4, #0]
   43826:	b170      	cbz	r0, 43846 <_nrf_modem_lib_init+0x5e>
	return node->next;
   43828:	6804      	ldr	r4, [r0, #0]
   4382a:	2c00      	cmp	r4, #0
   4382c:	bf38      	it	cc
   4382e:	2400      	movcc	r4, #0
	z_impl_k_sem_give(sem);
   43830:	3004      	adds	r0, #4
   43832:	f002 fe39 	bl	464a8 <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   43836:	b134      	cbz	r4, 43846 <_nrf_modem_lib_init+0x5e>
   43838:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   4383a:	4620      	mov	r0, r4
   4383c:	2b00      	cmp	r3, #0
   4383e:	bf38      	it	cc
   43840:	2300      	movcc	r3, #0
   43842:	461c      	mov	r4, r3
   43844:	e7f4      	b.n	43830 <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   43846:	4804      	ldr	r0, [pc, #16]	; (43858 <_nrf_modem_lib_init+0x70>)
   43848:	f002 fde8 	bl	4641c <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   4384c:	2000      	movs	r0, #0
   4384e:	bd38      	pop	{r3, r4, r5, pc}
   43850:	2001ade1 	.word	0x2001ade1
   43854:	2001a9ac 	.word	0x2001a9ac
   43858:	2001a9b4 	.word	0x2001a9b4
   4385c:	00048d9c 	.word	0x00048d9c
   43860:	2001a9a8 	.word	0x2001a9a8

00043864 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   43864:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   43866:	4c0d      	ldr	r4, [pc, #52]	; (4389c <thread_monitor_entry_get+0x38>)
{
   43868:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   4386a:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   4386c:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   4386e:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   43870:	4b0b      	ldr	r3, [pc, #44]	; (438a0 <thread_monitor_entry_get+0x3c>)
   43872:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   43874:	6801      	ldr	r1, [r0, #0]
   43876:	4291      	cmp	r1, r2
   43878:	d00e      	beq.n	43898 <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   4387a:	b151      	cbz	r1, 43892 <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   4387c:	6841      	ldr	r1, [r0, #4]
   4387e:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   43880:	42b1      	cmp	r1, r6
   43882:	bfc4      	itt	gt
   43884:	4604      	movgt	r4, r0
   43886:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   43888:	3d01      	subs	r5, #1
   4388a:	f100 0008 	add.w	r0, r0, #8
   4388e:	d1f1      	bne.n	43874 <thread_monitor_entry_get+0x10>
   43890:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   43892:	3b01      	subs	r3, #1
	new_entry->id = id;
   43894:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   43896:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   43898:	bd70      	pop	{r4, r5, r6, pc}
   4389a:	bf00      	nop
   4389c:	2001aa20 	.word	0x2001aa20
   438a0:	2001a9fc 	.word	0x2001a9fc

000438a4 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   438a4:	4668      	mov	r0, sp
   438a6:	f020 0107 	bic.w	r1, r0, #7
   438aa:	468d      	mov	sp, r1
   438ac:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   438ae:	4b0f      	ldr	r3, [pc, #60]	; (438ec <rpc_proxy_irq_handler+0x48>)
   438b0:	e8d3 2fef 	ldaex	r2, [r3]
   438b4:	3201      	adds	r2, #1
   438b6:	e8c3 2fe1 	stlex	r1, r2, [r3]
   438ba:	2900      	cmp	r1, #0
   438bc:	d1f8      	bne.n	438b0 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   438be:	f001 f951 	bl	44b64 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   438c2:	4b0b      	ldr	r3, [pc, #44]	; (438f0 <rpc_proxy_irq_handler+0x4c>)
   438c4:	681c      	ldr	r4, [r3, #0]
   438c6:	2c00      	cmp	r4, #0
   438c8:	bf38      	it	cc
   438ca:	2400      	movcc	r4, #0
   438cc:	b12c      	cbz	r4, 438da <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   438ce:	1d20      	adds	r0, r4, #4
   438d0:	f002 fdea 	bl	464a8 <z_impl_k_sem_give>
   438d4:	6824      	ldr	r4, [r4, #0]
   438d6:	2c00      	cmp	r4, #0
   438d8:	d1f8      	bne.n	438cc <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   438da:	f7fe facb 	bl	41e74 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   438de:	f7fe fba3 	bl	42028 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   438e2:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   438e6:	4685      	mov	sp, r0
   438e8:	4770      	bx	lr
   438ea:	bf00      	nop
   438ec:	2001a9fc 	.word	0x2001a9fc
   438f0:	2001aa18 	.word	0x2001aa18

000438f4 <nrf_modem_os_timedwait>:
{
   438f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   438f8:	4688      	mov	r8, r1
   438fa:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   438fc:	f004 ff76 	bl	487ec <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   43900:	f8d8 3000 	ldr.w	r3, [r8]
   43904:	4604      	mov	r4, r0
   43906:	2b00      	cmp	r3, #0
   43908:	460d      	mov	r5, r1
   4390a:	d103      	bne.n	43914 <nrf_modem_os_timedwait+0x20>
	z_impl_k_yield();
   4390c:	f003 f864 	bl	469d8 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   43910:	2074      	movs	r0, #116	; 0x74
   43912:	e077      	b.n	43a04 <nrf_modem_os_timedwait+0x110>
		*timeout = SYS_FOREVER_MS;
   43914:	bfbc      	itt	lt
   43916:	f04f 33ff 	movlt.w	r3, #4294967295
   4391a:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   4391e:	2201      	movs	r2, #1
   43920:	2100      	movs	r1, #0
   43922:	a802      	add	r0, sp, #8
   43924:	f004 fe20 	bl	48568 <z_impl_k_sem_init>
   43928:	f10d 0904 	add.w	r9, sp, #4
	__asm__ volatile(
   4392c:	f04f 0320 	mov.w	r3, #32
   43930:	f3ef 8b11 	mrs	fp, BASEPRI
   43934:	f383 8812 	msr	BASEPRI_MAX, r3
   43938:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   4393c:	f003 f8ee 	bl	46b1c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43940:	f7ff ff90 	bl	43864 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   43944:	4938      	ldr	r1, [pc, #224]	; (43a28 <nrf_modem_os_timedwait+0x134>)
   43946:	6843      	ldr	r3, [r0, #4]
   43948:	680a      	ldr	r2, [r1, #0]
   4394a:	468a      	mov	sl, r1
   4394c:	4293      	cmp	r3, r2
   4394e:	f04f 0300 	mov.w	r3, #0
   43952:	d108      	bne.n	43966 <nrf_modem_os_timedwait+0x72>
	parent->next = child;
   43954:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   43956:	4b35      	ldr	r3, [pc, #212]	; (43a2c <nrf_modem_os_timedwait+0x138>)
   43958:	685a      	ldr	r2, [r3, #4]
   4395a:	2a00      	cmp	r2, #0
   4395c:	d155      	bne.n	43a0a <nrf_modem_os_timedwait+0x116>
	list->head = node;
   4395e:	e9c3 9900 	strd	r9, r9, [r3]
		allow_to_sleep = true;
   43962:	2301      	movs	r3, #1
}
   43964:	e000      	b.n	43968 <nrf_modem_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   43966:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   43968:	f38b 8811 	msr	BASEPRI, fp
   4396c:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   43970:	2b00      	cmp	r3, #0
   43972:	d046      	beq.n	43a02 <nrf_modem_os_timedwait+0x10e>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   43974:	f8d8 2000 	ldr.w	r2, [r8]
   43978:	1c53      	adds	r3, r2, #1
   4397a:	bf19      	ittee	ne
   4397c:	ea22 72e2 	bicne.w	r2, r2, r2, asr #31
   43980:	17d3      	asrne	r3, r2, #31
   43982:	f04f 32ff 	moveq.w	r2, #4294967295
   43986:	f04f 33ff 	moveq.w	r3, #4294967295
	return z_impl_k_sem_take(sem, timeout);
   4398a:	a802      	add	r0, sp, #8
   4398c:	f002 fdac 	bl	464e8 <z_impl_k_sem_take>
	__asm__ volatile(
   43990:	f04f 0320 	mov.w	r3, #32
   43994:	f3ef 8b11 	mrs	fp, BASEPRI
   43998:	f383 8812 	msr	BASEPRI_MAX, r3
   4399c:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   439a0:	2000      	movs	r0, #0
   439a2:	4b22      	ldr	r3, [pc, #136]	; (43a2c <nrf_modem_os_timedwait+0x138>)
   439a4:	681a      	ldr	r2, [r3, #0]
   439a6:	b152      	cbz	r2, 439be <nrf_modem_os_timedwait+0xca>
   439a8:	454a      	cmp	r2, r9
   439aa:	d139      	bne.n	43a20 <nrf_modem_os_timedwait+0x12c>
Z_GENLIST_REMOVE(slist, snode)
   439ac:	9901      	ldr	r1, [sp, #4]
   439ae:	bb88      	cbnz	r0, 43a14 <nrf_modem_os_timedwait+0x120>
   439b0:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   439b2:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   439b4:	4290      	cmp	r0, r2
   439b6:	d100      	bne.n	439ba <nrf_modem_os_timedwait+0xc6>
	list->tail = node;
   439b8:	6059      	str	r1, [r3, #4]
	parent->next = child;
   439ba:	2300      	movs	r3, #0
   439bc:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   439be:	f003 f8ad 	bl	46b1c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   439c2:	f7ff ff4f 	bl	43864 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   439c6:	f8da 3000 	ldr.w	r3, [sl]
   439ca:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   439cc:	f38b 8811 	msr	BASEPRI, fp
   439d0:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   439d4:	f8d8 9000 	ldr.w	r9, [r8]
   439d8:	f1b9 3fff 	cmp.w	r9, #4294967295
   439dc:	d011      	beq.n	43a02 <nrf_modem_os_timedwait+0x10e>
	return z_impl_k_uptime_ticks();
   439de:	f004 ff05 	bl	487ec <z_impl_k_uptime_ticks>
	remaining = *timeout - k_uptime_delta(&start);
   439e2:	eb14 0409 	adds.w	r4, r4, r9
   439e6:	eb45 75e9 	adc.w	r5, r5, r9, asr #31
   439ea:	1a26      	subs	r6, r4, r0
   439ec:	eb65 0701 	sbc.w	r7, r5, r1
	*timeout = remaining > 0 ? remaining : 0;
   439f0:	2e00      	cmp	r6, #0
   439f2:	f177 0300 	sbcs.w	r3, r7, #0
   439f6:	bfb8      	it	lt
   439f8:	2600      	movlt	r6, #0
   439fa:	f8c8 6000 	str.w	r6, [r8]
	if (*timeout == 0) {
   439fe:	2e00      	cmp	r6, #0
   43a00:	d086      	beq.n	43910 <nrf_modem_os_timedwait+0x1c>
	return 0;
   43a02:	2000      	movs	r0, #0
}
   43a04:	b007      	add	sp, #28
   43a06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43a0a:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   43a0e:	f8c3 9004 	str.w	r9, [r3, #4]
   43a12:	e7a6      	b.n	43962 <nrf_modem_os_timedwait+0x6e>
	parent->next = child;
   43a14:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   43a16:	6859      	ldr	r1, [r3, #4]
   43a18:	4291      	cmp	r1, r2
	list->tail = node;
   43a1a:	bf08      	it	eq
   43a1c:	6058      	streq	r0, [r3, #4]
}
   43a1e:	e7cc      	b.n	439ba <nrf_modem_os_timedwait+0xc6>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43a20:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43a22:	6812      	ldr	r2, [r2, #0]
   43a24:	e7bf      	b.n	439a6 <nrf_modem_os_timedwait+0xb2>
   43a26:	bf00      	nop
   43a28:	2001a9fc 	.word	0x2001a9fc
   43a2c:	2001aa18 	.word	0x2001aa18

00043a30 <nrf_modem_os_sem_init>:
{
   43a30:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   43a32:	6804      	ldr	r4, [r0, #0]
   43a34:	4b09      	ldr	r3, [pc, #36]	; (43a5c <nrf_modem_os_sem_init+0x2c>)
   43a36:	b12c      	cbz	r4, 43a44 <nrf_modem_os_sem_init+0x14>
   43a38:	429c      	cmp	r4, r3
   43a3a:	d303      	bcc.n	43a44 <nrf_modem_os_sem_init+0x14>
   43a3c:	f103 0530 	add.w	r5, r3, #48	; 0x30
   43a40:	42ac      	cmp	r4, r5
   43a42:	d306      	bcc.n	43a52 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   43a44:	4d06      	ldr	r5, [pc, #24]	; (43a60 <nrf_modem_os_sem_init+0x30>)
   43a46:	782c      	ldrb	r4, [r5, #0]
   43a48:	1c66      	adds	r6, r4, #1
   43a4a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   43a4e:	702e      	strb	r6, [r5, #0]
   43a50:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   43a52:	6800      	ldr	r0, [r0, #0]
}
   43a54:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   43a56:	f004 bd87 	b.w	48568 <z_impl_k_sem_init>
   43a5a:	bf00      	nop
   43a5c:	2001a9cc 	.word	0x2001a9cc
   43a60:	2001ade2 	.word	0x2001ade2

00043a64 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43a64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43a68:	4b01      	ldr	r3, [pc, #4]	; (43a70 <nrf_modem_os_application_irq_set+0xc>)
   43a6a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43a6e:	4770      	bx	lr
   43a70:	e000e100 	.word	0xe000e100

00043a74 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43a74:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43a78:	4b01      	ldr	r3, [pc, #4]	; (43a80 <nrf_modem_os_application_irq_clear+0xc>)
   43a7a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43a7e:	4770      	bx	lr
   43a80:	e000e100 	.word	0xe000e100

00043a84 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43a84:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43a88:	4b01      	ldr	r3, [pc, #4]	; (43a90 <nrf_modem_os_trace_irq_set+0xc>)
   43a8a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43a8e:	4770      	bx	lr
   43a90:	e000e100 	.word	0xe000e100

00043a94 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43a94:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43a98:	4b01      	ldr	r3, [pc, #4]	; (43aa0 <nrf_modem_os_trace_irq_clear+0xc>)
   43a9a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43a9e:	4770      	bx	lr
   43aa0:	e000e100 	.word	0xe000e100

00043aa4 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   43aa4:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   43aa6:	2200      	movs	r2, #0
   43aa8:	2300      	movs	r3, #0
   43aaa:	4801      	ldr	r0, [pc, #4]	; (43ab0 <nrf_modem_os_alloc+0xc>)
   43aac:	f004 bcd8 	b.w	48460 <k_heap_alloc>
   43ab0:	2001a62c 	.word	0x2001a62c

00043ab4 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   43ab4:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   43ab6:	4801      	ldr	r0, [pc, #4]	; (43abc <nrf_modem_os_free+0x8>)
   43ab8:	f004 bcdc 	b.w	48474 <k_heap_free>
   43abc:	2001a62c 	.word	0x2001a62c

00043ac0 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   43ac0:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   43ac2:	2200      	movs	r2, #0
   43ac4:	2300      	movs	r3, #0
   43ac6:	4801      	ldr	r0, [pc, #4]	; (43acc <nrf_modem_os_shm_tx_alloc+0xc>)
   43ac8:	f004 bcca 	b.w	48460 <k_heap_alloc>
   43acc:	2001aa04 	.word	0x2001aa04

00043ad0 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   43ad0:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   43ad2:	4801      	ldr	r0, [pc, #4]	; (43ad8 <nrf_modem_os_shm_tx_free+0x8>)
   43ad4:	f004 bcce 	b.w	48474 <k_heap_free>
   43ad8:	2001aa04 	.word	0x2001aa04

00043adc <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   43adc:	b510      	push	{r4, lr}
	list->head = NULL;
   43ade:	2400      	movs	r4, #0
   43ae0:	4b0e      	ldr	r3, [pc, #56]	; (43b1c <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   43ae2:	e9c3 4400 	strd	r4, r4, [r3]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43ae6:	4b0e      	ldr	r3, [pc, #56]	; (43b20 <nrf_modem_os_init+0x44>)
   43ae8:	e8d3 2fef 	ldaex	r2, [r3]
   43aec:	e8c3 4fe1 	stlex	r1, r4, [r3]
   43af0:	2900      	cmp	r1, #0
   43af2:	d1f9      	bne.n	43ae8 <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   43af4:	f004 fb45 	bl	48182 <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   43af8:	4621      	mov	r1, r4
   43afa:	2204      	movs	r2, #4
   43afc:	4809      	ldr	r0, [pc, #36]	; (43b24 <nrf_modem_os_init+0x48>)
   43afe:	f004 f9b9 	bl	47e74 <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   43b02:	4621      	mov	r1, r4
   43b04:	2204      	movs	r2, #4
   43b06:	4808      	ldr	r0, [pc, #32]	; (43b28 <nrf_modem_os_init+0x4c>)
   43b08:	f004 f9b4 	bl	47e74 <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   43b0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   43b10:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   43b14:	4905      	ldr	r1, [pc, #20]	; (43b2c <nrf_modem_os_init+0x50>)
   43b16:	4806      	ldr	r0, [pc, #24]	; (43b30 <nrf_modem_os_init+0x54>)
   43b18:	f004 bc53 	b.w	483c2 <k_heap_init>
   43b1c:	2001aa18 	.word	0x2001aa18
   43b20:	2001a9fc 	.word	0x2001a9fc
   43b24:	2001a9c8 	.word	0x2001a9c8
   43b28:	2001aa00 	.word	0x2001aa00
   43b2c:	200164e8 	.word	0x200164e8
   43b30:	2001aa04 	.word	0x2001aa04

00043b34 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   43b34:	b508      	push	{r3, lr}
	z_impl_log_panic();
   43b36:	f7fd fc79 	bl	4142c <z_impl_log_panic>
   43b3a:	4b06      	ldr	r3, [pc, #24]	; (43b54 <k_sys_fatal_error_handler+0x20>)
   43b3c:	4906      	ldr	r1, [pc, #24]	; (43b58 <k_sys_fatal_error_handler+0x24>)
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   43b3e:	4807      	ldr	r0, [pc, #28]	; (43b5c <k_sys_fatal_error_handler+0x28>)
   43b40:	1ac9      	subs	r1, r1, r3
   43b42:	08c9      	lsrs	r1, r1, #3
   43b44:	0189      	lsls	r1, r1, #6
   43b46:	f041 0101 	orr.w	r1, r1, #1
   43b4a:	f003 fe89 	bl	47860 <log_0>
		sys_arch_reboot(0);
   43b4e:	2000      	movs	r0, #0
   43b50:	f004 fb26 	bl	481a0 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   43b54:	00048b88 	.word	0x00048b88
   43b58:	00048b90 	.word	0x00048b90
   43b5c:	000494b9 	.word	0x000494b9

00043b60 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   43b60:	b5f0      	push	{r4, r5, r6, r7, lr}
   43b62:	4604      	mov	r4, r0
   43b64:	b0a3      	sub	sp, #140	; 0x8c
   43b66:	460d      	mov	r5, r1
   43b68:	4616      	mov	r6, r2
   43b6a:	461f      	mov	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   43b6c:	f04f 32ff 	mov.w	r2, #4294967295
   43b70:	f04f 33ff 	mov.w	r3, #4294967295
   43b74:	480b      	ldr	r0, [pc, #44]	; (43ba4 <tfm_ns_interface_dispatch+0x44>)
   43b76:	f002 fbd3 	bl	46320 <z_impl_k_mutex_lock>
	int32_t result;

	/* TF-M request protected by NS lock */
	if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   43b7a:	b988      	cbnz	r0, 43ba0 <tfm_ns_interface_dispatch+0x40>
#endif

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   43b7c:	4668      	mov	r0, sp
   43b7e:	f004 f906 	bl	47d8e <z_arm_save_fp_context>
#endif

	result = fn(arg0, arg1, arg2, arg3);
   43b82:	463a      	mov	r2, r7
   43b84:	4631      	mov	r1, r6
   43b86:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   43b88:	4628      	mov	r0, r5
   43b8a:	47a0      	blx	r4
   43b8c:	4604      	mov	r4, r0

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	z_arm_restore_fp_context(&context_buffer);
   43b8e:	4668      	mov	r0, sp
   43b90:	f004 f8fe 	bl	47d90 <z_arm_restore_fp_context>
	return z_impl_k_mutex_unlock(mutex);
   43b94:	4803      	ldr	r0, [pc, #12]	; (43ba4 <tfm_ns_interface_dispatch+0x44>)
   43b96:	f002 fc41 	bl	4641c <z_impl_k_mutex_unlock>
#endif

	k_mutex_unlock(&tfm_mutex);

	return result;
}
   43b9a:	4620      	mov	r0, r4
   43b9c:	b023      	add	sp, #140	; 0x8c
   43b9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (int32_t)TFM_ERROR_GENERIC;
   43ba0:	241f      	movs	r4, #31
   43ba2:	e7fa      	b.n	43b9a <tfm_ns_interface_dispatch+0x3a>
   43ba4:	2001a654 	.word	0x2001a654

00043ba8 <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   43ba8:	4b01      	ldr	r3, [pc, #4]	; (43bb0 <SystemInit+0x8>)
   43baa:	4a02      	ldr	r2, [pc, #8]	; (43bb4 <SystemInit+0xc>)
   43bac:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   43bae:	4770      	bx	lr
   43bb0:	2001a58c 	.word	0x2001a58c
   43bb4:	03d09000 	.word	0x03d09000

00043bb8 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   43bb8:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   43bba:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   43bbc:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   43bbe:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   43bc2:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   43bc4:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   43bc8:	d010      	beq.n	43bec <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   43bca:	fa05 f204 	lsl.w	r2, r5, r4
   43bce:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   43bd2:	e8d0 6fef 	ldaex	r6, [r0]
   43bd6:	429e      	cmp	r6, r3
   43bd8:	d104      	bne.n	43be4 <nrfx_flag32_alloc+0x2c>
   43bda:	e8c0 2fec 	stlex	ip, r2, [r0]
   43bde:	f1bc 0f00 	cmp.w	ip, #0
   43be2:	d1f6      	bne.n	43bd2 <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43be4:	d1ea      	bne.n	43bbc <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   43be6:	4802      	ldr	r0, [pc, #8]	; (43bf0 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   43be8:	700c      	strb	r4, [r1, #0]
}
   43bea:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   43bec:	4801      	ldr	r0, [pc, #4]	; (43bf4 <nrfx_flag32_alloc+0x3c>)
   43bee:	e7fc      	b.n	43bea <nrfx_flag32_alloc+0x32>
   43bf0:	0bad0000 	.word	0x0bad0000
   43bf4:	0bad0002 	.word	0x0bad0002

00043bf8 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   43bf8:	6803      	ldr	r3, [r0, #0]
{
   43bfa:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   43bfc:	40cb      	lsrs	r3, r1
   43bfe:	07db      	lsls	r3, r3, #31
   43c00:	d411      	bmi.n	43c26 <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   43c02:	2301      	movs	r3, #1
   43c04:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   43c08:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   43c0a:	ea41 0203 	orr.w	r2, r1, r3
   43c0e:	e8d0 4fef 	ldaex	r4, [r0]
   43c12:	429c      	cmp	r4, r3
   43c14:	d104      	bne.n	43c20 <nrfx_flag32_free+0x28>
   43c16:	e8c0 2fec 	stlex	ip, r2, [r0]
   43c1a:	f1bc 0f00 	cmp.w	ip, #0
   43c1e:	d1f6      	bne.n	43c0e <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43c20:	d1f2      	bne.n	43c08 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   43c22:	4802      	ldr	r0, [pc, #8]	; (43c2c <nrfx_flag32_free+0x34>)
}
   43c24:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   43c26:	4802      	ldr	r0, [pc, #8]	; (43c30 <nrfx_flag32_free+0x38>)
   43c28:	e7fc      	b.n	43c24 <nrfx_flag32_free+0x2c>
   43c2a:	bf00      	nop
   43c2c:	0bad0000 	.word	0x0bad0000
   43c30:	0bad0004 	.word	0x0bad0004

00043c34 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   43c34:	4b04      	ldr	r3, [pc, #16]	; (43c48 <nrfx_clock_init+0x14>)
   43c36:	791a      	ldrb	r2, [r3, #4]
   43c38:	b922      	cbnz	r2, 43c44 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   43c3a:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   43c3c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   43c3e:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   43c40:	4802      	ldr	r0, [pc, #8]	; (43c4c <nrfx_clock_init+0x18>)
   43c42:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   43c44:	4802      	ldr	r0, [pc, #8]	; (43c50 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   43c46:	4770      	bx	lr
   43c48:	2001aa70 	.word	0x2001aa70
   43c4c:	0bad0000 	.word	0x0bad0000
   43c50:	0bad000c 	.word	0x0bad000c

00043c54 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43c54:	b110      	cbz	r0, 43c5c <nrfx_clock_start+0x8>
   43c56:	2801      	cmp	r0, #1
   43c58:	d01e      	beq.n	43c98 <nrfx_clock_start+0x44>
   43c5a:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43c5c:	4b13      	ldr	r3, [pc, #76]	; (43cac <nrfx_clock_start+0x58>)
   43c5e:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43c62:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   43c66:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   43c6a:	4619      	mov	r1, r3
   43c6c:	d010      	beq.n	43c90 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   43c6e:	f002 0203 	and.w	r2, r2, #3
   43c72:	2a02      	cmp	r2, #2
   43c74:	d10c      	bne.n	43c90 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43c76:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43c7a:	2200      	movs	r2, #0
   43c7c:	4b0c      	ldr	r3, [pc, #48]	; (43cb0 <nrfx_clock_start+0x5c>)
   43c7e:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   43c80:	2202      	movs	r2, #2
   43c82:	681b      	ldr	r3, [r3, #0]
   43c84:	4b09      	ldr	r3, [pc, #36]	; (43cac <nrfx_clock_start+0x58>)
   43c86:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43c8a:	2201      	movs	r2, #1
   43c8c:	609a      	str	r2, [r3, #8]
}
   43c8e:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   43c90:	2301      	movs	r3, #1
   43c92:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   43c96:	e7f0      	b.n	43c7a <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43c98:	2200      	movs	r2, #0
   43c9a:	4b06      	ldr	r3, [pc, #24]	; (43cb4 <nrfx_clock_start+0x60>)
   43c9c:	601a      	str	r2, [r3, #0]
   43c9e:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   43ca0:	4b02      	ldr	r3, [pc, #8]	; (43cac <nrfx_clock_start+0x58>)
   43ca2:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43ca6:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   43ca8:	4770      	bx	lr
   43caa:	bf00      	nop
   43cac:	40005000 	.word	0x40005000
   43cb0:	40005104 	.word	0x40005104
   43cb4:	40005100 	.word	0x40005100

00043cb8 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   43cb8:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43cba:	b110      	cbz	r0, 43cc2 <nrfx_clock_stop+0xa>
   43cbc:	2801      	cmp	r0, #1
   43cbe:	d016      	beq.n	43cee <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   43cc0:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   43cc2:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43cc4:	2101      	movs	r1, #1
   43cc6:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   43cca:	4c16      	ldr	r4, [pc, #88]	; (43d24 <nrfx_clock_stop+0x6c>)
   43ccc:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43cd0:	4a15      	ldr	r2, [pc, #84]	; (43d28 <nrfx_clock_stop+0x70>)
   43cd2:	6010      	str	r0, [r2, #0]
   43cd4:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43cd6:	4a15      	ldr	r2, [pc, #84]	; (43d2c <nrfx_clock_stop+0x74>)
   43cd8:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43cda:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   43cde:	03db      	lsls	r3, r3, #15
   43ce0:	d5ee      	bpl.n	43cc0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   43ce2:	2001      	movs	r0, #1
   43ce4:	f004 fa5f 	bl	481a6 <nrfx_busy_wait>
   43ce8:	3d01      	subs	r5, #1
   43cea:	d1f6      	bne.n	43cda <nrfx_clock_stop+0x22>
   43cec:	e7e8      	b.n	43cc0 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43cee:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43cf0:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43cf4:	4b0e      	ldr	r3, [pc, #56]	; (43d30 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   43cf6:	4c0b      	ldr	r4, [pc, #44]	; (43d24 <nrfx_clock_stop+0x6c>)
   43cf8:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43cfc:	601a      	str	r2, [r3, #0]
   43cfe:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43d00:	4b0c      	ldr	r3, [pc, #48]	; (43d34 <nrfx_clock_stop+0x7c>)
   43d02:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43d04:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43d08:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43d0c:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43d10:	03d2      	lsls	r2, r2, #15
   43d12:	d5d5      	bpl.n	43cc0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   43d14:	2b00      	cmp	r3, #0
   43d16:	d0d3      	beq.n	43cc0 <nrfx_clock_stop+0x8>
   43d18:	2001      	movs	r0, #1
   43d1a:	f004 fa44 	bl	481a6 <nrfx_busy_wait>
   43d1e:	3d01      	subs	r5, #1
   43d20:	d1f0      	bne.n	43d04 <nrfx_clock_stop+0x4c>
   43d22:	e7cd      	b.n	43cc0 <nrfx_clock_stop+0x8>
   43d24:	40005000 	.word	0x40005000
   43d28:	40005104 	.word	0x40005104
   43d2c:	4000500c 	.word	0x4000500c
   43d30:	40005100 	.word	0x40005100
   43d34:	40005004 	.word	0x40005004

00043d38 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43d38:	4b15      	ldr	r3, [pc, #84]	; (43d90 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   43d3a:	b510      	push	{r4, lr}
   43d3c:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   43d3e:	b14a      	cbz	r2, 43d54 <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43d40:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   43d42:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43d44:	6018      	str	r0, [r3, #0]
   43d46:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   43d48:	4b12      	ldr	r3, [pc, #72]	; (43d94 <nrfx_power_clock_irq_handler+0x5c>)
   43d4a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   43d4e:	4b12      	ldr	r3, [pc, #72]	; (43d98 <nrfx_power_clock_irq_handler+0x60>)
   43d50:	681b      	ldr	r3, [r3, #0]
   43d52:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43d54:	4b11      	ldr	r3, [pc, #68]	; (43d9c <nrfx_power_clock_irq_handler+0x64>)
   43d56:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   43d58:	b182      	cbz	r2, 43d7c <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43d5a:	2200      	movs	r2, #0
   43d5c:	601a      	str	r2, [r3, #0]
   43d5e:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43d60:	4b0c      	ldr	r3, [pc, #48]	; (43d94 <nrfx_power_clock_irq_handler+0x5c>)
   43d62:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43d66:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   43d6a:	f002 0203 	and.w	r2, r2, #3
   43d6e:	2a01      	cmp	r2, #1
   43d70:	f04f 0102 	mov.w	r1, #2
   43d74:	d103      	bne.n	43d7e <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43d76:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43d7a:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   43d7c:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   43d7e:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43d82:	4b05      	ldr	r3, [pc, #20]	; (43d98 <nrfx_power_clock_irq_handler+0x60>)
   43d84:	2001      	movs	r0, #1
}
   43d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43d8a:	681b      	ldr	r3, [r3, #0]
   43d8c:	4718      	bx	r3
   43d8e:	bf00      	nop
   43d90:	40005100 	.word	0x40005100
   43d94:	40005000 	.word	0x40005000
   43d98:	2001aa70 	.word	0x2001aa70
   43d9c:	40005104 	.word	0x40005104

00043da0 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   43da0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   43da2:	4801      	ldr	r0, [pc, #4]	; (43da8 <nrfx_dppi_channel_alloc+0x8>)
   43da4:	f7ff bf08 	b.w	43bb8 <nrfx_flag32_alloc>
   43da8:	2001a590 	.word	0x2001a590

00043dac <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   43dac:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43dae:	4c0d      	ldr	r4, [pc, #52]	; (43de4 <call_handler+0x38>)
   43db0:	f100 0308 	add.w	r3, r0, #8
   43db4:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   43db8:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43dba:	05da      	lsls	r2, r3, #23
{
   43dbc:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43dbe:	d507      	bpl.n	43dd0 <call_handler+0x24>
   43dc0:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   43dc4:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   43dc8:	6852      	ldr	r2, [r2, #4]
   43dca:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   43dce:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   43dd0:	68a3      	ldr	r3, [r4, #8]
   43dd2:	b12b      	cbz	r3, 43de0 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43dd4:	4631      	mov	r1, r6
   43dd6:	4628      	mov	r0, r5
   43dd8:	68e2      	ldr	r2, [r4, #12]
    }
}
   43dda:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43dde:	4718      	bx	r3
}
   43de0:	bd70      	pop	{r4, r5, r6, pc}
   43de2:	bf00      	nop
   43de4:	2001a594 	.word	0x2001a594

00043de8 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43de8:	4b12      	ldr	r3, [pc, #72]	; (43e34 <release_handler+0x4c>)
   43dea:	3008      	adds	r0, #8
   43dec:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   43df0:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43df2:	05d1      	lsls	r1, r2, #23
   43df4:	d51b      	bpl.n	43e2e <release_handler+0x46>
   43df6:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   43dfa:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   43dfe:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43e02:	2000      	movs	r0, #0
   43e04:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   43e08:	f834 2b02 	ldrh.w	r2, [r4], #2
   43e0c:	f412 7f80 	tst.w	r2, #256	; 0x100
   43e10:	d003      	beq.n	43e1a <release_handler+0x32>
   43e12:	f3c2 2243 	ubfx	r2, r2, #9, #4
   43e16:	4291      	cmp	r1, r2
   43e18:	d009      	beq.n	43e2e <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43e1a:	3001      	adds	r0, #1
   43e1c:	2820      	cmp	r0, #32
   43e1e:	d1f3      	bne.n	43e08 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   43e20:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43e22:	4805      	ldr	r0, [pc, #20]	; (43e38 <release_handler+0x50>)
}
   43e24:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   43e26:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43e2a:	f7ff bee5 	b.w	43bf8 <nrfx_flag32_free>
}
   43e2e:	bc10      	pop	{r4}
   43e30:	4770      	bx	lr
   43e32:	bf00      	nop
   43e34:	2001a594 	.word	0x2001a594
   43e38:	2001a5e8 	.word	0x2001a5e8

00043e3c <pin_handler_trigger_uninit>:
{
   43e3c:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   43e3e:	4c0c      	ldr	r4, [pc, #48]	; (43e70 <pin_handler_trigger_uninit+0x34>)
   43e40:	f100 0508 	add.w	r5, r0, #8
   43e44:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   43e48:	069a      	lsls	r2, r3, #26
   43e4a:	d50a      	bpl.n	43e62 <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   43e4c:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   43e4e:	0b5b      	lsrs	r3, r3, #13
   43e50:	009b      	lsls	r3, r3, #2
   43e52:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   43e56:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   43e5a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   43e5e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   43e62:	f7ff ffc1 	bl	43de8 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   43e66:	2300      	movs	r3, #0
   43e68:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   43e6c:	bd38      	pop	{r3, r4, r5, pc}
   43e6e:	bf00      	nop
   43e70:	2001a594 	.word	0x2001a594

00043e74 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   43e74:	f000 021f 	and.w	r2, r0, #31
   43e78:	4805      	ldr	r0, [pc, #20]	; (43e90 <nrf_gpio_cfg_sense_set+0x1c>)
   43e7a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   43e7e:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   43e82:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   43e86:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   43e8a:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   43e8e:	4770      	bx	lr
   43e90:	40842500 	.word	0x40842500

00043e94 <nrfx_gpiote_input_configure>:
{
   43e94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   43e96:	4604      	mov	r4, r0
    if (p_input_config)
   43e98:	b1f9      	cbz	r1, 43eda <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   43e9a:	4f4c      	ldr	r7, [pc, #304]	; (43fcc <nrfx_gpiote_input_configure+0x138>)
   43e9c:	f100 0c08 	add.w	ip, r0, #8
   43ea0:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   43ea4:	f000 0522 	and.w	r5, r0, #34	; 0x22
   43ea8:	2d22      	cmp	r5, #34	; 0x22
   43eaa:	d102      	bne.n	43eb2 <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   43eac:	4848      	ldr	r0, [pc, #288]	; (43fd0 <nrfx_gpiote_input_configure+0x13c>)
}
   43eae:	b003      	add	sp, #12
   43eb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   43eb2:	4d48      	ldr	r5, [pc, #288]	; (43fd4 <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   43eb4:	f004 061f 	and.w	r6, r4, #31
   43eb8:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   43ebc:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   43ec0:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   43ec2:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   43ec6:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   43eca:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   43ece:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   43ed2:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   43ed6:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   43eda:	b192      	cbz	r2, 43f02 <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   43edc:	483b      	ldr	r0, [pc, #236]	; (43fcc <nrfx_gpiote_input_configure+0x138>)
   43ede:	f104 0608 	add.w	r6, r4, #8
   43ee2:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   43ee6:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   43ee8:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   43eea:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   43eec:	d50c      	bpl.n	43f08 <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   43eee:	2a00      	cmp	r2, #0
   43ef0:	d1dc      	bne.n	43eac <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   43ef2:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   43ef6:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   43efa:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   43efe:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   43f02:	bbd3      	cbnz	r3, 43f7a <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   43f04:	4834      	ldr	r0, [pc, #208]	; (43fd8 <nrfx_gpiote_input_configure+0x144>)
   43f06:	e7d2      	b.n	43eae <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   43f08:	f021 0120 	bic.w	r1, r1, #32
   43f0c:	04c9      	lsls	r1, r1, #19
   43f0e:	0cc9      	lsrs	r1, r1, #19
   43f10:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   43f14:	2a00      	cmp	r2, #0
   43f16:	d0ec      	beq.n	43ef2 <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   43f18:	2d03      	cmp	r5, #3
   43f1a:	d8c7      	bhi.n	43eac <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   43f1c:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   43f20:	4662      	mov	r2, ip
   43f22:	0092      	lsls	r2, r2, #2
   43f24:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   43f28:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   43f2c:	b925      	cbnz	r5, 43f38 <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   43f2e:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   43f32:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   43f36:	e7dc      	b.n	43ef2 <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   43f38:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   43f3c:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   43f40:	f027 0703 	bic.w	r7, r7, #3
   43f44:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   43f48:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   43f4c:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   43f50:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   43f54:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   43f58:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   43f5c:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   43f60:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   43f64:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   43f68:	ea47 070e 	orr.w	r7, r7, lr
   43f6c:	f041 0120 	orr.w	r1, r1, #32
   43f70:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   43f74:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   43f78:	e7bb      	b.n	43ef2 <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   43f7a:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   43f7c:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   43f80:	f7ff ff32 	bl	43de8 <release_handler>
    if (!handler)
   43f84:	2e00      	cmp	r6, #0
   43f86:	d0bd      	beq.n	43f04 <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   43f88:	4d10      	ldr	r5, [pc, #64]	; (43fcc <nrfx_gpiote_input_configure+0x138>)
   43f8a:	682b      	ldr	r3, [r5, #0]
   43f8c:	429e      	cmp	r6, r3
   43f8e:	d104      	bne.n	43f9a <nrfx_gpiote_input_configure+0x106>
   43f90:	686b      	ldr	r3, [r5, #4]
   43f92:	429f      	cmp	r7, r3
   43f94:	d101      	bne.n	43f9a <nrfx_gpiote_input_configure+0x106>
   43f96:	2200      	movs	r2, #0
   43f98:	e009      	b.n	43fae <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   43f9a:	4810      	ldr	r0, [pc, #64]	; (43fdc <nrfx_gpiote_input_configure+0x148>)
   43f9c:	f10d 0107 	add.w	r1, sp, #7
   43fa0:	f7ff fe0a 	bl	43bb8 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   43fa4:	4b0c      	ldr	r3, [pc, #48]	; (43fd8 <nrfx_gpiote_input_configure+0x144>)
   43fa6:	4298      	cmp	r0, r3
   43fa8:	d181      	bne.n	43eae <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   43faa:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   43fae:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   43fb2:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   43fb4:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   43fb6:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   43fba:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   43fbe:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   43fc2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   43fc6:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   43fca:	e79b      	b.n	43f04 <nrfx_gpiote_input_configure+0x70>
   43fcc:	2001a594 	.word	0x2001a594
   43fd0:	0bad0004 	.word	0x0bad0004
   43fd4:	40842500 	.word	0x40842500
   43fd8:	0bad0000 	.word	0x0bad0000
   43fdc:	2001a5e8 	.word	0x2001a5e8

00043fe0 <nrfx_gpiote_output_configure>:
{
   43fe0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   43fe4:	2900      	cmp	r1, #0
   43fe6:	d044      	beq.n	44072 <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   43fe8:	4e43      	ldr	r6, [pc, #268]	; (440f8 <nrfx_gpiote_output_configure+0x118>)
   43fea:	f100 0c08 	add.w	ip, r0, #8
   43fee:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   43ff2:	07ab      	lsls	r3, r5, #30
   43ff4:	d404      	bmi.n	44000 <nrfx_gpiote_output_configure+0x20>
   43ff6:	06af      	lsls	r7, r5, #26
   43ff8:	d502      	bpl.n	44000 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   43ffa:	4840      	ldr	r0, [pc, #256]	; (440fc <nrfx_gpiote_output_configure+0x11c>)
}
   43ffc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   44000:	f015 0f1c 	tst.w	r5, #28
   44004:	d002      	beq.n	4400c <nrfx_gpiote_output_configure+0x2c>
   44006:	784b      	ldrb	r3, [r1, #1]
   44008:	2b01      	cmp	r3, #1
   4400a:	d0f6      	beq.n	43ffa <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4400c:	4b3c      	ldr	r3, [pc, #240]	; (44100 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4400e:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   44012:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   44016:	bf14      	ite	ne
   44018:	2402      	movne	r4, #2
   4401a:	2400      	moveq	r4, #0
   4401c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44020:	1c8b      	adds	r3, r1, #2
   44022:	bf14      	ite	ne
   44024:	f04f 090c 	movne.w	r9, #12
   44028:	f04f 0900 	moveq.w	r9, #0
   4402c:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44030:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44034:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   44038:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   4403c:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   44040:	f1be 0f00 	cmp.w	lr, #0
   44044:	d003      	beq.n	4404e <nrfx_gpiote_output_configure+0x6e>
   44046:	f891 e001 	ldrb.w	lr, [r1, #1]
   4404a:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4404e:	b10b      	cbz	r3, 44054 <nrfx_gpiote_output_configure+0x74>
   44050:	788c      	ldrb	r4, [r1, #2]
   44052:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   44054:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   44056:	f045 0503 	orr.w	r5, r5, #3
   4405a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   4405e:	ea43 0308 	orr.w	r3, r3, r8
   44062:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   44066:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   4406a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   4406e:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   44072:	b90a      	cbnz	r2, 44078 <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   44074:	4823      	ldr	r0, [pc, #140]	; (44104 <nrfx_gpiote_output_configure+0x124>)
   44076:	e7c1      	b.n	43ffc <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44078:	4d1f      	ldr	r5, [pc, #124]	; (440f8 <nrfx_gpiote_output_configure+0x118>)
   4407a:	f100 0608 	add.w	r6, r0, #8
   4407e:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   44082:	07a3      	lsls	r3, r4, #30
   44084:	d5b9      	bpl.n	43ffa <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   44086:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   44088:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   4408a:	f024 0420 	bic.w	r4, r4, #32
   4408e:	00b9      	lsls	r1, r7, #2
   44090:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   44094:	04e4      	lsls	r4, r4, #19
   44096:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   4409a:	0ce4      	lsrs	r4, r4, #19
   4409c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   440a0:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   440a4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   440a8:	f892 c001 	ldrb.w	ip, [r2, #1]
   440ac:	f1bc 0f00 	cmp.w	ip, #0
   440b0:	d0e0      	beq.n	44074 <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   440b2:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   440b6:	7892      	ldrb	r2, [r2, #2]
   440b8:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   440bc:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   440c0:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440c4:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   440c8:	0203      	lsls	r3, r0, #8
   440ca:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   440ce:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440d2:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   440d6:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   440da:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440dc:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   440de:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   440e2:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440e6:	4313      	orrs	r3, r2
   440e8:	f044 0420 	orr.w	r4, r4, #32
   440ec:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   440f0:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   440f4:	e7be      	b.n	44074 <nrfx_gpiote_output_configure+0x94>
   440f6:	bf00      	nop
   440f8:	2001a594 	.word	0x2001a594
   440fc:	0bad0004 	.word	0x0bad0004
   44100:	40842500 	.word	0x40842500
   44104:	0bad0000 	.word	0x0bad0000

00044108 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   44108:	4b01      	ldr	r3, [pc, #4]	; (44110 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   4410a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   4410e:	4770      	bx	lr
   44110:	2001a594 	.word	0x2001a594

00044114 <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44114:	4b05      	ldr	r3, [pc, #20]	; (4412c <nrfx_gpiote_channel_get+0x18>)
   44116:	3008      	adds	r0, #8
   44118:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   4411c:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   4411e:	bf43      	ittte	mi
   44120:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   44122:	4803      	ldrmi	r0, [pc, #12]	; (44130 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44124:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   44126:	4803      	ldrpl	r0, [pc, #12]	; (44134 <nrfx_gpiote_channel_get+0x20>)
}
   44128:	4770      	bx	lr
   4412a:	bf00      	nop
   4412c:	2001a594 	.word	0x2001a594
   44130:	0bad0000 	.word	0x0bad0000
   44134:	0bad0004 	.word	0x0bad0004

00044138 <nrfx_gpiote_init>:
{
   44138:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4413a:	4c0e      	ldr	r4, [pc, #56]	; (44174 <nrfx_gpiote_init+0x3c>)
   4413c:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   44140:	b9b5      	cbnz	r5, 44170 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   44142:	2240      	movs	r2, #64	; 0x40
   44144:	4629      	mov	r1, r5
   44146:	f104 0010 	add.w	r0, r4, #16
   4414a:	f003 fe93 	bl	47e74 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   4414e:	2031      	movs	r0, #49	; 0x31
   44150:	f7fd fe5c 	bl	41e0c <arch_irq_enable>
    p_reg->INTENSET = mask;
   44154:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44158:	4b07      	ldr	r3, [pc, #28]	; (44178 <nrfx_gpiote_init+0x40>)
    return err_code;
   4415a:	4808      	ldr	r0, [pc, #32]	; (4417c <nrfx_gpiote_init+0x44>)
   4415c:	601d      	str	r5, [r3, #0]
   4415e:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   44160:	4b07      	ldr	r3, [pc, #28]	; (44180 <nrfx_gpiote_init+0x48>)
   44162:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44166:	2301      	movs	r3, #1
   44168:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   4416c:	6563      	str	r3, [r4, #84]	; 0x54
}
   4416e:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   44170:	4804      	ldr	r0, [pc, #16]	; (44184 <nrfx_gpiote_init+0x4c>)
   44172:	e7fc      	b.n	4416e <nrfx_gpiote_init+0x36>
   44174:	2001a594 	.word	0x2001a594
   44178:	4003117c 	.word	0x4003117c
   4417c:	0bad0000 	.word	0x0bad0000
   44180:	40031000 	.word	0x40031000
   44184:	0bad0005 	.word	0x0bad0005

00044188 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   44188:	4b03      	ldr	r3, [pc, #12]	; (44198 <nrfx_gpiote_is_init+0x10>)
   4418a:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   4418e:	3800      	subs	r0, #0
   44190:	bf18      	it	ne
   44192:	2001      	movne	r0, #1
   44194:	4770      	bx	lr
   44196:	bf00      	nop
   44198:	2001a594 	.word	0x2001a594

0004419c <nrfx_gpiote_channel_free>:
{
   4419c:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   4419e:	4801      	ldr	r0, [pc, #4]	; (441a4 <nrfx_gpiote_channel_free+0x8>)
   441a0:	f7ff bd2a 	b.w	43bf8 <nrfx_flag32_free>
   441a4:	2001a5e4 	.word	0x2001a5e4

000441a8 <nrfx_gpiote_channel_alloc>:
{
   441a8:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   441aa:	4801      	ldr	r0, [pc, #4]	; (441b0 <nrfx_gpiote_channel_alloc+0x8>)
   441ac:	f7ff bd04 	b.w	43bb8 <nrfx_flag32_alloc>
   441b0:	2001a5e4 	.word	0x2001a5e4

000441b4 <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   441b4:	4b1b      	ldr	r3, [pc, #108]	; (44224 <nrfx_gpiote_trigger_enable+0x70>)
   441b6:	f100 0208 	add.w	r2, r0, #8
   441ba:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   441be:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   441c0:	069a      	lsls	r2, r3, #26
   441c2:	d51a      	bpl.n	441fa <nrfx_gpiote_trigger_enable+0x46>
   441c4:	f013 0402 	ands.w	r4, r3, #2
   441c8:	d117      	bne.n	441fa <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   441ca:	4817      	ldr	r0, [pc, #92]	; (44228 <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   441cc:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   441ce:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   441d0:	5084      	str	r4, [r0, r2]
   441d2:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   441d4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   441d8:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   441dc:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   441e0:	f040 0001 	orr.w	r0, r0, #1
   441e4:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   441e8:	b129      	cbz	r1, 441f6 <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   441ea:	2201      	movs	r2, #1
   441ec:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   441f0:	4a0e      	ldr	r2, [pc, #56]	; (4422c <nrfx_gpiote_trigger_enable+0x78>)
   441f2:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   441f6:	bc10      	pop	{r4}
   441f8:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   441fa:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   441fe:	2b04      	cmp	r3, #4
   44200:	d00c      	beq.n	4421c <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   44202:	2b05      	cmp	r3, #5
   44204:	d00c      	beq.n	44220 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   44206:	4b0a      	ldr	r3, [pc, #40]	; (44230 <nrfx_gpiote_trigger_enable+0x7c>)
   44208:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   4420a:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   4420e:	40d9      	lsrs	r1, r3
   44210:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44214:	3102      	adds	r1, #2
}
   44216:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   44218:	f7ff be2c 	b.w	43e74 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   4421c:	2103      	movs	r1, #3
   4421e:	e7fa      	b.n	44216 <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   44220:	2102      	movs	r1, #2
   44222:	e7f8      	b.n	44216 <nrfx_gpiote_trigger_enable+0x62>
   44224:	2001a594 	.word	0x2001a594
   44228:	40031100 	.word	0x40031100
   4422c:	40031000 	.word	0x40031000
   44230:	40842500 	.word	0x40842500

00044234 <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44234:	4b0e      	ldr	r3, [pc, #56]	; (44270 <nrfx_gpiote_trigger_disable+0x3c>)
   44236:	f100 0208 	add.w	r2, r0, #8
   4423a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   4423e:	0699      	lsls	r1, r3, #26
   44240:	d513      	bpl.n	4426a <nrfx_gpiote_trigger_disable+0x36>
   44242:	079a      	lsls	r2, r3, #30
   44244:	d411      	bmi.n	4426a <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   44246:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44248:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   4424a:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   4424c:	4909      	ldr	r1, [pc, #36]	; (44274 <nrfx_gpiote_trigger_disable+0x40>)
   4424e:	009b      	lsls	r3, r3, #2
   44250:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44254:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44258:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   4425c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   44260:	f022 0203 	bic.w	r2, r2, #3
   44264:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   44268:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   4426a:	2100      	movs	r1, #0
   4426c:	f7ff be02 	b.w	43e74 <nrf_gpio_cfg_sense_set>
   44270:	2001a594 	.word	0x2001a594
   44274:	40031000 	.word	0x40031000

00044278 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   44278:	4b0c      	ldr	r3, [pc, #48]	; (442ac <nrfx_gpiote_pin_uninit+0x34>)
   4427a:	f100 0208 	add.w	r2, r0, #8
   4427e:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   44282:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   44284:	07db      	lsls	r3, r3, #31
{
   44286:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   44288:	d50d      	bpl.n	442a6 <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   4428a:	f7ff ffd3 	bl	44234 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   4428e:	4620      	mov	r0, r4
   44290:	f7ff fdd4 	bl	43e3c <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   44294:	2202      	movs	r2, #2
   44296:	4b06      	ldr	r3, [pc, #24]	; (442b0 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   44298:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   4429c:	3480      	adds	r4, #128	; 0x80
   4429e:	4805      	ldr	r0, [pc, #20]	; (442b4 <nrfx_gpiote_pin_uninit+0x3c>)
   442a0:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   442a4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   442a6:	4804      	ldr	r0, [pc, #16]	; (442b8 <nrfx_gpiote_pin_uninit+0x40>)
   442a8:	e7fc      	b.n	442a4 <nrfx_gpiote_pin_uninit+0x2c>
   442aa:	bf00      	nop
   442ac:	2001a594 	.word	0x2001a594
   442b0:	40842500 	.word	0x40842500
   442b4:	0bad0000 	.word	0x0bad0000
   442b8:	0bad0004 	.word	0x0bad0004

000442bc <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   442bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   442c0:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   442c2:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   442c4:	4634      	mov	r4, r6
{
   442c6:	4b4b      	ldr	r3, [pc, #300]	; (443f4 <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   442c8:	484b      	ldr	r0, [pc, #300]	; (443f8 <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   442ca:	494c      	ldr	r1, [pc, #304]	; (443fc <nrfx_gpiote_irq_handler+0x140>)
{
   442cc:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   442ce:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   442d0:	b135      	cbz	r5, 442e0 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   442d2:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   442d6:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   442d8:	bf1e      	ittt	ne
   442da:	601c      	strne	r4, [r3, #0]
   442dc:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   442de:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   442e0:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   442e2:	428b      	cmp	r3, r1
        mask <<= 1;
   442e4:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   442e8:	d1f1      	bne.n	442ce <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   442ea:	4f45      	ldr	r7, [pc, #276]	; (44400 <nrfx_gpiote_irq_handler+0x144>)
   442ec:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   442ee:	b183      	cbz	r3, 44312 <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   442f0:	4d44      	ldr	r5, [pc, #272]	; (44404 <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   442f2:	f10d 080c 	add.w	r8, sp, #12
   442f6:	6a2b      	ldr	r3, [r5, #32]
   442f8:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   442fa:	622b      	str	r3, [r5, #32]
   442fc:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   44300:	9803      	ldr	r0, [sp, #12]
   44302:	b940      	cbnz	r0, 44316 <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44304:	6038      	str	r0, [r7, #0]
   44306:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   44308:	6a2b      	ldr	r3, [r5, #32]
   4430a:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4430c:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   4430e:	2b00      	cmp	r3, #0
   44310:	d1f4      	bne.n	442fc <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   44312:	2401      	movs	r4, #1
   44314:	e069      	b.n	443ea <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   44316:	fa90 faa0 	rbit	sl, r0
   4431a:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4431e:	4a3a      	ldr	r2, [pc, #232]	; (44408 <nrfx_gpiote_irq_handler+0x14c>)
   44320:	f10a 0308 	add.w	r3, sl, #8
   44324:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   44328:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   4432c:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   44330:	fa09 f403 	lsl.w	r4, r9, r3
   44334:	f818 300c 	ldrb.w	r3, [r8, ip]
   44338:	f3c1 0282 	ubfx	r2, r1, #2, #3
   4433c:	ea23 0304 	bic.w	r3, r3, r4
   44340:	f808 300c 	strb.w	r3, [r8, ip]
   44344:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44348:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   4434c:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4434e:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   44350:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   44354:	d518      	bpl.n	44388 <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   44356:	4611      	mov	r1, r2
   44358:	4650      	mov	r0, sl
   4435a:	9301      	str	r3, [sp, #4]
   4435c:	f7ff fd26 	bl	43dac <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44360:	9b01      	ldr	r3, [sp, #4]
   44362:	b2e4      	uxtb	r4, r4
   44364:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   44368:	f3c3 4301 	ubfx	r3, r3, #16, #2
   4436c:	429c      	cmp	r4, r3
   4436e:	d107      	bne.n	44380 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   44370:	2100      	movs	r1, #0
   44372:	4650      	mov	r0, sl
   44374:	f7ff fd7e 	bl	43e74 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   44378:	4621      	mov	r1, r4
   4437a:	4650      	mov	r0, sl
   4437c:	f7ff fd7a 	bl	43e74 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   44380:	fa09 f00a 	lsl.w	r0, r9, sl
   44384:	6228      	str	r0, [r5, #32]
}
   44386:	e7bb      	b.n	44300 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44388:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   4438a:	bf0c      	ite	eq
   4438c:	2103      	moveq	r1, #3
   4438e:	2102      	movne	r1, #2
   44390:	4650      	mov	r0, sl
   44392:	9201      	str	r2, [sp, #4]
   44394:	f7ff fd6e 	bl	43e74 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   44398:	9a01      	ldr	r2, [sp, #4]
   4439a:	2a03      	cmp	r2, #3
   4439c:	d004      	beq.n	443a8 <nrfx_gpiote_irq_handler+0xec>
   4439e:	2c02      	cmp	r4, #2
   443a0:	d107      	bne.n	443b2 <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   443a2:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   443a6:	d1eb      	bne.n	44380 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   443a8:	4659      	mov	r1, fp
   443aa:	4650      	mov	r0, sl
   443ac:	f7ff fcfe 	bl	43dac <call_handler>
   443b0:	e7e6      	b.n	44380 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   443b2:	2c03      	cmp	r4, #3
   443b4:	d1e4      	bne.n	44380 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   443b6:	f1bb 0f02 	cmp.w	fp, #2
   443ba:	e7f4      	b.n	443a6 <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   443bc:	fa96 f3a6 	rbit	r3, r6
   443c0:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   443c4:	fa04 f203 	lsl.w	r2, r4, r3
   443c8:	009b      	lsls	r3, r3, #2
   443ca:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   443ce:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   443d2:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   443d6:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   443da:	f3c0 2004 	ubfx	r0, r0, #8, #5
   443de:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   443e2:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   443e6:	f7ff fce1 	bl	43dac <call_handler>
    while (mask)
   443ea:	2e00      	cmp	r6, #0
   443ec:	d1e6      	bne.n	443bc <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   443ee:	b005      	add	sp, #20
   443f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   443f4:	40031100 	.word	0x40031100
   443f8:	40031000 	.word	0x40031000
   443fc:	40031120 	.word	0x40031120
   44400:	4003117c 	.word	0x4003117c
   44404:	40842500 	.word	0x40842500
   44408:	2001a594 	.word	0x2001a594

0004440c <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   4440c:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4440e:	4c08      	ldr	r4, [pc, #32]	; (44430 <nrfx_ipc_init+0x24>)
{
   44410:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44412:	7923      	ldrb	r3, [r4, #4]
{
   44414:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44416:	b943      	cbnz	r3, 4442a <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   44418:	202a      	movs	r0, #42	; 0x2a
   4441a:	f7fd fcf7 	bl	41e0c <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   4441e:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   44420:	4804      	ldr	r0, [pc, #16]	; (44434 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44422:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   44424:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   44426:	60a5      	str	r5, [r4, #8]
}
   44428:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   4442a:	4803      	ldr	r0, [pc, #12]	; (44438 <nrfx_ipc_init+0x2c>)
   4442c:	e7fc      	b.n	44428 <nrfx_ipc_init+0x1c>
   4442e:	bf00      	nop
   44430:	2001aa78 	.word	0x2001aa78
   44434:	0bad0000 	.word	0x0bad0000
   44438:	0bad000c 	.word	0x0bad000c

0004443c <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4443c:	2300      	movs	r3, #0
{
   4443e:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   44440:	4a0d      	ldr	r2, [pc, #52]	; (44478 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   44442:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   44446:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4444a:	3301      	adds	r3, #1
   4444c:	2b08      	cmp	r3, #8
   4444e:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   44452:	d1f6      	bne.n	44442 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   44454:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   44456:	4a08      	ldr	r2, [pc, #32]	; (44478 <nrfx_ipc_config_load+0x3c>)
   44458:	f100 0120 	add.w	r1, r0, #32
   4445c:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   44460:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44464:	3301      	adds	r3, #1
   44466:	2b08      	cmp	r3, #8
   44468:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   4446c:	d1f6      	bne.n	4445c <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   4446e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   44470:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44474:	bd30      	pop	{r4, r5, pc}
   44476:	bf00      	nop
   44478:	4002a000 	.word	0x4002a000

0004447c <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   4447c:	2300      	movs	r3, #0
   4447e:	4a14      	ldr	r2, [pc, #80]	; (444d0 <nrfx_ipc_uninit+0x54>)
   44480:	4914      	ldr	r1, [pc, #80]	; (444d4 <nrfx_ipc_uninit+0x58>)
   44482:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44486:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   4448a:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   4448e:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   44492:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   44496:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   4449a:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   4449e:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   444a2:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   444a6:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   444aa:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   444ae:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   444b2:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   444b6:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   444ba:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   444be:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   444c2:	f04f 32ff 	mov.w	r2, #4294967295
   444c6:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   444ca:	4a03      	ldr	r2, [pc, #12]	; (444d8 <nrfx_ipc_uninit+0x5c>)
   444cc:	7113      	strb	r3, [r2, #4]
}
   444ce:	4770      	bx	lr
   444d0:	4002a004 	.word	0x4002a004
   444d4:	4002a000 	.word	0x4002a000
   444d8:	2001aa78 	.word	0x2001aa78

000444dc <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   444dc:	4b0c      	ldr	r3, [pc, #48]	; (44510 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   444de:	b430      	push	{r4, r5}
   444e0:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   444e4:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   444e6:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   444e8:	2500      	movs	r5, #0
    while (bitmask)
   444ea:	b923      	cbnz	r3, 444f6 <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   444ec:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   444ee:	4b09      	ldr	r3, [pc, #36]	; (44514 <nrfx_ipc_irq_handler+0x38>)
   444f0:	681a      	ldr	r2, [r3, #0]
   444f2:	6899      	ldr	r1, [r3, #8]
   444f4:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   444f6:	fa93 f2a3 	rbit	r2, r3
   444fa:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   444fe:	fa04 f102 	lsl.w	r1, r4, r2
   44502:	ea23 0301 	bic.w	r3, r3, r1
   44506:	4904      	ldr	r1, [pc, #16]	; (44518 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   44508:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4450a:	508d      	str	r5, [r1, r2]
}
   4450c:	e7ed      	b.n	444ea <nrfx_ipc_irq_handler+0xe>
   4450e:	bf00      	nop
   44510:	4002a000 	.word	0x4002a000
   44514:	2001aa78 	.word	0x2001aa78
   44518:	4002a100 	.word	0x4002a100

0004451c <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   4451c:	2303      	movs	r3, #3
static void _DoInit(void) {
   4451e:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44520:	4c10      	ldr	r4, [pc, #64]	; (44564 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   44522:	4a11      	ldr	r2, [pc, #68]	; (44568 <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44524:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   44526:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   44528:	4b10      	ldr	r3, [pc, #64]	; (4456c <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   4452a:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   4452c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   4452e:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
   44532:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   44534:	2300      	movs	r3, #0
   44536:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   44538:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4453a:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   4453c:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   4453e:	4a0c      	ldr	r2, [pc, #48]	; (44570 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   44540:	490c      	ldr	r1, [pc, #48]	; (44574 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
   44542:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44544:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
   44546:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44548:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   4454a:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   4454c:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4454e:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   44550:	f003 fc58 	bl	47e04 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   44554:	4620      	mov	r0, r4
   44556:	4908      	ldr	r1, [pc, #32]	; (44578 <_DoInit+0x5c>)
   44558:	f003 fc54 	bl	47e04 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   4455c:	2320      	movs	r3, #32
   4455e:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   44560:	bd10      	pop	{r4, pc}
   44562:	bf00      	nop
   44564:	2001aa84 	.word	0x2001aa84
   44568:	000494d6 	.word	0x000494d6
   4456c:	2001adf3 	.word	0x2001adf3
   44570:	2001ade3 	.word	0x2001ade3
   44574:	000494df 	.word	0x000494df
   44578:	000494e3 	.word	0x000494e3

0004457c <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   4457c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   44580:	f04f 0b18 	mov.w	fp, #24
   44584:	4f22      	ldr	r7, [pc, #136]	; (44610 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44586:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   44588:	fb0b 7200 	mla	r2, fp, r0, r7
   4458c:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   4458e:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44590:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   44592:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44594:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   44596:	d834      	bhi.n	44602 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   44598:	f8d2 a020 	ldr.w	sl, [r2, #32]
   4459c:	ebaa 0905 	sub.w	r9, sl, r5
   445a0:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
   445a4:	4294      	cmp	r4, r2
   445a6:	d811      	bhi.n	445cc <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   445a8:	f04f 0918 	mov.w	r9, #24
   445ac:	fb06 9309 	mla	r3, r6, r9, r9
   445b0:	443b      	add	r3, r7
   445b2:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   445b4:	4622      	mov	r2, r4
   445b6:	4641      	mov	r1, r8
   445b8:	4428      	add	r0, r5
   445ba:	f003 fc50 	bl	47e5e <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   445be:	fb09 7606 	mla	r6, r9, r6, r7
   445c2:	442c      	add	r4, r5
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
   445c4:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   445c6:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   445c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   445cc:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   445ce:	429c      	cmp	r4, r3
   445d0:	d81b      	bhi.n	4460a <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   445d2:	fb00 bb0b 	mla	fp, r0, fp, fp
   445d6:	44bb      	add	fp, r7
   445d8:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   445dc:	464a      	mov	r2, r9
   445de:	4428      	add	r0, r5
   445e0:	442c      	add	r4, r5
   445e2:	f003 fc3c 	bl	47e5e <memcpy>
      if (NumBytes) {
   445e6:	ebb4 040a 	subs.w	r4, r4, sl
   445ea:	d006      	beq.n	445fa <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   445ec:	4622      	mov	r2, r4
   445ee:	f8db 0004 	ldr.w	r0, [fp, #4]
   445f2:	eb08 0109 	add.w	r1, r8, r9
   445f6:	f003 fc32 	bl	47e5e <memcpy>
      pRing->WrOff = NumBytes;
   445fa:	2018      	movs	r0, #24
   445fc:	fb00 7606 	mla	r6, r0, r6, r7
   44600:	e7e0      	b.n	445c4 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   44602:	3b01      	subs	r3, #1
   44604:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   44606:	42a3      	cmp	r3, r4
   44608:	d2ce      	bcs.n	445a8 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   4460a:	2000      	movs	r0, #0
   4460c:	e7dc      	b.n	445c8 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   4460e:	bf00      	nop
   44610:	2001aa84 	.word	0x2001aa84

00044614 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   44614:	2218      	movs	r2, #24
   44616:	4b03      	ldr	r3, [pc, #12]	; (44624 <SEGGER_RTT_HasDataUp+0x10>)
   44618:	fb02 3300 	mla	r3, r2, r0, r3
   4461c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   4461e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   44620:	1a80      	subs	r0, r0, r2
   44622:	4770      	bx	lr
   44624:	2001aa84 	.word	0x2001aa84

00044628 <rpc_handle_data_message>:
   44628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4462c:	4680      	mov	r8, r0
   4462e:	4604      	mov	r4, r0
   44630:	2700      	movs	r7, #0
   44632:	f858 6b08 	ldr.w	r6, [r8], #8
   44636:	4d0c      	ldr	r5, [pc, #48]	; (44668 <rpc_handle_data_message+0x40>)
   44638:	b2f6      	uxtb	r6, r6
   4463a:	782b      	ldrb	r3, [r5, #0]
   4463c:	42b3      	cmp	r3, r6
   4463e:	d00a      	beq.n	44656 <rpc_handle_data_message+0x2e>
   44640:	3701      	adds	r7, #1
   44642:	2f04      	cmp	r7, #4
   44644:	f105 050c 	add.w	r5, r5, #12
   44648:	d1f7      	bne.n	4463a <rpc_handle_data_message+0x12>
   4464a:	68a0      	ldr	r0, [r4, #8]
   4464c:	b150      	cbz	r0, 44664 <rpc_handle_data_message+0x3c>
   4464e:	f003 fe00 	bl	48252 <rpc_transport_peer_data_free>
   44652:	2000      	movs	r0, #0
   44654:	e006      	b.n	44664 <rpc_handle_data_message+0x3c>
   44656:	6821      	ldr	r1, [r4, #0]
   44658:	4640      	mov	r0, r8
   4465a:	686b      	ldr	r3, [r5, #4]
   4465c:	0c09      	lsrs	r1, r1, #16
   4465e:	4798      	blx	r3
   44660:	2802      	cmp	r0, #2
   44662:	d0ed      	beq.n	44640 <rpc_handle_data_message+0x18>
   44664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44668:	00048dc0 	.word	0x00048dc0

0004466c <trace_write>:
   4466c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44670:	4f53      	ldr	r7, [pc, #332]	; (447c0 <trace_write+0x154>)
   44672:	4605      	mov	r5, r0
   44674:	2100      	movs	r1, #0
   44676:	6838      	ldr	r0, [r7, #0]
   44678:	f003 fd71 	bl	4815e <nrf_modem_os_sem_take>
   4467c:	4604      	mov	r4, r0
   4467e:	2800      	cmp	r0, #0
   44680:	d14c      	bne.n	4471c <trace_write+0xb0>
   44682:	782b      	ldrb	r3, [r5, #0]
   44684:	f8d5 8008 	ldr.w	r8, [r5, #8]
   44688:	2b62      	cmp	r3, #98	; 0x62
   4468a:	d043      	beq.n	44714 <trace_write+0xa8>
   4468c:	2b63      	cmp	r3, #99	; 0x63
   4468e:	d043      	beq.n	44718 <trace_write+0xac>
   44690:	2b61      	cmp	r3, #97	; 0x61
   44692:	d102      	bne.n	4469a <trace_write+0x2e>
   44694:	4b4b      	ldr	r3, [pc, #300]	; (447c4 <trace_write+0x158>)
   44696:	881c      	ldrh	r4, [r3, #0]
   44698:	b2a4      	uxth	r4, r4
   4469a:	6838      	ldr	r0, [r7, #0]
   4469c:	f003 fd5d 	bl	4815a <nrf_modem_os_sem_give>
   446a0:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   446a4:	6929      	ldr	r1, [r5, #16]
   446a6:	eba8 080a 	sub.w	r8, r8, sl
   446aa:	eba1 030a 	sub.w	r3, r1, sl
   446ae:	b29b      	uxth	r3, r3
   446b0:	fa14 f488 	uxtah	r4, r4, r8
   446b4:	fbb4 f2f3 	udiv	r2, r4, r3
   446b8:	fb03 4412 	mls	r4, r3, r2, r4
   446bc:	686a      	ldr	r2, [r5, #4]
   446be:	eba2 020a 	sub.w	r2, r2, sl
   446c2:	fa13 f282 	uxtah	r2, r3, r2
   446c6:	1b12      	subs	r2, r2, r4
   446c8:	fb92 f0f3 	sdiv	r0, r2, r3
   446cc:	fb03 2210 	mls	r2, r3, r0, r2
   446d0:	fa1f f982 	uxth.w	r9, r2
   446d4:	fa14 f282 	uxtah	r2, r4, r2
   446d8:	4293      	cmp	r3, r2
   446da:	44a2      	add	sl, r4
   446dc:	da22      	bge.n	44724 <trace_write+0xb8>
   446de:	eba1 030a 	sub.w	r3, r1, sl
   446e2:	b29b      	uxth	r3, r3
   446e4:	eba9 0403 	sub.w	r4, r9, r3
   446e8:	4699      	mov	r9, r3
   446ea:	b2a4      	uxth	r4, r4
   446ec:	f1b9 0f00 	cmp.w	r9, #0
   446f0:	d064      	beq.n	447bc <trace_write+0x150>
   446f2:	2005      	movs	r0, #5
   446f4:	f7ff f9d6 	bl	43aa4 <nrf_modem_os_alloc>
   446f8:	4680      	mov	r8, r0
   446fa:	2800      	cmp	r0, #0
   446fc:	d05e      	beq.n	447bc <trace_write+0x150>
   446fe:	b19c      	cbz	r4, 44728 <trace_write+0xbc>
   44700:	2005      	movs	r0, #5
   44702:	f7ff f9cf 	bl	43aa4 <nrf_modem_os_alloc>
   44706:	4606      	mov	r6, r0
   44708:	b970      	cbnz	r0, 44728 <trace_write+0xbc>
   4470a:	4640      	mov	r0, r8
   4470c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44710:	f7ff b9d0 	b.w	43ab4 <nrf_modem_os_free>
   44714:	4b2c      	ldr	r3, [pc, #176]	; (447c8 <trace_write+0x15c>)
   44716:	e7be      	b.n	44696 <trace_write+0x2a>
   44718:	4b2c      	ldr	r3, [pc, #176]	; (447cc <trace_write+0x160>)
   4471a:	e7bc      	b.n	44696 <trace_write+0x2a>
   4471c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44720:	f7ff b9b0 	b.w	43a84 <nrf_modem_os_trace_irq_set>
   44724:	2400      	movs	r4, #0
   44726:	e7e1      	b.n	446ec <trace_write+0x80>
   44728:	2100      	movs	r1, #0
   4472a:	6838      	ldr	r0, [r7, #0]
   4472c:	f003 fd17 	bl	4815e <nrf_modem_os_sem_take>
   44730:	b140      	cbz	r0, 44744 <trace_write+0xd8>
   44732:	f7ff f9a7 	bl	43a84 <nrf_modem_os_trace_irq_set>
   44736:	4640      	mov	r0, r8
   44738:	f7ff f9bc 	bl	43ab4 <nrf_modem_os_free>
   4473c:	2c00      	cmp	r4, #0
   4473e:	d03d      	beq.n	447bc <trace_write+0x150>
   44740:	4630      	mov	r0, r6
   44742:	e7e3      	b.n	4470c <trace_write+0xa0>
   44744:	782b      	ldrb	r3, [r5, #0]
   44746:	2b62      	cmp	r3, #98	; 0x62
   44748:	d034      	beq.n	447b4 <trace_write+0x148>
   4474a:	2b63      	cmp	r3, #99	; 0x63
   4474c:	d034      	beq.n	447b8 <trace_write+0x14c>
   4474e:	2b61      	cmp	r3, #97	; 0x61
   44750:	d107      	bne.n	44762 <trace_write+0xf6>
   44752:	4a1c      	ldr	r2, [pc, #112]	; (447c4 <trace_write+0x158>)
   44754:	8813      	ldrh	r3, [r2, #0]
   44756:	eb04 0109 	add.w	r1, r4, r9
   4475a:	fa11 f383 	uxtah	r3, r1, r3
   4475e:	b29b      	uxth	r3, r3
   44760:	8013      	strh	r3, [r2, #0]
   44762:	6838      	ldr	r0, [r7, #0]
   44764:	f06f 0b10 	mvn.w	fp, #16
   44768:	f06f 0741 	mvn.w	r7, #65	; 0x41
   4476c:	f003 fcf5 	bl	4815a <nrf_modem_os_sem_give>
   44770:	f888 b000 	strb.w	fp, [r8]
   44774:	f888 7001 	strb.w	r7, [r8, #1]
   44778:	782b      	ldrb	r3, [r5, #0]
   4477a:	2105      	movs	r1, #5
   4477c:	4640      	mov	r0, r8
   4477e:	f888 3004 	strb.w	r3, [r8, #4]
   44782:	f8a8 9002 	strh.w	r9, [r8, #2]
   44786:	f003 fd07 	bl	48198 <nrf_modem_os_trace_put>
   4478a:	4649      	mov	r1, r9
   4478c:	4650      	mov	r0, sl
   4478e:	f003 fd03 	bl	48198 <nrf_modem_os_trace_put>
   44792:	b19c      	cbz	r4, 447bc <trace_write+0x150>
   44794:	f886 b000 	strb.w	fp, [r6]
   44798:	7077      	strb	r7, [r6, #1]
   4479a:	782b      	ldrb	r3, [r5, #0]
   4479c:	2105      	movs	r1, #5
   4479e:	4630      	mov	r0, r6
   447a0:	7133      	strb	r3, [r6, #4]
   447a2:	8074      	strh	r4, [r6, #2]
   447a4:	f003 fcf8 	bl	48198 <nrf_modem_os_trace_put>
   447a8:	4621      	mov	r1, r4
   447aa:	68e8      	ldr	r0, [r5, #12]
   447ac:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   447b0:	f003 bcf2 	b.w	48198 <nrf_modem_os_trace_put>
   447b4:	4a04      	ldr	r2, [pc, #16]	; (447c8 <trace_write+0x15c>)
   447b6:	e7cd      	b.n	44754 <trace_write+0xe8>
   447b8:	4a04      	ldr	r2, [pc, #16]	; (447cc <trace_write+0x160>)
   447ba:	e7cb      	b.n	44754 <trace_write+0xe8>
   447bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   447c0:	2001ab3c 	.word	0x2001ab3c
   447c4:	2001adc0 	.word	0x2001adc0
   447c8:	2001adbc 	.word	0x2001adbc
   447cc:	2001adbe 	.word	0x2001adbe

000447d0 <ipc_trace_init>:
   447d0:	2300      	movs	r3, #0
   447d2:	4a08      	ldr	r2, [pc, #32]	; (447f4 <ipc_trace_init+0x24>)
   447d4:	b510      	push	{r4, lr}
   447d6:	8013      	strh	r3, [r2, #0]
   447d8:	4a07      	ldr	r2, [pc, #28]	; (447f8 <ipc_trace_init+0x28>)
   447da:	4604      	mov	r4, r0
   447dc:	8013      	strh	r3, [r2, #0]
   447de:	4a07      	ldr	r2, [pc, #28]	; (447fc <ipc_trace_init+0x2c>)
   447e0:	4807      	ldr	r0, [pc, #28]	; (44800 <ipc_trace_init+0x30>)
   447e2:	8013      	strh	r3, [r2, #0]
   447e4:	2201      	movs	r2, #1
   447e6:	4611      	mov	r1, r2
   447e8:	f7ff f922 	bl	43a30 <nrf_modem_os_sem_init>
   447ec:	4b05      	ldr	r3, [pc, #20]	; (44804 <ipc_trace_init+0x34>)
   447ee:	601c      	str	r4, [r3, #0]
   447f0:	bd10      	pop	{r4, pc}
   447f2:	bf00      	nop
   447f4:	2001adc0 	.word	0x2001adc0
   447f8:	2001adbc 	.word	0x2001adbc
   447fc:	2001adbe 	.word	0x2001adbe
   44800:	2001ab3c 	.word	0x2001ab3c
   44804:	2001ab38 	.word	0x2001ab38

00044808 <nrf_modem_trace_irq_handler>:
   44808:	b508      	push	{r3, lr}
   4480a:	4b10      	ldr	r3, [pc, #64]	; (4484c <nrf_modem_trace_irq_handler+0x44>)
   4480c:	781b      	ldrb	r3, [r3, #0]
   4480e:	b90b      	cbnz	r3, 44814 <nrf_modem_trace_irq_handler+0xc>
   44810:	f7ff f940 	bl	43a94 <nrf_modem_os_trace_irq_clear>
   44814:	4b0e      	ldr	r3, [pc, #56]	; (44850 <nrf_modem_trace_irq_handler+0x48>)
   44816:	6818      	ldr	r0, [r3, #0]
   44818:	6842      	ldr	r2, [r0, #4]
   4481a:	6883      	ldr	r3, [r0, #8]
   4481c:	429a      	cmp	r2, r3
   4481e:	d001      	beq.n	44824 <nrf_modem_trace_irq_handler+0x1c>
   44820:	f7ff ff24 	bl	4466c <trace_write>
   44824:	4b0b      	ldr	r3, [pc, #44]	; (44854 <nrf_modem_trace_irq_handler+0x4c>)
   44826:	6818      	ldr	r0, [r3, #0]
   44828:	6882      	ldr	r2, [r0, #8]
   4482a:	6843      	ldr	r3, [r0, #4]
   4482c:	429a      	cmp	r2, r3
   4482e:	d001      	beq.n	44834 <nrf_modem_trace_irq_handler+0x2c>
   44830:	f7ff ff1c 	bl	4466c <trace_write>
   44834:	4b08      	ldr	r3, [pc, #32]	; (44858 <nrf_modem_trace_irq_handler+0x50>)
   44836:	6818      	ldr	r0, [r3, #0]
   44838:	6882      	ldr	r2, [r0, #8]
   4483a:	6843      	ldr	r3, [r0, #4]
   4483c:	429a      	cmp	r2, r3
   4483e:	d003      	beq.n	44848 <nrf_modem_trace_irq_handler+0x40>
   44840:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   44844:	f7ff bf12 	b.w	4466c <trace_write>
   44848:	bd08      	pop	{r3, pc}
   4484a:	bf00      	nop
   4484c:	2001e9f3 	.word	0x2001e9f3
   44850:	2001ab34 	.word	0x2001ab34
   44854:	2001ab2c 	.word	0x2001ab2c
   44858:	2001ab30 	.word	0x2001ab30

0004485c <ipc_trace_handle>:
   4485c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44860:	4b43      	ldr	r3, [pc, #268]	; (44970 <ipc_trace_handle+0x114>)
   44862:	681b      	ldr	r3, [r3, #0]
   44864:	6919      	ldr	r1, [r3, #16]
   44866:	f8d3 a014 	ldr.w	sl, [r3, #20]
   4486a:	7c1a      	ldrb	r2, [r3, #16]
   4486c:	2200      	movs	r2, #0
   4486e:	741a      	strb	r2, [r3, #16]
   44870:	7c58      	ldrb	r0, [r3, #17]
   44872:	745a      	strb	r2, [r3, #17]
   44874:	7c98      	ldrb	r0, [r3, #18]
   44876:	749a      	strb	r2, [r3, #18]
   44878:	7cd8      	ldrb	r0, [r3, #19]
   4487a:	74da      	strb	r2, [r3, #19]
   4487c:	7d18      	ldrb	r0, [r3, #20]
   4487e:	751a      	strb	r2, [r3, #20]
   44880:	7d58      	ldrb	r0, [r3, #21]
   44882:	755a      	strb	r2, [r3, #21]
   44884:	7d98      	ldrb	r0, [r3, #22]
   44886:	759a      	strb	r2, [r3, #22]
   44888:	7dd8      	ldrb	r0, [r3, #23]
   4488a:	75da      	strb	r2, [r3, #23]
   4488c:	2900      	cmp	r1, #0
   4488e:	d033      	beq.n	448f8 <ipc_trace_handle+0x9c>
   44890:	3901      	subs	r1, #1
   44892:	2903      	cmp	r1, #3
   44894:	d830      	bhi.n	448f8 <ipc_trace_handle+0x9c>
   44896:	e8df f001 	tbb	[pc, r1]
   4489a:	6502      	.short	0x6502
   4489c:	534c      	.short	0x534c
   4489e:	4a35      	ldr	r2, [pc, #212]	; (44974 <ipc_trace_handle+0x118>)
   448a0:	7811      	ldrb	r1, [r2, #0]
   448a2:	b109      	cbz	r1, 448a8 <ipc_trace_handle+0x4c>
   448a4:	2100      	movs	r1, #0
   448a6:	7011      	strb	r1, [r2, #0]
   448a8:	2200      	movs	r2, #0
   448aa:	4691      	mov	r9, r2
   448ac:	4617      	mov	r7, r2
   448ae:	4614      	mov	r4, r2
   448b0:	4d31      	ldr	r5, [pc, #196]	; (44978 <ipc_trace_handle+0x11c>)
   448b2:	4932      	ldr	r1, [pc, #200]	; (4497c <ipc_trace_handle+0x120>)
   448b4:	4832      	ldr	r0, [pc, #200]	; (44980 <ipc_trace_handle+0x124>)
   448b6:	f8d5 e000 	ldr.w	lr, [r5]
   448ba:	f8d1 8000 	ldr.w	r8, [r1]
   448be:	6806      	ldr	r6, [r0, #0]
   448c0:	f8da b008 	ldr.w	fp, [sl, #8]
   448c4:	9501      	str	r5, [sp, #4]
   448c6:	45a3      	cmp	fp, r4
   448c8:	d119      	bne.n	448fe <ipc_trace_handle+0xa2>
   448ca:	b107      	cbz	r7, 448ce <ipc_trace_handle+0x72>
   448cc:	6006      	str	r6, [r0, #0]
   448ce:	f1b9 0f00 	cmp.w	r9, #0
   448d2:	d001      	beq.n	448d8 <ipc_trace_handle+0x7c>
   448d4:	f8c1 8000 	str.w	r8, [r1]
   448d8:	b112      	cbz	r2, 448e0 <ipc_trace_handle+0x84>
   448da:	9a01      	ldr	r2, [sp, #4]
   448dc:	f8c2 e000 	str.w	lr, [r2]
   448e0:	7a1a      	ldrb	r2, [r3, #8]
   448e2:	2101      	movs	r1, #1
   448e4:	2200      	movs	r2, #0
   448e6:	7219      	strb	r1, [r3, #8]
   448e8:	7a59      	ldrb	r1, [r3, #9]
   448ea:	725a      	strb	r2, [r3, #9]
   448ec:	7a99      	ldrb	r1, [r3, #10]
   448ee:	729a      	strb	r2, [r3, #10]
   448f0:	7ada      	ldrb	r2, [r3, #11]
   448f2:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   448f6:	72da      	strb	r2, [r3, #11]
   448f8:	b003      	add	sp, #12
   448fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   448fe:	1ca5      	adds	r5, r4, #2
   44900:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   44904:	686d      	ldr	r5, [r5, #4]
   44906:	f895 c000 	ldrb.w	ip, [r5]
   4490a:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   4490e:	d009      	beq.n	44924 <ipc_trace_handle+0xc8>
   44910:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   44914:	d00a      	beq.n	4492c <ipc_trace_handle+0xd0>
   44916:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   4491a:	bf04      	itt	eq
   4491c:	462e      	moveq	r6, r5
   4491e:	2701      	moveq	r7, #1
   44920:	3401      	adds	r4, #1
   44922:	e7d0      	b.n	448c6 <ipc_trace_handle+0x6a>
   44924:	46a8      	mov	r8, r5
   44926:	f04f 0901 	mov.w	r9, #1
   4492a:	e7f9      	b.n	44920 <ipc_trace_handle+0xc4>
   4492c:	46ae      	mov	lr, r5
   4492e:	2201      	movs	r2, #1
   44930:	e7f6      	b.n	44920 <ipc_trace_handle+0xc4>
   44932:	2101      	movs	r1, #1
   44934:	4a0f      	ldr	r2, [pc, #60]	; (44974 <ipc_trace_handle+0x118>)
   44936:	7011      	strb	r1, [r2, #0]
   44938:	7a1a      	ldrb	r2, [r3, #8]
   4493a:	2103      	movs	r1, #3
   4493c:	2200      	movs	r2, #0
   4493e:	e7d2      	b.n	448e6 <ipc_trace_handle+0x8a>
   44940:	7a19      	ldrb	r1, [r3, #8]
   44942:	2104      	movs	r1, #4
   44944:	7219      	strb	r1, [r3, #8]
   44946:	7a59      	ldrb	r1, [r3, #9]
   44948:	725a      	strb	r2, [r3, #9]
   4494a:	7a99      	ldrb	r1, [r3, #10]
   4494c:	729a      	strb	r2, [r3, #10]
   4494e:	7ad9      	ldrb	r1, [r3, #11]
   44950:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   44954:	72d9      	strb	r1, [r3, #11]
   44956:	4b07      	ldr	r3, [pc, #28]	; (44974 <ipc_trace_handle+0x118>)
   44958:	701a      	strb	r2, [r3, #0]
   4495a:	b003      	add	sp, #12
   4495c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44960:	f7ff bf52 	b.w	44808 <nrf_modem_trace_irq_handler>
   44964:	b003      	add	sp, #12
   44966:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4496a:	f7ff b88b 	b.w	43a84 <nrf_modem_os_trace_irq_set>
   4496e:	bf00      	nop
   44970:	2001ab38 	.word	0x2001ab38
   44974:	2001e9f3 	.word	0x2001e9f3
   44978:	2001ab30 	.word	0x2001ab30
   4497c:	2001ab2c 	.word	0x2001ab2c
   44980:	2001ab34 	.word	0x2001ab34

00044984 <rpc_trace_coredump_in_progress>:
   44984:	4b01      	ldr	r3, [pc, #4]	; (4498c <rpc_trace_coredump_in_progress+0x8>)
   44986:	7818      	ldrb	r0, [r3, #0]
   44988:	4770      	bx	lr
   4498a:	bf00      	nop
   4498c:	2001e9f3 	.word	0x2001e9f3

00044990 <handle_modem_rpc_msg>:
   44990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44994:	4606      	mov	r6, r0
   44996:	460f      	mov	r7, r1
   44998:	2500      	movs	r5, #0
   4499a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 44a10 <handle_modem_rpc_msg+0x80>
   4499e:	6833      	ldr	r3, [r6, #0]
   449a0:	42ab      	cmp	r3, r5
   449a2:	d801      	bhi.n	449a8 <handle_modem_rpc_msg+0x18>
   449a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   449a8:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   449ac:	68a3      	ldr	r3, [r4, #8]
   449ae:	b1fb      	cbz	r3, 449f0 <handle_modem_rpc_msg+0x60>
   449b0:	6863      	ldr	r3, [r4, #4]
   449b2:	b2db      	uxtb	r3, r3
   449b4:	2b01      	cmp	r3, #1
   449b6:	d11b      	bne.n	449f0 <handle_modem_rpc_msg+0x60>
   449b8:	6862      	ldr	r2, [r4, #4]
   449ba:	f8b8 3000 	ldrh.w	r3, [r8]
   449be:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   449c2:	d115      	bne.n	449f0 <handle_modem_rpc_msg+0x60>
   449c4:	2f02      	cmp	r7, #2
   449c6:	68a0      	ldr	r0, [r4, #8]
   449c8:	d114      	bne.n	449f4 <handle_modem_rpc_msg+0x64>
   449ca:	f7ff fe2d 	bl	44628 <rpc_handle_data_message>
   449ce:	2802      	cmp	r0, #2
   449d0:	d00e      	beq.n	449f0 <handle_modem_rpc_msg+0x60>
   449d2:	2801      	cmp	r0, #1
   449d4:	d113      	bne.n	449fe <handle_modem_rpc_msg+0x6e>
   449d6:	6863      	ldr	r3, [r4, #4]
   449d8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   449dc:	f043 0302 	orr.w	r3, r3, #2
   449e0:	6063      	str	r3, [r4, #4]
   449e2:	f8b8 3000 	ldrh.w	r3, [r8]
   449e6:	3301      	adds	r3, #1
   449e8:	f8a8 3000 	strh.w	r3, [r8]
   449ec:	f7ff f83a 	bl	43a64 <nrf_modem_os_application_irq_set>
   449f0:	3501      	adds	r5, #1
   449f2:	e7d4      	b.n	4499e <handle_modem_rpc_msg+0xe>
   449f4:	6801      	ldr	r1, [r0, #0]
   449f6:	0c09      	lsrs	r1, r1, #16
   449f8:	f003 fbe9 	bl	481ce <rpc_handle_ctrl_message>
   449fc:	e7e7      	b.n	449ce <handle_modem_rpc_msg+0x3e>
   449fe:	2800      	cmp	r0, #0
   44a00:	d1ef      	bne.n	449e2 <handle_modem_rpc_msg+0x52>
   44a02:	6863      	ldr	r3, [r4, #4]
   44a04:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44a08:	f043 0303 	orr.w	r3, r3, #3
   44a0c:	e7e8      	b.n	449e0 <handle_modem_rpc_msg+0x50>
   44a0e:	bf00      	nop
   44a10:	2001adc2 	.word	0x2001adc2

00044a14 <rpc_transport_ipc_msg_alloc>:
   44a14:	b570      	push	{r4, r5, r6, lr}
   44a16:	4616      	mov	r6, r2
   44a18:	2400      	movs	r4, #0
   44a1a:	6803      	ldr	r3, [r0, #0]
   44a1c:	42a3      	cmp	r3, r4
   44a1e:	d101      	bne.n	44a24 <rpc_transport_ipc_msg_alloc+0x10>
   44a20:	2300      	movs	r3, #0
   44a22:	e01c      	b.n	44a5e <rpc_transport_ipc_msg_alloc+0x4a>
   44a24:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   44a28:	6855      	ldr	r5, [r2, #4]
   44a2a:	b2ed      	uxtb	r5, r5
   44a2c:	2d03      	cmp	r5, #3
   44a2e:	d118      	bne.n	44a62 <rpc_transport_ipc_msg_alloc+0x4e>
   44a30:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   44a34:	6093      	str	r3, [r2, #8]
   44a36:	6851      	ldr	r1, [r2, #4]
   44a38:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   44a3c:	6051      	str	r1, [r2, #4]
   44a3e:	490c      	ldr	r1, [pc, #48]	; (44a70 <rpc_transport_ipc_msg_alloc+0x5c>)
   44a40:	8808      	ldrh	r0, [r1, #0]
   44a42:	1c44      	adds	r4, r0, #1
   44a44:	800c      	strh	r4, [r1, #0]
   44a46:	6851      	ldr	r1, [r2, #4]
   44a48:	b289      	uxth	r1, r1
   44a4a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   44a4e:	6051      	str	r1, [r2, #4]
   44a50:	4618      	mov	r0, r3
   44a52:	2240      	movs	r2, #64	; 0x40
   44a54:	2100      	movs	r1, #0
   44a56:	f003 fa0d 	bl	47e74 <memset>
   44a5a:	4603      	mov	r3, r0
   44a5c:	6046      	str	r6, [r0, #4]
   44a5e:	4618      	mov	r0, r3
   44a60:	bd70      	pop	{r4, r5, r6, pc}
   44a62:	b915      	cbnz	r5, 44a6a <rpc_transport_ipc_msg_alloc+0x56>
   44a64:	6895      	ldr	r5, [r2, #8]
   44a66:	2d00      	cmp	r5, #0
   44a68:	d0e2      	beq.n	44a30 <rpc_transport_ipc_msg_alloc+0x1c>
   44a6a:	3401      	adds	r4, #1
   44a6c:	e7d6      	b.n	44a1c <rpc_transport_ipc_msg_alloc+0x8>
   44a6e:	bf00      	nop
   44a70:	2001adc4 	.word	0x2001adc4

00044a74 <rpc_transport_ipc_data_msg_send>:
   44a74:	b508      	push	{r3, lr}
   44a76:	4b0b      	ldr	r3, [pc, #44]	; (44aa4 <rpc_transport_ipc_data_msg_send+0x30>)
   44a78:	681b      	ldr	r3, [r3, #0]
   44a7a:	1ac0      	subs	r0, r0, r3
   44a7c:	4b0a      	ldr	r3, [pc, #40]	; (44aa8 <rpc_transport_ipc_data_msg_send+0x34>)
   44a7e:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44a82:	681b      	ldr	r3, [r3, #0]
   44a84:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44a88:	6843      	ldr	r3, [r0, #4]
   44a8a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44a8e:	f043 0301 	orr.w	r3, r3, #1
   44a92:	6043      	str	r3, [r0, #4]
   44a94:	2003      	movs	r0, #3
   44a96:	f003 fb5c 	bl	48152 <nrf_modem_os_busywait>
   44a9a:	2201      	movs	r2, #1
   44a9c:	4b03      	ldr	r3, [pc, #12]	; (44aac <rpc_transport_ipc_data_msg_send+0x38>)
   44a9e:	601a      	str	r2, [r3, #0]
   44aa0:	bd08      	pop	{r3, pc}
   44aa2:	bf00      	nop
   44aa4:	2001ab58 	.word	0x2001ab58
   44aa8:	2001ab5c 	.word	0x2001ab5c
   44aac:	4002a00c 	.word	0x4002a00c

00044ab0 <rpc_transport_ipc_ctrl_msg_send>:
   44ab0:	b508      	push	{r3, lr}
   44ab2:	4b0b      	ldr	r3, [pc, #44]	; (44ae0 <rpc_transport_ipc_ctrl_msg_send+0x30>)
   44ab4:	681b      	ldr	r3, [r3, #0]
   44ab6:	1ac0      	subs	r0, r0, r3
   44ab8:	4b0a      	ldr	r3, [pc, #40]	; (44ae4 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   44aba:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44abe:	681b      	ldr	r3, [r3, #0]
   44ac0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44ac4:	6843      	ldr	r3, [r0, #4]
   44ac6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44aca:	f043 0301 	orr.w	r3, r3, #1
   44ace:	6043      	str	r3, [r0, #4]
   44ad0:	2003      	movs	r0, #3
   44ad2:	f003 fb3e 	bl	48152 <nrf_modem_os_busywait>
   44ad6:	2201      	movs	r2, #1
   44ad8:	4b03      	ldr	r3, [pc, #12]	; (44ae8 <rpc_transport_ipc_ctrl_msg_send+0x38>)
   44ada:	601a      	str	r2, [r3, #0]
   44adc:	bd08      	pop	{r3, pc}
   44ade:	bf00      	nop
   44ae0:	2001ab50 	.word	0x2001ab50
   44ae4:	2001ab54 	.word	0x2001ab54
   44ae8:	4002a004 	.word	0x4002a004

00044aec <rpc_transport_ipc_data_msg_alloc>:
   44aec:	4b05      	ldr	r3, [pc, #20]	; (44b04 <rpc_transport_ipc_data_msg_alloc+0x18>)
   44aee:	781b      	ldrb	r3, [r3, #0]
   44af0:	b933      	cbnz	r3, 44b00 <rpc_transport_ipc_data_msg_alloc+0x14>
   44af2:	4b05      	ldr	r3, [pc, #20]	; (44b08 <rpc_transport_ipc_data_msg_alloc+0x1c>)
   44af4:	2202      	movs	r2, #2
   44af6:	6819      	ldr	r1, [r3, #0]
   44af8:	4b04      	ldr	r3, [pc, #16]	; (44b0c <rpc_transport_ipc_data_msg_alloc+0x20>)
   44afa:	6818      	ldr	r0, [r3, #0]
   44afc:	f7ff bf8a 	b.w	44a14 <rpc_transport_ipc_msg_alloc>
   44b00:	2000      	movs	r0, #0
   44b02:	4770      	bx	lr
   44b04:	2001e9f5 	.word	0x2001e9f5
   44b08:	2001ab58 	.word	0x2001ab58
   44b0c:	2001ab5c 	.word	0x2001ab5c

00044b10 <rpc_transport_ipc_ctrl_msg_alloc>:
   44b10:	230a      	movs	r3, #10
   44b12:	b537      	push	{r0, r1, r2, r4, r5, lr}
   44b14:	4c0c      	ldr	r4, [pc, #48]	; (44b48 <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   44b16:	4d0d      	ldr	r5, [pc, #52]	; (44b4c <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   44b18:	9301      	str	r3, [sp, #4]
   44b1a:	2201      	movs	r2, #1
   44b1c:	6821      	ldr	r1, [r4, #0]
   44b1e:	6828      	ldr	r0, [r5, #0]
   44b20:	f7ff ff78 	bl	44a14 <rpc_transport_ipc_msg_alloc>
   44b24:	b968      	cbnz	r0, 44b42 <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   44b26:	f003 fb16 	bl	48156 <nrf_modem_os_is_in_isr>
   44b2a:	b918      	cbnz	r0, 44b34 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   44b2c:	a901      	add	r1, sp, #4
   44b2e:	f7fe fee1 	bl	438f4 <nrf_modem_os_timedwait>
   44b32:	e7f2      	b.n	44b1a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44b34:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   44b38:	9b01      	ldr	r3, [sp, #4]
   44b3a:	4358      	muls	r0, r3
   44b3c:	f003 fb09 	bl	48152 <nrf_modem_os_busywait>
   44b40:	e7eb      	b.n	44b1a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44b42:	b003      	add	sp, #12
   44b44:	bd30      	pop	{r4, r5, pc}
   44b46:	bf00      	nop
   44b48:	2001ab50 	.word	0x2001ab50
   44b4c:	2001ab54 	.word	0x2001ab54

00044b50 <rpc_transport_ipc_data_alloc>:
   44b50:	4b03      	ldr	r3, [pc, #12]	; (44b60 <rpc_transport_ipc_data_alloc+0x10>)
   44b52:	781b      	ldrb	r3, [r3, #0]
   44b54:	b90b      	cbnz	r3, 44b5a <rpc_transport_ipc_data_alloc+0xa>
   44b56:	f7fe bfb3 	b.w	43ac0 <nrf_modem_os_shm_tx_alloc>
   44b5a:	2000      	movs	r0, #0
   44b5c:	4770      	bx	lr
   44b5e:	bf00      	nop
   44b60:	2001e9f5 	.word	0x2001e9f5

00044b64 <nrf_modem_application_irq_handler>:
   44b64:	b510      	push	{r4, lr}
   44b66:	4c06      	ldr	r4, [pc, #24]	; (44b80 <nrf_modem_application_irq_handler+0x1c>)
   44b68:	f7fe ff84 	bl	43a74 <nrf_modem_os_application_irq_clear>
   44b6c:	6820      	ldr	r0, [r4, #0]
   44b6e:	2101      	movs	r1, #1
   44b70:	f7ff ff0e 	bl	44990 <handle_modem_rpc_msg>
   44b74:	6860      	ldr	r0, [r4, #4]
   44b76:	2102      	movs	r1, #2
   44b78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   44b7c:	f7ff bf08 	b.w	44990 <handle_modem_rpc_msg>
   44b80:	2001ab44 	.word	0x2001ab44

00044b84 <rpc_transport_ipc_msg_free>:
   44b84:	2300      	movs	r3, #0
   44b86:	4911      	ldr	r1, [pc, #68]	; (44bcc <rpc_transport_ipc_msg_free+0x48>)
   44b88:	b530      	push	{r4, r5, lr}
   44b8a:	680a      	ldr	r2, [r1, #0]
   44b8c:	6814      	ldr	r4, [r2, #0]
   44b8e:	42a3      	cmp	r3, r4
   44b90:	d10b      	bne.n	44baa <rpc_transport_ipc_msg_free+0x26>
   44b92:	2300      	movs	r3, #0
   44b94:	684a      	ldr	r2, [r1, #4]
   44b96:	6811      	ldr	r1, [r2, #0]
   44b98:	428b      	cmp	r3, r1
   44b9a:	d015      	beq.n	44bc8 <rpc_transport_ipc_msg_free+0x44>
   44b9c:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   44ba0:	68a4      	ldr	r4, [r4, #8]
   44ba2:	42a0      	cmp	r0, r4
   44ba4:	d008      	beq.n	44bb8 <rpc_transport_ipc_msg_free+0x34>
   44ba6:	3301      	adds	r3, #1
   44ba8:	e7f6      	b.n	44b98 <rpc_transport_ipc_msg_free+0x14>
   44baa:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   44bae:	68ad      	ldr	r5, [r5, #8]
   44bb0:	42a8      	cmp	r0, r5
   44bb2:	d001      	beq.n	44bb8 <rpc_transport_ipc_msg_free+0x34>
   44bb4:	3301      	adds	r3, #1
   44bb6:	e7ea      	b.n	44b8e <rpc_transport_ipc_msg_free+0xa>
   44bb8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   44bbc:	685a      	ldr	r2, [r3, #4]
   44bbe:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   44bc2:	f042 0203 	orr.w	r2, r2, #3
   44bc6:	605a      	str	r2, [r3, #4]
   44bc8:	bd30      	pop	{r4, r5, pc}
   44bca:	bf00      	nop
   44bcc:	2001ab44 	.word	0x2001ab44

00044bd0 <rpc_transport_ipc_init>:
   44bd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44bd4:	2200      	movs	r2, #0
   44bd6:	b095      	sub	sp, #84	; 0x54
   44bd8:	4605      	mov	r5, r0
   44bda:	494d      	ldr	r1, [pc, #308]	; (44d10 <rpc_transport_ipc_init+0x140>)
   44bdc:	7900      	ldrb	r0, [r0, #4]
   44bde:	f7ff fc15 	bl	4440c <nrfx_ipc_init>
   44be2:	2238      	movs	r2, #56	; 0x38
   44be4:	2100      	movs	r1, #0
   44be6:	a803      	add	r0, sp, #12
   44be8:	f003 f944 	bl	47e74 <memset>
   44bec:	2302      	movs	r3, #2
   44bee:	9304      	str	r3, [sp, #16]
   44bf0:	2308      	movs	r3, #8
   44bf2:	9306      	str	r3, [sp, #24]
   44bf4:	2320      	movs	r3, #32
   44bf6:	9308      	str	r3, [sp, #32]
   44bf8:	2301      	movs	r3, #1
   44bfa:	930b      	str	r3, [sp, #44]	; 0x2c
   44bfc:	2304      	movs	r3, #4
   44bfe:	930d      	str	r3, [sp, #52]	; 0x34
   44c00:	2310      	movs	r3, #16
   44c02:	f04f 0c40 	mov.w	ip, #64	; 0x40
   44c06:	930f      	str	r3, [sp, #60]	; 0x3c
   44c08:	2380      	movs	r3, #128	; 0x80
   44c0a:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   44c0e:	23d5      	movs	r3, #213	; 0xd5
   44c10:	a803      	add	r0, sp, #12
   44c12:	9313      	str	r3, [sp, #76]	; 0x4c
   44c14:	f7ff fc12 	bl	4443c <nrfx_ipc_config_load>
   44c18:	682b      	ldr	r3, [r5, #0]
   44c1a:	2100      	movs	r1, #0
   44c1c:	685a      	ldr	r2, [r3, #4]
   44c1e:	6818      	ldr	r0, [r3, #0]
   44c20:	f003 f928 	bl	47e74 <memset>
   44c24:	682a      	ldr	r2, [r5, #0]
   44c26:	6814      	ldr	r4, [r2, #0]
   44c28:	69d3      	ldr	r3, [r2, #28]
   44c2a:	f104 0660 	add.w	r6, r4, #96	; 0x60
   44c2e:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   44c32:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   44c36:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   44c3a:	f104 0920 	add.w	r9, r4, #32
   44c3e:	2b00      	cmp	r3, #0
   44c40:	d060      	beq.n	44d04 <rpc_transport_ipc_init+0x134>
   44c42:	f104 0840 	add.w	r8, r4, #64	; 0x40
   44c46:	4933      	ldr	r1, [pc, #204]	; (44d14 <rpc_transport_ipc_init+0x144>)
   44c48:	f8c1 9000 	str.w	r9, [r1]
   44c4c:	b13b      	cbz	r3, 44c5e <rpc_transport_ipc_init+0x8e>
   44c4e:	6992      	ldr	r2, [r2, #24]
   44c50:	4640      	mov	r0, r8
   44c52:	f8c8 2004 	str.w	r2, [r8, #4]
   44c56:	f8c8 3000 	str.w	r3, [r8]
   44c5a:	f7ff fdb9 	bl	447d0 <ipc_trace_init>
   44c5e:	6828      	ldr	r0, [r5, #0]
   44c60:	2300      	movs	r3, #0
   44c62:	6902      	ldr	r2, [r0, #16]
   44c64:	2101      	movs	r1, #1
   44c66:	6062      	str	r2, [r4, #4]
   44c68:	6942      	ldr	r2, [r0, #20]
   44c6a:	70a1      	strb	r1, [r4, #2]
   44c6c:	60a2      	str	r2, [r4, #8]
   44c6e:	4a2a      	ldr	r2, [pc, #168]	; (44d18 <rpc_transport_ipc_init+0x148>)
   44c70:	7023      	strb	r3, [r4, #0]
   44c72:	6017      	str	r7, [r2, #0]
   44c74:	4a29      	ldr	r2, [pc, #164]	; (44d1c <rpc_transport_ipc_init+0x14c>)
   44c76:	7063      	strb	r3, [r4, #1]
   44c78:	6016      	str	r6, [r2, #0]
   44c7a:	2208      	movs	r2, #8
   44c7c:	70e3      	strb	r3, [r4, #3]
   44c7e:	60e6      	str	r6, [r4, #12]
   44c80:	6127      	str	r7, [r4, #16]
   44c82:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   44c86:	f8c4 9014 	str.w	r9, [r4, #20]
   44c8a:	f8c4 8018 	str.w	r8, [r4, #24]
   44c8e:	707b      	strb	r3, [r7, #1]
   44c90:	70bb      	strb	r3, [r7, #2]
   44c92:	70fb      	strb	r3, [r7, #3]
   44c94:	2714      	movs	r7, #20
   44c96:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   44c9a:	4a21      	ldr	r2, [pc, #132]	; (44d20 <rpc_transport_ipc_init+0x150>)
   44c9c:	4d21      	ldr	r5, [pc, #132]	; (44d24 <rpc_transport_ipc_init+0x154>)
   44c9e:	f8c2 b000 	str.w	fp, [r2]
   44ca2:	4a21      	ldr	r2, [pc, #132]	; (44d28 <rpc_transport_ipc_init+0x158>)
   44ca4:	7073      	strb	r3, [r6, #1]
   44ca6:	f8c2 a000 	str.w	sl, [r2]
   44caa:	4a20      	ldr	r2, [pc, #128]	; (44d2c <rpc_transport_ipc_init+0x15c>)
   44cac:	70b3      	strb	r3, [r6, #2]
   44cae:	70f3      	strb	r3, [r6, #3]
   44cb0:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   44cb4:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   44cb8:	4c1d      	ldr	r4, [pc, #116]	; (44d30 <rpc_transport_ipc_init+0x160>)
   44cba:	7029      	strb	r1, [r5, #0]
   44cbc:	491d      	ldr	r1, [pc, #116]	; (44d34 <rpc_transport_ipc_init+0x164>)
   44cbe:	6023      	str	r3, [r4, #0]
   44cc0:	9302      	str	r3, [sp, #8]
   44cc2:	600b      	str	r3, [r1, #0]
   44cc4:	680b      	ldr	r3, [r1, #0]
   44cc6:	4e1c      	ldr	r6, [pc, #112]	; (44d38 <rpc_transport_ipc_init+0x168>)
   44cc8:	9302      	str	r3, [sp, #8]
   44cca:	9b02      	ldr	r3, [sp, #8]
   44ccc:	2000      	movs	r0, #0
   44cce:	a901      	add	r1, sp, #4
   44cd0:	9701      	str	r7, [sp, #4]
   44cd2:	f7fe fe0f 	bl	438f4 <nrf_modem_os_timedwait>
   44cd6:	9b01      	ldr	r3, [sp, #4]
   44cd8:	3b14      	subs	r3, #20
   44cda:	441e      	add	r6, r3
   44cdc:	782b      	ldrb	r3, [r5, #0]
   44cde:	2b01      	cmp	r3, #1
   44ce0:	d104      	bne.n	44cec <rpc_transport_ipc_init+0x11c>
   44ce2:	2e00      	cmp	r6, #0
   44ce4:	d1f2      	bne.n	44ccc <rpc_transport_ipc_init+0xfc>
   44ce6:	f06f 0373 	mvn.w	r3, #115	; 0x73
   44cea:	6023      	str	r3, [r4, #0]
   44cec:	6824      	ldr	r4, [r4, #0]
   44cee:	b95c      	cbnz	r4, 44d08 <rpc_transport_ipc_init+0x138>
   44cf0:	4b12      	ldr	r3, [pc, #72]	; (44d3c <rpc_transport_ipc_init+0x16c>)
   44cf2:	701c      	strb	r4, [r3, #0]
   44cf4:	4b12      	ldr	r3, [pc, #72]	; (44d40 <rpc_transport_ipc_init+0x170>)
   44cf6:	801c      	strh	r4, [r3, #0]
   44cf8:	4b12      	ldr	r3, [pc, #72]	; (44d44 <rpc_transport_ipc_init+0x174>)
   44cfa:	801c      	strh	r4, [r3, #0]
   44cfc:	4620      	mov	r0, r4
   44cfe:	b015      	add	sp, #84	; 0x54
   44d00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44d04:	4698      	mov	r8, r3
   44d06:	e79e      	b.n	44c46 <rpc_transport_ipc_init+0x76>
   44d08:	f7ff fbb8 	bl	4447c <nrfx_ipc_uninit>
   44d0c:	e7f6      	b.n	44cfc <rpc_transport_ipc_init+0x12c>
   44d0e:	bf00      	nop
   44d10:	00044d49 	.word	0x00044d49
   44d14:	2001ab4c 	.word	0x2001ab4c
   44d18:	2001ab5c 	.word	0x2001ab5c
   44d1c:	2001ab54 	.word	0x2001ab54
   44d20:	2001ab58 	.word	0x2001ab58
   44d24:	2001e9f4 	.word	0x2001e9f4
   44d28:	2001ab50 	.word	0x2001ab50
   44d2c:	4002a000 	.word	0x4002a000
   44d30:	2001ab40 	.word	0x2001ab40
   44d34:	40005610 	.word	0x40005610
   44d38:	000249f0 	.word	0x000249f0
   44d3c:	2001e9f5 	.word	0x2001e9f5
   44d40:	2001adc4 	.word	0x2001adc4
   44d44:	2001adc2 	.word	0x2001adc2

00044d48 <ipc_irq_handler>:
   44d48:	b570      	push	{r4, r5, r6, lr}
   44d4a:	4604      	mov	r4, r0
   44d4c:	0620      	lsls	r0, r4, #24
   44d4e:	d50c      	bpl.n	44d6a <ipc_irq_handler+0x22>
   44d50:	f7ff fd84 	bl	4485c <ipc_trace_handle>
   44d54:	f7ff fe16 	bl	44984 <rpc_trace_coredump_in_progress>
   44d58:	b138      	cbz	r0, 44d6a <ipc_irq_handler+0x22>
   44d5a:	22e0      	movs	r2, #224	; 0xe0
   44d5c:	4b3e      	ldr	r3, [pc, #248]	; (44e58 <ipc_irq_handler+0x110>)
   44d5e:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   44d62:	f44f 6280 	mov.w	r2, #1024	; 0x400
   44d66:	605a      	str	r2, [r3, #4]
   44d68:	bd70      	pop	{r4, r5, r6, pc}
   44d6a:	07e1      	lsls	r1, r4, #31
   44d6c:	d548      	bpl.n	44e00 <ipc_irq_handler+0xb8>
   44d6e:	f248 0202 	movw	r2, #32770	; 0x8002
   44d72:	4b3a      	ldr	r3, [pc, #232]	; (44e5c <ipc_irq_handler+0x114>)
   44d74:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   44d78:	4293      	cmp	r3, r2
   44d7a:	d035      	beq.n	44de8 <ipc_irq_handler+0xa0>
   44d7c:	d81b      	bhi.n	44db6 <ipc_irq_handler+0x6e>
   44d7e:	f243 0232 	movw	r2, #12338	; 0x3032
   44d82:	4293      	cmp	r3, r2
   44d84:	d036      	beq.n	44df4 <ipc_irq_handler+0xac>
   44d86:	d80b      	bhi.n	44da0 <ipc_irq_handler+0x58>
   44d88:	3b01      	subs	r3, #1
   44d8a:	2b01      	cmp	r3, #1
   44d8c:	d8ec      	bhi.n	44d68 <ipc_irq_handler+0x20>
   44d8e:	2203      	movs	r2, #3
   44d90:	200e      	movs	r0, #14
   44d92:	4b33      	ldr	r3, [pc, #204]	; (44e60 <ipc_irq_handler+0x118>)
   44d94:	701a      	strb	r2, [r3, #0]
   44d96:	4b33      	ldr	r3, [pc, #204]	; (44e64 <ipc_irq_handler+0x11c>)
   44d98:	6018      	str	r0, [r3, #0]
   44d9a:	f003 fae6 	bl	4836a <rpc_transport_ipc_fault_handler>
   44d9e:	e7e3      	b.n	44d68 <ipc_irq_handler+0x20>
   44da0:	f248 0201 	movw	r2, #32769	; 0x8001
   44da4:	4293      	cmp	r3, r2
   44da6:	d1df      	bne.n	44d68 <ipc_irq_handler+0x20>
   44da8:	2203      	movs	r2, #3
   44daa:	4b2d      	ldr	r3, [pc, #180]	; (44e60 <ipc_irq_handler+0x118>)
   44dac:	701a      	strb	r2, [r3, #0]
   44dae:	2216      	movs	r2, #22
   44db0:	4b2c      	ldr	r3, [pc, #176]	; (44e64 <ipc_irq_handler+0x11c>)
   44db2:	601a      	str	r2, [r3, #0]
   44db4:	e7d8      	b.n	44d68 <ipc_irq_handler+0x20>
   44db6:	4a2c      	ldr	r2, [pc, #176]	; (44e68 <ipc_irq_handler+0x120>)
   44db8:	4293      	cmp	r3, r2
   44dba:	d80c      	bhi.n	44dd6 <ipc_irq_handler+0x8e>
   44dbc:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   44dc0:	d80c      	bhi.n	44ddc <ipc_irq_handler+0x94>
   44dc2:	f248 0203 	movw	r2, #32771	; 0x8003
   44dc6:	4293      	cmp	r3, r2
   44dc8:	d1ce      	bne.n	44d68 <ipc_irq_handler+0x20>
   44dca:	2203      	movs	r2, #3
   44dcc:	4b24      	ldr	r3, [pc, #144]	; (44e60 <ipc_irq_handler+0x118>)
   44dce:	701a      	strb	r2, [r3, #0]
   44dd0:	220c      	movs	r2, #12
   44dd2:	4b24      	ldr	r3, [pc, #144]	; (44e64 <ipc_irq_handler+0x11c>)
   44dd4:	e7ed      	b.n	44db2 <ipc_irq_handler+0x6a>
   44dd6:	4a25      	ldr	r2, [pc, #148]	; (44e6c <ipc_irq_handler+0x124>)
   44dd8:	4293      	cmp	r3, r2
   44dda:	d1c5      	bne.n	44d68 <ipc_irq_handler+0x20>
   44ddc:	2103      	movs	r1, #3
   44dde:	4a20      	ldr	r2, [pc, #128]	; (44e60 <ipc_irq_handler+0x118>)
   44de0:	7011      	strb	r1, [r2, #0]
   44de2:	4a20      	ldr	r2, [pc, #128]	; (44e64 <ipc_irq_handler+0x11c>)
   44de4:	6013      	str	r3, [r2, #0]
   44de6:	e7bf      	b.n	44d68 <ipc_irq_handler+0x20>
   44de8:	2203      	movs	r2, #3
   44dea:	4b1d      	ldr	r3, [pc, #116]	; (44e60 <ipc_irq_handler+0x118>)
   44dec:	701a      	strb	r2, [r3, #0]
   44dee:	225f      	movs	r2, #95	; 0x5f
   44df0:	4b1c      	ldr	r3, [pc, #112]	; (44e64 <ipc_irq_handler+0x11c>)
   44df2:	e7de      	b.n	44db2 <ipc_irq_handler+0x6a>
   44df4:	2203      	movs	r2, #3
   44df6:	4b1a      	ldr	r3, [pc, #104]	; (44e60 <ipc_irq_handler+0x118>)
   44df8:	701a      	strb	r2, [r3, #0]
   44dfa:	2205      	movs	r2, #5
   44dfc:	4b19      	ldr	r3, [pc, #100]	; (44e64 <ipc_irq_handler+0x11c>)
   44dfe:	e7d8      	b.n	44db2 <ipc_irq_handler+0x6a>
   44e00:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   44e04:	d003      	beq.n	44e0e <ipc_irq_handler+0xc6>
   44e06:	2202      	movs	r2, #2
   44e08:	4b15      	ldr	r3, [pc, #84]	; (44e60 <ipc_irq_handler+0x118>)
   44e0a:	701a      	strb	r2, [r3, #0]
   44e0c:	e7ac      	b.n	44d68 <ipc_irq_handler+0x20>
   44e0e:	0762      	lsls	r2, r4, #29
   44e10:	d505      	bpl.n	44e1e <ipc_irq_handler+0xd6>
   44e12:	4b13      	ldr	r3, [pc, #76]	; (44e60 <ipc_irq_handler+0x118>)
   44e14:	781a      	ldrb	r2, [r3, #0]
   44e16:	461e      	mov	r6, r3
   44e18:	b93a      	cbnz	r2, 44e2a <ipc_irq_handler+0xe2>
   44e1a:	f7fe fe23 	bl	43a64 <nrf_modem_os_application_irq_set>
   44e1e:	06e3      	lsls	r3, r4, #27
   44e20:	d5a2      	bpl.n	44d68 <ipc_irq_handler+0x20>
   44e22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   44e26:	f7fe be1d 	b.w	43a64 <nrf_modem_os_application_irq_set>
   44e2a:	2a01      	cmp	r2, #1
   44e2c:	d1f7      	bne.n	44e1e <ipc_irq_handler+0xd6>
   44e2e:	4a10      	ldr	r2, [pc, #64]	; (44e70 <ipc_irq_handler+0x128>)
   44e30:	4810      	ldr	r0, [pc, #64]	; (44e74 <ipc_irq_handler+0x12c>)
   44e32:	6812      	ldr	r2, [r2, #0]
   44e34:	6891      	ldr	r1, [r2, #8]
   44e36:	6041      	str	r1, [r0, #4]
   44e38:	6852      	ldr	r2, [r2, #4]
   44e3a:	6002      	str	r2, [r0, #0]
   44e3c:	b121      	cbz	r1, 44e48 <ipc_irq_handler+0x100>
   44e3e:	b11a      	cbz	r2, 44e48 <ipc_irq_handler+0x100>
   44e40:	6809      	ldr	r1, [r1, #0]
   44e42:	b109      	cbz	r1, 44e48 <ipc_irq_handler+0x100>
   44e44:	6812      	ldr	r2, [r2, #0]
   44e46:	b92a      	cbnz	r2, 44e54 <ipc_irq_handler+0x10c>
   44e48:	2303      	movs	r3, #3
   44e4a:	2205      	movs	r2, #5
   44e4c:	7033      	strb	r3, [r6, #0]
   44e4e:	4b05      	ldr	r3, [pc, #20]	; (44e64 <ipc_irq_handler+0x11c>)
   44e50:	601a      	str	r2, [r3, #0]
   44e52:	e7e4      	b.n	44e1e <ipc_irq_handler+0xd6>
   44e54:	701d      	strb	r5, [r3, #0]
   44e56:	e7e2      	b.n	44e1e <ipc_irq_handler+0xd6>
   44e58:	e000e100 	.word	0xe000e100
   44e5c:	4002a000 	.word	0x4002a000
   44e60:	2001e9f4 	.word	0x2001e9f4
   44e64:	2001ab40 	.word	0x2001ab40
   44e68:	04400004 	.word	0x04400004
   44e6c:	05500001 	.word	0x05500001
   44e70:	2001ab4c 	.word	0x2001ab4c
   44e74:	2001ab44 	.word	0x2001ab44

00044e78 <interface_init>:
   44e78:	b508      	push	{r3, lr}
   44e7a:	f44f 72b0 	mov.w	r2, #352	; 0x160
   44e7e:	2100      	movs	r1, #0
   44e80:	4802      	ldr	r0, [pc, #8]	; (44e8c <interface_init+0x14>)
   44e82:	f002 fff7 	bl	47e74 <memset>
   44e86:	2000      	movs	r0, #0
   44e88:	bd08      	pop	{r3, pc}
   44e8a:	bf00      	nop
   44e8c:	2001ab60 	.word	0x2001ab60

00044e90 <interface_socket_wait>:
   44e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44e94:	4615      	mov	r5, r2
   44e96:	222c      	movs	r2, #44	; 0x2c
   44e98:	4350      	muls	r0, r2
   44e9a:	461e      	mov	r6, r3
   44e9c:	4b0e      	ldr	r3, [pc, #56]	; (44ed8 <interface_socket_wait+0x48>)
   44e9e:	460c      	mov	r4, r1
   44ea0:	181f      	adds	r7, r3, r0
   44ea2:	581b      	ldr	r3, [r3, r0]
   44ea4:	402b      	ands	r3, r5
   44ea6:	428b      	cmp	r3, r1
   44ea8:	d102      	bne.n	44eb0 <interface_socket_wait+0x20>
   44eaa:	2000      	movs	r0, #0
   44eac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44eb0:	687b      	ldr	r3, [r7, #4]
   44eb2:	2b00      	cmp	r3, #0
   44eb4:	d1f9      	bne.n	44eaa <interface_socket_wait+0x1a>
   44eb6:	46b8      	mov	r8, r7
   44eb8:	f8d8 3000 	ldr.w	r3, [r8]
   44ebc:	402b      	ands	r3, r5
   44ebe:	42a3      	cmp	r3, r4
   44ec0:	d0f3      	beq.n	44eaa <interface_socket_wait+0x1a>
   44ec2:	f8d8 3004 	ldr.w	r3, [r8, #4]
   44ec6:	2b00      	cmp	r3, #0
   44ec8:	d1ef      	bne.n	44eaa <interface_socket_wait+0x1a>
   44eca:	4631      	mov	r1, r6
   44ecc:	4638      	mov	r0, r7
   44ece:	f7fe fd11 	bl	438f4 <nrf_modem_os_timedwait>
   44ed2:	2800      	cmp	r0, #0
   44ed4:	d0f0      	beq.n	44eb8 <interface_socket_wait+0x28>
   44ed6:	e7e9      	b.n	44eac <interface_socket_wait+0x1c>
   44ed8:	2001ab60 	.word	0x2001ab60

00044edc <interface_sockets_aux_state_set>:
   44edc:	4a0d      	ldr	r2, [pc, #52]	; (44f14 <interface_sockets_aux_state_set+0x38>)
   44ede:	b570      	push	{r4, r5, r6, lr}
   44ee0:	2300      	movs	r3, #0
   44ee2:	4611      	mov	r1, r2
   44ee4:	252c      	movs	r5, #44	; 0x2c
   44ee6:	fb05 f403 	mul.w	r4, r5, r3
   44eea:	590c      	ldr	r4, [r1, r4]
   44eec:	b15c      	cbz	r4, 44f06 <interface_sockets_aux_state_set+0x2a>
   44eee:	68d4      	ldr	r4, [r2, #12]
   44ef0:	f024 0608 	bic.w	r6, r4, #8
   44ef4:	2e02      	cmp	r6, #2
   44ef6:	d001      	beq.n	44efc <interface_sockets_aux_state_set+0x20>
   44ef8:	2c05      	cmp	r4, #5
   44efa:	d104      	bne.n	44f06 <interface_sockets_aux_state_set+0x2a>
   44efc:	fb05 f603 	mul.w	r6, r5, r3
   44f00:	598c      	ldr	r4, [r1, r6]
   44f02:	4304      	orrs	r4, r0
   44f04:	518c      	str	r4, [r1, r6]
   44f06:	3301      	adds	r3, #1
   44f08:	2b08      	cmp	r3, #8
   44f0a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   44f0e:	d1ea      	bne.n	44ee6 <interface_sockets_aux_state_set+0xa>
   44f10:	bd70      	pop	{r4, r5, r6, pc}
   44f12:	bf00      	nop
   44f14:	2001ab60 	.word	0x2001ab60

00044f18 <interface_sockets_aux_state_clear>:
   44f18:	4a0d      	ldr	r2, [pc, #52]	; (44f50 <interface_sockets_aux_state_clear+0x38>)
   44f1a:	b570      	push	{r4, r5, r6, lr}
   44f1c:	2300      	movs	r3, #0
   44f1e:	4611      	mov	r1, r2
   44f20:	252c      	movs	r5, #44	; 0x2c
   44f22:	43c0      	mvns	r0, r0
   44f24:	fb05 f403 	mul.w	r4, r5, r3
   44f28:	590c      	ldr	r4, [r1, r4]
   44f2a:	b15c      	cbz	r4, 44f44 <interface_sockets_aux_state_clear+0x2c>
   44f2c:	68d4      	ldr	r4, [r2, #12]
   44f2e:	f024 0608 	bic.w	r6, r4, #8
   44f32:	2e02      	cmp	r6, #2
   44f34:	d001      	beq.n	44f3a <interface_sockets_aux_state_clear+0x22>
   44f36:	2c05      	cmp	r4, #5
   44f38:	d104      	bne.n	44f44 <interface_sockets_aux_state_clear+0x2c>
   44f3a:	fb05 f603 	mul.w	r6, r5, r3
   44f3e:	598c      	ldr	r4, [r1, r6]
   44f40:	4004      	ands	r4, r0
   44f42:	518c      	str	r4, [r1, r6]
   44f44:	3301      	adds	r3, #1
   44f46:	2b08      	cmp	r3, #8
   44f48:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   44f4c:	d1ea      	bne.n	44f24 <interface_sockets_aux_state_clear+0xc>
   44f4e:	bd70      	pop	{r4, r5, r6, pc}
   44f50:	2001ab60 	.word	0x2001ab60

00044f54 <interface_from_internal_id_search>:
   44f54:	4b0a      	ldr	r3, [pc, #40]	; (44f80 <interface_from_internal_id_search+0x2c>)
   44f56:	4602      	mov	r2, r0
   44f58:	b530      	push	{r4, r5, lr}
   44f5a:	2000      	movs	r0, #0
   44f5c:	461c      	mov	r4, r3
   44f5e:	212c      	movs	r1, #44	; 0x2c
   44f60:	fb01 f500 	mul.w	r5, r1, r0
   44f64:	5965      	ldr	r5, [r4, r5]
   44f66:	b115      	cbz	r5, 44f6e <interface_from_internal_id_search+0x1a>
   44f68:	699d      	ldr	r5, [r3, #24]
   44f6a:	4295      	cmp	r5, r2
   44f6c:	d006      	beq.n	44f7c <interface_from_internal_id_search+0x28>
   44f6e:	3001      	adds	r0, #1
   44f70:	2808      	cmp	r0, #8
   44f72:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   44f76:	d1f3      	bne.n	44f60 <interface_from_internal_id_search+0xc>
   44f78:	f04f 30ff 	mov.w	r0, #4294967295
   44f7c:	bd30      	pop	{r4, r5, pc}
   44f7e:	bf00      	nop
   44f80:	2001ab60 	.word	0x2001ab60

00044f84 <interface_socket_from_handle_get>:
   44f84:	2807      	cmp	r0, #7
   44f86:	d808      	bhi.n	44f9a <interface_socket_from_handle_get+0x16>
   44f88:	232c      	movs	r3, #44	; 0x2c
   44f8a:	4343      	muls	r3, r0
   44f8c:	4a04      	ldr	r2, [pc, #16]	; (44fa0 <interface_socket_from_handle_get+0x1c>)
   44f8e:	18d0      	adds	r0, r2, r3
   44f90:	58d3      	ldr	r3, [r2, r3]
   44f92:	2b00      	cmp	r3, #0
   44f94:	bf08      	it	eq
   44f96:	2000      	moveq	r0, #0
   44f98:	4770      	bx	lr
   44f9a:	2000      	movs	r0, #0
   44f9c:	4770      	bx	lr
   44f9e:	bf00      	nop
   44fa0:	2001ab60 	.word	0x2001ab60

00044fa4 <rpc_error_to_nrf_errno>:
   44fa4:	286a      	cmp	r0, #106	; 0x6a
   44fa6:	bf9a      	itte	ls
   44fa8:	4b01      	ldrls	r3, [pc, #4]	; (44fb0 <rpc_error_to_nrf_errno+0xc>)
   44faa:	5c18      	ldrbls	r0, [r3, r0]
   44fac:	205f      	movhi	r0, #95	; 0x5f
   44fae:	4770      	bx	lr
   44fb0:	000494ef 	.word	0x000494ef

00044fb4 <rpc_error_to_nrf_gai_errno>:
   44fb4:	2805      	cmp	r0, #5
   44fb6:	d013      	beq.n	44fe0 <rpc_error_to_nrf_gai_errno+0x2c>
   44fb8:	d807      	bhi.n	44fca <rpc_error_to_nrf_gai_errno+0x16>
   44fba:	b170      	cbz	r0, 44fda <rpc_error_to_nrf_gai_errno+0x26>
   44fbc:	4b0b      	ldr	r3, [pc, #44]	; (44fec <rpc_error_to_nrf_gai_errno+0x38>)
   44fbe:	5c1b      	ldrb	r3, [r3, r0]
   44fc0:	4a0b      	ldr	r2, [pc, #44]	; (44ff0 <rpc_error_to_nrf_gai_errno+0x3c>)
   44fc2:	f240 1015 	movw	r0, #277	; 0x115
   44fc6:	6013      	str	r3, [r2, #0]
   44fc8:	4770      	bx	lr
   44fca:	2806      	cmp	r0, #6
   44fcc:	d00b      	beq.n	44fe6 <rpc_error_to_nrf_gai_errno+0x32>
   44fce:	280d      	cmp	r0, #13
   44fd0:	d009      	beq.n	44fe6 <rpc_error_to_nrf_gai_errno+0x32>
   44fd2:	286a      	cmp	r0, #106	; 0x6a
   44fd4:	d9f2      	bls.n	44fbc <rpc_error_to_nrf_gai_errno+0x8>
   44fd6:	235f      	movs	r3, #95	; 0x5f
   44fd8:	e7f2      	b.n	44fc0 <rpc_error_to_nrf_gai_errno+0xc>
   44fda:	4b05      	ldr	r3, [pc, #20]	; (44ff0 <rpc_error_to_nrf_gai_errno+0x3c>)
   44fdc:	6018      	str	r0, [r3, #0]
   44fde:	4770      	bx	lr
   44fe0:	f44f 708a 	mov.w	r0, #276	; 0x114
   44fe4:	4770      	bx	lr
   44fe6:	f240 1011 	movw	r0, #273	; 0x111
   44fea:	4770      	bx	lr
   44fec:	000494ef 	.word	0x000494ef
   44ff0:	2001acc8 	.word	0x2001acc8

00044ff4 <ip_interface_init>:
   44ff4:	b510      	push	{r4, lr}
   44ff6:	2400      	movs	r4, #0
   44ff8:	4b06      	ldr	r3, [pc, #24]	; (45014 <ip_interface_init+0x20>)
   44ffa:	2220      	movs	r2, #32
   44ffc:	601c      	str	r4, [r3, #0]
   44ffe:	4b06      	ldr	r3, [pc, #24]	; (45018 <ip_interface_init+0x24>)
   45000:	4621      	mov	r1, r4
   45002:	4806      	ldr	r0, [pc, #24]	; (4501c <ip_interface_init+0x28>)
   45004:	601c      	str	r4, [r3, #0]
   45006:	f002 ff35 	bl	47e74 <memset>
   4500a:	2201      	movs	r2, #1
   4500c:	4b04      	ldr	r3, [pc, #16]	; (45020 <ip_interface_init+0x2c>)
   4500e:	4620      	mov	r0, r4
   45010:	701a      	strb	r2, [r3, #0]
   45012:	bd10      	pop	{r4, pc}
   45014:	2001acd4 	.word	0x2001acd4
   45018:	2001acd0 	.word	0x2001acd0
   4501c:	2001acd8 	.word	0x2001acd8
   45020:	2001e9f7 	.word	0x2001e9f7

00045024 <rpc_ip_event_handler>:
   45024:	f248 030f 	movw	r3, #32783	; 0x800f
   45028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4502c:	4299      	cmp	r1, r3
   4502e:	4604      	mov	r4, r0
   45030:	460e      	mov	r6, r1
   45032:	b089      	sub	sp, #36	; 0x24
   45034:	f000 80a4 	beq.w	45180 <rpc_ip_event_handler+0x15c>
   45038:	f249 0304 	movw	r3, #36868	; 0x9004
   4503c:	4299      	cmp	r1, r3
   4503e:	f000 80ab 	beq.w	45198 <rpc_ip_event_handler+0x174>
   45042:	f248 030d 	movw	r3, #32781	; 0x800d
   45046:	4299      	cmp	r1, r3
   45048:	f040 80b8 	bne.w	451bc <rpc_ip_event_handler+0x198>
   4504c:	4bbc      	ldr	r3, [pc, #752]	; (45340 <rpc_ip_event_handler+0x31c>)
   4504e:	681a      	ldr	r2, [r3, #0]
   45050:	9303      	str	r3, [sp, #12]
   45052:	2a01      	cmp	r2, #1
   45054:	d12d      	bne.n	450b2 <rpc_ip_event_handler+0x8e>
   45056:	6940      	ldr	r0, [r0, #20]
   45058:	2800      	cmp	r0, #0
   4505a:	f040 808c 	bne.w	45176 <rpc_ip_event_handler+0x152>
   4505e:	f8d4 a018 	ldr.w	sl, [r4, #24]
   45062:	f8d4 8000 	ldr.w	r8, [r4]
   45066:	ea4f 134a 	mov.w	r3, sl, lsl #5
   4506a:	4618      	mov	r0, r3
   4506c:	9301      	str	r3, [sp, #4]
   4506e:	f7fe fd19 	bl	43aa4 <nrf_modem_os_alloc>
   45072:	4607      	mov	r7, r0
   45074:	b310      	cbz	r0, 450bc <rpc_ip_event_handler+0x98>
   45076:	2024      	movs	r0, #36	; 0x24
   45078:	fb00 f00a 	mul.w	r0, r0, sl
   4507c:	f7fe fd12 	bl	43aa4 <nrf_modem_os_alloc>
   45080:	4605      	mov	r5, r0
   45082:	b1e8      	cbz	r0, 450c0 <rpc_ip_event_handler+0x9c>
   45084:	2604      	movs	r6, #4
   45086:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   4508a:	f107 0920 	add.w	r9, r7, #32
   4508e:	9302      	str	r3, [sp, #8]
   45090:	9b02      	ldr	r3, [sp, #8]
   45092:	42ab      	cmp	r3, r5
   45094:	d118      	bne.n	450c8 <rpc_ip_event_handler+0xa4>
   45096:	f1ba 0f00 	cmp.w	sl, #0
   4509a:	d005      	beq.n	450a8 <rpc_ip_event_handler+0x84>
   4509c:	9b01      	ldr	r3, [sp, #4]
   4509e:	443b      	add	r3, r7
   450a0:	4699      	mov	r9, r3
   450a2:	2300      	movs	r3, #0
   450a4:	f849 3c04 	str.w	r3, [r9, #-4]
   450a8:	4ba6      	ldr	r3, [pc, #664]	; (45344 <rpc_ip_event_handler+0x320>)
   450aa:	601f      	str	r7, [r3, #0]
   450ac:	2302      	movs	r3, #2
   450ae:	9a03      	ldr	r2, [sp, #12]
   450b0:	6013      	str	r3, [r2, #0]
   450b2:	6820      	ldr	r0, [r4, #0]
   450b4:	2800      	cmp	r0, #0
   450b6:	f040 81c7 	bne.w	45448 <rpc_ip_event_handler+0x424>
   450ba:	e1c7      	b.n	4544c <rpc_ip_event_handler+0x428>
   450bc:	f7fe fcfa 	bl	43ab4 <nrf_modem_os_free>
   450c0:	220c      	movs	r2, #12
   450c2:	4ba1      	ldr	r3, [pc, #644]	; (45348 <rpc_ip_event_handler+0x324>)
   450c4:	601a      	str	r2, [r3, #0]
   450c6:	e7ef      	b.n	450a8 <rpc_ip_event_handler+0x84>
   450c8:	f858 2006 	ldr.w	r2, [r8, r6]
   450cc:	eb08 0106 	add.w	r1, r8, r6
   450d0:	f849 2c20 	str.w	r2, [r9, #-32]
   450d4:	eb08 0206 	add.w	r2, r8, r6
   450d8:	6852      	ldr	r2, [r2, #4]
   450da:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   450de:	3a01      	subs	r2, #1
   450e0:	2a04      	cmp	r2, #4
   450e2:	bf8c      	ite	hi
   450e4:	2200      	movhi	r2, #0
   450e6:	4b99      	ldrls	r3, [pc, #612]	; (4534c <rpc_ip_event_handler+0x328>)
   450e8:	f106 0614 	add.w	r6, r6, #20
   450ec:	bf98      	it	ls
   450ee:	569a      	ldrsbls	r2, [r3, r2]
   450f0:	4b97      	ldr	r3, [pc, #604]	; (45350 <rpc_ip_event_handler+0x32c>)
   450f2:	f849 2c1c 	str.w	r2, [r9, #-28]
   450f6:	681a      	ldr	r2, [r3, #0]
   450f8:	4b96      	ldr	r3, [pc, #600]	; (45354 <rpc_ip_event_handler+0x330>)
   450fa:	f849 2c18 	str.w	r2, [r9, #-24]
   450fe:	681a      	ldr	r2, [r3, #0]
   45100:	f849 2c14 	str.w	r2, [r9, #-20]
   45104:	8a0a      	ldrh	r2, [r1, #16]
   45106:	4994      	ldr	r1, [pc, #592]	; (45358 <rpc_ip_event_handler+0x334>)
   45108:	2a04      	cmp	r2, #4
   4510a:	8808      	ldrh	r0, [r1, #0]
   4510c:	f849 2c10 	str.w	r2, [r9, #-16]
   45110:	f849 5c0c 	str.w	r5, [r9, #-12]
   45114:	eb08 0106 	add.w	r1, r8, r6
   45118:	d121      	bne.n	4515e <rpc_ip_event_handler+0x13a>
   4511a:	2202      	movs	r2, #2
   4511c:	606a      	str	r2, [r5, #4]
   4511e:	2210      	movs	r2, #16
   45120:	8128      	strh	r0, [r5, #8]
   45122:	702a      	strb	r2, [r5, #0]
   45124:	680a      	ldr	r2, [r1, #0]
   45126:	60ea      	str	r2, [r5, #12]
   45128:	f859 2c10 	ldr.w	r2, [r9, #-16]
   4512c:	f10b 0001 	add.w	r0, fp, #1
   45130:	4416      	add	r6, r2
   45132:	f7fe fcb7 	bl	43aa4 <nrf_modem_os_alloc>
   45136:	f849 0c08 	str.w	r0, [r9, #-8]
   4513a:	b148      	cbz	r0, 45150 <rpc_ip_event_handler+0x12c>
   4513c:	465a      	mov	r2, fp
   4513e:	eb08 0106 	add.w	r1, r8, r6
   45142:	f002 fe8c 	bl	47e5e <memcpy>
   45146:	2100      	movs	r1, #0
   45148:	f859 2c08 	ldr.w	r2, [r9, #-8]
   4514c:	f802 100b 	strb.w	r1, [r2, fp]
   45150:	f849 9c04 	str.w	r9, [r9, #-4]
   45154:	445e      	add	r6, fp
   45156:	f109 0920 	add.w	r9, r9, #32
   4515a:	3508      	adds	r5, #8
   4515c:	e798      	b.n	45090 <rpc_ip_event_handler+0x6c>
   4515e:	230a      	movs	r3, #10
   45160:	f04f 0c24 	mov.w	ip, #36	; 0x24
   45164:	8128      	strh	r0, [r5, #8]
   45166:	606b      	str	r3, [r5, #4]
   45168:	f885 c000 	strb.w	ip, [r5]
   4516c:	f105 0010 	add.w	r0, r5, #16
   45170:	f002 fe75 	bl	47e5e <memcpy>
   45174:	e7d8      	b.n	45128 <rpc_ip_event_handler+0x104>
   45176:	f7ff ff1d 	bl	44fb4 <rpc_error_to_nrf_gai_errno>
   4517a:	4b73      	ldr	r3, [pc, #460]	; (45348 <rpc_ip_event_handler+0x324>)
   4517c:	6018      	str	r0, [r3, #0]
   4517e:	e795      	b.n	450ac <rpc_ip_event_handler+0x88>
   45180:	6943      	ldr	r3, [r0, #20]
   45182:	2b6a      	cmp	r3, #106	; 0x6a
   45184:	bf8e      	itee	hi
   45186:	235f      	movhi	r3, #95	; 0x5f
   45188:	4a74      	ldrls	r2, [pc, #464]	; (4535c <rpc_ip_event_handler+0x338>)
   4518a:	5cd3      	ldrbls	r3, [r2, r3]
   4518c:	4a74      	ldr	r2, [pc, #464]	; (45360 <rpc_ip_event_handler+0x33c>)
   4518e:	6013      	str	r3, [r2, #0]
   45190:	4b74      	ldr	r3, [pc, #464]	; (45364 <rpc_ip_event_handler+0x340>)
   45192:	2201      	movs	r2, #1
   45194:	701a      	strb	r2, [r3, #0]
   45196:	e159      	b.n	4544c <rpc_ip_event_handler+0x428>
   45198:	6903      	ldr	r3, [r0, #16]
   4519a:	2b03      	cmp	r3, #3
   4519c:	d807      	bhi.n	451ae <rpc_ip_event_handler+0x18a>
   4519e:	e8df f003 	tbb	[pc, r3]
   451a2:	0802      	.short	0x0802
   451a4:	0802      	.short	0x0802
   451a6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   451aa:	f7ff fe97 	bl	44edc <interface_sockets_aux_state_set>
   451ae:	4b6e      	ldr	r3, [pc, #440]	; (45368 <rpc_ip_event_handler+0x344>)
   451b0:	e7ef      	b.n	45192 <rpc_ip_event_handler+0x16e>
   451b2:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   451b6:	f7ff feaf 	bl	44f18 <interface_sockets_aux_state_clear>
   451ba:	e7f8      	b.n	451ae <rpc_ip_event_handler+0x18a>
   451bc:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   451c0:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   451c4:	68c0      	ldr	r0, [r0, #12]
   451c6:	d13b      	bne.n	45240 <rpc_ip_event_handler+0x21c>
   451c8:	f7ff fec4 	bl	44f54 <interface_from_internal_id_search>
   451cc:	4607      	mov	r7, r0
   451ce:	4638      	mov	r0, r7
   451d0:	f7ff fed8 	bl	44f84 <interface_socket_from_handle_get>
   451d4:	4605      	mov	r5, r0
   451d6:	2800      	cmp	r0, #0
   451d8:	f43f af6b 	beq.w	450b2 <rpc_ip_event_handler+0x8e>
   451dc:	4601      	mov	r1, r0
   451de:	4633      	mov	r3, r6
   451e0:	4622      	mov	r2, r4
   451e2:	4638      	mov	r0, r7
   451e4:	f000 f9f4 	bl	455d0 <tls_rpc_ip_event_handler>
   451e8:	2800      	cmp	r0, #0
   451ea:	f000 812f 	beq.w	4544c <rpc_ip_event_handler+0x428>
   451ee:	f248 030c 	movw	r3, #32780	; 0x800c
   451f2:	429e      	cmp	r6, r3
   451f4:	d826      	bhi.n	45244 <rpc_ip_event_handler+0x220>
   451f6:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   451fa:	f67f af5a 	bls.w	450b2 <rpc_ip_event_handler+0x8e>
   451fe:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   45202:	3e01      	subs	r6, #1
   45204:	2e0b      	cmp	r6, #11
   45206:	f63f af54 	bhi.w	450b2 <rpc_ip_event_handler+0x8e>
   4520a:	a301      	add	r3, pc, #4	; (adr r3, 45210 <rpc_ip_event_handler+0x1ec>)
   4520c:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   45210:	000452d5 	.word	0x000452d5
   45214:	00045389 	.word	0x00045389
   45218:	000454a5 	.word	0x000454a5
   4521c:	000454c3 	.word	0x000454c3
   45220:	0004536d 	.word	0x0004536d
   45224:	00045455 	.word	0x00045455
   45228:	00045455 	.word	0x00045455
   4522c:	000453cd 	.word	0x000453cd
   45230:	000452ef 	.word	0x000452ef
   45234:	000450b3 	.word	0x000450b3
   45238:	000450b3 	.word	0x000450b3
   4523c:	000453f7 	.word	0x000453f7
   45240:	0c07      	lsrs	r7, r0, #16
   45242:	e7c4      	b.n	451ce <rpc_ip_event_handler+0x1aa>
   45244:	f249 0302 	movw	r3, #36866	; 0x9002
   45248:	429e      	cmp	r6, r3
   4524a:	f000 80cc 	beq.w	453e6 <rpc_ip_event_handler+0x3c2>
   4524e:	f249 0303 	movw	r3, #36867	; 0x9003
   45252:	429e      	cmp	r6, r3
   45254:	d05b      	beq.n	4530e <rpc_ip_event_handler+0x2ea>
   45256:	f249 0301 	movw	r3, #36865	; 0x9001
   4525a:	429e      	cmp	r6, r3
   4525c:	f47f af29 	bne.w	450b2 <rpc_ip_event_handler+0x8e>
   45260:	682e      	ldr	r6, [r5, #0]
   45262:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   45266:	f000 80ee 	beq.w	45446 <rpc_ip_event_handler+0x422>
   4526a:	68a3      	ldr	r3, [r4, #8]
   4526c:	2b04      	cmp	r3, #4
   4526e:	f240 80e7 	bls.w	45440 <rpc_ip_event_handler+0x41c>
   45272:	8a63      	ldrh	r3, [r4, #18]
   45274:	2b00      	cmp	r3, #0
   45276:	f000 80e4 	beq.w	45442 <rpc_ip_event_handler+0x41e>
   4527a:	2b10      	cmp	r3, #16
   4527c:	f040 80cc 	bne.w	45418 <rpc_ip_event_handler+0x3f4>
   45280:	2024      	movs	r0, #36	; 0x24
   45282:	f7fe fc0f 	bl	43aa4 <nrf_modem_os_alloc>
   45286:	b318      	cbz	r0, 452d0 <rpc_ip_event_handler+0x2ac>
   45288:	230a      	movs	r3, #10
   4528a:	6043      	str	r3, [r0, #4]
   4528c:	2324      	movs	r3, #36	; 0x24
   4528e:	7003      	strb	r3, [r0, #0]
   45290:	7c62      	ldrb	r2, [r4, #17]
   45292:	7c23      	ldrb	r3, [r4, #16]
   45294:	f104 0124 	add.w	r1, r4, #36	; 0x24
   45298:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4529c:	8103      	strh	r3, [r0, #8]
   4529e:	f100 0210 	add.w	r2, r0, #16
   452a2:	f104 0314 	add.w	r3, r4, #20
   452a6:	f853 6b04 	ldr.w	r6, [r3], #4
   452aa:	428b      	cmp	r3, r1
   452ac:	f842 6b04 	str.w	r6, [r2], #4
   452b0:	d1f9      	bne.n	452a6 <rpc_ip_event_handler+0x282>
   452b2:	2324      	movs	r3, #36	; 0x24
   452b4:	6822      	ldr	r2, [r4, #0]
   452b6:	9307      	str	r3, [sp, #28]
   452b8:	9204      	str	r2, [sp, #16]
   452ba:	6862      	ldr	r2, [r4, #4]
   452bc:	a904      	add	r1, sp, #16
   452be:	e9cd 2005 	strd	r2, r0, [sp, #20]
   452c2:	69e8      	ldr	r0, [r5, #28]
   452c4:	6803      	ldr	r3, [r0, #0]
   452c6:	685b      	ldr	r3, [r3, #4]
   452c8:	4798      	blx	r3
   452ca:	3001      	adds	r0, #1
   452cc:	f040 808f 	bne.w	453ee <rpc_ip_event_handler+0x3ca>
   452d0:	2002      	movs	r0, #2
   452d2:	e0bc      	b.n	4544e <rpc_ip_event_handler+0x42a>
   452d4:	682b      	ldr	r3, [r5, #0]
   452d6:	2b01      	cmp	r3, #1
   452d8:	f040 80b8 	bne.w	4544c <rpc_ip_event_handler+0x428>
   452dc:	6960      	ldr	r0, [r4, #20]
   452de:	2800      	cmp	r0, #0
   452e0:	f040 80e9 	bne.w	454b6 <rpc_ip_event_handler+0x492>
   452e4:	2302      	movs	r3, #2
   452e6:	602b      	str	r3, [r5, #0]
   452e8:	69a3      	ldr	r3, [r4, #24]
   452ea:	61ab      	str	r3, [r5, #24]
   452ec:	e0af      	b.n	4544e <rpc_ip_event_handler+0x42a>
   452ee:	682b      	ldr	r3, [r5, #0]
   452f0:	b29b      	uxth	r3, r3
   452f2:	2b0d      	cmp	r3, #13
   452f4:	f040 80aa 	bne.w	4544c <rpc_ip_event_handler+0x428>
   452f8:	6960      	ldr	r0, [r4, #20]
   452fa:	2800      	cmp	r0, #0
   452fc:	f040 80db 	bne.w	454b6 <rpc_ip_event_handler+0x492>
   45300:	682b      	ldr	r3, [r5, #0]
   45302:	0c1b      	lsrs	r3, r3, #16
   45304:	041b      	lsls	r3, r3, #16
   45306:	f043 030e 	orr.w	r3, r3, #14
   4530a:	602b      	str	r3, [r5, #0]
   4530c:	e09f      	b.n	4544e <rpc_ip_event_handler+0x42a>
   4530e:	682b      	ldr	r3, [r5, #0]
   45310:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   45314:	602b      	str	r3, [r5, #0]
   45316:	682b      	ldr	r3, [r5, #0]
   45318:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   4531c:	602b      	str	r3, [r5, #0]
   4531e:	6923      	ldr	r3, [r4, #16]
   45320:	2b6c      	cmp	r3, #108	; 0x6c
   45322:	d107      	bne.n	45334 <rpc_ip_event_handler+0x310>
   45324:	682b      	ldr	r3, [r5, #0]
   45326:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   4532a:	602b      	str	r3, [r5, #0]
   4532c:	2380      	movs	r3, #128	; 0x80
   4532e:	606b      	str	r3, [r5, #4]
   45330:	60ab      	str	r3, [r5, #8]
   45332:	e08b      	b.n	4544c <rpc_ip_event_handler+0x428>
   45334:	2b6a      	cmp	r3, #106	; 0x6a
   45336:	bf96      	itet	ls
   45338:	4a08      	ldrls	r2, [pc, #32]	; (4535c <rpc_ip_event_handler+0x338>)
   4533a:	235f      	movhi	r3, #95	; 0x5f
   4533c:	5cd3      	ldrbls	r3, [r2, r3]
   4533e:	e7f6      	b.n	4532e <rpc_ip_event_handler+0x30a>
   45340:	2001acd0 	.word	0x2001acd0
   45344:	2001acd4 	.word	0x2001acd4
   45348:	2001accc 	.word	0x2001accc
   4534c:	000494ea 	.word	0x000494ea
   45350:	2001acc4 	.word	0x2001acc4
   45354:	2001acc0 	.word	0x2001acc0
   45358:	2001adc6 	.word	0x2001adc6
   4535c:	000494ef 	.word	0x000494ef
   45360:	2001acf8 	.word	0x2001acf8
   45364:	2001e9f8 	.word	0x2001e9f8
   45368:	2001e9f6 	.word	0x2001e9f6
   4536c:	682b      	ldr	r3, [r5, #0]
   4536e:	b29b      	uxth	r3, r3
   45370:	2b03      	cmp	r3, #3
   45372:	d16b      	bne.n	4544c <rpc_ip_event_handler+0x428>
   45374:	6960      	ldr	r0, [r4, #20]
   45376:	2800      	cmp	r0, #0
   45378:	f040 809d 	bne.w	454b6 <rpc_ip_event_handler+0x492>
   4537c:	682b      	ldr	r3, [r5, #0]
   4537e:	0c1b      	lsrs	r3, r3, #16
   45380:	041b      	lsls	r3, r3, #16
   45382:	f043 0304 	orr.w	r3, r3, #4
   45386:	e7c0      	b.n	4530a <rpc_ip_event_handler+0x2e6>
   45388:	682b      	ldr	r3, [r5, #0]
   4538a:	0099      	lsls	r1, r3, #2
   4538c:	d55e      	bpl.n	4544c <rpc_ip_event_handler+0x428>
   4538e:	682b      	ldr	r3, [r5, #0]
   45390:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45394:	602b      	str	r3, [r5, #0]
   45396:	6960      	ldr	r0, [r4, #20]
   45398:	b968      	cbnz	r0, 453b6 <rpc_ip_event_handler+0x392>
   4539a:	682b      	ldr	r3, [r5, #0]
   4539c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   453a0:	602b      	str	r3, [r5, #0]
   453a2:	682b      	ldr	r3, [r5, #0]
   453a4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   453a8:	602b      	str	r3, [r5, #0]
   453aa:	682b      	ldr	r3, [r5, #0]
   453ac:	0c1b      	lsrs	r3, r3, #16
   453ae:	041b      	lsls	r3, r3, #16
   453b0:	f043 0305 	orr.w	r3, r3, #5
   453b4:	e7a9      	b.n	4530a <rpc_ip_event_handler+0x2e6>
   453b6:	286a      	cmp	r0, #106	; 0x6a
   453b8:	bf8e      	itee	hi
   453ba:	235f      	movhi	r3, #95	; 0x5f
   453bc:	4b4c      	ldrls	r3, [pc, #304]	; (454f0 <rpc_ip_event_handler+0x4cc>)
   453be:	5c1b      	ldrbls	r3, [r3, r0]
   453c0:	606b      	str	r3, [r5, #4]
   453c2:	682b      	ldr	r3, [r5, #0]
   453c4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   453c8:	602b      	str	r3, [r5, #0]
   453ca:	e03f      	b.n	4544c <rpc_ip_event_handler+0x428>
   453cc:	682b      	ldr	r3, [r5, #0]
   453ce:	b29b      	uxth	r3, r3
   453d0:	2b06      	cmp	r3, #6
   453d2:	d13b      	bne.n	4544c <rpc_ip_event_handler+0x428>
   453d4:	6960      	ldr	r0, [r4, #20]
   453d6:	2800      	cmp	r0, #0
   453d8:	d16d      	bne.n	454b6 <rpc_ip_event_handler+0x492>
   453da:	682b      	ldr	r3, [r5, #0]
   453dc:	0c1b      	lsrs	r3, r3, #16
   453de:	041b      	lsls	r3, r3, #16
   453e0:	f043 0307 	orr.w	r3, r3, #7
   453e4:	e791      	b.n	4530a <rpc_ip_event_handler+0x2e6>
   453e6:	682b      	ldr	r3, [r5, #0]
   453e8:	b29b      	uxth	r3, r3
   453ea:	2b07      	cmp	r3, #7
   453ec:	d12e      	bne.n	4544c <rpc_ip_event_handler+0x428>
   453ee:	682b      	ldr	r3, [r5, #0]
   453f0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   453f4:	e7e8      	b.n	453c8 <rpc_ip_event_handler+0x3a4>
   453f6:	682b      	ldr	r3, [r5, #0]
   453f8:	b29b      	uxth	r3, r3
   453fa:	2b08      	cmp	r3, #8
   453fc:	d126      	bne.n	4544c <rpc_ip_event_handler+0x428>
   453fe:	6963      	ldr	r3, [r4, #20]
   45400:	2b00      	cmp	r3, #0
   45402:	d16d      	bne.n	454e0 <rpc_ip_event_handler+0x4bc>
   45404:	4b3b      	ldr	r3, [pc, #236]	; (454f4 <rpc_ip_event_handler+0x4d0>)
   45406:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4540a:	682b      	ldr	r3, [r5, #0]
   4540c:	0c1b      	lsrs	r3, r3, #16
   4540e:	041b      	lsls	r3, r3, #16
   45410:	f043 0309 	orr.w	r3, r3, #9
   45414:	602b      	str	r3, [r5, #0]
   45416:	e032      	b.n	4547e <rpc_ip_event_handler+0x45a>
   45418:	2b04      	cmp	r3, #4
   4541a:	d114      	bne.n	45446 <rpc_ip_event_handler+0x422>
   4541c:	2010      	movs	r0, #16
   4541e:	f7fe fb41 	bl	43aa4 <nrf_modem_os_alloc>
   45422:	2800      	cmp	r0, #0
   45424:	f43f af54 	beq.w	452d0 <rpc_ip_event_handler+0x2ac>
   45428:	2302      	movs	r3, #2
   4542a:	6043      	str	r3, [r0, #4]
   4542c:	2310      	movs	r3, #16
   4542e:	7003      	strb	r3, [r0, #0]
   45430:	7c22      	ldrb	r2, [r4, #16]
   45432:	7c61      	ldrb	r1, [r4, #17]
   45434:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   45438:	8102      	strh	r2, [r0, #8]
   4543a:	6962      	ldr	r2, [r4, #20]
   4543c:	60c2      	str	r2, [r0, #12]
   4543e:	e739      	b.n	452b4 <rpc_ip_event_handler+0x290>
   45440:	2300      	movs	r3, #0
   45442:	4618      	mov	r0, r3
   45444:	e736      	b.n	452b4 <rpc_ip_event_handler+0x290>
   45446:	6820      	ldr	r0, [r4, #0]
   45448:	f002 ff2d 	bl	482a6 <rpc_client_data_free>
   4544c:	2000      	movs	r0, #0
   4544e:	b009      	add	sp, #36	; 0x24
   45450:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45454:	4b27      	ldr	r3, [pc, #156]	; (454f4 <rpc_ip_event_handler+0x4d0>)
   45456:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4545a:	6963      	ldr	r3, [r4, #20]
   4545c:	b17b      	cbz	r3, 4547e <rpc_ip_event_handler+0x45a>
   4545e:	2b6b      	cmp	r3, #107	; 0x6b
   45460:	d10f      	bne.n	45482 <rpc_ip_event_handler+0x45e>
   45462:	6928      	ldr	r0, [r5, #16]
   45464:	220c      	movs	r2, #12
   45466:	2801      	cmp	r0, #1
   45468:	682b      	ldr	r3, [r5, #0]
   4546a:	d104      	bne.n	45476 <rpc_ip_event_handler+0x452>
   4546c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   45470:	602b      	str	r3, [r5, #0]
   45472:	606a      	str	r2, [r5, #4]
   45474:	e7eb      	b.n	4544e <rpc_ip_event_handler+0x42a>
   45476:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   4547a:	602b      	str	r3, [r5, #0]
   4547c:	606a      	str	r2, [r5, #4]
   4547e:	2001      	movs	r0, #1
   45480:	e7e5      	b.n	4544e <rpc_ip_event_handler+0x42a>
   45482:	f023 0002 	bic.w	r0, r3, #2
   45486:	2801      	cmp	r0, #1
   45488:	d102      	bne.n	45490 <rpc_ip_event_handler+0x46c>
   4548a:	230c      	movs	r3, #12
   4548c:	606b      	str	r3, [r5, #4]
   4548e:	e7de      	b.n	4544e <rpc_ip_event_handler+0x42a>
   45490:	2b6a      	cmp	r3, #106	; 0x6a
   45492:	bf8e      	itee	hi
   45494:	235f      	movhi	r3, #95	; 0x5f
   45496:	4a16      	ldrls	r2, [pc, #88]	; (454f0 <rpc_ip_event_handler+0x4cc>)
   45498:	5cd3      	ldrbls	r3, [r2, r3]
   4549a:	606b      	str	r3, [r5, #4]
   4549c:	682b      	ldr	r3, [r5, #0]
   4549e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   454a2:	e7b7      	b.n	45414 <rpc_ip_event_handler+0x3f0>
   454a4:	682b      	ldr	r3, [r5, #0]
   454a6:	025a      	lsls	r2, r3, #9
   454a8:	d5d0      	bpl.n	4544c <rpc_ip_event_handler+0x428>
   454aa:	6960      	ldr	r0, [r4, #20]
   454ac:	b918      	cbnz	r0, 454b6 <rpc_ip_event_handler+0x492>
   454ae:	682b      	ldr	r3, [r5, #0]
   454b0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   454b4:	e729      	b.n	4530a <rpc_ip_event_handler+0x2e6>
   454b6:	286a      	cmp	r0, #106	; 0x6a
   454b8:	d817      	bhi.n	454ea <rpc_ip_event_handler+0x4c6>
   454ba:	4b0d      	ldr	r3, [pc, #52]	; (454f0 <rpc_ip_event_handler+0x4cc>)
   454bc:	5c1b      	ldrb	r3, [r3, r0]
   454be:	606b      	str	r3, [r5, #4]
   454c0:	e7c4      	b.n	4544c <rpc_ip_event_handler+0x428>
   454c2:	682b      	ldr	r3, [r5, #0]
   454c4:	01db      	lsls	r3, r3, #7
   454c6:	d5c1      	bpl.n	4544c <rpc_ip_event_handler+0x428>
   454c8:	6963      	ldr	r3, [r4, #20]
   454ca:	b94b      	cbnz	r3, 454e0 <rpc_ip_event_handler+0x4bc>
   454cc:	6820      	ldr	r0, [r4, #0]
   454ce:	b118      	cbz	r0, 454d8 <rpc_ip_event_handler+0x4b4>
   454d0:	2001      	movs	r0, #1
   454d2:	4b08      	ldr	r3, [pc, #32]	; (454f4 <rpc_ip_event_handler+0x4d0>)
   454d4:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   454d8:	682b      	ldr	r3, [r5, #0]
   454da:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   454de:	e714      	b.n	4530a <rpc_ip_event_handler+0x2e6>
   454e0:	2b6a      	cmp	r3, #106	; 0x6a
   454e2:	d802      	bhi.n	454ea <rpc_ip_event_handler+0x4c6>
   454e4:	4a02      	ldr	r2, [pc, #8]	; (454f0 <rpc_ip_event_handler+0x4cc>)
   454e6:	5cd3      	ldrb	r3, [r2, r3]
   454e8:	e7e9      	b.n	454be <rpc_ip_event_handler+0x49a>
   454ea:	235f      	movs	r3, #95	; 0x5f
   454ec:	e7e7      	b.n	454be <rpc_ip_event_handler+0x49a>
   454ee:	bf00      	nop
   454f0:	000494ef 	.word	0x000494ef
   454f4:	2001acd8 	.word	0x2001acd8

000454f8 <hostname_free>:
   454f8:	b538      	push	{r3, r4, r5, lr}
   454fa:	4c07      	ldr	r4, [pc, #28]	; (45518 <hostname_free+0x20>)
   454fc:	4605      	mov	r5, r0
   454fe:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   45502:	b138      	cbz	r0, 45514 <hostname_free+0x1c>
   45504:	f7fe fad6 	bl	43ab4 <nrf_modem_os_free>
   45508:	2300      	movs	r3, #0
   4550a:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   4550e:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   45512:	6063      	str	r3, [r4, #4]
   45514:	bd38      	pop	{r3, r4, r5, pc}
   45516:	bf00      	nop
   45518:	2001acfc 	.word	0x2001acfc

0004551c <secure_socket_attach_initiate>:
   4551c:	f04f 33ff 	mov.w	r3, #4294967295
   45520:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   45524:	f8df 8094 	ldr.w	r8, [pc, #148]	; 455bc <secure_socket_attach_initiate+0xa0>
   45528:	9301      	str	r3, [sp, #4]
   4552a:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   4552e:	460d      	mov	r5, r1
   45530:	4616      	mov	r6, r2
   45532:	f8d9 3004 	ldr.w	r3, [r9, #4]
   45536:	f247 0281 	movw	r2, #28801	; 0x7081
   4553a:	6989      	ldr	r1, [r1, #24]
   4553c:	4607      	mov	r7, r0
   4553e:	f002 feb4 	bl	482aa <ip_interface_request_create>
   45542:	4604      	mov	r4, r0
   45544:	b398      	cbz	r0, 455ae <secure_socket_attach_initiate+0x92>
   45546:	f8d9 2004 	ldr.w	r2, [r9, #4]
   4554a:	b122      	cbz	r2, 45556 <secure_socket_attach_initiate+0x3a>
   4554c:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   45550:	6800      	ldr	r0, [r0, #0]
   45552:	f002 fc84 	bl	47e5e <memcpy>
   45556:	2324      	movs	r3, #36	; 0x24
   45558:	4a17      	ldr	r2, [pc, #92]	; (455b8 <secure_socket_attach_initiate+0x9c>)
   4555a:	fb03 2307 	mla	r3, r3, r7, r2
   4555e:	f104 0214 	add.w	r2, r4, #20
   45562:	f103 0124 	add.w	r1, r3, #36	; 0x24
   45566:	f853 0b04 	ldr.w	r0, [r3], #4
   4556a:	428b      	cmp	r3, r1
   4556c:	f842 0b04 	str.w	r0, [r2], #4
   45570:	d1f9      	bne.n	45566 <secure_socket_attach_initiate+0x4a>
   45572:	68a3      	ldr	r3, [r4, #8]
   45574:	4622      	mov	r2, r4
   45576:	3324      	adds	r3, #36	; 0x24
   45578:	60a3      	str	r3, [r4, #8]
   4557a:	682b      	ldr	r3, [r5, #0]
   4557c:	f247 0181 	movw	r1, #28801	; 0x7081
   45580:	0c1b      	lsrs	r3, r3, #16
   45582:	041b      	lsls	r3, r3, #16
   45584:	f043 030a 	orr.w	r3, r3, #10
   45588:	602b      	str	r3, [r5, #0]
   4558a:	2004      	movs	r0, #4
   4558c:	f002 fe84 	bl	48298 <rpc_client_request_send>
   45590:	682b      	ldr	r3, [r5, #0]
   45592:	00db      	lsls	r3, r3, #3
   45594:	d40d      	bmi.n	455b2 <secure_socket_attach_initiate+0x96>
   45596:	f64f 72ff 	movw	r2, #65535	; 0xffff
   4559a:	210b      	movs	r1, #11
   4559c:	4638      	mov	r0, r7
   4559e:	ab01      	add	r3, sp, #4
   455a0:	f002 fe96 	bl	482d0 <ip_interface_wait>
   455a4:	b100      	cbz	r0, 455a8 <secure_socket_attach_initiate+0x8c>
   455a6:	602e      	str	r6, [r5, #0]
   455a8:	b003      	add	sp, #12
   455aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   455ae:	200c      	movs	r0, #12
   455b0:	e7fa      	b.n	455a8 <secure_socket_attach_initiate+0x8c>
   455b2:	2077      	movs	r0, #119	; 0x77
   455b4:	e7f8      	b.n	455a8 <secure_socket_attach_initiate+0x8c>
   455b6:	bf00      	nop
   455b8:	2001e9fa 	.word	0x2001e9fa
   455bc:	2001acfc 	.word	0x2001acfc

000455c0 <tls_interface_init>:
   455c0:	2201      	movs	r2, #1
   455c2:	4b02      	ldr	r3, [pc, #8]	; (455cc <tls_interface_init+0xc>)
   455c4:	2000      	movs	r0, #0
   455c6:	701a      	strb	r2, [r3, #0]
   455c8:	4770      	bx	lr
   455ca:	bf00      	nop
   455cc:	2001e9f9 	.word	0x2001e9f9

000455d0 <tls_rpc_ip_event_handler>:
   455d0:	b570      	push	{r4, r5, r6, lr}
   455d2:	460c      	mov	r4, r1
   455d4:	f248 0181 	movw	r1, #32897	; 0x8081
   455d8:	428b      	cmp	r3, r1
   455da:	4606      	mov	r6, r0
   455dc:	d035      	beq.n	4564a <tls_rpc_ip_event_handler+0x7a>
   455de:	f249 0182 	movw	r1, #36994	; 0x9082
   455e2:	428b      	cmp	r3, r1
   455e4:	d040      	beq.n	45668 <tls_rpc_ip_event_handler+0x98>
   455e6:	f248 0102 	movw	r1, #32770	; 0x8002
   455ea:	428b      	cmp	r3, r1
   455ec:	d161      	bne.n	456b2 <tls_rpc_ip_event_handler+0xe2>
   455ee:	2c00      	cmp	r4, #0
   455f0:	d05f      	beq.n	456b2 <tls_rpc_ip_event_handler+0xe2>
   455f2:	6963      	ldr	r3, [r4, #20]
   455f4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   455f8:	d002      	beq.n	45600 <tls_rpc_ip_event_handler+0x30>
   455fa:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   455fe:	d158      	bne.n	456b2 <tls_rpc_ip_event_handler+0xe2>
   45600:	6823      	ldr	r3, [r4, #0]
   45602:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45606:	6023      	str	r3, [r4, #0]
   45608:	6955      	ldr	r5, [r2, #20]
   4560a:	2d00      	cmp	r5, #0
   4560c:	d14d      	bne.n	456aa <tls_rpc_ip_event_handler+0xda>
   4560e:	6823      	ldr	r3, [r4, #0]
   45610:	0c1b      	lsrs	r3, r3, #16
   45612:	041b      	lsls	r3, r3, #16
   45614:	f043 0305 	orr.w	r3, r3, #5
   45618:	6023      	str	r3, [r4, #0]
   4561a:	6823      	ldr	r3, [r4, #0]
   4561c:	00db      	lsls	r3, r3, #3
   4561e:	d401      	bmi.n	45624 <tls_rpc_ip_event_handler+0x54>
   45620:	2000      	movs	r0, #0
   45622:	e020      	b.n	45666 <tls_rpc_ip_event_handler+0x96>
   45624:	2324      	movs	r3, #36	; 0x24
   45626:	4373      	muls	r3, r6
   45628:	4a23      	ldr	r2, [pc, #140]	; (456b8 <tls_rpc_ip_event_handler+0xe8>)
   4562a:	5cd3      	ldrb	r3, [r2, r3]
   4562c:	2b02      	cmp	r3, #2
   4562e:	d1f7      	bne.n	45620 <tls_rpc_ip_event_handler+0x50>
   45630:	4621      	mov	r1, r4
   45632:	4630      	mov	r0, r6
   45634:	f002 fe5c 	bl	482f0 <secure_client_socket>
   45638:	2800      	cmp	r0, #0
   4563a:	d0f1      	beq.n	45620 <tls_rpc_ip_event_handler+0x50>
   4563c:	2877      	cmp	r0, #119	; 0x77
   4563e:	d0ef      	beq.n	45620 <tls_rpc_ip_event_handler+0x50>
   45640:	6060      	str	r0, [r4, #4]
   45642:	6823      	ldr	r3, [r4, #0]
   45644:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45648:	e02d      	b.n	456a6 <tls_rpc_ip_event_handler+0xd6>
   4564a:	2c00      	cmp	r4, #0
   4564c:	d0e8      	beq.n	45620 <tls_rpc_ip_event_handler+0x50>
   4564e:	6823      	ldr	r3, [r4, #0]
   45650:	b29b      	uxth	r3, r3
   45652:	2b0a      	cmp	r3, #10
   45654:	d1e4      	bne.n	45620 <tls_rpc_ip_event_handler+0x50>
   45656:	6950      	ldr	r0, [r2, #20]
   45658:	bb40      	cbnz	r0, 456ac <tls_rpc_ip_event_handler+0xdc>
   4565a:	6823      	ldr	r3, [r4, #0]
   4565c:	0c1b      	lsrs	r3, r3, #16
   4565e:	041b      	lsls	r3, r3, #16
   45660:	f043 030b 	orr.w	r3, r3, #11
   45664:	6023      	str	r3, [r4, #0]
   45666:	bd70      	pop	{r4, r5, r6, pc}
   45668:	2c00      	cmp	r4, #0
   4566a:	d0d9      	beq.n	45620 <tls_rpc_ip_event_handler+0x50>
   4566c:	6823      	ldr	r3, [r4, #0]
   4566e:	b29b      	uxth	r3, r3
   45670:	2b0b      	cmp	r3, #11
   45672:	d1d5      	bne.n	45620 <tls_rpc_ip_event_handler+0x50>
   45674:	6915      	ldr	r5, [r2, #16]
   45676:	b9c5      	cbnz	r5, 456aa <tls_rpc_ip_event_handler+0xda>
   45678:	6823      	ldr	r3, [r4, #0]
   4567a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   4567e:	6023      	str	r3, [r4, #0]
   45680:	f7ff ff3a 	bl	454f8 <hostname_free>
   45684:	6823      	ldr	r3, [r4, #0]
   45686:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   4568a:	6023      	str	r3, [r4, #0]
   4568c:	6823      	ldr	r3, [r4, #0]
   4568e:	0c1b      	lsrs	r3, r3, #16
   45690:	041b      	lsls	r3, r3, #16
   45692:	f043 030c 	orr.w	r3, r3, #12
   45696:	6023      	str	r3, [r4, #0]
   45698:	6823      	ldr	r3, [r4, #0]
   4569a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   4569e:	6023      	str	r3, [r4, #0]
   456a0:	6823      	ldr	r3, [r4, #0]
   456a2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   456a6:	6023      	str	r3, [r4, #0]
   456a8:	e7ba      	b.n	45620 <tls_rpc_ip_event_handler+0x50>
   456aa:	4628      	mov	r0, r5
   456ac:	f7ff fc7a 	bl	44fa4 <rpc_error_to_nrf_errno>
   456b0:	e7c6      	b.n	45640 <tls_rpc_ip_event_handler+0x70>
   456b2:	2001      	movs	r0, #1
   456b4:	e7d7      	b.n	45666 <tls_rpc_ip_event_handler+0x96>
   456b6:	bf00      	nop
   456b8:	2001e9fa 	.word	0x2001e9fa

000456bc <at_cmd_send>:
   456bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   456be:	4615      	mov	r5, r2
   456c0:	f06f 0258 	mvn.w	r2, #88	; 0x58
   456c4:	2300      	movs	r3, #0
   456c6:	7302      	strb	r2, [r0, #12]
   456c8:	2204      	movs	r2, #4
   456ca:	4c0d      	ldr	r4, [pc, #52]	; (45700 <at_cmd_send+0x44>)
   456cc:	7343      	strb	r3, [r0, #13]
   456ce:	7383      	strb	r3, [r0, #14]
   456d0:	73c3      	strb	r3, [r0, #15]
   456d2:	7202      	strb	r2, [r0, #8]
   456d4:	7243      	strb	r3, [r0, #9]
   456d6:	7283      	strb	r3, [r0, #10]
   456d8:	72c3      	strb	r3, [r0, #11]
   456da:	4602      	mov	r2, r0
   456dc:	b289      	uxth	r1, r1
   456de:	2003      	movs	r0, #3
   456e0:	7023      	strb	r3, [r4, #0]
   456e2:	f002 fdd9 	bl	48298 <rpc_client_request_send>
   456e6:	f04f 33ff 	mov.w	r3, #4294967295
   456ea:	9301      	str	r3, [sp, #4]
   456ec:	7823      	ldrb	r3, [r4, #0]
   456ee:	42ab      	cmp	r3, r5
   456f0:	d101      	bne.n	456f6 <at_cmd_send+0x3a>
   456f2:	b003      	add	sp, #12
   456f4:	bd30      	pop	{r4, r5, pc}
   456f6:	a901      	add	r1, sp, #4
   456f8:	2000      	movs	r0, #0
   456fa:	f7fe f8fb 	bl	438f4 <nrf_modem_os_timedwait>
   456fe:	e7f5      	b.n	456ec <at_cmd_send+0x30>
   45700:	2001eb1a 	.word	0x2001eb1a

00045704 <nrf_modem_at_init>:
   45704:	2201      	movs	r2, #1
   45706:	b508      	push	{r3, lr}
   45708:	4611      	mov	r1, r2
   4570a:	4808      	ldr	r0, [pc, #32]	; (4572c <nrf_modem_at_init+0x28>)
   4570c:	f7fe f990 	bl	43a30 <nrf_modem_os_sem_init>
   45710:	2000      	movs	r0, #0
   45712:	f002 fdbb 	bl	4828c <rpc_client_request_alloc>
   45716:	b128      	cbz	r0, 45724 <nrf_modem_at_init+0x20>
   45718:	2201      	movs	r2, #1
   4571a:	2105      	movs	r1, #5
   4571c:	f7ff ffce 	bl	456bc <at_cmd_send>
   45720:	2000      	movs	r0, #0
   45722:	bd08      	pop	{r3, pc}
   45724:	f06f 000b 	mvn.w	r0, #11
   45728:	e7fb      	b.n	45722 <nrf_modem_at_init+0x1e>
   4572a:	bf00      	nop
   4572c:	2001ad3c 	.word	0x2001ad3c

00045730 <rpc_at_event_handler>:
   45730:	b570      	push	{r4, r5, r6, lr}
   45732:	68c3      	ldr	r3, [r0, #12]
   45734:	4605      	mov	r5, r0
   45736:	2ba7      	cmp	r3, #167	; 0xa7
   45738:	d003      	beq.n	45742 <rpc_at_event_handler+0x12>
   4573a:	6828      	ldr	r0, [r5, #0]
   4573c:	f002 fdb3 	bl	482a6 <rpc_client_data_free>
   45740:	e008      	b.n	45754 <rpc_at_event_handler+0x24>
   45742:	2903      	cmp	r1, #3
   45744:	d008      	beq.n	45758 <rpc_at_event_handler+0x28>
   45746:	2904      	cmp	r1, #4
   45748:	d019      	beq.n	4577e <rpc_at_event_handler+0x4e>
   4574a:	2902      	cmp	r1, #2
   4574c:	d102      	bne.n	45754 <rpc_at_event_handler+0x24>
   4574e:	2201      	movs	r2, #1
   45750:	4b0e      	ldr	r3, [pc, #56]	; (4578c <rpc_at_event_handler+0x5c>)
   45752:	701a      	strb	r2, [r3, #0]
   45754:	2000      	movs	r0, #0
   45756:	e00a      	b.n	4576e <rpc_at_event_handler+0x3e>
   45758:	4e0d      	ldr	r6, [pc, #52]	; (45790 <rpc_at_event_handler+0x60>)
   4575a:	6833      	ldr	r3, [r6, #0]
   4575c:	b143      	cbz	r3, 45770 <rpc_at_event_handler+0x40>
   4575e:	2400      	movs	r4, #0
   45760:	6800      	ldr	r0, [r0, #0]
   45762:	4798      	blx	r3
   45764:	6828      	ldr	r0, [r5, #0]
   45766:	6034      	str	r4, [r6, #0]
   45768:	f002 fd9d 	bl	482a6 <rpc_client_data_free>
   4576c:	b2e0      	uxtb	r0, r4
   4576e:	bd70      	pop	{r4, r5, r6, pc}
   45770:	2202      	movs	r2, #2
   45772:	4b08      	ldr	r3, [pc, #32]	; (45794 <rpc_at_event_handler+0x64>)
   45774:	2401      	movs	r4, #1
   45776:	6018      	str	r0, [r3, #0]
   45778:	4b04      	ldr	r3, [pc, #16]	; (4578c <rpc_at_event_handler+0x5c>)
   4577a:	701a      	strb	r2, [r3, #0]
   4577c:	e7f6      	b.n	4576c <rpc_at_event_handler+0x3c>
   4577e:	4b06      	ldr	r3, [pc, #24]	; (45798 <rpc_at_event_handler+0x68>)
   45780:	681b      	ldr	r3, [r3, #0]
   45782:	2b00      	cmp	r3, #0
   45784:	d0d9      	beq.n	4573a <rpc_at_event_handler+0xa>
   45786:	6800      	ldr	r0, [r0, #0]
   45788:	4798      	blx	r3
   4578a:	e7d6      	b.n	4573a <rpc_at_event_handler+0xa>
   4578c:	2001eb1a 	.word	0x2001eb1a
   45790:	2001ad48 	.word	0x2001ad48
   45794:	2001ad44 	.word	0x2001ad44
   45798:	2001ad40 	.word	0x2001ad40

0004579c <rpc_dfu_event_handler>:
   4579c:	b510      	push	{r4, lr}
   4579e:	4604      	mov	r4, r0
   457a0:	6800      	ldr	r0, [r0, #0]
   457a2:	b108      	cbz	r0, 457a8 <rpc_dfu_event_handler+0xc>
   457a4:	f002 fd7f 	bl	482a6 <rpc_client_data_free>
   457a8:	4b05      	ldr	r3, [pc, #20]	; (457c0 <rpc_dfu_event_handler+0x24>)
   457aa:	68e2      	ldr	r2, [r4, #12]
   457ac:	429a      	cmp	r2, r3
   457ae:	bf05      	ittet	eq
   457b0:	2001      	moveq	r0, #1
   457b2:	4b04      	ldreq	r3, [pc, #16]	; (457c4 <rpc_dfu_event_handler+0x28>)
   457b4:	2000      	movne	r0, #0
   457b6:	7018      	strbeq	r0, [r3, #0]
   457b8:	bf04      	itt	eq
   457ba:	4b03      	ldreq	r3, [pc, #12]	; (457c8 <rpc_dfu_event_handler+0x2c>)
   457bc:	601c      	streq	r4, [r3, #0]
   457be:	bd10      	pop	{r4, pc}
   457c0:	15abe11a 	.word	0x15abe11a
   457c4:	2001eb1b 	.word	0x2001eb1b
   457c8:	2001ad4c 	.word	0x2001ad4c

000457cc <rpc_gnss_event_handler>:
   457cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   457d0:	6804      	ldr	r4, [r0, #0]
   457d2:	4607      	mov	r7, r0
   457d4:	460d      	mov	r5, r1
   457d6:	2c00      	cmp	r4, #0
   457d8:	f000 8086 	beq.w	458e8 <rpc_gnss_event_handler+0x11c>
   457dc:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   457e0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   457e4:	d142      	bne.n	4586c <rpc_gnss_event_handler+0xa0>
   457e6:	4b5f      	ldr	r3, [pc, #380]	; (45964 <rpc_gnss_event_handler+0x198>)
   457e8:	781a      	ldrb	r2, [r3, #0]
   457ea:	4698      	mov	r8, r3
   457ec:	2a01      	cmp	r2, #1
   457ee:	d131      	bne.n	45854 <rpc_gnss_event_handler+0x88>
   457f0:	4a5d      	ldr	r2, [pc, #372]	; (45968 <rpc_gnss_event_handler+0x19c>)
   457f2:	6821      	ldr	r1, [r4, #0]
   457f4:	8812      	ldrh	r2, [r2, #0]
   457f6:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   457fa:	d12b      	bne.n	45854 <rpc_gnss_event_handler+0x88>
   457fc:	6862      	ldr	r2, [r4, #4]
   457fe:	bb6a      	cbnz	r2, 4585c <rpc_gnss_event_handler+0x90>
   45800:	4b5a      	ldr	r3, [pc, #360]	; (4596c <rpc_gnss_event_handler+0x1a0>)
   45802:	681e      	ldr	r6, [r3, #0]
   45804:	b31e      	cbz	r6, 4584e <rpc_gnss_event_handler+0x82>
   45806:	f242 0309 	movw	r3, #8201	; 0x2009
   4580a:	429d      	cmp	r5, r3
   4580c:	d11f      	bne.n	4584e <rpc_gnss_event_handler+0x82>
   4580e:	4630      	mov	r0, r6
   45810:	8923      	ldrh	r3, [r4, #8]
   45812:	2280      	movs	r2, #128	; 0x80
   45814:	f840 3b04 	str.w	r3, [r0], #4
   45818:	f104 010a 	add.w	r1, r4, #10
   4581c:	f002 fb1f 	bl	47e5e <memcpy>
   45820:	2280      	movs	r2, #128	; 0x80
   45822:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   45826:	f106 0084 	add.w	r0, r6, #132	; 0x84
   4582a:	f002 fb18 	bl	47e5e <memcpy>
   4582e:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   45832:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   45836:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   4583a:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   4583e:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   45842:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   45846:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   4584a:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   4584e:	2300      	movs	r3, #0
   45850:	f888 3000 	strb.w	r3, [r8]
   45854:	6838      	ldr	r0, [r7, #0]
   45856:	f002 fd26 	bl	482a6 <rpc_client_data_free>
   4585a:	e045      	b.n	458e8 <rpc_gnss_event_handler+0x11c>
   4585c:	f647 71ff 	movw	r1, #32767	; 0x7fff
   45860:	428a      	cmp	r2, r1
   45862:	bf0c      	ite	eq
   45864:	2203      	moveq	r2, #3
   45866:	2202      	movne	r2, #2
   45868:	701a      	strb	r2, [r3, #0]
   4586a:	e7f3      	b.n	45854 <rpc_gnss_event_handler+0x88>
   4586c:	4e40      	ldr	r6, [pc, #256]	; (45970 <rpc_gnss_event_handler+0x1a4>)
   4586e:	6833      	ldr	r3, [r6, #0]
   45870:	2b00      	cmp	r3, #0
   45872:	d0ef      	beq.n	45854 <rpc_gnss_event_handler+0x88>
   45874:	f244 0204 	movw	r2, #16388	; 0x4004
   45878:	4291      	cmp	r1, r2
   4587a:	d80b      	bhi.n	45894 <rpc_gnss_event_handler+0xc8>
   4587c:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   45880:	d9e8      	bls.n	45854 <rpc_gnss_event_handler+0x88>
   45882:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   45886:	3a02      	subs	r2, #2
   45888:	2a02      	cmp	r2, #2
   4588a:	d80b      	bhi.n	458a4 <rpc_gnss_event_handler+0xd8>
   4588c:	e8df f002 	tbb	[pc, r2]
   45890:	4f45      	.short	0x4f45
   45892:	59          	.byte	0x59
   45893:	00          	.byte	0x00
   45894:	f244 1301 	movw	r3, #16641	; 0x4101
   45898:	4299      	cmp	r1, r3
   4589a:	d003      	beq.n	458a4 <rpc_gnss_event_handler+0xd8>
   4589c:	f244 2301 	movw	r3, #16897	; 0x4201
   458a0:	4299      	cmp	r1, r3
   458a2:	d1d7      	bne.n	45854 <rpc_gnss_event_handler+0x88>
   458a4:	4f33      	ldr	r7, [pc, #204]	; (45974 <rpc_gnss_event_handler+0x1a8>)
   458a6:	6838      	ldr	r0, [r7, #0]
   458a8:	b108      	cbz	r0, 458ae <rpc_gnss_event_handler+0xe2>
   458aa:	f002 fcfc 	bl	482a6 <rpc_client_data_free>
   458ae:	f244 2301 	movw	r3, #16897	; 0x4201
   458b2:	429d      	cmp	r5, r3
   458b4:	4b30      	ldr	r3, [pc, #192]	; (45978 <rpc_gnss_event_handler+0x1ac>)
   458b6:	d11a      	bne.n	458ee <rpc_gnss_event_handler+0x122>
   458b8:	2202      	movs	r2, #2
   458ba:	603c      	str	r4, [r7, #0]
   458bc:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   458c0:	701a      	strb	r2, [r3, #0]
   458c2:	07e3      	lsls	r3, r4, #31
   458c4:	d502      	bpl.n	458cc <rpc_gnss_event_handler+0x100>
   458c6:	2002      	movs	r0, #2
   458c8:	6833      	ldr	r3, [r6, #0]
   458ca:	4798      	blx	r3
   458cc:	4d2b      	ldr	r5, [pc, #172]	; (4597c <rpc_gnss_event_handler+0x1b0>)
   458ce:	f014 0418 	ands.w	r4, r4, #24
   458d2:	6833      	ldr	r3, [r6, #0]
   458d4:	782a      	ldrb	r2, [r5, #0]
   458d6:	d01a      	beq.n	4590e <rpc_gnss_event_handler+0x142>
   458d8:	b91a      	cbnz	r2, 458e2 <rpc_gnss_event_handler+0x116>
   458da:	2005      	movs	r0, #5
   458dc:	4798      	blx	r3
   458de:	2301      	movs	r3, #1
   458e0:	702b      	strb	r3, [r5, #0]
   458e2:	2001      	movs	r0, #1
   458e4:	6833      	ldr	r3, [r6, #0]
   458e6:	4798      	blx	r3
   458e8:	2000      	movs	r0, #0
   458ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   458ee:	f244 1201 	movw	r2, #16641	; 0x4101
   458f2:	4295      	cmp	r5, r2
   458f4:	bf0b      	itete	eq
   458f6:	2201      	moveq	r2, #1
   458f8:	2200      	movne	r2, #0
   458fa:	603c      	streq	r4, [r7, #0]
   458fc:	603c      	strne	r4, [r7, #0]
   458fe:	bf0b      	itete	eq
   45900:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   45904:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   45908:	701a      	strbeq	r2, [r3, #0]
   4590a:	701a      	strbne	r2, [r3, #0]
   4590c:	e7d9      	b.n	458c2 <rpc_gnss_event_handler+0xf6>
   4590e:	2a00      	cmp	r2, #0
   45910:	d0e7      	beq.n	458e2 <rpc_gnss_event_handler+0x116>
   45912:	2006      	movs	r0, #6
   45914:	4798      	blx	r3
   45916:	702c      	strb	r4, [r5, #0]
   45918:	e7e3      	b.n	458e2 <rpc_gnss_event_handler+0x116>
   4591a:	4c19      	ldr	r4, [pc, #100]	; (45980 <rpc_gnss_event_handler+0x1b4>)
   4591c:	6820      	ldr	r0, [r4, #0]
   4591e:	b108      	cbz	r0, 45924 <rpc_gnss_event_handler+0x158>
   45920:	f002 fcc1 	bl	482a6 <rpc_client_data_free>
   45924:	683b      	ldr	r3, [r7, #0]
   45926:	2003      	movs	r0, #3
   45928:	6023      	str	r3, [r4, #0]
   4592a:	6833      	ldr	r3, [r6, #0]
   4592c:	e7db      	b.n	458e6 <rpc_gnss_event_handler+0x11a>
   4592e:	4c15      	ldr	r4, [pc, #84]	; (45984 <rpc_gnss_event_handler+0x1b8>)
   45930:	6820      	ldr	r0, [r4, #0]
   45932:	b108      	cbz	r0, 45938 <rpc_gnss_event_handler+0x16c>
   45934:	f002 fcb7 	bl	482a6 <rpc_client_data_free>
   45938:	683b      	ldr	r3, [r7, #0]
   4593a:	2004      	movs	r0, #4
   4593c:	6023      	str	r3, [r4, #0]
   4593e:	6833      	ldr	r3, [r6, #0]
   45940:	e7d1      	b.n	458e6 <rpc_gnss_event_handler+0x11a>
   45942:	7822      	ldrb	r2, [r4, #0]
   45944:	2a03      	cmp	r2, #3
   45946:	d885      	bhi.n	45854 <rpc_gnss_event_handler+0x88>
   45948:	e8df f002 	tbb	[pc, r2]
   4594c:	09070502 	.word	0x09070502
   45950:	2007      	movs	r0, #7
   45952:	4798      	blx	r3
   45954:	e77e      	b.n	45854 <rpc_gnss_event_handler+0x88>
   45956:	2008      	movs	r0, #8
   45958:	e7fb      	b.n	45952 <rpc_gnss_event_handler+0x186>
   4595a:	2009      	movs	r0, #9
   4595c:	e7f9      	b.n	45952 <rpc_gnss_event_handler+0x186>
   4595e:	200a      	movs	r0, #10
   45960:	e7f7      	b.n	45952 <rpc_gnss_event_handler+0x186>
   45962:	bf00      	nop
   45964:	2001eb1e 	.word	0x2001eb1e
   45968:	2001adc8 	.word	0x2001adc8
   4596c:	2001ad60 	.word	0x2001ad60
   45970:	2001ad50 	.word	0x2001ad50
   45974:	2001ad54 	.word	0x2001ad54
   45978:	2001eb1d 	.word	0x2001eb1d
   4597c:	2001eb1c 	.word	0x2001eb1c
   45980:	2001ad5c 	.word	0x2001ad5c
   45984:	2001ad58 	.word	0x2001ad58

00045988 <full_dfu_ipc_irq_handler>:
   45988:	2301      	movs	r3, #1
   4598a:	4a03      	ldr	r2, [pc, #12]	; (45998 <full_dfu_ipc_irq_handler+0x10>)
   4598c:	6013      	str	r3, [r2, #0]
   4598e:	07c2      	lsls	r2, r0, #31
   45990:	bf44      	itt	mi
   45992:	4a02      	ldrmi	r2, [pc, #8]	; (4599c <full_dfu_ipc_irq_handler+0x14>)
   45994:	7013      	strbmi	r3, [r2, #0]
   45996:	4770      	bx	lr
   45998:	2001ad64 	.word	0x2001ad64
   4599c:	2001eb1f 	.word	0x2001eb1f

000459a0 <modem_ipc_wait_for_event>:
   459a0:	b538      	push	{r3, r4, r5, lr}
   459a2:	2300      	movs	r3, #0
   459a4:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   459a8:	4c0b      	ldr	r4, [pc, #44]	; (459d8 <modem_ipc_wait_for_event+0x38>)
   459aa:	6023      	str	r3, [r4, #0]
   459ac:	6823      	ldr	r3, [r4, #0]
   459ae:	b92b      	cbnz	r3, 459bc <modem_ipc_wait_for_event+0x1c>
   459b0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   459b4:	f002 fbcd 	bl	48152 <nrf_modem_os_busywait>
   459b8:	3d01      	subs	r5, #1
   459ba:	d1f7      	bne.n	459ac <modem_ipc_wait_for_event+0xc>
   459bc:	6823      	ldr	r3, [r4, #0]
   459be:	b913      	cbnz	r3, 459c6 <modem_ipc_wait_for_event+0x26>
   459c0:	f06f 0073 	mvn.w	r0, #115	; 0x73
   459c4:	e006      	b.n	459d4 <modem_ipc_wait_for_event+0x34>
   459c6:	4b05      	ldr	r3, [pc, #20]	; (459dc <modem_ipc_wait_for_event+0x3c>)
   459c8:	781b      	ldrb	r3, [r3, #0]
   459ca:	2b01      	cmp	r3, #1
   459cc:	bf14      	ite	ne
   459ce:	2000      	movne	r0, #0
   459d0:	f06f 0004 	mvneq.w	r0, #4
   459d4:	bd38      	pop	{r3, r4, r5, pc}
   459d6:	bf00      	nop
   459d8:	2001ad64 	.word	0x2001ad64
   459dc:	2001eb1f 	.word	0x2001eb1f

000459e0 <nrf_modem_full_dfu_setup>:
   459e0:	2200      	movs	r2, #0
   459e2:	2300      	movs	r3, #0
   459e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   459e6:	4d2b      	ldr	r5, [pc, #172]	; (45a94 <nrf_modem_full_dfu_setup+0xb4>)
   459e8:	4e2b      	ldr	r6, [pc, #172]	; (45a98 <nrf_modem_full_dfu_setup+0xb8>)
   459ea:	e9c5 2302 	strd	r2, r3, [r5, #8]
   459ee:	e9c5 2304 	strd	r2, r3, [r5, #16]
   459f2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   459f6:	4b29      	ldr	r3, [pc, #164]	; (45a9c <nrf_modem_full_dfu_setup+0xbc>)
   459f8:	2400      	movs	r4, #0
   459fa:	601a      	str	r2, [r3, #0]
   459fc:	f100 031c 	add.w	r3, r0, #28
   45a00:	6033      	str	r3, [r6, #0]
   45a02:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   45a06:	6043      	str	r3, [r0, #4]
   45a08:	231c      	movs	r3, #28
   45a0a:	7203      	strb	r3, [r0, #8]
   45a0c:	2320      	movs	r3, #32
   45a0e:	2701      	movs	r7, #1
   45a10:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   45a14:	7243      	strb	r3, [r0, #9]
   45a16:	4b22      	ldr	r3, [pc, #136]	; (45aa0 <nrf_modem_full_dfu_setup+0xc0>)
   45a18:	7004      	strb	r4, [r0, #0]
   45a1a:	7044      	strb	r4, [r0, #1]
   45a1c:	70c2      	strb	r2, [r0, #3]
   45a1e:	7284      	strb	r4, [r0, #10]
   45a20:	72c4      	strb	r4, [r0, #11]
   45a22:	7087      	strb	r7, [r0, #2]
   45a24:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   45a28:	702c      	strb	r4, [r5, #0]
   45a2a:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   45a2e:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   45a32:	4b1c      	ldr	r3, [pc, #112]	; (45aa4 <nrf_modem_full_dfu_setup+0xc4>)
   45a34:	b093      	sub	sp, #76	; 0x4c
   45a36:	4622      	mov	r2, r4
   45a38:	4620      	mov	r0, r4
   45a3a:	491b      	ldr	r1, [pc, #108]	; (45aa8 <nrf_modem_full_dfu_setup+0xc8>)
   45a3c:	701c      	strb	r4, [r3, #0]
   45a3e:	f7fe fce5 	bl	4440c <nrfx_ipc_init>
   45a42:	4621      	mov	r1, r4
   45a44:	2240      	movs	r2, #64	; 0x40
   45a46:	a801      	add	r0, sp, #4
   45a48:	f002 fa14 	bl	47e74 <memset>
   45a4c:	2302      	movs	r3, #2
   45a4e:	9302      	str	r3, [sp, #8]
   45a50:	2304      	movs	r3, #4
   45a52:	930b      	str	r3, [sp, #44]	; 0x2c
   45a54:	2305      	movs	r3, #5
   45a56:	a801      	add	r0, sp, #4
   45a58:	9311      	str	r3, [sp, #68]	; 0x44
   45a5a:	9709      	str	r7, [sp, #36]	; 0x24
   45a5c:	f7fe fcee 	bl	4443c <nrfx_ipc_config_load>
   45a60:	4b12      	ldr	r3, [pc, #72]	; (45aac <nrf_modem_full_dfu_setup+0xcc>)
   45a62:	9400      	str	r4, [sp, #0]
   45a64:	6836      	ldr	r6, [r6, #0]
   45a66:	601c      	str	r4, [r3, #0]
   45a68:	681b      	ldr	r3, [r3, #0]
   45a6a:	9300      	str	r3, [sp, #0]
   45a6c:	9b00      	ldr	r3, [sp, #0]
   45a6e:	f7ff ff97 	bl	459a0 <modem_ipc_wait_for_event>
   45a72:	4604      	mov	r4, r0
   45a74:	b130      	cbz	r0, 45a84 <nrf_modem_full_dfu_setup+0xa4>
   45a76:	2303      	movs	r3, #3
   45a78:	702b      	strb	r3, [r5, #0]
   45a7a:	f7fe fcff 	bl	4447c <nrfx_ipc_uninit>
   45a7e:	4620      	mov	r0, r4
   45a80:	b013      	add	sp, #76	; 0x4c
   45a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
   45a84:	6832      	ldr	r2, [r6, #0]
   45a86:	4b0a      	ldr	r3, [pc, #40]	; (45ab0 <nrf_modem_full_dfu_setup+0xd0>)
   45a88:	429a      	cmp	r2, r3
   45a8a:	d0f8      	beq.n	45a7e <nrf_modem_full_dfu_setup+0x9e>
   45a8c:	f06f 0404 	mvn.w	r4, #4
   45a90:	e7f3      	b.n	45a7a <nrf_modem_full_dfu_setup+0x9a>
   45a92:	bf00      	nop
   45a94:	2001a750 	.word	0x2001a750
   45a98:	2001ad68 	.word	0x2001ad68
   45a9c:	2001ad6c 	.word	0x2001ad6c
   45aa0:	4002a000 	.word	0x4002a000
   45aa4:	2001eb1f 	.word	0x2001eb1f
   45aa8:	00045989 	.word	0x00045989
   45aac:	40005610 	.word	0x40005610
   45ab0:	a5000001 	.word	0xa5000001

00045ab4 <modem_off>:
   45ab4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45ab6:	2501      	movs	r5, #1
   45ab8:	4c07      	ldr	r4, [pc, #28]	; (45ad8 <modem_off+0x24>)
   45aba:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   45abe:	6065      	str	r5, [r4, #4]
   45ac0:	f002 fb47 	bl	48152 <nrf_modem_os_busywait>
   45ac4:	2300      	movs	r3, #0
   45ac6:	6063      	str	r3, [r4, #4]
   45ac8:	9301      	str	r3, [sp, #4]
   45aca:	6025      	str	r5, [r4, #0]
   45acc:	6823      	ldr	r3, [r4, #0]
   45ace:	9301      	str	r3, [sp, #4]
   45ad0:	9b01      	ldr	r3, [sp, #4]
   45ad2:	b003      	add	sp, #12
   45ad4:	bd30      	pop	{r4, r5, pc}
   45ad6:	bf00      	nop
   45ad8:	40005610 	.word	0x40005610

00045adc <nrf_modem_init>:
   45adc:	b570      	push	{r4, r5, r6, lr}
   45ade:	460d      	mov	r5, r1
   45ae0:	b300      	cbz	r0, 45b24 <nrf_modem_init+0x48>
   45ae2:	4e15      	ldr	r6, [pc, #84]	; (45b38 <nrf_modem_init+0x5c>)
   45ae4:	7832      	ldrb	r2, [r6, #0]
   45ae6:	bb02      	cbnz	r2, 45b2a <nrf_modem_init+0x4e>
   45ae8:	2901      	cmp	r1, #1
   45aea:	d113      	bne.n	45b14 <nrf_modem_init+0x38>
   45aec:	68c1      	ldr	r1, [r0, #12]
   45aee:	6842      	ldr	r2, [r0, #4]
   45af0:	440a      	add	r2, r1
   45af2:	6941      	ldr	r1, [r0, #20]
   45af4:	440a      	add	r2, r1
   45af6:	69c1      	ldr	r1, [r0, #28]
   45af8:	440a      	add	r2, r1
   45afa:	f242 011b 	movw	r1, #8219	; 0x201b
   45afe:	428a      	cmp	r2, r1
   45b00:	d916      	bls.n	45b30 <nrf_modem_init+0x54>
   45b02:	6800      	ldr	r0, [r0, #0]
   45b04:	f7ff ff6c 	bl	459e0 <nrf_modem_full_dfu_setup>
   45b08:	4604      	mov	r4, r0
   45b0a:	b130      	cbz	r0, 45b1a <nrf_modem_init+0x3e>
   45b0c:	f7ff ffd2 	bl	45ab4 <modem_off>
   45b10:	4620      	mov	r0, r4
   45b12:	bd70      	pop	{r4, r5, r6, pc}
   45b14:	f002 fc2b 	bl	4836e <nrf_modem_platform_init>
   45b18:	e7f6      	b.n	45b08 <nrf_modem_init+0x2c>
   45b1a:	4b08      	ldr	r3, [pc, #32]	; (45b3c <nrf_modem_init+0x60>)
   45b1c:	701d      	strb	r5, [r3, #0]
   45b1e:	2301      	movs	r3, #1
   45b20:	7033      	strb	r3, [r6, #0]
   45b22:	e7f5      	b.n	45b10 <nrf_modem_init+0x34>
   45b24:	f06f 040d 	mvn.w	r4, #13
   45b28:	e7f2      	b.n	45b10 <nrf_modem_init+0x34>
   45b2a:	f04f 34ff 	mov.w	r4, #4294967295
   45b2e:	e7ef      	b.n	45b10 <nrf_modem_init+0x34>
   45b30:	f06f 040b 	mvn.w	r4, #11
   45b34:	e7ec      	b.n	45b10 <nrf_modem_init+0x34>
   45b36:	bf00      	nop
   45b38:	2001eb20 	.word	0x2001eb20
   45b3c:	2001eb21 	.word	0x2001eb21

00045b40 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
   45b40:	4b02      	ldr	r3, [pc, #8]	; (45b4c <mbedtls_platform_set_calloc_free+0xc>)
   45b42:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
   45b44:	4b02      	ldr	r3, [pc, #8]	; (45b50 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
   45b46:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
   45b48:	6019      	str	r1, [r3, #0]
}
   45b4a:	4770      	bx	lr
   45b4c:	2001a5f0 	.word	0x2001a5f0
   45b50:	2001a5f4 	.word	0x2001a5f4

00045b54 <_heap_init>:
 *
 * Not static in order to allow extern use.
 */
void _heap_init(void)
{
	mbedtls_memory_buffer_alloc_init(mbedtls_heap, sizeof(mbedtls_heap));
   45b54:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   45b58:	4801      	ldr	r0, [pc, #4]	; (45b60 <_heap_init+0xc>)
   45b5a:	f000 b947 	b.w	45dec <mbedtls_memory_buffer_alloc_init>
   45b5e:	bf00      	nop
   45b60:	2001eb22 	.word	0x2001eb22

00045b64 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
   45b64:	6801      	ldr	r1, [r0, #0]
   45b66:	4a0e      	ldr	r2, [pc, #56]	; (45ba0 <verify_header+0x3c>)
{
   45b68:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
   45b6a:	4291      	cmp	r1, r2
   45b6c:	d115      	bne.n	45b9a <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
   45b6e:	69c1      	ldr	r1, [r0, #28]
   45b70:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
   45b74:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
   45b78:	4291      	cmp	r1, r2
   45b7a:	d10e      	bne.n	45b9a <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
   45b7c:	6882      	ldr	r2, [r0, #8]
   45b7e:	2a01      	cmp	r2, #1
   45b80:	d80b      	bhi.n	45b9a <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
   45b82:	68c2      	ldr	r2, [r0, #12]
   45b84:	b112      	cbz	r2, 45b8c <verify_header+0x28>
   45b86:	6901      	ldr	r1, [r0, #16]
   45b88:	428a      	cmp	r2, r1
   45b8a:	d006      	beq.n	45b9a <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
   45b8c:	6958      	ldr	r0, [r3, #20]
   45b8e:	b128      	cbz	r0, 45b9c <verify_header+0x38>
   45b90:	699b      	ldr	r3, [r3, #24]
   45b92:	1a1b      	subs	r3, r3, r0
   45b94:	4258      	negs	r0, r3
   45b96:	4158      	adcs	r0, r3
   45b98:	4770      	bx	lr
        return( 1 );
   45b9a:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
   45b9c:	4770      	bx	lr
   45b9e:	bf00      	nop
   45ba0:	ff00aa55 	.word	0xff00aa55

00045ba4 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
   45ba4:	4b0d      	ldr	r3, [pc, #52]	; (45bdc <verify_chain+0x38>)
{
   45ba6:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
   45ba8:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
   45baa:	b1a6      	cbz	r6, 45bd6 <verify_chain+0x32>
   45bac:	4630      	mov	r0, r6
   45bae:	f7ff ffd9 	bl	45b64 <verify_header>
   45bb2:	4604      	mov	r4, r0
   45bb4:	b978      	cbnz	r0, 45bd6 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
   45bb6:	68f3      	ldr	r3, [r6, #12]
   45bb8:	b96b      	cbnz	r3, 45bd6 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
   45bba:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
   45bbc:	b90d      	cbnz	r5, 45bc2 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
   45bbe:	4620      	mov	r0, r4
   45bc0:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
   45bc2:	4628      	mov	r0, r5
   45bc4:	f7ff ffce 	bl	45b64 <verify_header>
   45bc8:	b928      	cbnz	r0, 45bd6 <verify_chain+0x32>
        if( cur->prev != prv )
   45bca:	68eb      	ldr	r3, [r5, #12]
   45bcc:	42b3      	cmp	r3, r6
   45bce:	d102      	bne.n	45bd6 <verify_chain+0x32>
        cur = cur->next;
   45bd0:	462e      	mov	r6, r5
   45bd2:	692d      	ldr	r5, [r5, #16]
   45bd4:	e7f2      	b.n	45bbc <verify_chain+0x18>
        return( 1 );
   45bd6:	2401      	movs	r4, #1
   45bd8:	e7f1      	b.n	45bbe <verify_chain+0x1a>
   45bda:	bf00      	nop
   45bdc:	2001ad70 	.word	0x2001ad70

00045be0 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
   45be0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
   45be4:	4d3e      	ldr	r5, [pc, #248]	; (45ce0 <buffer_alloc_calloc+0x100>)
   45be6:	682c      	ldr	r4, [r5, #0]
   45be8:	b1d4      	cbz	r4, 45c20 <buffer_alloc_calloc+0x40>
   45bea:	68ac      	ldr	r4, [r5, #8]
   45bec:	b1c4      	cbz	r4, 45c20 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
   45bee:	2800      	cmp	r0, #0
   45bf0:	d04b      	beq.n	45c8a <buffer_alloc_calloc+0xaa>
   45bf2:	2900      	cmp	r1, #0
   45bf4:	d049      	beq.n	45c8a <buffer_alloc_calloc+0xaa>
    original_len = len = n * size;
   45bf6:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
   45bfa:	fbb6 f0f0 	udiv	r0, r6, r0
   45bfe:	4288      	cmp	r0, r1
   45c00:	d143      	bne.n	45c8a <buffer_alloc_calloc+0xaa>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45c02:	1d30      	adds	r0, r6, #4
   45c04:	d841      	bhi.n	45c8a <buffer_alloc_calloc+0xaa>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45c06:	07b1      	lsls	r1, r6, #30
   45c08:	d00d      	beq.n	45c26 <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45c0a:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45c0e:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
   45c10:	68ec      	ldr	r4, [r5, #12]
   45c12:	e003      	b.n	45c1c <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
   45c14:	6863      	ldr	r3, [r4, #4]
   45c16:	42bb      	cmp	r3, r7
   45c18:	d239      	bcs.n	45c8e <buffer_alloc_calloc+0xae>
            break;

        cur = cur->next_free;
   45c1a:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
   45c1c:	2c00      	cmp	r4, #0
   45c1e:	d1f9      	bne.n	45c14 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
   45c20:	4620      	mov	r0, r4
   45c22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   45c26:	4637      	mov	r7, r6
   45c28:	e7f2      	b.n	45c10 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
   45c2a:	60e8      	str	r0, [r5, #12]
   45c2c:	e041      	b.n	45cb2 <buffer_alloc_calloc+0xd2>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
   45c2e:	f107 0c20 	add.w	ip, r7, #32
   45c32:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
   45c36:	3920      	subs	r1, #32
   45c38:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
   45c3a:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
   45c3c:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 45ce4 <buffer_alloc_calloc+0x104>
    new->prev = cur;
   45c40:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
   45c44:	6921      	ldr	r1, [r4, #16]
   45c46:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
   45c48:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
   45c4c:	f8df c098 	ldr.w	ip, [pc, #152]	; 45ce8 <buffer_alloc_calloc+0x108>
   45c50:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
   45c54:	b101      	cbz	r1, 45c58 <buffer_alloc_calloc+0x78>
        new->next->prev = new;
   45c56:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
   45c58:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
   45c5c:	b19a      	cbz	r2, 45c86 <buffer_alloc_calloc+0xa6>
        new->prev_free->next_free = new;
   45c5e:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
   45c60:	699a      	ldr	r2, [r3, #24]
   45c62:	b102      	cbz	r2, 45c66 <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
   45c64:	6153      	str	r3, [r2, #20]
    cur->next = new;
   45c66:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
   45c68:	2300      	movs	r3, #0
    cur->alloc = 1;
   45c6a:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
   45c6e:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45c72:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
   45c74:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45c78:	07db      	lsls	r3, r3, #31
   45c7a:	d529      	bpl.n	45cd0 <buffer_alloc_calloc+0xf0>
   45c7c:	f7ff ff92 	bl	45ba4 <verify_chain>
   45c80:	b330      	cbz	r0, 45cd0 <buffer_alloc_calloc+0xf0>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void _exit(int status);
static inline void exit(int status)
{
	_exit(status);
   45c82:	4648      	mov	r0, r9
   45c84:	e022      	b.n	45ccc <buffer_alloc_calloc+0xec>
        heap.first_free = new;
   45c86:	60eb      	str	r3, [r5, #12]
   45c88:	e7ea      	b.n	45c60 <buffer_alloc_calloc+0x80>
        return( NULL );
   45c8a:	2400      	movs	r4, #0
   45c8c:	e7c8      	b.n	45c20 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
   45c8e:	68a3      	ldr	r3, [r4, #8]
   45c90:	b113      	cbz	r3, 45c98 <buffer_alloc_calloc+0xb8>
   45c92:	2001      	movs	r0, #1
   45c94:	f7fc fe58 	bl	42948 <_exit>
    if( cur->size - len < sizeof(memory_header) +
   45c98:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
   45c9c:	6861      	ldr	r1, [r4, #4]
   45c9e:	f104 0820 	add.w	r8, r4, #32
   45ca2:	1bc9      	subs	r1, r1, r7
   45ca4:	2923      	cmp	r1, #35	; 0x23
   45ca6:	d8c2      	bhi.n	45c2e <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
   45ca8:	2301      	movs	r3, #1
   45caa:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
   45cac:	2a00      	cmp	r2, #0
   45cae:	d0bc      	beq.n	45c2a <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
   45cb0:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
   45cb2:	69a3      	ldr	r3, [r4, #24]
   45cb4:	b103      	cbz	r3, 45cb8 <buffer_alloc_calloc+0xd8>
            cur->next_free->prev_free = cur->prev_free;
   45cb6:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
   45cb8:	2300      	movs	r3, #0
        cur->next_free = NULL;
   45cba:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45cbe:	692b      	ldr	r3, [r5, #16]
   45cc0:	07da      	lsls	r2, r3, #31
   45cc2:	d505      	bpl.n	45cd0 <buffer_alloc_calloc+0xf0>
   45cc4:	f7ff ff6e 	bl	45ba4 <verify_chain>
   45cc8:	b110      	cbz	r0, 45cd0 <buffer_alloc_calloc+0xf0>
   45cca:	2001      	movs	r0, #1
   45ccc:	f7fc fe3c 	bl	42948 <_exit>
    memset( ret, 0, original_len );
   45cd0:	4632      	mov	r2, r6
   45cd2:	2100      	movs	r1, #0
   45cd4:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
   45cd6:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
   45cd8:	f002 f8cc 	bl	47e74 <memset>
    return( ret );
   45cdc:	e7a0      	b.n	45c20 <buffer_alloc_calloc+0x40>
   45cde:	bf00      	nop
   45ce0:	2001ad70 	.word	0x2001ad70
   45ce4:	ff00aa55 	.word	0xff00aa55
   45ce8:	ee119966 	.word	0xee119966

00045cec <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
   45cec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
   45cee:	4605      	mov	r5, r0
   45cf0:	2800      	cmp	r0, #0
   45cf2:	d078      	beq.n	45de6 <buffer_alloc_free+0xfa>
   45cf4:	4e3c      	ldr	r6, [pc, #240]	; (45de8 <buffer_alloc_free+0xfc>)
   45cf6:	6833      	ldr	r3, [r6, #0]
   45cf8:	2b00      	cmp	r3, #0
   45cfa:	d074      	beq.n	45de6 <buffer_alloc_free+0xfa>
   45cfc:	68b2      	ldr	r2, [r6, #8]
   45cfe:	2a00      	cmp	r2, #0
   45d00:	d071      	beq.n	45de6 <buffer_alloc_free+0xfa>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
   45d02:	4283      	cmp	r3, r0
   45d04:	d803      	bhi.n	45d0e <buffer_alloc_free+0x22>
   45d06:	6872      	ldr	r2, [r6, #4]
   45d08:	4413      	add	r3, r2
   45d0a:	4298      	cmp	r0, r3
   45d0c:	d302      	bcc.n	45d14 <buffer_alloc_free+0x28>
   45d0e:	2001      	movs	r0, #1
   45d10:	f7fc fe1a 	bl	42948 <_exit>
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
    }

    p -= sizeof(memory_header);
   45d14:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
   45d18:	4620      	mov	r0, r4
   45d1a:	f7ff ff23 	bl	45b64 <verify_header>
   45d1e:	b110      	cbz	r0, 45d26 <buffer_alloc_free+0x3a>
   45d20:	2001      	movs	r0, #1
   45d22:	f7fc fe11 	bl	42948 <_exit>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
   45d26:	f855 3c18 	ldr.w	r3, [r5, #-24]
   45d2a:	2b01      	cmp	r3, #1
   45d2c:	d002      	beq.n	45d34 <buffer_alloc_free+0x48>
   45d2e:	2001      	movs	r0, #1
   45d30:	f7fc fe0a 	bl	42948 <_exit>
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
    }

    hdr->alloc = 0;
   45d34:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45d36:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
   45d3a:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45d3e:	b1af      	cbz	r7, 45d6c <buffer_alloc_free+0x80>
   45d40:	68ba      	ldr	r2, [r7, #8]
   45d42:	b992      	cbnz	r2, 45d6a <buffer_alloc_free+0x7e>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
   45d44:	f855 3c1c 	ldr.w	r3, [r5, #-28]
   45d48:	f103 0220 	add.w	r2, r3, #32
   45d4c:	687b      	ldr	r3, [r7, #4]
   45d4e:	4413      	add	r3, r2
   45d50:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
   45d52:	f855 3c10 	ldr.w	r3, [r5, #-16]
   45d56:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
   45d58:	b103      	cbz	r3, 45d5c <buffer_alloc_free+0x70>
            hdr->next->prev = hdr;
   45d5a:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45d5c:	4620      	mov	r0, r4
   45d5e:	2220      	movs	r2, #32
   45d60:	2100      	movs	r1, #0
   45d62:	f002 f887 	bl	47e74 <memset>
   45d66:	4623      	mov	r3, r4
   45d68:	463c      	mov	r4, r7
    memory_header *hdr, *old = NULL;
   45d6a:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
   45d6c:	6920      	ldr	r0, [r4, #16]
   45d6e:	2800      	cmp	r0, #0
   45d70:	d031      	beq.n	45dd6 <buffer_alloc_free+0xea>
   45d72:	6883      	ldr	r3, [r0, #8]
   45d74:	2b00      	cmp	r3, #0
   45d76:	d12e      	bne.n	45dd6 <buffer_alloc_free+0xea>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
   45d78:	6863      	ldr	r3, [r4, #4]
   45d7a:	6842      	ldr	r2, [r0, #4]
   45d7c:	3320      	adds	r3, #32
   45d7e:	4413      	add	r3, r2
   45d80:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
   45d82:	6903      	ldr	r3, [r0, #16]
   45d84:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
   45d88:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
   45d8a:	b9d2      	cbnz	r2, 45dc2 <buffer_alloc_free+0xd6>
   45d8c:	b9f9      	cbnz	r1, 45dce <buffer_alloc_free+0xe2>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
   45d8e:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
   45d90:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
   45d92:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
   45d94:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
   45d96:	b1e2      	cbz	r2, 45dd2 <buffer_alloc_free+0xe6>
            hdr->prev_free->next_free = hdr;
   45d98:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
   45d9a:	69a2      	ldr	r2, [r4, #24]
   45d9c:	b102      	cbz	r2, 45da0 <buffer_alloc_free+0xb4>
            hdr->next_free->prev_free = hdr;
   45d9e:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
   45da0:	b103      	cbz	r3, 45da4 <buffer_alloc_free+0xb8>
            hdr->next->prev = hdr;
   45da2:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45da4:	2220      	movs	r2, #32
   45da6:	2100      	movs	r1, #0
   45da8:	f002 f864 	bl	47e74 <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
   45dac:	6933      	ldr	r3, [r6, #16]
   45dae:	079b      	lsls	r3, r3, #30
   45db0:	d519      	bpl.n	45de6 <buffer_alloc_free+0xfa>
   45db2:	f7ff fef7 	bl	45ba4 <verify_chain>
   45db6:	b1b0      	cbz	r0, 45de6 <buffer_alloc_free+0xfa>
        mbedtls_exit( 1 );
}
   45db8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   45dbc:	2001      	movs	r0, #1
   45dbe:	f7fc bdc3 	b.w	42948 <_exit>
                hdr->prev_free->next_free = hdr->next_free;
   45dc2:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
   45dc4:	69a1      	ldr	r1, [r4, #24]
   45dc6:	2900      	cmp	r1, #0
   45dc8:	d0e1      	beq.n	45d8e <buffer_alloc_free+0xa2>
                hdr->next_free->prev_free = hdr->prev_free;
   45dca:	614a      	str	r2, [r1, #20]
   45dcc:	e7df      	b.n	45d8e <buffer_alloc_free+0xa2>
                heap.first_free = hdr->next_free;
   45dce:	60f1      	str	r1, [r6, #12]
   45dd0:	e7f8      	b.n	45dc4 <buffer_alloc_free+0xd8>
            heap.first_free = hdr;
   45dd2:	60f4      	str	r4, [r6, #12]
   45dd4:	e7e1      	b.n	45d9a <buffer_alloc_free+0xae>
    if( old == NULL )
   45dd6:	2f00      	cmp	r7, #0
   45dd8:	d1e8      	bne.n	45dac <buffer_alloc_free+0xc0>
        hdr->next_free = heap.first_free;
   45dda:	68f3      	ldr	r3, [r6, #12]
   45ddc:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
   45dde:	b103      	cbz	r3, 45de2 <buffer_alloc_free+0xf6>
            heap.first_free->prev_free = hdr;
   45de0:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
   45de2:	60f4      	str	r4, [r6, #12]
   45de4:	e7e2      	b.n	45dac <buffer_alloc_free+0xc0>
}
   45de6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   45de8:	2001ad70 	.word	0x2001ad70

00045dec <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
   45dec:	b538      	push	{r3, r4, r5, lr}
   45dee:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45df0:	2214      	movs	r2, #20
   45df2:	2100      	movs	r1, #0
{
   45df4:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45df6:	4812      	ldr	r0, [pc, #72]	; (45e40 <mbedtls_memory_buffer_alloc_init+0x54>)
   45df8:	f002 f83c 	bl	47e74 <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
   45dfc:	4911      	ldr	r1, [pc, #68]	; (45e44 <mbedtls_memory_buffer_alloc_init+0x58>)
   45dfe:	4812      	ldr	r0, [pc, #72]	; (45e48 <mbedtls_memory_buffer_alloc_init+0x5c>)
   45e00:	f7ff fe9e 	bl	45b40 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45e04:	2d23      	cmp	r5, #35	; 0x23
   45e06:	d91a      	bls.n	45e3e <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45e08:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45e0c:	bf1f      	itttt	ne
   45e0e:	3d04      	subne	r5, #4
   45e10:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45e12:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45e16:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
   45e18:	462a      	mov	r2, r5
   45e1a:	2100      	movs	r1, #0
   45e1c:	4620      	mov	r0, r4
   45e1e:	f002 f829 	bl	47e74 <memset>

    heap.buf = buf;
   45e22:	4b07      	ldr	r3, [pc, #28]	; (45e40 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
   45e24:	4a09      	ldr	r2, [pc, #36]	; (45e4c <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
   45e26:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
   45e2a:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
   45e2c:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
   45e2e:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
   45e32:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
   45e34:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
   45e38:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
   45e3a:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
   45e3c:	60dc      	str	r4, [r3, #12]
}
   45e3e:	bd38      	pop	{r3, r4, r5, pc}
   45e40:	2001ad70 	.word	0x2001ad70
   45e44:	00045ced 	.word	0x00045ced
   45e48:	00045be1 	.word	0x00045be1
   45e4c:	ff00aa55 	.word	0xff00aa55

00045e50 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45e50:	4b0e      	ldr	r3, [pc, #56]	; (45e8c <z_sys_init_run_level+0x3c>)
{
   45e52:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45e54:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   45e58:	3001      	adds	r0, #1
   45e5a:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   45e5e:	42a6      	cmp	r6, r4
   45e60:	d800      	bhi.n	45e64 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   45e62:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   45e64:	e9d4 3500 	ldrd	r3, r5, [r4]
   45e68:	4628      	mov	r0, r5
   45e6a:	4798      	blx	r3
		if (dev != NULL) {
   45e6c:	b165      	cbz	r5, 45e88 <z_sys_init_run_level+0x38>
			if (rc != 0) {
   45e6e:	68eb      	ldr	r3, [r5, #12]
   45e70:	b130      	cbz	r0, 45e80 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   45e72:	2800      	cmp	r0, #0
   45e74:	bfb8      	it	lt
   45e76:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   45e78:	28ff      	cmp	r0, #255	; 0xff
   45e7a:	bfa8      	it	ge
   45e7c:	20ff      	movge	r0, #255	; 0xff
   45e7e:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   45e80:	785a      	ldrb	r2, [r3, #1]
   45e82:	f042 0201 	orr.w	r2, r2, #1
   45e86:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45e88:	3408      	adds	r4, #8
   45e8a:	e7e8      	b.n	45e5e <z_sys_init_run_level+0xe>
   45e8c:	00048df0 	.word	0x00048df0

00045e90 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   45e90:	4b01      	ldr	r3, [pc, #4]	; (45e98 <z_impl_z_errno+0x8>)
   45e92:	6898      	ldr	r0, [r3, #8]
}
   45e94:	3060      	adds	r0, #96	; 0x60
   45e96:	4770      	bx	lr
   45e98:	2001ad84 	.word	0x2001ad84

00045e9c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   45e9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   45ea0:	4606      	mov	r6, r0
   45ea2:	460f      	mov	r7, r1
	__asm__ volatile(
   45ea4:	f04f 0320 	mov.w	r3, #32
   45ea8:	f3ef 8811 	mrs	r8, BASEPRI
   45eac:	f383 8812 	msr	BASEPRI_MAX, r3
   45eb0:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   45eb4:	f000 fe32 	bl	46b1c <z_impl_z_current_get>
   45eb8:	4c21      	ldr	r4, [pc, #132]	; (45f40 <z_fatal_error+0xa4>)
   45eba:	4b22      	ldr	r3, [pc, #136]	; (45f44 <z_fatal_error+0xa8>)
   45ebc:	2e04      	cmp	r6, #4
   45ebe:	eba4 0403 	sub.w	r4, r4, r3
   45ec2:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   45ec6:	bf98      	it	ls
   45ec8:	4a1f      	ldrls	r2, [pc, #124]	; (45f48 <z_fatal_error+0xac>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   45eca:	ea4f 1484 	mov.w	r4, r4, lsl #6
   45ece:	f044 0301 	orr.w	r3, r4, #1
   45ed2:	4605      	mov	r5, r0
	switch (reason) {
   45ed4:	bf94      	ite	ls
   45ed6:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   45eda:	4a1c      	ldrhi	r2, [pc, #112]	; (45f4c <z_fatal_error+0xb0>)
   45edc:	f8ad 3000 	strh.w	r3, [sp]
   45ee0:	4631      	mov	r1, r6
   45ee2:	2300      	movs	r3, #0
   45ee4:	481a      	ldr	r0, [pc, #104]	; (45f50 <z_fatal_error+0xb4>)
   45ee6:	f001 fcf5 	bl	478d4 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   45eea:	b147      	cbz	r7, 45efe <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   45eec:	69fb      	ldr	r3, [r7, #28]
   45eee:	f3c3 0308 	ubfx	r3, r3, #0, #9
   45ef2:	b123      	cbz	r3, 45efe <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
   45ef4:	4817      	ldr	r0, [pc, #92]	; (45f54 <z_fatal_error+0xb8>)
   45ef6:	f044 0101 	orr.w	r1, r4, #1
   45efa:	f001 fcb1 	bl	47860 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   45efe:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   45f02:	b12d      	cbz	r5, 45f10 <z_fatal_error+0x74>
   45f04:	4628      	mov	r0, r5
   45f06:	f002 fb1f 	bl	48548 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   45f0a:	b108      	cbz	r0, 45f10 <z_fatal_error+0x74>
   45f0c:	7803      	ldrb	r3, [r0, #0]
   45f0e:	b903      	cbnz	r3, 45f12 <z_fatal_error+0x76>
		thread_name = "unknown";
   45f10:	4811      	ldr	r0, [pc, #68]	; (45f58 <z_fatal_error+0xbc>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
   45f12:	f7fb f92d 	bl	41170 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
   45f16:	4623      	mov	r3, r4
   45f18:	4602      	mov	r2, r0
   45f1a:	4629      	mov	r1, r5
   45f1c:	480f      	ldr	r0, [pc, #60]	; (45f5c <z_fatal_error+0xc0>)
   45f1e:	f001 fcc0 	bl	478a2 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   45f22:	4639      	mov	r1, r7
   45f24:	4630      	mov	r0, r6
   45f26:	f7fd fe05 	bl	43b34 <k_sys_fatal_error_handler>
	__asm__ volatile(
   45f2a:	f388 8811 	msr	BASEPRI, r8
   45f2e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   45f32:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   45f34:	b002      	add	sp, #8
   45f36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   45f3a:	f7fc bb3b 	b.w	425b4 <z_impl_k_thread_abort>
   45f3e:	bf00      	nop
   45f40:	00048bb8 	.word	0x00048bb8
   45f44:	00048b88 	.word	0x00048b88
   45f48:	00048e08 	.word	0x00048e08
   45f4c:	0004955a 	.word	0x0004955a
   45f50:	00049570 	.word	0x00049570
   45f54:	00049598 	.word	0x00049598
   45f58:	00049568 	.word	0x00049568
   45f5c:	000495b9 	.word	0x000495b9

00045f60 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   45f60:	2300      	movs	r3, #0
   45f62:	2201      	movs	r2, #1
{
   45f64:	b510      	push	{r4, lr}
   45f66:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   45f68:	e9cd 2304 	strd	r2, r3, [sp, #16]
   45f6c:	220f      	movs	r2, #15
   45f6e:	9301      	str	r3, [sp, #4]
   45f70:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   45f74:	2318      	movs	r3, #24
   45f76:	4a0b      	ldr	r2, [pc, #44]	; (45fa4 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   45f78:	4c0b      	ldr	r4, [pc, #44]	; (45fa8 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   45f7a:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   45f7e:	f44f 72a0 	mov.w	r2, #320	; 0x140
   45f82:	490a      	ldr	r1, [pc, #40]	; (45fac <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   45f84:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   45f88:	fb02 1100 	mla	r1, r2, r0, r1
   45f8c:	9300      	str	r3, [sp, #0]
   45f8e:	4620      	mov	r0, r4
   45f90:	4b07      	ldr	r3, [pc, #28]	; (45fb0 <init_idle_thread+0x50>)
   45f92:	f000 f90b 	bl	461ac <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   45f96:	7b63      	ldrb	r3, [r4, #13]
   45f98:	f023 0304 	bic.w	r3, r3, #4
   45f9c:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   45f9e:	b006      	add	sp, #24
   45fa0:	bd10      	pop	{r4, pc}
   45fa2:	bf00      	nop
   45fa4:	2001ad84 	.word	0x2001ad84
   45fa8:	2001a768 	.word	0x2001a768
   45fac:	20023228 	.word	0x20023228
   45fb0:	000462f5 	.word	0x000462f5

00045fb4 <bg_thread_main>:
	z_sys_post_kernel = true;
   45fb4:	2201      	movs	r2, #1
{
   45fb6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   45fb8:	4b09      	ldr	r3, [pc, #36]	; (45fe0 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   45fba:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   45fbc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   45fbe:	f7ff ff47 	bl	45e50 <z_sys_init_run_level>
	boot_banner();
   45fc2:	f001 f81d 	bl	47000 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   45fc6:	2003      	movs	r0, #3
   45fc8:	f7ff ff42 	bl	45e50 <z_sys_init_run_level>
	z_init_static_threads();
   45fcc:	f000 f94a 	bl	46264 <z_init_static_threads>
	main();
   45fd0:	f7fa fa36 	bl	40440 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   45fd4:	4a03      	ldr	r2, [pc, #12]	; (45fe4 <bg_thread_main+0x30>)
   45fd6:	7b13      	ldrb	r3, [r2, #12]
   45fd8:	f023 0301 	bic.w	r3, r3, #1
   45fdc:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   45fde:	bd08      	pop	{r3, pc}
   45fe0:	20020b22 	.word	0x20020b22
   45fe4:	2001a7e8 	.word	0x2001a7e8

00045fe8 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   45fe8:	4802      	ldr	r0, [pc, #8]	; (45ff4 <z_bss_zero+0xc>)
   45fea:	4a03      	ldr	r2, [pc, #12]	; (45ff8 <z_bss_zero+0x10>)
   45fec:	2100      	movs	r1, #0
   45fee:	1a12      	subs	r2, r2, r0
   45ff0:	f001 bf40 	b.w	47e74 <memset>
   45ff4:	2001a678 	.word	0x2001a678
   45ff8:	20020b24 	.word	0x20020b24

00045ffc <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   45ffc:	b580      	push	{r7, lr}
   45ffe:	b0a6      	sub	sp, #152	; 0x98
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   46000:	f7fb f806 	bl	41010 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   46004:	4b2f      	ldr	r3, [pc, #188]	; (460c4 <z_cstart+0xc8>)
	uint32_t msp =
   46006:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   4600a:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   4600e:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   46012:	2400      	movs	r4, #0
   46014:	23e0      	movs	r3, #224	; 0xe0
   46016:	4d2c      	ldr	r5, [pc, #176]	; (460c8 <z_cstart+0xcc>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   46018:	4e2c      	ldr	r6, [pc, #176]	; (460cc <z_cstart+0xd0>)
   4601a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   4601e:	77ec      	strb	r4, [r5, #31]
   46020:	762c      	strb	r4, [r5, #24]
   46022:	766c      	strb	r4, [r5, #25]
   46024:	76ac      	strb	r4, [r5, #26]
   46026:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   4602a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4602c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 460e0 <z_cstart+0xe4>
   46030:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   46034:	626b      	str	r3, [r5, #36]	; 0x24
   46036:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   4603a:	f7fc fa33 	bl	424a4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   4603e:	f7fb fe8f 	bl	41d60 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   46042:	f04f 33ff 	mov.w	r3, #4294967295
   46046:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   46048:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   4604a:	f7fc fc3f 	bl	428cc <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   4604e:	f7fc fac3 	bl	425d8 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   46052:	f240 1301 	movw	r3, #257	; 0x101
   46056:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   4605a:	ab06      	add	r3, sp, #24
   4605c:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   4605e:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   46062:	f002 f9a3 	bl	483ac <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   46066:	4620      	mov	r0, r4
   46068:	f7ff fef2 	bl	45e50 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   4606c:	2001      	movs	r0, #1
   4606e:	f7ff feef 	bl	45e50 <z_sys_init_run_level>
	z_sched_init();
   46072:	f000 fca5 	bl	469c0 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46076:	4b16      	ldr	r3, [pc, #88]	; (460d0 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   46078:	4d16      	ldr	r5, [pc, #88]	; (460d4 <z_cstart+0xd8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4607a:	9305      	str	r3, [sp, #20]
   4607c:	2301      	movs	r3, #1
   4607e:	4916      	ldr	r1, [pc, #88]	; (460d8 <z_cstart+0xdc>)
   46080:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   46084:	e9cd 4303 	strd	r4, r3, [sp, #12]
   46088:	4628      	mov	r0, r5
   4608a:	464b      	mov	r3, r9
   4608c:	e9cd 4401 	strd	r4, r4, [sp, #4]
   46090:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   46092:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46094:	f000 f88a 	bl	461ac <z_setup_new_thread>
   46098:	4607      	mov	r7, r0
   4609a:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   4609c:	4628      	mov	r0, r5
   4609e:	f022 0204 	bic.w	r2, r2, #4
   460a2:	736a      	strb	r2, [r5, #13]
   460a4:	f002 fac2 	bl	4862c <z_ready_thread>
		init_idle_thread(i);
   460a8:	4620      	mov	r0, r4
   460aa:	f7ff ff59 	bl	45f60 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   460ae:	4b0b      	ldr	r3, [pc, #44]	; (460dc <z_cstart+0xe0>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   460b0:	464a      	mov	r2, r9
   460b2:	4639      	mov	r1, r7
   460b4:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   460b6:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   460b8:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   460ba:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   460be:	f7fb ff7f 	bl	41fc0 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   460c2:	bf00      	nop
   460c4:	20023368 	.word	0x20023368
   460c8:	e000ed00 	.word	0xe000ed00
   460cc:	2001ad84 	.word	0x2001ad84
   460d0:	0004961b 	.word	0x0004961b
   460d4:	2001a7e8 	.word	0x2001a7e8
   460d8:	20021228 	.word	0x20021228
   460dc:	2001a768 	.word	0x2001a768
   460e0:	00045fb5 	.word	0x00045fb5

000460e4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   460e4:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   460e6:	4c06      	ldr	r4, [pc, #24]	; (46100 <statics_init+0x1c>)
   460e8:	4d06      	ldr	r5, [pc, #24]	; (46104 <statics_init+0x20>)
   460ea:	42ac      	cmp	r4, r5
   460ec:	d301      	bcc.n	460f2 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   460ee:	2000      	movs	r0, #0
   460f0:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   460f2:	4620      	mov	r0, r4
   460f4:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   460f8:	f002 f963 	bl	483c2 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   460fc:	3414      	adds	r4, #20
   460fe:	e7f4      	b.n	460ea <statics_init+0x6>
   46100:	2001a62c 	.word	0x2001a62c
   46104:	2001a640 	.word	0x2001a640

00046108 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   46108:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4610a:	4b0e      	ldr	r3, [pc, #56]	; (46144 <init_mem_slab_module+0x3c>)
   4610c:	4c0e      	ldr	r4, [pc, #56]	; (46148 <init_mem_slab_module+0x40>)
   4610e:	42a3      	cmp	r3, r4
   46110:	d301      	bcc.n	46116 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   46112:	2000      	movs	r0, #0
	return rc;
}
   46114:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   46116:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   4611a:	ea41 0200 	orr.w	r2, r1, r0
   4611e:	f012 0203 	ands.w	r2, r2, #3
   46122:	d10b      	bne.n	4613c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   46124:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   46126:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46128:	42aa      	cmp	r2, r5
   4612a:	d101      	bne.n	46130 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4612c:	331c      	adds	r3, #28
   4612e:	e7ee      	b.n	4610e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   46130:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46132:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   46134:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   46136:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   46138:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   4613a:	e7f5      	b.n	46128 <init_mem_slab_module+0x20>
		return -EINVAL;
   4613c:	f06f 0015 	mvn.w	r0, #21
	return rc;
   46140:	e7e8      	b.n	46114 <init_mem_slab_module+0xc>
   46142:	bf00      	nop
   46144:	2001a62c 	.word	0x2001a62c
   46148:	2001a62c 	.word	0x2001a62c

0004614c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   4614c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   4614e:	460c      	mov	r4, r1
   46150:	4616      	mov	r6, r2
   46152:	461f      	mov	r7, r3
	__asm__ volatile(
   46154:	f04f 0320 	mov.w	r3, #32
   46158:	f3ef 8111 	mrs	r1, BASEPRI
   4615c:	f383 8812 	msr	BASEPRI_MAX, r3
   46160:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   46164:	6943      	ldr	r3, [r0, #20]
   46166:	b15b      	cbz	r3, 46180 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   46168:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   4616a:	681b      	ldr	r3, [r3, #0]
   4616c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   4616e:	6983      	ldr	r3, [r0, #24]
   46170:	3301      	adds	r3, #1
   46172:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   46174:	2000      	movs	r0, #0
	__asm__ volatile(
   46176:	f381 8811 	msr	BASEPRI, r1
   4617a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   4617e:	e011      	b.n	461a4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   46180:	ea56 0207 	orrs.w	r2, r6, r7
   46184:	d103      	bne.n	4618e <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   46186:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   4618a:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   4618c:	e7f3      	b.n	46176 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   4618e:	4602      	mov	r2, r0
   46190:	e9cd 6700 	strd	r6, r7, [sp]
   46194:	3008      	adds	r0, #8
   46196:	f000 fb65 	bl	46864 <z_pend_curr>
		if (result == 0) {
   4619a:	b918      	cbnz	r0, 461a4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   4619c:	4b02      	ldr	r3, [pc, #8]	; (461a8 <k_mem_slab_alloc+0x5c>)
   4619e:	689b      	ldr	r3, [r3, #8]
   461a0:	695b      	ldr	r3, [r3, #20]
   461a2:	6023      	str	r3, [r4, #0]
}
   461a4:	b002      	add	sp, #8
   461a6:	bdd0      	pop	{r4, r6, r7, pc}
   461a8:	2001ad84 	.word	0x2001ad84

000461ac <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   461ac:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   461b0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   461b2:	f100 0558 	add.w	r5, r0, #88	; 0x58
   461b6:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   461b8:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   461ba:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   461be:	2500      	movs	r5, #0
{
   461c0:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   461c2:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   461c4:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   461c6:	e9c0 5506 	strd	r5, r5, [r0, #24]
   461ca:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   461cc:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   461ce:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   461d0:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   461d4:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   461d8:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   461da:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   461dc:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   461de:	9202      	str	r2, [sp, #8]
   461e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   461e2:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   461e6:	9201      	str	r2, [sp, #4]
   461e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   461ea:	9200      	str	r2, [sp, #0]
   461ec:	4642      	mov	r2, r8
   461ee:	f7fb fec9 	bl	41f84 <arch_new_thread>
	if (!_current) {
   461f2:	4b05      	ldr	r3, [pc, #20]	; (46208 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   461f4:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   461f6:	689b      	ldr	r3, [r3, #8]
   461f8:	b103      	cbz	r3, 461fc <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   461fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   461fc:	4640      	mov	r0, r8
   461fe:	6723      	str	r3, [r4, #112]	; 0x70
   46200:	b004      	add	sp, #16
   46202:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46206:	bf00      	nop
   46208:	2001ad84 	.word	0x2001ad84

0004620c <z_impl_k_thread_create>:
{
   4620c:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4620e:	2500      	movs	r5, #0
{
   46210:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46212:	9505      	str	r5, [sp, #20]
   46214:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   46216:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4621a:	9504      	str	r5, [sp, #16]
   4621c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   4621e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46220:	9503      	str	r5, [sp, #12]
   46222:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   46224:	9502      	str	r5, [sp, #8]
   46226:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   46228:	9501      	str	r5, [sp, #4]
   4622a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   4622c:	9500      	str	r5, [sp, #0]
   4622e:	f7ff ffbd 	bl	461ac <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   46232:	1c7b      	adds	r3, r7, #1
   46234:	bf08      	it	eq
   46236:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   4623a:	d005      	beq.n	46248 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   4623c:	ea56 0307 	orrs.w	r3, r6, r7
   46240:	d105      	bne.n	4624e <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   46242:	4620      	mov	r0, r4
   46244:	f000 fab2 	bl	467ac <z_sched_start>
}
   46248:	4620      	mov	r0, r4
   4624a:	b007      	add	sp, #28
   4624c:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   4624e:	4632      	mov	r2, r6
   46250:	463b      	mov	r3, r7
   46252:	4903      	ldr	r1, [pc, #12]	; (46260 <z_impl_k_thread_create+0x54>)
   46254:	f104 0018 	add.w	r0, r4, #24
   46258:	f000 fd22 	bl	46ca0 <z_add_timeout>
   4625c:	e7f4      	b.n	46248 <z_impl_k_thread_create+0x3c>
   4625e:	bf00      	nop
   46260:	0004864d 	.word	0x0004864d

00046264 <z_init_static_threads>:
{
   46264:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   46266:	4e20      	ldr	r6, [pc, #128]	; (462e8 <z_init_static_threads+0x84>)
   46268:	4d20      	ldr	r5, [pc, #128]	; (462ec <z_init_static_threads+0x88>)
   4626a:	4637      	mov	r7, r6
{
   4626c:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   4626e:	42b5      	cmp	r5, r6
   46270:	f105 0430 	add.w	r4, r5, #48	; 0x30
   46274:	d30a      	bcc.n	4628c <z_init_static_threads+0x28>
	k_sched_lock();
   46276:	f000 f9ad 	bl	465d4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   4627a:	4c1c      	ldr	r4, [pc, #112]	; (462ec <z_init_static_threads+0x88>)
   4627c:	4d1c      	ldr	r5, [pc, #112]	; (462f0 <z_init_static_threads+0x8c>)
   4627e:	42bc      	cmp	r4, r7
   46280:	d321      	bcc.n	462c6 <z_init_static_threads+0x62>
}
   46282:	b007      	add	sp, #28
   46284:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   46288:	f000 bb7e 	b.w	46988 <k_sched_unlock>
		z_setup_new_thread(
   4628c:	f854 3c04 	ldr.w	r3, [r4, #-4]
   46290:	9305      	str	r3, [sp, #20]
   46292:	f854 3c10 	ldr.w	r3, [r4, #-16]
   46296:	9304      	str	r3, [sp, #16]
   46298:	f854 3c14 	ldr.w	r3, [r4, #-20]
   4629c:	9303      	str	r3, [sp, #12]
   4629e:	f854 3c18 	ldr.w	r3, [r4, #-24]
   462a2:	9302      	str	r3, [sp, #8]
   462a4:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   462a8:	9301      	str	r3, [sp, #4]
   462aa:	f854 3c20 	ldr.w	r3, [r4, #-32]
   462ae:	9300      	str	r3, [sp, #0]
   462b0:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   462b4:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   462b8:	f7ff ff78 	bl	461ac <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   462bc:	f854 3c30 	ldr.w	r3, [r4, #-48]
   462c0:	655d      	str	r5, [r3, #84]	; 0x54
   462c2:	4625      	mov	r5, r4
   462c4:	e7d3      	b.n	4626e <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   462c6:	6a62      	ldr	r2, [r4, #36]	; 0x24
   462c8:	1c53      	adds	r3, r2, #1
   462ca:	d004      	beq.n	462d6 <z_init_static_threads+0x72>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   462cc:	2a00      	cmp	r2, #0
			schedule_new_thread(thread_data->init_thread,
   462ce:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   462d0:	dc03      	bgt.n	462da <z_init_static_threads+0x76>
	z_sched_start(thread);
   462d2:	f000 fa6b 	bl	467ac <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   462d6:	3430      	adds	r4, #48	; 0x30
   462d8:	e7d1      	b.n	4627e <z_init_static_threads+0x1a>
   462da:	4629      	mov	r1, r5
   462dc:	17d3      	asrs	r3, r2, #31
   462de:	3018      	adds	r0, #24
   462e0:	f000 fcde 	bl	46ca0 <z_add_timeout>
   462e4:	e7f7      	b.n	462d6 <z_init_static_threads+0x72>
   462e6:	bf00      	nop
   462e8:	2001a62c 	.word	0x2001a62c
   462ec:	2001a62c 	.word	0x2001a62c
   462f0:	0004864d 	.word	0x0004864d

000462f4 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   462f4:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   462f6:	4c09      	ldr	r4, [pc, #36]	; (4631c <idle+0x28>)
	__asm__ volatile(
   462f8:	f04f 0220 	mov.w	r2, #32
   462fc:	f3ef 8311 	mrs	r3, BASEPRI
   46300:	f382 8812 	msr	BASEPRI_MAX, r2
   46304:	f3bf 8f6f 	isb	sy
   46308:	f002 fa42 	bl	48790 <z_get_next_timeout_expiry>
   4630c:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   4630e:	f7fb fca7 	bl	41c60 <pm_system_suspend>
   46312:	2800      	cmp	r0, #0
   46314:	d1f0      	bne.n	462f8 <idle+0x4>
	arch_cpu_idle();
   46316:	f7fb fd29 	bl	41d6c <arch_cpu_idle>
}
   4631a:	e7ed      	b.n	462f8 <idle+0x4>
   4631c:	2001ad84 	.word	0x2001ad84

00046320 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   46320:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46324:	4604      	mov	r4, r0
   46326:	4616      	mov	r6, r2
   46328:	461f      	mov	r7, r3
   4632a:	f04f 0320 	mov.w	r3, #32
   4632e:	f3ef 8811 	mrs	r8, BASEPRI
   46332:	f383 8812 	msr	BASEPRI_MAX, r3
   46336:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   4633a:	68c3      	ldr	r3, [r0, #12]
   4633c:	4a35      	ldr	r2, [pc, #212]	; (46414 <z_impl_k_mutex_lock+0xf4>)
   4633e:	b16b      	cbz	r3, 4635c <z_impl_k_mutex_lock+0x3c>
   46340:	6880      	ldr	r0, [r0, #8]
   46342:	6891      	ldr	r1, [r2, #8]
   46344:	4288      	cmp	r0, r1
   46346:	d019      	beq.n	4637c <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   46348:	ea56 0307 	orrs.w	r3, r6, r7
   4634c:	d118      	bne.n	46380 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   4634e:	f388 8811 	msr	BASEPRI, r8
   46352:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   46356:	f06f 000f 	mvn.w	r0, #15
   4635a:	e00c      	b.n	46376 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   4635c:	6891      	ldr	r1, [r2, #8]
   4635e:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   46362:	3301      	adds	r3, #1
   46364:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   46366:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   46368:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   4636a:	60a3      	str	r3, [r4, #8]
   4636c:	f388 8811 	msr	BASEPRI, r8
   46370:	f3bf 8f6f 	isb	sy
		return 0;
   46374:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   46376:	b002      	add	sp, #8
   46378:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   4637c:	6921      	ldr	r1, [r4, #16]
   4637e:	e7f0      	b.n	46362 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   46380:	f991 100e 	ldrsb.w	r1, [r1, #14]
   46384:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   46388:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   4638c:	4299      	cmp	r1, r3
   4638e:	bfa8      	it	ge
   46390:	4619      	movge	r1, r3
   46392:	4291      	cmp	r1, r2
   46394:	bfb8      	it	lt
   46396:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   46398:	428b      	cmp	r3, r1
   4639a:	dd2f      	ble.n	463fc <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   4639c:	f000 fa76 	bl	4688c <z_set_prio>
   463a0:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   463a2:	4622      	mov	r2, r4
   463a4:	4641      	mov	r1, r8
   463a6:	e9cd 6700 	strd	r6, r7, [sp]
   463aa:	481b      	ldr	r0, [pc, #108]	; (46418 <z_impl_k_mutex_lock+0xf8>)
   463ac:	f000 fa5a 	bl	46864 <z_pend_curr>
	if (got_mutex == 0) {
   463b0:	2800      	cmp	r0, #0
   463b2:	d0e0      	beq.n	46376 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   463b4:	f04f 0320 	mov.w	r3, #32
   463b8:	f3ef 8611 	mrs	r6, BASEPRI
   463bc:	f383 8812 	msr	BASEPRI_MAX, r3
   463c0:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   463c4:	6823      	ldr	r3, [r4, #0]
   463c6:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   463c8:	429c      	cmp	r4, r3
   463ca:	d00a      	beq.n	463e2 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   463cc:	b14b      	cbz	r3, 463e2 <z_impl_k_mutex_lock+0xc2>
   463ce:	f993 300e 	ldrsb.w	r3, [r3, #14]
   463d2:	4299      	cmp	r1, r3
   463d4:	bfa8      	it	ge
   463d6:	4619      	movge	r1, r3
   463d8:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   463dc:	4299      	cmp	r1, r3
   463de:	bfb8      	it	lt
   463e0:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   463e2:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   463e4:	f990 300e 	ldrsb.w	r3, [r0, #14]
   463e8:	4299      	cmp	r1, r3
   463ea:	d109      	bne.n	46400 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   463ec:	b16d      	cbz	r5, 4640a <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   463ee:	4631      	mov	r1, r6
   463f0:	4809      	ldr	r0, [pc, #36]	; (46418 <z_impl_k_mutex_lock+0xf8>)
   463f2:	f000 f8dd 	bl	465b0 <z_reschedule>
	return -EAGAIN;
   463f6:	f06f 000a 	mvn.w	r0, #10
   463fa:	e7bc      	b.n	46376 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   463fc:	2500      	movs	r5, #0
   463fe:	e7d0      	b.n	463a2 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   46400:	f000 fa44 	bl	4688c <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46404:	2800      	cmp	r0, #0
   46406:	d1f2      	bne.n	463ee <z_impl_k_mutex_lock+0xce>
   46408:	e7f0      	b.n	463ec <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   4640a:	f386 8811 	msr	BASEPRI, r6
   4640e:	f3bf 8f6f 	isb	sy
   46412:	e7f0      	b.n	463f6 <z_impl_k_mutex_lock+0xd6>
   46414:	2001ad84 	.word	0x2001ad84
   46418:	20020b23 	.word	0x20020b23

0004641c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   4641c:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   4641e:	6883      	ldr	r3, [r0, #8]
{
   46420:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   46422:	2b00      	cmp	r3, #0
   46424:	d036      	beq.n	46494 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   46426:	4a1e      	ldr	r2, [pc, #120]	; (464a0 <z_impl_k_mutex_unlock+0x84>)
   46428:	6892      	ldr	r2, [r2, #8]
   4642a:	4293      	cmp	r3, r2
   4642c:	d135      	bne.n	4649a <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   4642e:	7bda      	ldrb	r2, [r3, #15]
   46430:	3a01      	subs	r2, #1
   46432:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   46434:	68c3      	ldr	r3, [r0, #12]
   46436:	2b01      	cmp	r3, #1
   46438:	d905      	bls.n	46446 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   4643a:	3b01      	subs	r3, #1
   4643c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   4643e:	f000 faa3 	bl	46988 <k_sched_unlock>

	return 0;
   46442:	2000      	movs	r0, #0
}
   46444:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   46446:	f04f 0320 	mov.w	r3, #32
   4644a:	f3ef 8511 	mrs	r5, BASEPRI
   4644e:	f383 8812 	msr	BASEPRI_MAX, r3
   46452:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   46456:	6901      	ldr	r1, [r0, #16]
   46458:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   4645a:	f990 300e 	ldrsb.w	r3, [r0, #14]
   4645e:	4299      	cmp	r1, r3
   46460:	d001      	beq.n	46466 <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   46462:	f000 fa13 	bl	4688c <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   46466:	4620      	mov	r0, r4
   46468:	f002 f954 	bl	48714 <z_unpend_first_thread>
	mutex->owner = new_owner;
   4646c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   4646e:	b158      	cbz	r0, 46488 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   46470:	f990 200e 	ldrsb.w	r2, [r0, #14]
   46474:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   46476:	2200      	movs	r2, #0
   46478:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   4647a:	f002 f8d7 	bl	4862c <z_ready_thread>
		z_reschedule(&lock, key);
   4647e:	4629      	mov	r1, r5
   46480:	4808      	ldr	r0, [pc, #32]	; (464a4 <z_impl_k_mutex_unlock+0x88>)
   46482:	f000 f895 	bl	465b0 <z_reschedule>
   46486:	e7da      	b.n	4643e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   46488:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4648a:	f385 8811 	msr	BASEPRI, r5
   4648e:	f3bf 8f6f 	isb	sy
   46492:	e7d4      	b.n	4643e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   46494:	f06f 0015 	mvn.w	r0, #21
   46498:	e7d4      	b.n	46444 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   4649a:	f04f 30ff 	mov.w	r0, #4294967295
   4649e:	e7d1      	b.n	46444 <z_impl_k_mutex_unlock+0x28>
   464a0:	2001ad84 	.word	0x2001ad84
   464a4:	20020b23 	.word	0x20020b23

000464a8 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   464a8:	b538      	push	{r3, r4, r5, lr}
   464aa:	4604      	mov	r4, r0
	__asm__ volatile(
   464ac:	f04f 0320 	mov.w	r3, #32
   464b0:	f3ef 8511 	mrs	r5, BASEPRI
   464b4:	f383 8812 	msr	BASEPRI_MAX, r3
   464b8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   464bc:	f002 f92a 	bl	48714 <z_unpend_first_thread>

	if (thread != NULL) {
   464c0:	b148      	cbz	r0, 464d6 <z_impl_k_sem_give+0x2e>
   464c2:	2200      	movs	r2, #0
   464c4:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   464c6:	f002 f8b1 	bl	4862c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   464ca:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   464cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   464d0:	4804      	ldr	r0, [pc, #16]	; (464e4 <z_impl_k_sem_give+0x3c>)
   464d2:	f000 b86d 	b.w	465b0 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   464d6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   464da:	429a      	cmp	r2, r3
   464dc:	bf18      	it	ne
   464de:	3301      	addne	r3, #1
   464e0:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   464e2:	e7f2      	b.n	464ca <z_impl_k_sem_give+0x22>
   464e4:	20020b23 	.word	0x20020b23

000464e8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   464e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   464ea:	4614      	mov	r4, r2
   464ec:	461d      	mov	r5, r3
   464ee:	f04f 0320 	mov.w	r3, #32
   464f2:	f3ef 8111 	mrs	r1, BASEPRI
   464f6:	f383 8812 	msr	BASEPRI_MAX, r3
   464fa:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   464fe:	6883      	ldr	r3, [r0, #8]
   46500:	b143      	cbz	r3, 46514 <z_impl_k_sem_take+0x2c>
		sem->count--;
   46502:	3b01      	subs	r3, #1
   46504:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   46506:	f381 8811 	msr	BASEPRI, r1
   4650a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   4650e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   46510:	b003      	add	sp, #12
   46512:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46514:	ea54 0305 	orrs.w	r3, r4, r5
   46518:	d106      	bne.n	46528 <z_impl_k_sem_take+0x40>
   4651a:	f381 8811 	msr	BASEPRI, r1
   4651e:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   46522:	f06f 000f 	mvn.w	r0, #15
   46526:	e7f3      	b.n	46510 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   46528:	4602      	mov	r2, r0
   4652a:	e9cd 4500 	strd	r4, r5, [sp]
   4652e:	4802      	ldr	r0, [pc, #8]	; (46538 <z_impl_k_sem_take+0x50>)
   46530:	f000 f998 	bl	46864 <z_pend_curr>
	return ret;
   46534:	e7ec      	b.n	46510 <z_impl_k_sem_take+0x28>
   46536:	bf00      	nop
   46538:	20020b23 	.word	0x20020b23

0004653c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   4653c:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   4653e:	4c08      	ldr	r4, [pc, #32]	; (46560 <z_reset_time_slice+0x24>)
   46540:	6823      	ldr	r3, [r4, #0]
   46542:	b15b      	cbz	r3, 4655c <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46544:	f7fd f940 	bl	437c8 <sys_clock_elapsed>
   46548:	4603      	mov	r3, r0
   4654a:	6820      	ldr	r0, [r4, #0]
   4654c:	4a05      	ldr	r2, [pc, #20]	; (46564 <z_reset_time_slice+0x28>)
   4654e:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   46550:	2100      	movs	r1, #0
	}
}
   46552:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46556:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   46558:	f002 b92a 	b.w	487b0 <z_set_timeout_expiry>
}
   4655c:	bd10      	pop	{r4, pc}
   4655e:	bf00      	nop
   46560:	2001adb4 	.word	0x2001adb4
   46564:	2001ad84 	.word	0x2001ad84

00046568 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   46568:	b510      	push	{r4, lr}
	__asm__ volatile(
   4656a:	f04f 0320 	mov.w	r3, #32
   4656e:	f3ef 8411 	mrs	r4, BASEPRI
   46572:	f383 8812 	msr	BASEPRI_MAX, r3
   46576:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   4657a:	2200      	movs	r2, #0
   4657c:	4b09      	ldr	r3, [pc, #36]	; (465a4 <k_sched_time_slice_set+0x3c>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   4657e:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
   46580:	611a      	str	r2, [r3, #16]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   46582:	4b09      	ldr	r3, [pc, #36]	; (465a8 <k_sched_time_slice_set+0x40>)
   46584:	dc09      	bgt.n	4659a <k_sched_time_slice_set+0x32>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   46586:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   46588:	4b08      	ldr	r3, [pc, #32]	; (465ac <k_sched_time_slice_set+0x44>)
   4658a:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
   4658c:	f7ff ffd6 	bl	4653c <z_reset_time_slice>
	__asm__ volatile(
   46590:	f384 8811 	msr	BASEPRI, r4
   46594:	f3bf 8f6f 	isb	sy
	}
}
   46598:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
   4659a:	2802      	cmp	r0, #2
   4659c:	bfb8      	it	lt
   4659e:	2002      	movlt	r0, #2
   465a0:	e7f1      	b.n	46586 <k_sched_time_slice_set+0x1e>
   465a2:	bf00      	nop
   465a4:	2001ad84 	.word	0x2001ad84
   465a8:	2001adb4 	.word	0x2001adb4
   465ac:	2001adb0 	.word	0x2001adb0

000465b0 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   465b0:	b949      	cbnz	r1, 465c6 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   465b2:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   465b6:	b930      	cbnz	r0, 465c6 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   465b8:	4b05      	ldr	r3, [pc, #20]	; (465d0 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   465ba:	69da      	ldr	r2, [r3, #28]
   465bc:	689b      	ldr	r3, [r3, #8]
   465be:	429a      	cmp	r2, r3
   465c0:	d001      	beq.n	465c6 <z_reschedule+0x16>
	ret = arch_swap(key);
   465c2:	f7fb bc85 	b.w	41ed0 <arch_swap>
   465c6:	f381 8811 	msr	BASEPRI, r1
   465ca:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   465ce:	4770      	bx	lr
   465d0:	2001ad84 	.word	0x2001ad84

000465d4 <k_sched_lock>:
	__asm__ volatile(
   465d4:	f04f 0320 	mov.w	r3, #32
   465d8:	f3ef 8111 	mrs	r1, BASEPRI
   465dc:	f383 8812 	msr	BASEPRI_MAX, r3
   465e0:	f3bf 8f6f 	isb	sy
   465e4:	4b04      	ldr	r3, [pc, #16]	; (465f8 <k_sched_lock+0x24>)
   465e6:	689a      	ldr	r2, [r3, #8]
   465e8:	7bd3      	ldrb	r3, [r2, #15]
   465ea:	3b01      	subs	r3, #1
   465ec:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   465ee:	f381 8811 	msr	BASEPRI, r1
   465f2:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   465f6:	4770      	bx	lr
   465f8:	2001ad84 	.word	0x2001ad84

000465fc <update_cache>:
{
   465fc:	b538      	push	{r3, r4, r5, lr}
   465fe:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   46600:	480c      	ldr	r0, [pc, #48]	; (46634 <update_cache+0x38>)
   46602:	f002 f809 	bl	48618 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   46606:	4d0c      	ldr	r5, [pc, #48]	; (46638 <update_cache+0x3c>)
   46608:	4604      	mov	r4, r0
   4660a:	b900      	cbnz	r0, 4660e <update_cache+0x12>
   4660c:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   4660e:	68ab      	ldr	r3, [r5, #8]
   46610:	b94a      	cbnz	r2, 46626 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   46612:	7b5a      	ldrb	r2, [r3, #13]
   46614:	06d2      	lsls	r2, r2, #27
   46616:	d106      	bne.n	46626 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   46618:	69a2      	ldr	r2, [r4, #24]
   4661a:	b922      	cbnz	r2, 46626 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   4661c:	89da      	ldrh	r2, [r3, #14]
   4661e:	2a7f      	cmp	r2, #127	; 0x7f
   46620:	d901      	bls.n	46626 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   46622:	61eb      	str	r3, [r5, #28]
}
   46624:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   46626:	429c      	cmp	r4, r3
   46628:	d001      	beq.n	4662e <update_cache+0x32>
			z_reset_time_slice();
   4662a:	f7ff ff87 	bl	4653c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   4662e:	61ec      	str	r4, [r5, #28]
}
   46630:	e7f8      	b.n	46624 <update_cache+0x28>
   46632:	bf00      	nop
   46634:	2001ada4 	.word	0x2001ada4
   46638:	2001ad84 	.word	0x2001ad84

0004663c <move_thread_to_end_of_prio_q>:
{
   4663c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   4663e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46642:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46644:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46646:	7b43      	ldrb	r3, [r0, #13]
   46648:	da04      	bge.n	46654 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   4664a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4664e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   46650:	f001 ff96 	bl	48580 <sys_dlist_remove>
	return list->head == list;
   46654:	4a17      	ldr	r2, [pc, #92]	; (466b4 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46656:	7b4b      	ldrb	r3, [r1, #13]
   46658:	4610      	mov	r0, r2
   4665a:	f063 037f 	orn	r3, r3, #127	; 0x7f
   4665e:	734b      	strb	r3, [r1, #13]
   46660:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46664:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46666:	4283      	cmp	r3, r0
   46668:	bf08      	it	eq
   4666a:	2300      	moveq	r3, #0
   4666c:	2b00      	cmp	r3, #0
   4666e:	bf38      	it	cc
   46670:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46672:	b1cb      	cbz	r3, 466a8 <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   46674:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   46678:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   4667c:	42a6      	cmp	r6, r4
   4667e:	d00f      	beq.n	466a0 <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   46680:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46682:	2c00      	cmp	r4, #0
   46684:	dd0c      	ble.n	466a0 <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   46686:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   46688:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   4668c:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   4668e:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   46690:	6890      	ldr	r0, [r2, #8]
}
   46692:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   46696:	1a43      	subs	r3, r0, r1
   46698:	4258      	negs	r0, r3
   4669a:	4158      	adcs	r0, r3
   4669c:	f7ff bfae 	b.w	465fc <update_cache>
	return (node == list->tail) ? NULL : node->next;
   466a0:	42ab      	cmp	r3, r5
   466a2:	d001      	beq.n	466a8 <move_thread_to_end_of_prio_q+0x6c>
   466a4:	681b      	ldr	r3, [r3, #0]
   466a6:	e7e4      	b.n	46672 <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   466a8:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   466ac:	6029      	str	r1, [r5, #0]
	list->tail = node;
   466ae:	6251      	str	r1, [r2, #36]	; 0x24
}
   466b0:	e7ee      	b.n	46690 <move_thread_to_end_of_prio_q+0x54>
   466b2:	bf00      	nop
   466b4:	2001ad84 	.word	0x2001ad84

000466b8 <z_time_slice>:
{
   466b8:	4601      	mov	r1, r0
   466ba:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   466bc:	f04f 0320 	mov.w	r3, #32
   466c0:	f3ef 8411 	mrs	r4, BASEPRI
   466c4:	f383 8812 	msr	BASEPRI_MAX, r3
   466c8:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   466cc:	4b16      	ldr	r3, [pc, #88]	; (46728 <z_time_slice+0x70>)
   466ce:	4a17      	ldr	r2, [pc, #92]	; (4672c <z_time_slice+0x74>)
   466d0:	6898      	ldr	r0, [r3, #8]
   466d2:	6815      	ldr	r5, [r2, #0]
   466d4:	42a8      	cmp	r0, r5
   466d6:	461d      	mov	r5, r3
   466d8:	d106      	bne.n	466e8 <z_time_slice+0x30>
			z_reset_time_slice();
   466da:	f7ff ff2f 	bl	4653c <z_reset_time_slice>
	__asm__ volatile(
   466de:	f384 8811 	msr	BASEPRI, r4
   466e2:	f3bf 8f6f 	isb	sy
}
   466e6:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   466e8:	2600      	movs	r6, #0
   466ea:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   466ec:	4a10      	ldr	r2, [pc, #64]	; (46730 <z_time_slice+0x78>)
   466ee:	6812      	ldr	r2, [r2, #0]
   466f0:	b1ba      	cbz	r2, 46722 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   466f2:	89c2      	ldrh	r2, [r0, #14]
   466f4:	2a7f      	cmp	r2, #127	; 0x7f
   466f6:	d814      	bhi.n	46722 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   466f8:	7b42      	ldrb	r2, [r0, #13]
   466fa:	06d2      	lsls	r2, r2, #27
   466fc:	d111      	bne.n	46722 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   466fe:	4a0d      	ldr	r2, [pc, #52]	; (46734 <z_time_slice+0x7c>)
   46700:	f990 600e 	ldrsb.w	r6, [r0, #14]
   46704:	6812      	ldr	r2, [r2, #0]
   46706:	4296      	cmp	r6, r2
   46708:	db0b      	blt.n	46722 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   4670a:	4a0b      	ldr	r2, [pc, #44]	; (46738 <z_time_slice+0x80>)
   4670c:	4290      	cmp	r0, r2
   4670e:	d008      	beq.n	46722 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   46710:	691a      	ldr	r2, [r3, #16]
   46712:	428a      	cmp	r2, r1
   46714:	dc02      	bgt.n	4671c <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   46716:	f7ff ff91 	bl	4663c <move_thread_to_end_of_prio_q>
   4671a:	e7de      	b.n	466da <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   4671c:	1a52      	subs	r2, r2, r1
   4671e:	611a      	str	r2, [r3, #16]
   46720:	e7dd      	b.n	466de <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   46722:	2300      	movs	r3, #0
   46724:	612b      	str	r3, [r5, #16]
   46726:	e7da      	b.n	466de <z_time_slice+0x26>
   46728:	2001ad84 	.word	0x2001ad84
   4672c:	2001adac 	.word	0x2001adac
   46730:	2001adb4 	.word	0x2001adb4
   46734:	2001adb0 	.word	0x2001adb0
   46738:	2001a768 	.word	0x2001a768

0004673c <ready_thread>:
{
   4673c:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   4673e:	f990 300d 	ldrsb.w	r3, [r0, #13]
   46742:	7b42      	ldrb	r2, [r0, #13]
   46744:	2b00      	cmp	r3, #0
   46746:	db2d      	blt.n	467a4 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46748:	06d3      	lsls	r3, r2, #27
   4674a:	d12b      	bne.n	467a4 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   4674c:	6983      	ldr	r3, [r0, #24]
   4674e:	bb4b      	cbnz	r3, 467a4 <ready_thread+0x68>
	return list->head == list;
   46750:	4915      	ldr	r1, [pc, #84]	; (467a8 <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46752:	f062 027f 	orn	r2, r2, #127	; 0x7f
   46756:	7342      	strb	r2, [r0, #13]
   46758:	460a      	mov	r2, r1
   4675a:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   4675e:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46760:	4294      	cmp	r4, r2
   46762:	bf18      	it	ne
   46764:	4623      	movne	r3, r4
   46766:	2b00      	cmp	r3, #0
   46768:	bf38      	it	cc
   4676a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   4676c:	b1ab      	cbz	r3, 4679a <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   4676e:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   46772:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   46776:	42a6      	cmp	r6, r4
   46778:	d00b      	beq.n	46792 <ready_thread+0x56>
		return b2 - b1;
   4677a:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   4677c:	2c00      	cmp	r4, #0
   4677e:	dd08      	ble.n	46792 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   46780:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46782:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   46786:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   46788:	6058      	str	r0, [r3, #4]
		update_cache(0);
   4678a:	2000      	movs	r0, #0
}
   4678c:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   4678e:	f7ff bf35 	b.w	465fc <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46792:	42ab      	cmp	r3, r5
   46794:	d001      	beq.n	4679a <ready_thread+0x5e>
   46796:	681b      	ldr	r3, [r3, #0]
   46798:	e7e8      	b.n	4676c <ready_thread+0x30>
	node->prev = tail;
   4679a:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   4679e:	6028      	str	r0, [r5, #0]
	list->tail = node;
   467a0:	6248      	str	r0, [r1, #36]	; 0x24
}
   467a2:	e7f2      	b.n	4678a <ready_thread+0x4e>
}
   467a4:	bc70      	pop	{r4, r5, r6}
   467a6:	4770      	bx	lr
   467a8:	2001ad84 	.word	0x2001ad84

000467ac <z_sched_start>:
{
   467ac:	b510      	push	{r4, lr}
	__asm__ volatile(
   467ae:	f04f 0220 	mov.w	r2, #32
   467b2:	f3ef 8411 	mrs	r4, BASEPRI
   467b6:	f382 8812 	msr	BASEPRI_MAX, r2
   467ba:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   467be:	7b42      	ldrb	r2, [r0, #13]
   467c0:	0751      	lsls	r1, r2, #29
   467c2:	d404      	bmi.n	467ce <z_sched_start+0x22>
	__asm__ volatile(
   467c4:	f384 8811 	msr	BASEPRI, r4
   467c8:	f3bf 8f6f 	isb	sy
}
   467cc:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   467ce:	f022 0204 	bic.w	r2, r2, #4
   467d2:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   467d4:	f7ff ffb2 	bl	4673c <ready_thread>
	z_reschedule(&sched_spinlock, key);
   467d8:	4621      	mov	r1, r4
}
   467da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   467de:	4801      	ldr	r0, [pc, #4]	; (467e4 <z_sched_start+0x38>)
   467e0:	f7ff bee6 	b.w	465b0 <z_reschedule>
   467e4:	20020b23 	.word	0x20020b23

000467e8 <unready_thread>:
{
   467e8:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   467ea:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   467ee:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   467f0:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   467f2:	7b43      	ldrb	r3, [r0, #13]
   467f4:	da04      	bge.n	46800 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   467f6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   467fa:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   467fc:	f001 fec0 	bl	48580 <sys_dlist_remove>
	update_cache(thread == _current);
   46800:	4b04      	ldr	r3, [pc, #16]	; (46814 <unready_thread+0x2c>)
   46802:	6898      	ldr	r0, [r3, #8]
   46804:	1a43      	subs	r3, r0, r1
   46806:	4258      	negs	r0, r3
   46808:	4158      	adcs	r0, r3
}
   4680a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   4680e:	f7ff bef5 	b.w	465fc <update_cache>
   46812:	bf00      	nop
   46814:	2001ad84 	.word	0x2001ad84

00046818 <pend>:
{
   46818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4681c:	4606      	mov	r6, r0
   4681e:	4614      	mov	r4, r2
   46820:	461d      	mov	r5, r3
	__asm__ volatile(
   46822:	f04f 0320 	mov.w	r3, #32
   46826:	f3ef 8711 	mrs	r7, BASEPRI
   4682a:	f383 8812 	msr	BASEPRI_MAX, r3
   4682e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   46832:	f001 ff2d 	bl	48690 <add_to_waitq_locked>
	__asm__ volatile(
   46836:	f387 8811 	msr	BASEPRI, r7
   4683a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   4683e:	1c6b      	adds	r3, r5, #1
   46840:	bf08      	it	eq
   46842:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   46846:	d008      	beq.n	4685a <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46848:	4622      	mov	r2, r4
   4684a:	462b      	mov	r3, r5
   4684c:	f106 0018 	add.w	r0, r6, #24
   46850:	4903      	ldr	r1, [pc, #12]	; (46860 <pend+0x48>)
}
   46852:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   46856:	f000 ba23 	b.w	46ca0 <z_add_timeout>
   4685a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4685e:	bf00      	nop
   46860:	0004864d 	.word	0x0004864d

00046864 <z_pend_curr>:
{
   46864:	b510      	push	{r4, lr}
   46866:	460c      	mov	r4, r1
	pending_current = _current;
   46868:	4b06      	ldr	r3, [pc, #24]	; (46884 <z_pend_curr+0x20>)
{
   4686a:	4611      	mov	r1, r2
	pending_current = _current;
   4686c:	6898      	ldr	r0, [r3, #8]
   4686e:	4b06      	ldr	r3, [pc, #24]	; (46888 <z_pend_curr+0x24>)
   46870:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   46872:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   46876:	f7ff ffcf 	bl	46818 <pend>
   4687a:	4620      	mov	r0, r4
}
   4687c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   46880:	f7fb bb26 	b.w	41ed0 <arch_swap>
   46884:	2001ad84 	.word	0x2001ad84
   46888:	2001adac 	.word	0x2001adac

0004688c <z_set_prio>:
{
   4688c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4688e:	4604      	mov	r4, r0
	__asm__ volatile(
   46890:	f04f 0320 	mov.w	r3, #32
   46894:	f3ef 8611 	mrs	r6, BASEPRI
   46898:	f383 8812 	msr	BASEPRI_MAX, r3
   4689c:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   468a0:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   468a2:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   468a4:	06da      	lsls	r2, r3, #27
   468a6:	d138      	bne.n	4691a <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   468a8:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   468aa:	2d00      	cmp	r5, #0
   468ac:	d135      	bne.n	4691a <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   468ae:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   468b2:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   468b4:	f001 fe64 	bl	48580 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   468b8:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   468ba:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   468bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
   468c0:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   468c2:	4817      	ldr	r0, [pc, #92]	; (46920 <z_set_prio+0x94>)
   468c4:	4603      	mov	r3, r0
   468c6:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   468ca:	429f      	cmp	r7, r3
   468cc:	bf18      	it	ne
   468ce:	463d      	movne	r5, r7
   468d0:	2d00      	cmp	r5, #0
   468d2:	461a      	mov	r2, r3
   468d4:	462b      	mov	r3, r5
   468d6:	bf38      	it	cc
   468d8:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   468da:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   468dc:	b1c3      	cbz	r3, 46910 <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   468de:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   468e2:	42a9      	cmp	r1, r5
   468e4:	d010      	beq.n	46908 <z_set_prio+0x7c>
		return b2 - b1;
   468e6:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   468e8:	2d00      	cmp	r5, #0
   468ea:	dd0d      	ble.n	46908 <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   468ec:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   468ee:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   468f2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   468f4:	605c      	str	r4, [r3, #4]
			update_cache(1);
   468f6:	2001      	movs	r0, #1
   468f8:	f7ff fe80 	bl	465fc <update_cache>
   468fc:	2001      	movs	r0, #1
	__asm__ volatile(
   468fe:	f386 8811 	msr	BASEPRI, r6
   46902:	f3bf 8f6f 	isb	sy
}
   46906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   46908:	42bb      	cmp	r3, r7
   4690a:	d001      	beq.n	46910 <z_set_prio+0x84>
   4690c:	681b      	ldr	r3, [r3, #0]
   4690e:	e7e5      	b.n	468dc <z_set_prio+0x50>
	node->prev = tail;
   46910:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   46914:	603c      	str	r4, [r7, #0]
	list->tail = node;
   46916:	6244      	str	r4, [r0, #36]	; 0x24
}
   46918:	e7ed      	b.n	468f6 <z_set_prio+0x6a>
			thread->base.prio = prio;
   4691a:	2000      	movs	r0, #0
   4691c:	73a1      	strb	r1, [r4, #14]
   4691e:	e7ee      	b.n	468fe <z_set_prio+0x72>
   46920:	2001ad84 	.word	0x2001ad84

00046924 <z_impl_k_thread_suspend>:
{
   46924:	b570      	push	{r4, r5, r6, lr}
   46926:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   46928:	3018      	adds	r0, #24
   4692a:	f001 ff1b 	bl	48764 <z_abort_timeout>
	__asm__ volatile(
   4692e:	f04f 0320 	mov.w	r3, #32
   46932:	f3ef 8611 	mrs	r6, BASEPRI
   46936:	f383 8812 	msr	BASEPRI_MAX, r3
   4693a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   4693e:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46942:	7b63      	ldrb	r3, [r4, #13]
   46944:	2a00      	cmp	r2, #0
   46946:	da05      	bge.n	46954 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46948:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   4694c:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   4694e:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46950:	f001 fe16 	bl	48580 <sys_dlist_remove>
		update_cache(thread == _current);
   46954:	4d0b      	ldr	r5, [pc, #44]	; (46984 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   46956:	7b63      	ldrb	r3, [r4, #13]
   46958:	68a8      	ldr	r0, [r5, #8]
   4695a:	f043 0310 	orr.w	r3, r3, #16
   4695e:	7363      	strb	r3, [r4, #13]
   46960:	1b03      	subs	r3, r0, r4
   46962:	4258      	negs	r0, r3
   46964:	4158      	adcs	r0, r3
   46966:	f7ff fe49 	bl	465fc <update_cache>
	__asm__ volatile(
   4696a:	f386 8811 	msr	BASEPRI, r6
   4696e:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   46972:	68ab      	ldr	r3, [r5, #8]
   46974:	42a3      	cmp	r3, r4
   46976:	d103      	bne.n	46980 <z_impl_k_thread_suspend+0x5c>
}
   46978:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   4697c:	f001 be42 	b.w	48604 <z_reschedule_unlocked>
}
   46980:	bd70      	pop	{r4, r5, r6, pc}
   46982:	bf00      	nop
   46984:	2001ad84 	.word	0x2001ad84

00046988 <k_sched_unlock>:
{
   46988:	b510      	push	{r4, lr}
	__asm__ volatile(
   4698a:	f04f 0320 	mov.w	r3, #32
   4698e:	f3ef 8411 	mrs	r4, BASEPRI
   46992:	f383 8812 	msr	BASEPRI_MAX, r3
   46996:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   4699a:	4b08      	ldr	r3, [pc, #32]	; (469bc <k_sched_unlock+0x34>)
		update_cache(0);
   4699c:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   4699e:	689a      	ldr	r2, [r3, #8]
   469a0:	7bd3      	ldrb	r3, [r2, #15]
   469a2:	3301      	adds	r3, #1
   469a4:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   469a6:	f7ff fe29 	bl	465fc <update_cache>
	__asm__ volatile(
   469aa:	f384 8811 	msr	BASEPRI, r4
   469ae:	f3bf 8f6f 	isb	sy
}
   469b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   469b6:	f001 be25 	b.w	48604 <z_reschedule_unlocked>
   469ba:	bf00      	nop
   469bc:	2001ad84 	.word	0x2001ad84

000469c0 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   469c0:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   469c2:	4b04      	ldr	r3, [pc, #16]	; (469d4 <z_sched_init+0x14>)
   469c4:	4608      	mov	r0, r1
   469c6:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   469ca:	e9c3 2208 	strd	r2, r2, [r3, #32]
   469ce:	f7ff bdcb 	b.w	46568 <k_sched_time_slice_set>
   469d2:	bf00      	nop
   469d4:	2001ad84 	.word	0x2001ad84

000469d8 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   469d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   469da:	f04f 0320 	mov.w	r3, #32
   469de:	f3ef 8411 	mrs	r4, BASEPRI
   469e2:	f383 8812 	msr	BASEPRI_MAX, r3
   469e6:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   469ea:	491b      	ldr	r1, [pc, #108]	; (46a58 <z_impl_k_yield+0x80>)
   469ec:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   469ee:	7b43      	ldrb	r3, [r0, #13]
   469f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   469f4:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   469f6:	f001 fdc3 	bl	48580 <sys_dlist_remove>
	return list->head == list;
   469fa:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   469fc:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   469fe:	7b53      	ldrb	r3, [r2, #13]
   46a00:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46a04:	7353      	strb	r3, [r2, #13]
   46a06:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46a0a:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46a0c:	4283      	cmp	r3, r0
   46a0e:	bf08      	it	eq
   46a10:	2300      	moveq	r3, #0
   46a12:	2b00      	cmp	r3, #0
   46a14:	bf38      	it	cc
   46a16:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46a18:	b1cb      	cbz	r3, 46a4e <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   46a1a:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   46a1e:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46a22:	42af      	cmp	r7, r5
   46a24:	d00f      	beq.n	46a46 <z_impl_k_yield+0x6e>
		return b2 - b1;
   46a26:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   46a28:	2d00      	cmp	r5, #0
   46a2a:	dd0c      	ble.n	46a46 <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   46a2c:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46a2e:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   46a32:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   46a34:	605a      	str	r2, [r3, #4]
	update_cache(1);
   46a36:	2001      	movs	r0, #1
   46a38:	f7ff fde0 	bl	465fc <update_cache>
   46a3c:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   46a3e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   46a42:	f7fb ba45 	b.w	41ed0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   46a46:	42b3      	cmp	r3, r6
   46a48:	d001      	beq.n	46a4e <z_impl_k_yield+0x76>
   46a4a:	681b      	ldr	r3, [r3, #0]
   46a4c:	e7e4      	b.n	46a18 <z_impl_k_yield+0x40>
	node->prev = tail;
   46a4e:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   46a52:	6032      	str	r2, [r6, #0]
	list->tail = node;
   46a54:	624a      	str	r2, [r1, #36]	; 0x24
}
   46a56:	e7ee      	b.n	46a36 <z_impl_k_yield+0x5e>
   46a58:	2001ad84 	.word	0x2001ad84

00046a5c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   46a5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46a60:	4604      	mov	r4, r0
   46a62:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   46a64:	ea54 0105 	orrs.w	r1, r4, r5
   46a68:	d104      	bne.n	46a74 <z_tick_sleep+0x18>
	z_impl_k_yield();
   46a6a:	f7ff ffb5 	bl	469d8 <z_impl_k_yield>
		k_yield();
		return 0;
   46a6e:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   46a70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   46a74:	f06f 0101 	mvn.w	r1, #1
   46a78:	1a0a      	subs	r2, r1, r0
   46a7a:	f04f 31ff 	mov.w	r1, #4294967295
   46a7e:	eb61 0305 	sbc.w	r3, r1, r5
   46a82:	2a01      	cmp	r2, #1
   46a84:	f173 0300 	sbcs.w	r3, r3, #0
   46a88:	da2a      	bge.n	46ae0 <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   46a8a:	f001 feab 	bl	487e4 <sys_clock_tick_get_32>
   46a8e:	1906      	adds	r6, r0, r4
   46a90:	f04f 0320 	mov.w	r3, #32
   46a94:	f3ef 8811 	mrs	r8, BASEPRI
   46a98:	f383 8812 	msr	BASEPRI_MAX, r3
   46a9c:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   46aa0:	4f11      	ldr	r7, [pc, #68]	; (46ae8 <z_tick_sleep+0x8c>)
   46aa2:	4b12      	ldr	r3, [pc, #72]	; (46aec <z_tick_sleep+0x90>)
   46aa4:	68b8      	ldr	r0, [r7, #8]
   46aa6:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   46aa8:	f7ff fe9e 	bl	467e8 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   46aac:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46aae:	4910      	ldr	r1, [pc, #64]	; (46af0 <z_tick_sleep+0x94>)
   46ab0:	4622      	mov	r2, r4
   46ab2:	462b      	mov	r3, r5
   46ab4:	3018      	adds	r0, #24
   46ab6:	f000 f8f3 	bl	46ca0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   46aba:	68ba      	ldr	r2, [r7, #8]
   46abc:	4640      	mov	r0, r8
   46abe:	7b53      	ldrb	r3, [r2, #13]
   46ac0:	f043 0310 	orr.w	r3, r3, #16
   46ac4:	7353      	strb	r3, [r2, #13]
   46ac6:	f7fb fa03 	bl	41ed0 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   46aca:	f001 fe8b 	bl	487e4 <sys_clock_tick_get_32>
   46ace:	1a30      	subs	r0, r6, r0
   46ad0:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   46ad4:	2801      	cmp	r0, #1
   46ad6:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   46ada:	bfb8      	it	lt
   46adc:	2000      	movlt	r0, #0
   46ade:	e7c7      	b.n	46a70 <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   46ae0:	f06f 0601 	mvn.w	r6, #1
   46ae4:	1a36      	subs	r6, r6, r0
   46ae6:	e7d3      	b.n	46a90 <z_tick_sleep+0x34>
   46ae8:	2001ad84 	.word	0x2001ad84
   46aec:	2001adac 	.word	0x2001adac
   46af0:	0004864d 	.word	0x0004864d

00046af4 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   46af4:	b508      	push	{r3, lr}
   46af6:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46af8:	3301      	adds	r3, #1
   46afa:	bf08      	it	eq
   46afc:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   46b00:	d003      	beq.n	46b0a <z_impl_k_sleep+0x16>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   46b02:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ticks = z_tick_sleep(ticks);
   46b06:	f7ff bfa9 	b.w	46a5c <z_tick_sleep>
		k_thread_suspend(_current);
   46b0a:	4b03      	ldr	r3, [pc, #12]	; (46b18 <z_impl_k_sleep+0x24>)
   46b0c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   46b0e:	f7ff ff09 	bl	46924 <z_impl_k_thread_suspend>
}
   46b12:	f04f 30ff 	mov.w	r0, #4294967295
   46b16:	bd08      	pop	{r3, pc}
   46b18:	2001ad84 	.word	0x2001ad84

00046b1c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   46b1c:	4b01      	ldr	r3, [pc, #4]	; (46b24 <z_impl_z_current_get+0x8>)
   46b1e:	6898      	ldr	r0, [r3, #8]
   46b20:	4770      	bx	lr
   46b22:	bf00      	nop
   46b24:	2001ad84 	.word	0x2001ad84

00046b28 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   46b28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46b2c:	4604      	mov	r4, r0
   46b2e:	f04f 0320 	mov.w	r3, #32
   46b32:	f3ef 8611 	mrs	r6, BASEPRI
   46b36:	f383 8812 	msr	BASEPRI_MAX, r3
   46b3a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   46b3e:	7b43      	ldrb	r3, [r0, #13]
   46b40:	071a      	lsls	r2, r3, #28
   46b42:	d505      	bpl.n	46b50 <z_thread_abort+0x28>
	__asm__ volatile(
   46b44:	f386 8811 	msr	BASEPRI, r6
   46b48:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   46b4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46b50:	f023 0220 	bic.w	r2, r3, #32
   46b54:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   46b58:	09d2      	lsrs	r2, r2, #7
   46b5a:	d120      	bne.n	46b9e <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46b5c:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   46b5e:	68a3      	ldr	r3, [r4, #8]
   46b60:	b113      	cbz	r3, 46b68 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   46b62:	4620      	mov	r0, r4
   46b64:	f001 fd14 	bl	48590 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   46b68:	f104 0018 	add.w	r0, r4, #24
   46b6c:	f001 fdfa 	bl	48764 <z_abort_timeout>
   46b70:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   46b74:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   46b78:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46b7a:	42bd      	cmp	r5, r7
   46b7c:	d000      	beq.n	46b80 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   46b7e:	b9b5      	cbnz	r5, 46bae <z_thread_abort+0x86>
		update_cache(1);
   46b80:	2001      	movs	r0, #1
   46b82:	f7ff fd3b 	bl	465fc <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   46b86:	4b10      	ldr	r3, [pc, #64]	; (46bc8 <z_thread_abort+0xa0>)
   46b88:	689b      	ldr	r3, [r3, #8]
   46b8a:	42a3      	cmp	r3, r4
   46b8c:	d1da      	bne.n	46b44 <z_thread_abort+0x1c>
   46b8e:	f3ef 8305 	mrs	r3, IPSR
   46b92:	2b00      	cmp	r3, #0
   46b94:	d1d6      	bne.n	46b44 <z_thread_abort+0x1c>
   46b96:	4630      	mov	r0, r6
   46b98:	f7fb f99a 	bl	41ed0 <arch_swap>
	return ret;
   46b9c:	e7d2      	b.n	46b44 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46b9e:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   46ba2:	f043 0308 	orr.w	r3, r3, #8
   46ba6:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46ba8:	f001 fcea 	bl	48580 <sys_dlist_remove>
}
   46bac:	e7d7      	b.n	46b5e <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   46bae:	4628      	mov	r0, r5
   46bb0:	f001 fcee 	bl	48590 <unpend_thread_no_timeout>
   46bb4:	f105 0018 	add.w	r0, r5, #24
   46bb8:	f001 fdd4 	bl	48764 <z_abort_timeout>
		ready_thread(thread);
   46bbc:	4628      	mov	r0, r5
   46bbe:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   46bc2:	f7ff fdbb 	bl	4673c <ready_thread>
   46bc6:	e7d7      	b.n	46b78 <z_thread_abort+0x50>
   46bc8:	2001ad84 	.word	0x2001ad84

00046bcc <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   46bcc:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   46bce:	4806      	ldr	r0, [pc, #24]	; (46be8 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   46bd0:	4a06      	ldr	r2, [pc, #24]	; (46bec <z_data_copy+0x20>)
   46bd2:	4907      	ldr	r1, [pc, #28]	; (46bf0 <z_data_copy+0x24>)
   46bd4:	1a12      	subs	r2, r2, r0
   46bd6:	f001 f942 	bl	47e5e <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   46bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   46bde:	4a05      	ldr	r2, [pc, #20]	; (46bf4 <z_data_copy+0x28>)
   46be0:	4905      	ldr	r1, [pc, #20]	; (46bf8 <z_data_copy+0x2c>)
   46be2:	4806      	ldr	r0, [pc, #24]	; (46bfc <z_data_copy+0x30>)
   46be4:	f001 b93b 	b.w	47e5e <memcpy>
   46be8:	2001a500 	.word	0x2001a500
   46bec:	2001a678 	.word	0x2001a678
   46bf0:	00049670 	.word	0x00049670
   46bf4:	00000000 	.word	0x00000000
   46bf8:	00049658 	.word	0x00049658
   46bfc:	2001a500 	.word	0x2001a500

00046c00 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   46c00:	4b03      	ldr	r3, [pc, #12]	; (46c10 <elapsed+0x10>)
   46c02:	681b      	ldr	r3, [r3, #0]
   46c04:	b90b      	cbnz	r3, 46c0a <elapsed+0xa>
   46c06:	f7fc bddf 	b.w	437c8 <sys_clock_elapsed>
}
   46c0a:	2000      	movs	r0, #0
   46c0c:	4770      	bx	lr
   46c0e:	bf00      	nop
   46c10:	2001adb8 	.word	0x2001adb8

00046c14 <remove_timeout>:
{
   46c14:	b530      	push	{r4, r5, lr}
   46c16:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46c18:	b168      	cbz	r0, 46c36 <remove_timeout+0x22>
   46c1a:	4a0a      	ldr	r2, [pc, #40]	; (46c44 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   46c1c:	6852      	ldr	r2, [r2, #4]
   46c1e:	4290      	cmp	r0, r2
   46c20:	d009      	beq.n	46c36 <remove_timeout+0x22>
	if (next(t) != NULL) {
   46c22:	b143      	cbz	r3, 46c36 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   46c24:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   46c28:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   46c2c:	1912      	adds	r2, r2, r4
   46c2e:	eb45 0101 	adc.w	r1, r5, r1
   46c32:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   46c36:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   46c38:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   46c3a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   46c3c:	2300      	movs	r3, #0
	node->prev = NULL;
   46c3e:	e9c0 3300 	strd	r3, r3, [r0]
}
   46c42:	bd30      	pop	{r4, r5, pc}
   46c44:	2001a5f8 	.word	0x2001a5f8

00046c48 <next_timeout>:

static int32_t next_timeout(void)
{
   46c48:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   46c4a:	4b13      	ldr	r3, [pc, #76]	; (46c98 <next_timeout+0x50>)
   46c4c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46c4e:	429c      	cmp	r4, r3
   46c50:	bf08      	it	eq
   46c52:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   46c54:	f7ff ffd4 	bl	46c00 <elapsed>
   46c58:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   46c5a:	b1bc      	cbz	r4, 46c8c <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46c5c:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   46c60:	1b40      	subs	r0, r0, r5
   46c62:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   46c66:	2801      	cmp	r0, #1
   46c68:	f171 0300 	sbcs.w	r3, r1, #0
   46c6c:	db11      	blt.n	46c92 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46c6e:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   46c72:	2300      	movs	r3, #0
   46c74:	4282      	cmp	r2, r0
   46c76:	eb73 0401 	sbcs.w	r4, r3, r1
   46c7a:	da00      	bge.n	46c7e <next_timeout+0x36>
   46c7c:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   46c7e:	4b07      	ldr	r3, [pc, #28]	; (46c9c <next_timeout+0x54>)
   46c80:	691b      	ldr	r3, [r3, #16]
   46c82:	b113      	cbz	r3, 46c8a <next_timeout+0x42>
   46c84:	4298      	cmp	r0, r3
   46c86:	bfa8      	it	ge
   46c88:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   46c8a:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   46c8c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   46c90:	e7f5      	b.n	46c7e <next_timeout+0x36>
   46c92:	2000      	movs	r0, #0
   46c94:	e7f3      	b.n	46c7e <next_timeout+0x36>
   46c96:	bf00      	nop
   46c98:	2001a5f8 	.word	0x2001a5f8
   46c9c:	2001ad84 	.word	0x2001ad84

00046ca0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46ca0:	f1b3 3fff 	cmp.w	r3, #4294967295
   46ca4:	bf08      	it	eq
   46ca6:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
   46caa:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46cae:	4604      	mov	r4, r0
   46cb0:	4692      	mov	sl, r2
   46cb2:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46cb4:	d073      	beq.n	46d9e <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   46cb6:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   46cb8:	f04f 0320 	mov.w	r3, #32
   46cbc:	f3ef 8511 	mrs	r5, BASEPRI
   46cc0:	f383 8812 	msr	BASEPRI_MAX, r3
   46cc4:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   46cc8:	f06f 0301 	mvn.w	r3, #1
   46ccc:	f04f 32ff 	mov.w	r2, #4294967295
   46cd0:	ebb3 080a 	subs.w	r8, r3, sl
   46cd4:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   46cd8:	f1b8 0f00 	cmp.w	r8, #0
   46cdc:	f179 0100 	sbcs.w	r1, r9, #0
   46ce0:	db1c      	blt.n	46d1c <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   46ce2:	4830      	ldr	r0, [pc, #192]	; (46da4 <z_add_timeout+0x104>)
   46ce4:	e9d0 1000 	ldrd	r1, r0, [r0]
   46ce8:	1a5b      	subs	r3, r3, r1
   46cea:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   46cee:	ebb3 060a 	subs.w	r6, r3, sl
   46cf2:	eb62 070b 	sbc.w	r7, r2, fp
   46cf6:	2e01      	cmp	r6, #1
   46cf8:	f177 0300 	sbcs.w	r3, r7, #0
   46cfc:	bfbc      	itt	lt
   46cfe:	2601      	movlt	r6, #1
   46d00:	2700      	movlt	r7, #0
   46d02:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   46d06:	4a28      	ldr	r2, [pc, #160]	; (46da8 <z_add_timeout+0x108>)
   46d08:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46d0c:	4293      	cmp	r3, r2
   46d0e:	d11e      	bne.n	46d4e <z_add_timeout+0xae>
	node->prev = tail;
   46d10:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   46d14:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   46d18:	6054      	str	r4, [r2, #4]
}
   46d1a:	e02d      	b.n	46d78 <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   46d1c:	f7ff ff70 	bl	46c00 <elapsed>
   46d20:	f11a 0301 	adds.w	r3, sl, #1
   46d24:	9300      	str	r3, [sp, #0]
   46d26:	f14b 0300 	adc.w	r3, fp, #0
   46d2a:	9301      	str	r3, [sp, #4]
   46d2c:	e9dd 2300 	ldrd	r2, r3, [sp]
   46d30:	1812      	adds	r2, r2, r0
   46d32:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   46d36:	e9c4 2304 	strd	r2, r3, [r4, #16]
   46d3a:	e7e4      	b.n	46d06 <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   46d3c:	ebb6 0008 	subs.w	r0, r6, r8
   46d40:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   46d44:	4563      	cmp	r3, ip
   46d46:	e9c4 0104 	strd	r0, r1, [r4, #16]
   46d4a:	d0e1      	beq.n	46d10 <z_add_timeout+0x70>
   46d4c:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   46d4e:	2b00      	cmp	r3, #0
   46d50:	d0de      	beq.n	46d10 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   46d52:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   46d56:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   46d5a:	4546      	cmp	r6, r8
   46d5c:	eb77 0109 	sbcs.w	r1, r7, r9
   46d60:	daec      	bge.n	46d3c <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   46d62:	ebb8 0006 	subs.w	r0, r8, r6
   46d66:	eb69 0107 	sbc.w	r1, r9, r7
   46d6a:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   46d6e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46d70:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   46d74:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   46d76:	605c      	str	r4, [r3, #4]
	return list->head == list;
   46d78:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46d7a:	4293      	cmp	r3, r2
   46d7c:	d00b      	beq.n	46d96 <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   46d7e:	429c      	cmp	r4, r3
   46d80:	d109      	bne.n	46d96 <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   46d82:	f7ff ff61 	bl	46c48 <next_timeout>

			if (next_time == 0 ||
   46d86:	b118      	cbz	r0, 46d90 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   46d88:	4b08      	ldr	r3, [pc, #32]	; (46dac <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   46d8a:	691b      	ldr	r3, [r3, #16]
   46d8c:	4283      	cmp	r3, r0
   46d8e:	d002      	beq.n	46d96 <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   46d90:	2100      	movs	r1, #0
   46d92:	f7fc fce5 	bl	43760 <sys_clock_set_timeout>
	__asm__ volatile(
   46d96:	f385 8811 	msr	BASEPRI, r5
   46d9a:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   46d9e:	b003      	add	sp, #12
   46da0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   46da4:	2001a868 	.word	0x2001a868
   46da8:	2001a5f8 	.word	0x2001a5f8
   46dac:	2001ad84 	.word	0x2001ad84

00046db0 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   46db0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46db4:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   46db6:	f7ff fc7f 	bl	466b8 <z_time_slice>
	__asm__ volatile(
   46dba:	f04f 0320 	mov.w	r3, #32
   46dbe:	f3ef 8411 	mrs	r4, BASEPRI
   46dc2:	f383 8812 	msr	BASEPRI_MAX, r3
   46dc6:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   46dca:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 46e7c <sys_clock_announce+0xcc>
   46dce:	4d2a      	ldr	r5, [pc, #168]	; (46e78 <sys_clock_announce+0xc8>)
   46dd0:	4651      	mov	r1, sl
	return list->head == list;
   46dd2:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 46e80 <sys_clock_announce+0xd0>
   46dd6:	602e      	str	r6, [r5, #0]
   46dd8:	f8d5 c000 	ldr.w	ip, [r5]
   46ddc:	f8db 0000 	ldr.w	r0, [fp]
   46de0:	4662      	mov	r2, ip
   46de2:	e9da 8900 	ldrd	r8, r9, [sl]
   46de6:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46de8:	4558      	cmp	r0, fp
   46dea:	e9cd 2300 	strd	r2, r3, [sp]
   46dee:	d00d      	beq.n	46e0c <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   46df0:	b160      	cbz	r0, 46e0c <sys_clock_announce+0x5c>
   46df2:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   46df6:	45b4      	cmp	ip, r6
   46df8:	41bb      	sbcs	r3, r7
   46dfa:	da1d      	bge.n	46e38 <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   46dfc:	9b00      	ldr	r3, [sp, #0]
   46dfe:	ebb6 0c03 	subs.w	ip, r6, r3
   46e02:	9b01      	ldr	r3, [sp, #4]
   46e04:	eb67 0603 	sbc.w	r6, r7, r3
   46e08:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   46e0c:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   46e0e:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   46e10:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   46e12:	eb13 0208 	adds.w	r2, r3, r8
   46e16:	9b01      	ldr	r3, [sp, #4]
   46e18:	eb43 0309 	adc.w	r3, r3, r9
   46e1c:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   46e20:	f7ff ff12 	bl	46c48 <next_timeout>
   46e24:	4631      	mov	r1, r6
   46e26:	f7fc fc9b 	bl	43760 <sys_clock_set_timeout>
	__asm__ volatile(
   46e2a:	f384 8811 	msr	BASEPRI, r4
   46e2e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   46e32:	b003      	add	sp, #12
   46e34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   46e38:	2200      	movs	r2, #0
   46e3a:	2300      	movs	r3, #0
		curr_tick += dt;
   46e3c:	eb18 0806 	adds.w	r8, r8, r6
   46e40:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   46e44:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   46e48:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   46e4c:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   46e50:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   46e52:	f7ff fedf 	bl	46c14 <remove_timeout>
   46e56:	f384 8811 	msr	BASEPRI, r4
   46e5a:	f3bf 8f6f 	isb	sy
		t->fn(t);
   46e5e:	6883      	ldr	r3, [r0, #8]
   46e60:	4798      	blx	r3
	__asm__ volatile(
   46e62:	f04f 0320 	mov.w	r3, #32
   46e66:	f3ef 8411 	mrs	r4, BASEPRI
   46e6a:	f383 8812 	msr	BASEPRI_MAX, r3
   46e6e:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   46e72:	4902      	ldr	r1, [pc, #8]	; (46e7c <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   46e74:	e7b0      	b.n	46dd8 <sys_clock_announce+0x28>
   46e76:	bf00      	nop
   46e78:	2001adb8 	.word	0x2001adb8
   46e7c:	2001a868 	.word	0x2001a868
   46e80:	2001a5f8 	.word	0x2001a5f8

00046e84 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   46e84:	b510      	push	{r4, lr}
   46e86:	f04f 0320 	mov.w	r3, #32
   46e8a:	f3ef 8411 	mrs	r4, BASEPRI
   46e8e:	f383 8812 	msr	BASEPRI_MAX, r3
   46e92:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   46e96:	f7fc fc97 	bl	437c8 <sys_clock_elapsed>
   46e9a:	4b06      	ldr	r3, [pc, #24]	; (46eb4 <sys_clock_tick_get+0x30>)
   46e9c:	e9d3 2300 	ldrd	r2, r3, [r3]
   46ea0:	1812      	adds	r2, r2, r0
   46ea2:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   46ea6:	f384 8811 	msr	BASEPRI, r4
   46eaa:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   46eae:	4610      	mov	r0, r2
   46eb0:	4619      	mov	r1, r3
   46eb2:	bd10      	pop	{r4, pc}
   46eb4:	2001a868 	.word	0x2001a868

00046eb8 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   46eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   46eba:	4604      	mov	r4, r0
	__asm__ volatile(
   46ebc:	f04f 0320 	mov.w	r3, #32
   46ec0:	f3ef 8511 	mrs	r5, BASEPRI
   46ec4:	f383 8812 	msr	BASEPRI_MAX, r3
   46ec8:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   46ecc:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   46ed0:	1c56      	adds	r6, r2, #1
   46ed2:	f143 0700 	adc.w	r7, r3, #0
   46ed6:	2f00      	cmp	r7, #0
   46ed8:	bf08      	it	eq
   46eda:	2e02      	cmpeq	r6, #2
   46edc:	d302      	bcc.n	46ee4 <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   46ede:	4917      	ldr	r1, [pc, #92]	; (46f3c <z_timer_expiration_handler+0x84>)
   46ee0:	f7ff fede 	bl	46ca0 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   46ee4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   46ee6:	3301      	adds	r3, #1
   46ee8:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   46eea:	6a23      	ldr	r3, [r4, #32]
   46eec:	b173      	cbz	r3, 46f0c <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   46eee:	f385 8811 	msr	BASEPRI, r5
   46ef2:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   46ef6:	4620      	mov	r0, r4
   46ef8:	6a23      	ldr	r3, [r4, #32]
   46efa:	4798      	blx	r3
	__asm__ volatile(
   46efc:	f04f 0320 	mov.w	r3, #32
   46f00:	f3ef 8511 	mrs	r5, BASEPRI
   46f04:	f383 8812 	msr	BASEPRI_MAX, r3
   46f08:	f3bf 8f6f 	isb	sy
	return list->head == list;
   46f0c:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f10:	42a6      	cmp	r6, r4
   46f12:	d000      	beq.n	46f16 <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   46f14:	b926      	cbnz	r6, 46f20 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   46f16:	f385 8811 	msr	BASEPRI, r5
   46f1a:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   46f1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   46f20:	4630      	mov	r0, r6
   46f22:	f001 fb3f 	bl	485a4 <z_unpend_thread_no_timeout>
   46f26:	2300      	movs	r3, #0
   46f28:	67b3      	str	r3, [r6, #120]	; 0x78
   46f2a:	f385 8811 	msr	BASEPRI, r5
   46f2e:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   46f32:	4630      	mov	r0, r6
}
   46f34:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   46f38:	f001 bb78 	b.w	4862c <z_ready_thread>
   46f3c:	00046eb9 	.word	0x00046eb9

00046f40 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   46f40:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   46f44:	4619      	mov	r1, r3
   46f46:	4606      	mov	r6, r0
   46f48:	4610      	mov	r0, r2
   46f4a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   46f4e:	1c4c      	adds	r4, r1, #1
   46f50:	bf08      	it	eq
   46f52:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   46f56:	4680      	mov	r8, r0
   46f58:	4689      	mov	r9, r1
   46f5a:	d04c      	beq.n	46ff6 <z_impl_k_timer_start+0xb6>
   46f5c:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   46f5e:	1c6b      	adds	r3, r5, #1
   46f60:	bf08      	it	eq
   46f62:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   46f66:	4614      	mov	r4, r2
   46f68:	d019      	beq.n	46f9e <z_impl_k_timer_start+0x5e>
   46f6a:	ea54 0305 	orrs.w	r3, r4, r5
   46f6e:	d016      	beq.n	46f9e <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   46f70:	f06f 0301 	mvn.w	r3, #1
   46f74:	ebb3 0a02 	subs.w	sl, r3, r2
   46f78:	f04f 33ff 	mov.w	r3, #4294967295
   46f7c:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   46f80:	f1ba 0f00 	cmp.w	sl, #0
   46f84:	f17b 0300 	sbcs.w	r3, fp, #0
   46f88:	da09      	bge.n	46f9e <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   46f8a:	f112 34ff 	adds.w	r4, r2, #4294967295
   46f8e:	f145 35ff 	adc.w	r5, r5, #4294967295
   46f92:	2c01      	cmp	r4, #1
   46f94:	f175 0300 	sbcs.w	r3, r5, #0
   46f98:	bfbc      	itt	lt
   46f9a:	2401      	movlt	r4, #1
   46f9c:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   46f9e:	f06f 0301 	mvn.w	r3, #1
   46fa2:	1a1b      	subs	r3, r3, r0
   46fa4:	9300      	str	r3, [sp, #0]
   46fa6:	f04f 33ff 	mov.w	r3, #4294967295
   46faa:	eb63 0301 	sbc.w	r3, r3, r1
   46fae:	9301      	str	r3, [sp, #4]
   46fb0:	e9dd 2300 	ldrd	r2, r3, [sp]
   46fb4:	2a00      	cmp	r2, #0
   46fb6:	f173 0300 	sbcs.w	r3, r3, #0
   46fba:	da0c      	bge.n	46fd6 <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   46fbc:	f110 38ff 	adds.w	r8, r0, #4294967295
   46fc0:	f141 39ff 	adc.w	r9, r1, #4294967295
   46fc4:	f1b8 0f00 	cmp.w	r8, #0
   46fc8:	f179 0300 	sbcs.w	r3, r9, #0
   46fcc:	bfbc      	itt	lt
   46fce:	f04f 0800 	movlt.w	r8, #0
   46fd2:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   46fd6:	4630      	mov	r0, r6
   46fd8:	f001 fbc4 	bl	48764 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   46fdc:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   46fde:	4642      	mov	r2, r8
	timer->status = 0U;
   46fe0:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   46fe2:	4630      	mov	r0, r6
   46fe4:	464b      	mov	r3, r9
   46fe6:	4905      	ldr	r1, [pc, #20]	; (46ffc <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   46fe8:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   46fec:	b002      	add	sp, #8
   46fee:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   46ff2:	f7ff be55 	b.w	46ca0 <z_add_timeout>
}
   46ff6:	b002      	add	sp, #8
   46ff8:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   46ffc:	00046eb9 	.word	0x00046eb9

00047000 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   47000:	4a02      	ldr	r2, [pc, #8]	; (4700c <boot_banner+0xc>)
   47002:	4903      	ldr	r1, [pc, #12]	; (47010 <boot_banner+0x10>)
   47004:	4803      	ldr	r0, [pc, #12]	; (47014 <boot_banner+0x14>)
   47006:	f000 b8d4 	b.w	471b2 <printk>
   4700a:	bf00      	nop
   4700c:	00048e52 	.word	0x00048e52
   47010:	00049623 	.word	0x00049623
   47014:	00049630 	.word	0x00049630

00047018 <tfm_platform_system_reset>:
#include "tfm_ns_interface.h"
#include "tfm_veneers.h"

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   47018:	2300      	movs	r3, #0
{
   4701a:	b507      	push	{r0, r1, r2, lr}
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   4701c:	461a      	mov	r2, r3
   4701e:	4619      	mov	r1, r3
   47020:	9300      	str	r3, [sp, #0]
   47022:	4803      	ldr	r0, [pc, #12]	; (47030 <tfm_platform_system_reset+0x18>)
   47024:	f7fc fd9c 	bl	43b60 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_platform_sp_system_reset_veneer,
                                0,
                                0,
                                0,
                                0);
}
   47028:	b003      	add	sp, #12
   4702a:	f85d fb04 	ldr.w	pc, [sp], #4
   4702e:	bf00      	nop
   47030:	00037e41 	.word	0x00037e41

00047034 <psa_generate_random>:
    return status;
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   47034:	b530      	push	{r4, r5, lr}
   47036:	b093      	sub	sp, #76	; 0x4c
   47038:	4605      	mov	r5, r0
   4703a:	460c      	mov	r4, r1
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   4703c:	2228      	movs	r2, #40	; 0x28
   4703e:	2100      	movs	r1, #0
   47040:	a808      	add	r0, sp, #32
   47042:	f000 ff17 	bl	47e74 <memset>
   47046:	233f      	movs	r3, #63	; 0x3f
   47048:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_GENERATE_RANDOM_SID,
    };

    psa_invec in_vec[] = {
   4704a:	ab07      	add	r3, sp, #28
   4704c:	9303      	str	r3, [sp, #12]
   4704e:	232c      	movs	r3, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   47050:	9406      	str	r4, [sp, #24]
   47052:	e9cd 3504 	strd	r3, r5, [sp, #16]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   47056:	b144      	cbz	r4, 4706a <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    status = API_DISPATCH(tfm_crypto_generate_random,
   47058:	2201      	movs	r2, #1
   4705a:	4805      	ldr	r0, [pc, #20]	; (47070 <psa_generate_random+0x3c>)
   4705c:	9200      	str	r2, [sp, #0]
   4705e:	ab05      	add	r3, sp, #20
   47060:	a903      	add	r1, sp, #12
   47062:	f7fc fd7d 	bl	43b60 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_RANDOM);

    return status;
}
   47066:	b013      	add	sp, #76	; 0x4c
   47068:	bd30      	pop	{r4, r5, pc}
        return PSA_SUCCESS;
   4706a:	4620      	mov	r0, r4
   4706c:	e7fb      	b.n	47066 <psa_generate_random+0x32>
   4706e:	bf00      	nop
   47070:	00037c11 	.word	0x00037c11

00047074 <rlp_encode_list>:

// Returns length of output in bytes, or a negative error value
int rlp_encode_list(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, 
                    const RlpElement_t *const *rlpElementsArr, size_t rplElementsLen)
{
   47074:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47078:	460e      	mov	r6, r1
   4707a:	4690      	mov	r8, r2
   4707c:	4699      	mov	r9, r3
  if( rlpEncodedOutput == NULL || rlpElementsArr == NULL || rlpEncodedOutputLen == 0 )
   4707e:	4604      	mov	r4, r0
   47080:	2800      	cmp	r0, #0
   47082:	d05d      	beq.n	47140 <rlp_encode_list+0xcc>
   47084:	2a00      	cmp	r2, #0
   47086:	d05b      	beq.n	47140 <rlp_encode_list+0xcc>
   47088:	2900      	cmp	r1, #0
   4708a:	d059      	beq.n	47140 <rlp_encode_list+0xcc>
   4708c:	460a      	mov	r2, r1
    return ERR_RLP_EBADARG;
  
  // loop through all elements and determine if sufficient output space is available
  // and there are no memory overlap violations
  size_t spaceRemaining = rlpEncodedOutputLen;
  for(int i = 0; i < rplElementsLen; i++) {
   4708e:	2300      	movs	r3, #0
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   47090:	1845      	adds	r5, r0, r1
  for(int i = 0; i < rplElementsLen; i++) {
   47092:	454b      	cmp	r3, r9
   47094:	d120      	bne.n	470d8 <rlp_encode_list+0x64>
  }
  size_t rlpEncodedLen = 0;
  uint8_t *rlpOut = (uint8_t *) rlpEncodedOutput;
  
  // Encode each element
  for(int i = 0; i < rplElementsLen; i++) {
   47096:	2700      	movs	r7, #0
  size_t rlpEncodedLen = 0;
   47098:	463d      	mov	r5, r7
  for(int i = 0; i < rplElementsLen; i++) {
   4709a:	454f      	cmp	r7, r9
   4709c:	d135      	bne.n	4710a <rlp_encode_list+0x96>
      return ret;
    rlpEncodedLen += ret;
  }
  // Calculate list header byte size
  uint8_t listHdrByteCnt = 0;
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   4709e:	462a      	mov	r2, r5
   470a0:	2100      	movs	r1, #0
   470a2:	2a00      	cmp	r2, #0
   470a4:	b2cb      	uxtb	r3, r1
   470a6:	f101 0101 	add.w	r1, r1, #1
   470aa:	dc39      	bgt.n	47120 <rlp_encode_list+0xac>
    listHdrByteCnt++;
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD)
   470ac:	2d37      	cmp	r5, #55	; 0x37
    listHdrByteCnt++; // additional byte for extended length tag
   470ae:	bf84      	itt	hi
   470b0:	3301      	addhi	r3, #1
   470b2:	b2db      	uxtbhi	r3, r3
  // orig
  if((listHdrByteCnt + rlpEncodedLen) > rlpEncodedOutputLen) {
   470b4:	1958      	adds	r0, r3, r5
   470b6:	42b0      	cmp	r0, r6
   470b8:	d814      	bhi.n	470e4 <rlp_encode_list+0x70>
    // ain't enough room for the header
    return ERR_RLP_ENOMEM;
  }
  // first shift everything down to fit the header
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   470ba:	1822      	adds	r2, r4, r0
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   470bc:	425e      	negs	r6, r3
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   470be:	1b11      	subs	r1, r2, r4
   470c0:	428b      	cmp	r3, r1
   470c2:	dd2f      	ble.n	47124 <rlp_encode_list+0xb0>
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD) {
   470c4:	2d37      	cmp	r5, #55	; 0x37
   470c6:	d938      	bls.n	4713a <rlp_encode_list+0xc6>
    // generate the header
    for(int i = 0; i < listHdrByteCnt; i++) {
   470c8:	2200      	movs	r2, #0
   470ca:	1e59      	subs	r1, r3, #1
   470cc:	4421      	add	r1, r4
   470ce:	4293      	cmp	r3, r2
   470d0:	dc2c      	bgt.n	4712c <rlp_encode_list+0xb8>
      rlpOut[(listHdrByteCnt - 1) - i] = // subtract 1 to turn count into index
        (uint8_t) (rlpEncodedLen >> (8 * i));
    }
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_LONG + (listHdrByteCnt - 1));
   470d2:	3b0a      	subs	r3, #10
   470d4:	7023      	strb	r3, [r4, #0]
   470d6:	e007      	b.n	470e8 <rlp_encode_list+0x74>
    if(spaceRemaining < (rlpElementsArr[i]->len + 1)) // extra byte for rlp encoding tag
   470d8:	f858 1023 	ldr.w	r1, [r8, r3, lsl #2]
   470dc:	6848      	ldr	r0, [r1, #4]
   470de:	1c47      	adds	r7, r0, #1
   470e0:	4297      	cmp	r7, r2
   470e2:	d903      	bls.n	470ec <rlp_encode_list+0x78>
      return ERR_RLP_ENOMEM;
   470e4:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  else {
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
  }
  rlpEncodedLen += listHdrByteCnt;
  return rlpEncodedLen;
   470e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   470ec:	43c7      	mvns	r7, r0
    if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElementsArr[i]->buff, rlpElementsArr[i]->len)) // No overlapping memory regions
   470ee:	6889      	ldr	r1, [r1, #8]
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   470f0:	443a      	add	r2, r7
    if( (aAddr == bAddr) ||
   470f2:	42a1      	cmp	r1, r4
   470f4:	d027      	beq.n	47146 <rlp_encode_list+0xd2>
   470f6:	d901      	bls.n	470fc <rlp_encode_list+0x88>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   470f8:	42a9      	cmp	r1, r5
   470fa:	d924      	bls.n	47146 <rlp_encode_list+0xd2>
   470fc:	42a1      	cmp	r1, r4
   470fe:	d202      	bcs.n	47106 <rlp_encode_list+0x92>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   47100:	4401      	add	r1, r0
   47102:	428c      	cmp	r4, r1
   47104:	d91f      	bls.n	47146 <rlp_encode_list+0xd2>
  for(int i = 0; i < rplElementsLen; i++) {
   47106:	3301      	adds	r3, #1
   47108:	e7c3      	b.n	47092 <rlp_encode_list+0x1e>
    int ret = rlp_encode_element((rlpOut + rlpEncodedLen), (rlpEncodedOutputLen - rlpEncodedLen), rlpElementsArr[i]);
   4710a:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
   4710e:	1b71      	subs	r1, r6, r5
   47110:	1960      	adds	r0, r4, r5
   47112:	f7f9 f9d7 	bl	404c4 <rlp_encode_element>
    if(ret < 0)
   47116:	2800      	cmp	r0, #0
   47118:	dbe6      	blt.n	470e8 <rlp_encode_list+0x74>
    rlpEncodedLen += ret;
   4711a:	4405      	add	r5, r0
  for(int i = 0; i < rplElementsLen; i++) {
   4711c:	3701      	adds	r7, #1
   4711e:	e7bc      	b.n	4709a <rlp_encode_list+0x26>
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   47120:	1212      	asrs	r2, r2, #8
   47122:	e7be      	b.n	470a2 <rlp_encode_list+0x2e>
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   47124:	5d91      	ldrb	r1, [r2, r6]
   47126:	f802 1901 	strb.w	r1, [r2], #-1
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   4712a:	e7c8      	b.n	470be <rlp_encode_list+0x4a>
        (uint8_t) (rlpEncodedLen >> (8 * i));
   4712c:	00d6      	lsls	r6, r2, #3
   4712e:	fa25 f606 	lsr.w	r6, r5, r6
   47132:	f801 6901 	strb.w	r6, [r1], #-1
    for(int i = 0; i < listHdrByteCnt; i++) {
   47136:	3201      	adds	r2, #1
   47138:	e7c9      	b.n	470ce <rlp_encode_list+0x5a>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
   4713a:	3d40      	subs	r5, #64	; 0x40
   4713c:	7025      	strb	r5, [r4, #0]
   4713e:	e7d3      	b.n	470e8 <rlp_encode_list+0x74>
    return ERR_RLP_EBADARG;
   47140:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   47144:	e7d0      	b.n	470e8 <rlp_encode_list+0x74>
      return ERR_RLP_EILLEGALMEM;
   47146:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   4714a:	e7cd      	b.n	470e8 <rlp_encode_list+0x74>

0004714c <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   4714c:	4603      	mov	r3, r0
   4714e:	b158      	cbz	r0, 47168 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   47150:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   47152:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   47156:	2a01      	cmp	r2, #1
   47158:	d003      	beq.n	47162 <sys_notify_validate+0x16>
   4715a:	2a03      	cmp	r2, #3
   4715c:	d104      	bne.n	47168 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   4715e:	6802      	ldr	r2, [r0, #0]
   47160:	b112      	cbz	r2, 47168 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   47162:	2000      	movs	r0, #0
   47164:	6098      	str	r0, [r3, #8]
   47166:	4770      	bx	lr
		return -EINVAL;
   47168:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   4716c:	4770      	bx	lr

0004716e <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   4716e:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   47170:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   47172:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   47176:	2a03      	cmp	r2, #3
   47178:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   4717c:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   4717e:	bf14      	ite	ne
   47180:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   47182:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   47184:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   47186:	4770      	bx	lr

00047188 <arch_printk_char_out>:
}
   47188:	2000      	movs	r0, #0
   4718a:	4770      	bx	lr

0004718c <str_out>:
{
   4718c:	b530      	push	{r4, r5, lr}
   4718e:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   47190:	680c      	ldr	r4, [r1, #0]
   47192:	1c55      	adds	r5, r2, #1
   47194:	b114      	cbz	r4, 4719c <str_out+0x10>
   47196:	684b      	ldr	r3, [r1, #4]
   47198:	4293      	cmp	r3, r2
   4719a:	dc01      	bgt.n	471a0 <str_out+0x14>
		ctx->count++;
   4719c:	608d      	str	r5, [r1, #8]
}
   4719e:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   471a0:	3b01      	subs	r3, #1
   471a2:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   471a4:	bf08      	it	eq
   471a6:	2200      	moveq	r2, #0
   471a8:	608d      	str	r5, [r1, #8]
   471aa:	bf0c      	ite	eq
   471ac:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   471ae:	54a0      	strbne	r0, [r4, r2]
   471b0:	e7f5      	b.n	4719e <str_out+0x12>

000471b2 <printk>:
{
   471b2:	b40f      	push	{r0, r1, r2, r3}
   471b4:	b507      	push	{r0, r1, r2, lr}
   471b6:	a904      	add	r1, sp, #16
   471b8:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   471bc:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   471be:	f7f9 fa0d 	bl	405dc <vprintk>
}
   471c2:	b003      	add	sp, #12
   471c4:	f85d eb04 	ldr.w	lr, [sp], #4
   471c8:	b004      	add	sp, #16
   471ca:	4770      	bx	lr

000471cc <snprintk>:
{
   471cc:	b40c      	push	{r2, r3}
   471ce:	b507      	push	{r0, r1, r2, lr}
   471d0:	ab04      	add	r3, sp, #16
   471d2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   471d6:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   471d8:	f7f9 fa0e 	bl	405f8 <vsnprintk>
}
   471dc:	b003      	add	sp, #12
   471de:	f85d eb04 	ldr.w	lr, [sp], #4
   471e2:	b002      	add	sp, #8
   471e4:	4770      	bx	lr

000471e6 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   471e6:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   471e8:	f013 0307 	ands.w	r3, r3, #7
   471ec:	d105      	bne.n	471fa <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   471ee:	6803      	ldr	r3, [r0, #0]
   471f0:	2b00      	cmp	r3, #0
		evt = EVT_START;
   471f2:	bf0c      	ite	eq
   471f4:	2000      	moveq	r0, #0
   471f6:	2003      	movne	r0, #3
   471f8:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   471fa:	2b02      	cmp	r3, #2
   471fc:	d105      	bne.n	4720a <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   471fe:	8b43      	ldrh	r3, [r0, #26]
   47200:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   47202:	bf14      	ite	ne
   47204:	2000      	movne	r0, #0
   47206:	2004      	moveq	r0, #4
   47208:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   4720a:	2b01      	cmp	r3, #1
   4720c:	d105      	bne.n	4721a <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   4720e:	6803      	ldr	r3, [r0, #0]
   47210:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   47212:	bf0c      	ite	eq
   47214:	2000      	moveq	r0, #0
   47216:	2005      	movne	r0, #5
   47218:	4770      	bx	lr
	int evt = EVT_NOP;
   4721a:	2000      	movs	r0, #0
}
   4721c:	4770      	bx	lr

0004721e <notify_one>:
{
   4721e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47222:	460d      	mov	r5, r1
   47224:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47226:	4619      	mov	r1, r3
   47228:	1d28      	adds	r0, r5, #4
{
   4722a:	4690      	mov	r8, r2
   4722c:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   4722e:	f7ff ff9e 	bl	4716e <sys_notify_finalize>
	if (cb) {
   47232:	4604      	mov	r4, r0
   47234:	b138      	cbz	r0, 47246 <notify_one+0x28>
		cb(mgr, cli, state, res);
   47236:	4633      	mov	r3, r6
   47238:	4642      	mov	r2, r8
   4723a:	4629      	mov	r1, r5
   4723c:	4638      	mov	r0, r7
   4723e:	46a4      	mov	ip, r4
}
   47240:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   47244:	4760      	bx	ip
}
   47246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004724a <transition_complete>:
{
   4724a:	b410      	push	{r4}
	__asm__ volatile(
   4724c:	f04f 0420 	mov.w	r4, #32
   47250:	f3ef 8211 	mrs	r2, BASEPRI
   47254:	f384 8812 	msr	BASEPRI_MAX, r4
   47258:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   4725c:	6141      	str	r1, [r0, #20]
}
   4725e:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   47260:	2101      	movs	r1, #1
   47262:	f7f9 b9dd 	b.w	40620 <process_event>

00047266 <validate_args>:
{
   47266:	b510      	push	{r4, lr}
   47268:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   4726a:	b140      	cbz	r0, 4727e <validate_args+0x18>
   4726c:	b139      	cbz	r1, 4727e <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   4726e:	1d08      	adds	r0, r1, #4
   47270:	f7ff ff6c 	bl	4714c <sys_notify_validate>
	if ((rv == 0)
   47274:	b928      	cbnz	r0, 47282 <validate_args+0x1c>
	    && ((cli->notify.flags
   47276:	68a3      	ldr	r3, [r4, #8]
   47278:	f033 0303 	bics.w	r3, r3, #3
   4727c:	d001      	beq.n	47282 <validate_args+0x1c>
		rv = -EINVAL;
   4727e:	f06f 0015 	mvn.w	r0, #21
}
   47282:	bd10      	pop	{r4, pc}

00047284 <onoff_manager_init>:
{
   47284:	b538      	push	{r3, r4, r5, lr}
   47286:	460c      	mov	r4, r1
	if ((mgr == NULL)
   47288:	4605      	mov	r5, r0
   4728a:	b158      	cbz	r0, 472a4 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   4728c:	b151      	cbz	r1, 472a4 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   4728e:	680b      	ldr	r3, [r1, #0]
   47290:	b143      	cbz	r3, 472a4 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   47292:	684b      	ldr	r3, [r1, #4]
   47294:	b133      	cbz	r3, 472a4 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   47296:	221c      	movs	r2, #28
   47298:	2100      	movs	r1, #0
   4729a:	f000 fdeb 	bl	47e74 <memset>
	return 0;
   4729e:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   472a0:	612c      	str	r4, [r5, #16]
}
   472a2:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   472a4:	f06f 0015 	mvn.w	r0, #21
   472a8:	e7fb      	b.n	472a2 <onoff_manager_init+0x1e>

000472aa <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   472aa:	b570      	push	{r4, r5, r6, lr}
   472ac:	4604      	mov	r4, r0
   472ae:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   472b0:	f7ff ffd9 	bl	47266 <validate_args>

	if (rv < 0) {
   472b4:	1e05      	subs	r5, r0, #0
   472b6:	db31      	blt.n	4731c <onoff_request+0x72>
   472b8:	f04f 0320 	mov.w	r3, #32
   472bc:	f3ef 8111 	mrs	r1, BASEPRI
   472c0:	f383 8812 	msr	BASEPRI_MAX, r3
   472c4:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   472c8:	f64f 75ff 	movw	r5, #65535	; 0xffff
   472cc:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   472ce:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   472d0:	42ab      	cmp	r3, r5
   472d2:	f000 0207 	and.w	r2, r0, #7
   472d6:	d02e      	beq.n	47336 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   472d8:	2a02      	cmp	r2, #2
   472da:	d10e      	bne.n	472fa <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   472dc:	3301      	adds	r3, #1
   472de:	8363      	strh	r3, [r4, #26]
	rv = state;
   472e0:	4615      	mov	r5, r2
		notify = true;
   472e2:	2301      	movs	r3, #1
	__asm__ volatile(
   472e4:	f381 8811 	msr	BASEPRI, r1
   472e8:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   472ec:	b1b3      	cbz	r3, 4731c <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   472ee:	2300      	movs	r3, #0
   472f0:	4631      	mov	r1, r6
   472f2:	4620      	mov	r0, r4
   472f4:	f7ff ff93 	bl	4721e <notify_one>
   472f8:	e010      	b.n	4731c <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   472fa:	0783      	lsls	r3, r0, #30
   472fc:	d001      	beq.n	47302 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   472fe:	2a06      	cmp	r2, #6
   47300:	d10e      	bne.n	47320 <onoff_request+0x76>
	parent->next = child;
   47302:	2300      	movs	r3, #0
   47304:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   47306:	6863      	ldr	r3, [r4, #4]
   47308:	b993      	cbnz	r3, 47330 <onoff_request+0x86>
	list->head = node;
   4730a:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   4730e:	4615      	mov	r5, r2
   47310:	b962      	cbnz	r2, 4732c <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   47312:	460a      	mov	r2, r1
   47314:	4620      	mov	r0, r4
   47316:	2102      	movs	r1, #2
   47318:	f7f9 f982 	bl	40620 <process_event>
		}
	}

	return rv;
}
   4731c:	4628      	mov	r0, r5
   4731e:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   47320:	2a05      	cmp	r2, #5
   47322:	bf0c      	ite	eq
   47324:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   47328:	f06f 0504 	mvnne.w	r5, #4
   4732c:	2300      	movs	r3, #0
   4732e:	e7d9      	b.n	472e4 <onoff_request+0x3a>
	parent->next = child;
   47330:	601e      	str	r6, [r3, #0]
	list->tail = node;
   47332:	6066      	str	r6, [r4, #4]
}
   47334:	e7eb      	b.n	4730e <onoff_request+0x64>
		rv = -EAGAIN;
   47336:	f06f 050a 	mvn.w	r5, #10
   4733a:	e7f7      	b.n	4732c <onoff_request+0x82>

0004733c <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   4733c:	4604      	mov	r4, r0
   4733e:	b508      	push	{r3, lr}
   47340:	4608      	mov	r0, r1
   47342:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   47344:	461a      	mov	r2, r3
   47346:	47a0      	blx	r4
	return z_impl_z_current_get();
   47348:	f7ff fbe8 	bl	46b1c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   4734c:	f7fb f932 	bl	425b4 <z_impl_k_thread_abort>

00047350 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   47350:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   47354:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   47356:	0840      	lsrs	r0, r0, #1
   47358:	4770      	bx	lr

0004735a <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   4735a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4735c:	4603      	mov	r3, r0
   4735e:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   47360:	f7ff fff6 	bl	47350 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   47364:	fab0 f080 	clz	r0, r0
   47368:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   4736c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   47370:	f8dc 6010 	ldr.w	r6, [ip, #16]
   47374:	00ca      	lsls	r2, r1, #3
   47376:	1d17      	adds	r7, r2, #4
   47378:	b28d      	uxth	r5, r1
   4737a:	3206      	adds	r2, #6
   4737c:	b956      	cbnz	r6, 47394 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   4737e:	2101      	movs	r1, #1
   47380:	fa01 f000 	lsl.w	r0, r1, r0
   47384:	68d9      	ldr	r1, [r3, #12]
   47386:	4301      	orrs	r1, r0
   47388:	60d9      	str	r1, [r3, #12]
		b->next = c;
   4738a:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   4738e:	53dd      	strh	r5, [r3, r7]
   47390:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   47392:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   47394:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   47396:	3104      	adds	r1, #4
   47398:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   4739a:	53d8      	strh	r0, [r3, r7]
   4739c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   473a0:	529e      	strh	r6, [r3, r2]
   473a2:	80c5      	strh	r5, [r0, #6]
   473a4:	525d      	strh	r5, [r3, r1]
   473a6:	e7f4      	b.n	47392 <free_list_add+0x38>

000473a8 <free_list_remove_bidx>:
{
   473a8:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   473aa:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   473ae:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   473b0:	4299      	cmp	r1, r3
   473b2:	f102 0104 	add.w	r1, r2, #4
   473b6:	d10a      	bne.n	473ce <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   473b8:	2301      	movs	r3, #1
   473ba:	fa03 f202 	lsl.w	r2, r3, r2
   473be:	68c3      	ldr	r3, [r0, #12]
   473c0:	ea23 0302 	bic.w	r3, r3, r2
   473c4:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   473c6:	2300      	movs	r3, #0
   473c8:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   473cc:	bd10      	pop	{r4, pc}
   473ce:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   473d0:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   473d4:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   473d8:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   473dc:	80cb      	strh	r3, [r1, #6]
   473de:	8082      	strh	r2, [r0, #4]
}
   473e0:	e7f4      	b.n	473cc <free_list_remove_bidx+0x24>

000473e2 <free_list_remove>:
{
   473e2:	b510      	push	{r4, lr}
   473e4:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   473e6:	f7ff ffb3 	bl	47350 <chunk_size>
}
   473ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   473ee:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   473f2:	4618      	mov	r0, r3
   473f4:	f1c2 021f 	rsb	r2, r2, #31
   473f8:	f7ff bfd6 	b.w	473a8 <free_list_remove_bidx>

000473fc <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   473fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47400:	fab1 f581 	clz	r5, r1
   47404:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   47408:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   4740c:	693a      	ldr	r2, [r7, #16]
{
   4740e:	4603      	mov	r3, r0
   47410:	460e      	mov	r6, r1
	if (b->next) {
   47412:	b1ca      	cbz	r2, 47448 <alloc_chunk+0x4c>
   47414:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   47418:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   4741a:	4618      	mov	r0, r3
   4741c:	4621      	mov	r1, r4
   4741e:	f7ff ff97 	bl	47350 <chunk_size>
   47422:	42b0      	cmp	r0, r6
   47424:	d307      	bcc.n	47436 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   47426:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   47428:	4621      	mov	r1, r4
   4742a:	4618      	mov	r0, r3
   4742c:	f7ff ffbc 	bl	473a8 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   47430:	4620      	mov	r0, r4
   47432:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   47436:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   4743a:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   4743c:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   47440:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   47442:	d001      	beq.n	47448 <alloc_chunk+0x4c>
   47444:	428a      	cmp	r2, r1
   47446:	d1e7      	bne.n	47418 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   47448:	f04f 34ff 	mov.w	r4, #4294967295
   4744c:	68d9      	ldr	r1, [r3, #12]
   4744e:	f1c5 0520 	rsb	r5, r5, #32
   47452:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   47454:	400c      	ands	r4, r1
   47456:	d0eb      	beq.n	47430 <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   47458:	fa94 f2a4 	rbit	r2, r4
   4745c:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   47460:	1d11      	adds	r1, r2, #4
   47462:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   47466:	e7df      	b.n	47428 <alloc_chunk+0x2c>

00047468 <merge_chunks>:
{
   47468:	b538      	push	{r3, r4, r5, lr}
   4746a:	4603      	mov	r3, r0
   4746c:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   4746e:	f7ff ff6f 	bl	47350 <chunk_size>
   47472:	4611      	mov	r1, r2
   47474:	4604      	mov	r4, r0
   47476:	4618      	mov	r0, r3
   47478:	f7ff ff6a 	bl	47350 <chunk_size>
   4747c:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   4747e:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47482:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   47484:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   47486:	4618      	mov	r0, r3
   47488:	4611      	mov	r1, r2
   4748a:	f7ff ff61 	bl	47350 <chunk_size>
	void *cmem = &buf[c];
   4748e:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   47490:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   47494:	bd38      	pop	{r3, r4, r5, pc}

00047496 <split_chunks>:
{
   47496:	b538      	push	{r3, r4, r5, lr}
   47498:	4603      	mov	r3, r0
   4749a:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   4749c:	f7ff ff58 	bl	47350 <chunk_size>
	chunksz_t lsz = rc - lc;
   474a0:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   474a2:	1aa5      	subs	r5, r4, r2
   474a4:	4405      	add	r5, r0
   474a6:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   474aa:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   474ac:	8060      	strh	r0, [r4, #2]
   474ae:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   474b2:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   474b4:	8044      	strh	r4, [r0, #2]
   474b6:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   474ba:	4618      	mov	r0, r3
   474bc:	4611      	mov	r1, r2
   474be:	f7ff ff47 	bl	47350 <chunk_size>
	void *cmem = &buf[c];
   474c2:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   474c4:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   474c8:	bd38      	pop	{r3, r4, r5, pc}

000474ca <free_chunk>:
{
   474ca:	b538      	push	{r3, r4, r5, lr}
   474cc:	4605      	mov	r5, r0
   474ce:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   474d0:	f7ff ff3e 	bl	47350 <chunk_size>
   474d4:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   474d6:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   474da:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   474dc:	07da      	lsls	r2, r3, #31
   474de:	d40a      	bmi.n	474f6 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   474e0:	4628      	mov	r0, r5
   474e2:	f7ff ff7e 	bl	473e2 <free_list_remove>
	return c + chunk_size(h, c);
   474e6:	4621      	mov	r1, r4
   474e8:	4628      	mov	r0, r5
   474ea:	f7ff ff31 	bl	47350 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   474ee:	1822      	adds	r2, r4, r0
   474f0:	4628      	mov	r0, r5
   474f2:	f7ff ffb9 	bl	47468 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   474f6:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   474fa:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   474fc:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   47500:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   47502:	07db      	lsls	r3, r3, #31
   47504:	d40c      	bmi.n	47520 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   47506:	4628      	mov	r0, r5
   47508:	f7ff ff6b 	bl	473e2 <free_list_remove>
		return ((uint16_t *)cmem)[f];
   4750c:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   47510:	4622      	mov	r2, r4
   47512:	1a61      	subs	r1, r4, r1
   47514:	4628      	mov	r0, r5
   47516:	f7ff ffa7 	bl	47468 <merge_chunks>
   4751a:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   4751e:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   47520:	4621      	mov	r1, r4
   47522:	4628      	mov	r0, r5
}
   47524:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   47528:	f7ff bf17 	b.w	4735a <free_list_add>

0004752c <sys_heap_free>:
	if (mem == NULL) {
   4752c:	b161      	cbz	r1, 47548 <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   4752e:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47530:	3904      	subs	r1, #4
   47532:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   47534:	f021 0307 	bic.w	r3, r1, #7
   47538:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   4753a:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   4753c:	08c9      	lsrs	r1, r1, #3
   4753e:	f022 0201 	bic.w	r2, r2, #1
   47542:	805a      	strh	r2, [r3, #2]
   47544:	f7ff bfc1 	b.w	474ca <free_chunk>
}
   47548:	4770      	bx	lr

0004754a <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   4754a:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   4754c:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   4754e:	b909      	cbnz	r1, 47554 <sys_heap_alloc+0xa>
		return NULL;
   47550:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   47552:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   47554:	68ab      	ldr	r3, [r5, #8]
   47556:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   4755a:	d9f9      	bls.n	47550 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   4755c:	310b      	adds	r1, #11
   4755e:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   47560:	4621      	mov	r1, r4
   47562:	4628      	mov	r0, r5
   47564:	f7ff ff4a 	bl	473fc <alloc_chunk>
	if (c == 0U) {
   47568:	4606      	mov	r6, r0
   4756a:	2800      	cmp	r0, #0
   4756c:	d0f0      	beq.n	47550 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   4756e:	4601      	mov	r1, r0
   47570:	4628      	mov	r0, r5
   47572:	f7ff feed 	bl	47350 <chunk_size>
   47576:	42a0      	cmp	r0, r4
   47578:	d908      	bls.n	4758c <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   4757a:	4434      	add	r4, r6
   4757c:	4628      	mov	r0, r5
   4757e:	4622      	mov	r2, r4
   47580:	f7ff ff89 	bl	47496 <split_chunks>
		free_list_add(h, c + chunk_sz);
   47584:	4621      	mov	r1, r4
   47586:	4628      	mov	r0, r5
   47588:	f7ff fee7 	bl	4735a <free_list_add>
	void *cmem = &buf[c];
   4758c:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   47590:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47592:	8853      	ldrh	r3, [r2, #2]
   47594:	3004      	adds	r0, #4
   47596:	f043 0301 	orr.w	r3, r3, #1
   4759a:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   4759c:	e7d9      	b.n	47552 <sys_heap_alloc+0x8>

0004759e <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   4759e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   475a2:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   475a4:	424a      	negs	r2, r1
   475a6:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   475aa:	ea31 0202 	bics.w	r2, r1, r2
{
   475ae:	4603      	mov	r3, r0
	if (align != rew) {
   475b0:	d00a      	beq.n	475c8 <sys_heap_aligned_alloc+0x2a>
		return false;
   475b2:	2f04      	cmp	r7, #4
   475b4:	463a      	mov	r2, r7
   475b6:	bf28      	it	cs
   475b8:	2204      	movcs	r2, #4
   475ba:	46b9      	mov	r9, r7
		align -= rew;
   475bc:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   475be:	b974      	cbnz	r4, 475de <sys_heap_aligned_alloc+0x40>
		return NULL;
   475c0:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   475c2:	4628      	mov	r0, r5
   475c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   475c8:	2904      	cmp	r1, #4
   475ca:	d804      	bhi.n	475d6 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   475cc:	4621      	mov	r1, r4
}
   475ce:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   475d2:	f7ff bfba 	b.w	4754a <sys_heap_alloc>
		rew = 0;
   475d6:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   475da:	2204      	movs	r2, #4
   475dc:	e7ef      	b.n	475be <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   475de:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   475e0:	68b3      	ldr	r3, [r6, #8]
   475e2:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   475e6:	d9eb      	bls.n	475c0 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   475e8:	f104 010b 	add.w	r1, r4, #11
   475ec:	4439      	add	r1, r7
   475ee:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   475f0:	4630      	mov	r0, r6
   475f2:	08c9      	lsrs	r1, r1, #3
   475f4:	f7ff ff02 	bl	473fc <alloc_chunk>
	if (c0 == 0) {
   475f8:	4680      	mov	r8, r0
   475fa:	2800      	cmp	r0, #0
   475fc:	d0e0      	beq.n	475c0 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   475fe:	f109 0504 	add.w	r5, r9, #4
   47602:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   47606:	1e7b      	subs	r3, r7, #1
   47608:	4435      	add	r5, r6
   4760a:	441d      	add	r5, r3
   4760c:	427f      	negs	r7, r7
   4760e:	403d      	ands	r5, r7
   47610:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47614:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47616:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47618:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   4761a:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   4761c:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   47620:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   47622:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47626:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   4762a:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   4762e:	d208      	bcs.n	47642 <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   47630:	4601      	mov	r1, r0
   47632:	463a      	mov	r2, r7
   47634:	4630      	mov	r0, r6
   47636:	f7ff ff2e 	bl	47496 <split_chunks>
		free_list_add(h, c0);
   4763a:	4641      	mov	r1, r8
   4763c:	4630      	mov	r0, r6
   4763e:	f7ff fe8c 	bl	4735a <free_list_add>
	return c + chunk_size(h, c);
   47642:	4639      	mov	r1, r7
   47644:	4630      	mov	r0, r6
   47646:	f7ff fe83 	bl	47350 <chunk_size>
   4764a:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   4764c:	4284      	cmp	r4, r0
   4764e:	d207      	bcs.n	47660 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   47650:	4630      	mov	r0, r6
   47652:	4622      	mov	r2, r4
   47654:	f7ff ff1f 	bl	47496 <split_chunks>
		free_list_add(h, c_end);
   47658:	4621      	mov	r1, r4
   4765a:	4630      	mov	r0, r6
   4765c:	f7ff fe7d 	bl	4735a <free_list_add>
	void *cmem = &buf[c];
   47660:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47664:	8873      	ldrh	r3, [r6, #2]
   47666:	f043 0301 	orr.w	r3, r3, #1
   4766a:	8073      	strh	r3, [r6, #2]
   4766c:	e7a9      	b.n	475c2 <sys_heap_aligned_alloc+0x24>

0004766e <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   4766e:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   47670:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47672:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   47674:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47678:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   4767c:	1ad2      	subs	r2, r2, r3
{
   4767e:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   47680:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   47682:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   47684:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   47688:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   4768a:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   4768e:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47690:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   47692:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   47694:	60dd      	str	r5, [r3, #12]
   47696:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   47698:	f103 0610 	add.w	r6, r3, #16
   4769c:	4418      	add	r0, r3
   4769e:	4286      	cmp	r6, r0
   476a0:	d118      	bne.n	476d4 <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   476a2:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   476a4:	f040 0001 	orr.w	r0, r0, #1
   476a8:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   476aa:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   476ac:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   476ae:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   476b2:	801d      	strh	r5, [r3, #0]
   476b4:	8077      	strh	r7, [r6, #2]
   476b6:	189e      	adds	r6, r3, r2
   476b8:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   476bc:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   476c0:	8075      	strh	r5, [r6, #2]
   476c2:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   476c4:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   476c6:	4618      	mov	r0, r3
   476c8:	f042 0201 	orr.w	r2, r2, #1
   476cc:	8062      	strh	r2, [r4, #2]
}
   476ce:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   476d0:	f7ff be43 	b.w	4735a <free_list_add>
		h->buckets[i].next = 0;
   476d4:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   476d8:	e7e1      	b.n	4769e <sys_heap_init+0x30>

000476da <encode_uint>:
{
   476da:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   476de:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   476e0:	78d3      	ldrb	r3, [r2, #3]
{
   476e2:	4614      	mov	r4, r2
	switch (specifier) {
   476e4:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   476e6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   476ea:	4606      	mov	r6, r0
   476ec:	460f      	mov	r7, r1
   476ee:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   476f0:	d02d      	beq.n	4774e <encode_uint+0x74>
   476f2:	d828      	bhi.n	47746 <encode_uint+0x6c>
		return 16;
   476f4:	2b58      	cmp	r3, #88	; 0x58
   476f6:	bf14      	ite	ne
   476f8:	250a      	movne	r5, #10
   476fa:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   476fc:	46aa      	mov	sl, r5
   476fe:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   47702:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   47706:	4652      	mov	r2, sl
   47708:	465b      	mov	r3, fp
   4770a:	4630      	mov	r0, r6
   4770c:	4639      	mov	r1, r7
   4770e:	f7f8 fd19 	bl	40144 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47712:	2a09      	cmp	r2, #9
   47714:	b2d3      	uxtb	r3, r2
   47716:	d81f      	bhi.n	47758 <encode_uint+0x7e>
   47718:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   4771a:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   4771c:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   4771e:	bf08      	it	eq
   47720:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47722:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   47726:	d301      	bcc.n	4772c <encode_uint+0x52>
   47728:	45c8      	cmp	r8, r9
   4772a:	d812      	bhi.n	47752 <encode_uint+0x78>
	if (conv->flag_hash) {
   4772c:	7823      	ldrb	r3, [r4, #0]
   4772e:	069b      	lsls	r3, r3, #26
   47730:	d505      	bpl.n	4773e <encode_uint+0x64>
		if (radix == 8) {
   47732:	2d08      	cmp	r5, #8
   47734:	d116      	bne.n	47764 <encode_uint+0x8a>
			conv->altform_0 = true;
   47736:	78a3      	ldrb	r3, [r4, #2]
   47738:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   4773c:	70a3      	strb	r3, [r4, #2]
}
   4773e:	4640      	mov	r0, r8
   47740:	b003      	add	sp, #12
   47742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   47746:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   4774a:	2b70      	cmp	r3, #112	; 0x70
   4774c:	e7d3      	b.n	476f6 <encode_uint+0x1c>
	switch (specifier) {
   4774e:	2508      	movs	r5, #8
   47750:	e7d4      	b.n	476fc <encode_uint+0x22>
		value /= radix;
   47752:	4606      	mov	r6, r0
   47754:	460f      	mov	r7, r1
   47756:	e7d6      	b.n	47706 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47758:	9a01      	ldr	r2, [sp, #4]
   4775a:	2a19      	cmp	r2, #25
   4775c:	bf94      	ite	ls
   4775e:	3337      	addls	r3, #55	; 0x37
   47760:	3357      	addhi	r3, #87	; 0x57
   47762:	e7da      	b.n	4771a <encode_uint+0x40>
		} else if (radix == 16) {
   47764:	2d10      	cmp	r5, #16
   47766:	d1ea      	bne.n	4773e <encode_uint+0x64>
			conv->altform_0c = true;
   47768:	78a3      	ldrb	r3, [r4, #2]
   4776a:	f043 0310 	orr.w	r3, r3, #16
   4776e:	e7e5      	b.n	4773c <encode_uint+0x62>

00047770 <outs>:
{
   47770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47774:	4607      	mov	r7, r0
   47776:	4688      	mov	r8, r1
   47778:	4615      	mov	r5, r2
   4777a:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   4777c:	4614      	mov	r4, r2
   4777e:	42b4      	cmp	r4, r6
   47780:	eba4 0005 	sub.w	r0, r4, r5
   47784:	d302      	bcc.n	4778c <outs+0x1c>
   47786:	b93e      	cbnz	r6, 47798 <outs+0x28>
   47788:	7823      	ldrb	r3, [r4, #0]
   4778a:	b12b      	cbz	r3, 47798 <outs+0x28>
		int rc = out((int)*sp++, ctx);
   4778c:	4641      	mov	r1, r8
   4778e:	f814 0b01 	ldrb.w	r0, [r4], #1
   47792:	47b8      	blx	r7
		if (rc < 0) {
   47794:	2800      	cmp	r0, #0
   47796:	daf2      	bge.n	4777e <outs+0xe>
}
   47798:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004779c <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   4779c:	4770      	bx	lr

0004779e <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   4779e:	b084      	sub	sp, #16
   477a0:	ab04      	add	r3, sp, #16
   477a2:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   477a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
   477aa:	2b06      	cmp	r3, #6
   477ac:	d108      	bne.n	477c0 <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   477ae:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   477b2:	2201      	movs	r2, #1
   477b4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   477b8:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   477bc:	bf20      	wfe
    while (true)
   477be:	e7fd      	b.n	477bc <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   477c0:	b004      	add	sp, #16
   477c2:	4770      	bx	lr

000477c4 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   477c4:	b084      	sub	sp, #16
   477c6:	ab04      	add	r3, sp, #16
   477c8:	e903 0007 	stmdb	r3, {r0, r1, r2}
   477cc:	2300      	movs	r3, #0
   477ce:	f383 8811 	msr	BASEPRI, r3
   477d2:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   477d6:	b004      	add	sp, #16
   477d8:	4770      	bx	lr

000477da <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   477da:	2300      	movs	r3, #0
	list->head = NULL;
   477dc:	e9c0 3300 	strd	r3, r3, [r0]
}
   477e0:	4770      	bx	lr

000477e2 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   477e2:	6803      	ldr	r3, [r0, #0]
   477e4:	b923      	cbnz	r3, 477f0 <log_list_add_tail+0xe>
		list->head = msg;
   477e6:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   477e8:	2300      	movs	r3, #0
	list->tail = msg;
   477ea:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   477ec:	600b      	str	r3, [r1, #0]
}
   477ee:	4770      	bx	lr
		list->tail->next = msg;
   477f0:	6843      	ldr	r3, [r0, #4]
   477f2:	6019      	str	r1, [r3, #0]
   477f4:	e7f8      	b.n	477e8 <log_list_add_tail+0x6>

000477f6 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   477f6:	6800      	ldr	r0, [r0, #0]
   477f8:	4770      	bx	lr

000477fa <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   477fa:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   477fc:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   477fe:	b108      	cbz	r0, 47804 <log_list_head_get+0xa>
		list->head = list->head->next;
   47800:	6802      	ldr	r2, [r0, #0]
   47802:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   47804:	4770      	bx	lr

00047806 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   47806:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   47808:	f7f9 fe8a 	bl	41520 <log_msg_chunk_alloc>

	if (msg != NULL) {
   4780c:	b118      	cbz	r0, 47816 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   4780e:	2301      	movs	r3, #1
   47810:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   47812:	2300      	movs	r3, #0
   47814:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
   47816:	bd08      	pop	{r3, pc}

00047818 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   47818:	f000 bc97 	b.w	4814a <sys_clock_cycle_get_32>

0004781c <dummy_timestamp>:
   4781c:	2000      	movs	r0, #0
   4781e:	4770      	bx	lr

00047820 <z_log_get_s_mask>:
{
   47820:	b5f0      	push	{r4, r5, r6, r7, lr}
   47822:	4605      	mov	r5, r0
	uint32_t mask = 0U;
   47824:	2000      	movs	r0, #0
				mask |= BIT(arg);
   47826:	2701      	movs	r7, #1
	uint32_t arg = 0U;
   47828:	4603      	mov	r3, r0
	bool arm = false;
   4782a:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
   4782c:	f815 4b01 	ldrb.w	r4, [r5], #1
   47830:	b10c      	cbz	r4, 47836 <z_log_get_s_mask+0x16>
   47832:	428b      	cmp	r3, r1
   47834:	d300      	bcc.n	47838 <z_log_get_s_mask+0x18>
}
   47836:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   47838:	2c25      	cmp	r4, #37	; 0x25
   4783a:	d102      	bne.n	47842 <z_log_get_s_mask+0x22>
			arm = !arm;
   4783c:	f082 0201 	eor.w	r2, r2, #1
   47840:	e7f4      	b.n	4782c <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   47842:	2a00      	cmp	r2, #0
   47844:	d0f2      	beq.n	4782c <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   47846:	f044 0620 	orr.w	r6, r4, #32
   4784a:	3e61      	subs	r6, #97	; 0x61
   4784c:	2e19      	cmp	r6, #25
   4784e:	d8ed      	bhi.n	4782c <z_log_get_s_mask+0xc>
			if (curr == 's') {
   47850:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   47852:	bf04      	itt	eq
   47854:	fa07 f203 	lsleq.w	r2, r7, r3
   47858:	4310      	orreq	r0, r2
			arg++;
   4785a:	3301      	adds	r3, #1
			arm = false;
   4785c:	2200      	movs	r2, #0
   4785e:	e7e5      	b.n	4782c <z_log_get_s_mask+0xc>

00047860 <log_0>:
{
   47860:	b538      	push	{r3, r4, r5, lr}
   47862:	4605      	mov	r5, r0
   47864:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   47866:	f7ff ffce 	bl	47806 <z_log_msg_std_alloc>

	if (msg != NULL) {
   4786a:	b128      	cbz	r0, 47878 <log_0+0x18>
		msg_finalize(msg, src_level);
   4786c:	4621      	mov	r1, r4
		msg->str = str;
   4786e:	6105      	str	r5, [r0, #16]
}
   47870:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   47874:	f7f9 bd5a 	b.w	4132c <msg_finalize>
}
   47878:	bd38      	pop	{r3, r4, r5, pc}

0004787a <log_1>:
{
   4787a:	b570      	push	{r4, r5, r6, lr}
   4787c:	4606      	mov	r6, r0
   4787e:	460d      	mov	r5, r1
   47880:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47882:	f7ff ffc0 	bl	47806 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47886:	b158      	cbz	r0, 478a0 <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   47888:	2101      	movs	r1, #1
   4788a:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   4788c:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   4788e:	f361 1207 	bfi	r2, r1, #4, #4
   47892:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
   47894:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
   47896:	6145      	str	r5, [r0, #20]
}
   47898:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   4789c:	f7f9 bd46 	b.w	4132c <msg_finalize>
}
   478a0:	bd70      	pop	{r4, r5, r6, pc}

000478a2 <log_2>:
{
   478a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   478a6:	4680      	mov	r8, r0
   478a8:	460f      	mov	r7, r1
   478aa:	4616      	mov	r6, r2
   478ac:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   478ae:	f7ff ffaa 	bl	47806 <z_log_msg_std_alloc>

	if (msg != NULL) {
   478b2:	b168      	cbz	r0, 478d0 <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   478b4:	2202      	movs	r2, #2
   478b6:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   478b8:	4629      	mov	r1, r5
   478ba:	f362 1307 	bfi	r3, r2, #4, #4
   478be:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   478c0:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   478c4:	f8c0 8010 	str.w	r8, [r0, #16]
}
   478c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   478cc:	f7f9 bd2e 	b.w	4132c <msg_finalize>
}
   478d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000478d4 <log_3>:
{
   478d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   478d8:	4680      	mov	r8, r0
   478da:	460f      	mov	r7, r1
   478dc:	4616      	mov	r6, r2
   478de:	461d      	mov	r5, r3
   478e0:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   478e4:	f7ff ff8f 	bl	47806 <z_log_msg_std_alloc>

	if (msg != NULL) {
   478e8:	b170      	cbz	r0, 47908 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   478ea:	2203      	movs	r2, #3
   478ec:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   478ee:	4649      	mov	r1, r9
   478f0:	f362 1307 	bfi	r3, r2, #4, #4
   478f4:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   478f6:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   478fa:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
   478fe:	61c5      	str	r5, [r0, #28]
}
   47900:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   47904:	f7f9 bd12 	b.w	4132c <msg_finalize>
}
   47908:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0004790c <z_log_get_tag>:
}
   4790c:	2000      	movs	r0, #0
   4790e:	4770      	bx	lr

00047910 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   47910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47914:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47916:	8903      	ldrh	r3, [r0, #8]
{
   47918:	460e      	mov	r6, r1
   4791a:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
   4791c:	f3c3 028d 	ubfx	r2, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   47920:	42a2      	cmp	r2, r4
{
   47922:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
   47926:	d803      	bhi.n	47930 <log_msg_hexdump_data_op+0x20>
		*length = 0;
   47928:	2300      	movs	r3, #0
   4792a:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   4792c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   47930:	680b      	ldr	r3, [r1, #0]
   47932:	4423      	add	r3, r4
   47934:	4293      	cmp	r3, r2
		*length = available_len - offset;
   47936:	bf84      	itt	hi
   47938:	1b13      	subhi	r3, r2, r4
   4793a:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   4793c:	2a0c      	cmp	r2, #12
	req_len = *length;
   4793e:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47942:	d92a      	bls.n	4799a <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   47944:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   47946:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   4794a:	d82d      	bhi.n	479a8 <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   4794c:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
   4794e:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47950:	454a      	cmp	r2, r9
   47952:	bf28      	it	cs
   47954:	464a      	movcs	r2, r9
   47956:	4420      	add	r0, r4
   47958:	4615      	mov	r5, r2
		if (put_op) {
   4795a:	b317      	cbz	r7, 479a2 <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
   4795c:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   4795e:	f000 fa7e 	bl	47e5e <memcpy>
		req_len -= cpy_len;
   47962:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47966:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
   47968:	f1b9 0f00 	cmp.w	r9, #0
   4796c:	d0de      	beq.n	4792c <log_msg_hexdump_data_op+0x1c>
   4796e:	f1b8 0f00 	cmp.w	r8, #0
   47972:	d0db      	beq.n	4792c <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   47974:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47978:	454d      	cmp	r5, r9
   4797a:	bf28      	it	cs
   4797c:	464d      	movcs	r5, r9
		if (put_op) {
   4797e:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
   47980:	462a      	mov	r2, r5
   47982:	4440      	add	r0, r8
		if (put_op) {
   47984:	b1bf      	cbz	r7, 479b6 <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
   47986:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   47988:	f000 fa69 	bl	47e5e <memcpy>
		offset = 0;
   4798c:	2400      	movs	r4, #0
		cont = cont->next;
   4798e:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
   47992:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47996:	442e      	add	r6, r5
   47998:	e7e6      	b.n	47968 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
   4799a:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
   4799e:	3014      	adds	r0, #20
	if (offset < chunk_len) {
   479a0:	e7d6      	b.n	47950 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   479a2:	4601      	mov	r1, r0
   479a4:	4630      	mov	r0, r6
   479a6:	e7da      	b.n	4795e <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   479a8:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   479aa:	2c1b      	cmp	r4, #27
   479ac:	d9dc      	bls.n	47968 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   479ae:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   479b2:	3c1c      	subs	r4, #28
   479b4:	e7f9      	b.n	479aa <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
   479b6:	4601      	mov	r1, r0
   479b8:	4630      	mov	r0, r6
   479ba:	e7e5      	b.n	47988 <log_msg_hexdump_data_op+0x78>

000479bc <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   479bc:	3004      	adds	r0, #4
   479be:	e8d0 3fef 	ldaex	r3, [r0]
   479c2:	3301      	adds	r3, #1
   479c4:	e8c0 3fe2 	stlex	r2, r3, [r0]
   479c8:	2a00      	cmp	r2, #0
   479ca:	d1f8      	bne.n	479be <log_msg_get+0x2>
}
   479cc:	4770      	bx	lr

000479ce <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   479ce:	7a40      	ldrb	r0, [r0, #9]
}
   479d0:	0900      	lsrs	r0, r0, #4
   479d2:	4770      	bx	lr

000479d4 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   479d4:	7a43      	ldrb	r3, [r0, #9]
   479d6:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   479da:	ea4f 1213 	mov.w	r2, r3, lsr #4
   479de:	d216      	bcs.n	47a0e <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   479e0:	2a03      	cmp	r2, #3
   479e2:	d803      	bhi.n	479ec <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   479e4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   479e8:	6948      	ldr	r0, [r1, #20]
   479ea:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   479ec:	2901      	cmp	r1, #1
   479ee:	d803      	bhi.n	479f8 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   479f0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   479f4:	6988      	ldr	r0, [r1, #24]
   479f6:	4770      	bx	lr
	cont = msg->payload.ext.next;
   479f8:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   479fa:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   479fc:	2906      	cmp	r1, #6
   479fe:	d803      	bhi.n	47a08 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   47a00:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   47a04:	6848      	ldr	r0, [r1, #4]
   47a06:	4770      	bx	lr
		cont = cont->next;
   47a08:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   47a0a:	3907      	subs	r1, #7
		cont = cont->next;
   47a0c:	e7f6      	b.n	479fc <log_msg_arg_get+0x28>
		return 0;
   47a0e:	2000      	movs	r0, #0
}
   47a10:	4770      	bx	lr

00047a12 <log_msg_put>:
{
   47a12:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   47a14:	1d02      	adds	r2, r0, #4
   47a16:	e8d2 1fef 	ldaex	r1, [r2]
   47a1a:	3901      	subs	r1, #1
   47a1c:	e8c2 1fec 	stlex	ip, r1, [r2]
   47a20:	f1bc 0f00 	cmp.w	ip, #0
   47a24:	d1f7      	bne.n	47a16 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
   47a26:	685b      	ldr	r3, [r3, #4]
   47a28:	b90b      	cbnz	r3, 47a2e <log_msg_put+0x1c>
		msg_free(msg);
   47a2a:	f7f9 bd8d 	b.w	41548 <msg_free>
}
   47a2e:	4770      	bx	lr

00047a30 <log_msg_str_get>:
}
   47a30:	6900      	ldr	r0, [r0, #16]
   47a32:	4770      	bx	lr

00047a34 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   47a34:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   47a36:	2400      	movs	r4, #0
   47a38:	9400      	str	r4, [sp, #0]
   47a3a:	f7ff ff69 	bl	47910 <log_msg_hexdump_data_op>
}
   47a3e:	b002      	add	sp, #8
   47a40:	bd10      	pop	{r4, pc}

00047a42 <buffer_write>:
{
   47a42:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47a44:	4606      	mov	r6, r0
   47a46:	460d      	mov	r5, r1
   47a48:	4614      	mov	r4, r2
   47a4a:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   47a4c:	4621      	mov	r1, r4
   47a4e:	4628      	mov	r0, r5
   47a50:	463a      	mov	r2, r7
   47a52:	47b0      	blx	r6
	} while (len != 0);
   47a54:	1a24      	subs	r4, r4, r0
		buf += processed;
   47a56:	4405      	add	r5, r0
	} while (len != 0);
   47a58:	d1f8      	bne.n	47a4c <buffer_write+0xa>
}
   47a5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00047a5c <std_print>:
{
   47a5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   47a60:	b08e      	sub	sp, #56	; 0x38
   47a62:	af0e      	add	r7, sp, #56	; 0x38
   47a64:	4680      	mov	r8, r0
   47a66:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   47a68:	f7ff ffe2 	bl	47a30 <log_msg_str_get>
   47a6c:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
   47a6e:	4640      	mov	r0, r8
   47a70:	f7ff ffad 	bl	479ce <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
   47a74:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
   47a78:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
   47a7a:	0083      	lsls	r3, r0, #2
   47a7c:	3307      	adds	r3, #7
   47a7e:	f023 0307 	bic.w	r3, r3, #7
   47a82:	ebad 0d03 	sub.w	sp, sp, r3
   47a86:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   47a88:	45d1      	cmp	r9, sl
   47a8a:	d116      	bne.n	47aba <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   47a8c:	4640      	mov	r0, r8
   47a8e:	f7ff ff9e 	bl	479ce <log_msg_nargs_get>
   47a92:	280f      	cmp	r0, #15
   47a94:	d81e      	bhi.n	47ad4 <std_print+0x78>
   47a96:	e8df f010 	tbh	[pc, r0, lsl #1]
   47a9a:	0019      	.short	0x0019
   47a9c:	00260020 	.word	0x00260020
   47aa0:	0036002d 	.word	0x0036002d
   47aa4:	004e0041 	.word	0x004e0041
   47aa8:	006e005d 	.word	0x006e005d
   47aac:	00960081 	.word	0x00960081
   47ab0:	00c600ad 	.word	0x00c600ad
   47ab4:	00fe00e1 	.word	0x00fe00e1
   47ab8:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   47aba:	4649      	mov	r1, r9
   47abc:	4640      	mov	r0, r8
   47abe:	f7ff ff89 	bl	479d4 <log_msg_arg_get>
   47ac2:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   47ac6:	f109 0901 	add.w	r9, r9, #1
   47aca:	e7dd      	b.n	47a88 <std_print+0x2c>
		print_formatted(output, str);
   47acc:	4631      	mov	r1, r6
   47ace:	4628      	mov	r0, r5
   47ad0:	f7f9 fd78 	bl	415c4 <print_formatted>
}
   47ad4:	46bd      	mov	sp, r7
   47ad6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
   47ada:	4631      	mov	r1, r6
   47adc:	4628      	mov	r0, r5
   47ade:	6822      	ldr	r2, [r4, #0]
   47ae0:	f7f9 fd70 	bl	415c4 <print_formatted>
		break;
   47ae4:	e7f6      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
   47ae6:	4631      	mov	r1, r6
   47ae8:	e9d4 2300 	ldrd	r2, r3, [r4]
   47aec:	4628      	mov	r0, r5
   47aee:	f7f9 fd69 	bl	415c4 <print_formatted>
		break;
   47af2:	e7ef      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
   47af4:	68a3      	ldr	r3, [r4, #8]
   47af6:	4631      	mov	r1, r6
   47af8:	9300      	str	r3, [sp, #0]
   47afa:	4628      	mov	r0, r5
   47afc:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b00:	f7f9 fd60 	bl	415c4 <print_formatted>
		break;
   47b04:	e7e6      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b06:	68e3      	ldr	r3, [r4, #12]
   47b08:	4631      	mov	r1, r6
   47b0a:	9301      	str	r3, [sp, #4]
   47b0c:	68a3      	ldr	r3, [r4, #8]
   47b0e:	4628      	mov	r0, r5
   47b10:	9300      	str	r3, [sp, #0]
   47b12:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b16:	f7f9 fd55 	bl	415c4 <print_formatted>
		break;
   47b1a:	e7db      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b1c:	6923      	ldr	r3, [r4, #16]
   47b1e:	4631      	mov	r1, r6
   47b20:	9302      	str	r3, [sp, #8]
   47b22:	68e3      	ldr	r3, [r4, #12]
   47b24:	4628      	mov	r0, r5
   47b26:	9301      	str	r3, [sp, #4]
   47b28:	68a3      	ldr	r3, [r4, #8]
   47b2a:	9300      	str	r3, [sp, #0]
   47b2c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b30:	f7f9 fd48 	bl	415c4 <print_formatted>
		break;
   47b34:	e7ce      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b36:	6963      	ldr	r3, [r4, #20]
   47b38:	4631      	mov	r1, r6
   47b3a:	9303      	str	r3, [sp, #12]
   47b3c:	6923      	ldr	r3, [r4, #16]
   47b3e:	4628      	mov	r0, r5
   47b40:	9302      	str	r3, [sp, #8]
   47b42:	68e3      	ldr	r3, [r4, #12]
   47b44:	9301      	str	r3, [sp, #4]
   47b46:	68a3      	ldr	r3, [r4, #8]
   47b48:	9300      	str	r3, [sp, #0]
   47b4a:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b4e:	f7f9 fd39 	bl	415c4 <print_formatted>
		break;
   47b52:	e7bf      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b54:	69a3      	ldr	r3, [r4, #24]
   47b56:	4631      	mov	r1, r6
   47b58:	9304      	str	r3, [sp, #16]
   47b5a:	6963      	ldr	r3, [r4, #20]
   47b5c:	4628      	mov	r0, r5
   47b5e:	9303      	str	r3, [sp, #12]
   47b60:	6923      	ldr	r3, [r4, #16]
   47b62:	9302      	str	r3, [sp, #8]
   47b64:	68e3      	ldr	r3, [r4, #12]
   47b66:	9301      	str	r3, [sp, #4]
   47b68:	68a3      	ldr	r3, [r4, #8]
   47b6a:	9300      	str	r3, [sp, #0]
   47b6c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b70:	f7f9 fd28 	bl	415c4 <print_formatted>
		break;
   47b74:	e7ae      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b76:	69e3      	ldr	r3, [r4, #28]
   47b78:	4631      	mov	r1, r6
   47b7a:	9305      	str	r3, [sp, #20]
   47b7c:	69a3      	ldr	r3, [r4, #24]
   47b7e:	4628      	mov	r0, r5
   47b80:	9304      	str	r3, [sp, #16]
   47b82:	6963      	ldr	r3, [r4, #20]
   47b84:	9303      	str	r3, [sp, #12]
   47b86:	6923      	ldr	r3, [r4, #16]
   47b88:	9302      	str	r3, [sp, #8]
   47b8a:	68e3      	ldr	r3, [r4, #12]
   47b8c:	9301      	str	r3, [sp, #4]
   47b8e:	68a3      	ldr	r3, [r4, #8]
   47b90:	9300      	str	r3, [sp, #0]
   47b92:	e9d4 2300 	ldrd	r2, r3, [r4]
   47b96:	f7f9 fd15 	bl	415c4 <print_formatted>
		break;
   47b9a:	e79b      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47b9c:	6a23      	ldr	r3, [r4, #32]
   47b9e:	4631      	mov	r1, r6
   47ba0:	9306      	str	r3, [sp, #24]
   47ba2:	69e3      	ldr	r3, [r4, #28]
   47ba4:	4628      	mov	r0, r5
   47ba6:	9305      	str	r3, [sp, #20]
   47ba8:	69a3      	ldr	r3, [r4, #24]
   47baa:	9304      	str	r3, [sp, #16]
   47bac:	6963      	ldr	r3, [r4, #20]
   47bae:	9303      	str	r3, [sp, #12]
   47bb0:	6923      	ldr	r3, [r4, #16]
   47bb2:	9302      	str	r3, [sp, #8]
   47bb4:	68e3      	ldr	r3, [r4, #12]
   47bb6:	9301      	str	r3, [sp, #4]
   47bb8:	68a3      	ldr	r3, [r4, #8]
   47bba:	9300      	str	r3, [sp, #0]
   47bbc:	e9d4 2300 	ldrd	r2, r3, [r4]
   47bc0:	f7f9 fd00 	bl	415c4 <print_formatted>
		break;
   47bc4:	e786      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47bc6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47bc8:	4631      	mov	r1, r6
   47bca:	9307      	str	r3, [sp, #28]
   47bcc:	6a23      	ldr	r3, [r4, #32]
   47bce:	4628      	mov	r0, r5
   47bd0:	9306      	str	r3, [sp, #24]
   47bd2:	69e3      	ldr	r3, [r4, #28]
   47bd4:	9305      	str	r3, [sp, #20]
   47bd6:	69a3      	ldr	r3, [r4, #24]
   47bd8:	9304      	str	r3, [sp, #16]
   47bda:	6963      	ldr	r3, [r4, #20]
   47bdc:	9303      	str	r3, [sp, #12]
   47bde:	6923      	ldr	r3, [r4, #16]
   47be0:	9302      	str	r3, [sp, #8]
   47be2:	68e3      	ldr	r3, [r4, #12]
   47be4:	9301      	str	r3, [sp, #4]
   47be6:	68a3      	ldr	r3, [r4, #8]
   47be8:	9300      	str	r3, [sp, #0]
   47bea:	e9d4 2300 	ldrd	r2, r3, [r4]
   47bee:	f7f9 fce9 	bl	415c4 <print_formatted>
		break;
   47bf2:	e76f      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47bf4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47bf6:	4631      	mov	r1, r6
   47bf8:	9308      	str	r3, [sp, #32]
   47bfa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47bfc:	4628      	mov	r0, r5
   47bfe:	9307      	str	r3, [sp, #28]
   47c00:	6a23      	ldr	r3, [r4, #32]
   47c02:	9306      	str	r3, [sp, #24]
   47c04:	69e3      	ldr	r3, [r4, #28]
   47c06:	9305      	str	r3, [sp, #20]
   47c08:	69a3      	ldr	r3, [r4, #24]
   47c0a:	9304      	str	r3, [sp, #16]
   47c0c:	6963      	ldr	r3, [r4, #20]
   47c0e:	9303      	str	r3, [sp, #12]
   47c10:	6923      	ldr	r3, [r4, #16]
   47c12:	9302      	str	r3, [sp, #8]
   47c14:	68e3      	ldr	r3, [r4, #12]
   47c16:	9301      	str	r3, [sp, #4]
   47c18:	68a3      	ldr	r3, [r4, #8]
   47c1a:	9300      	str	r3, [sp, #0]
   47c1c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47c20:	f7f9 fcd0 	bl	415c4 <print_formatted>
		break;
   47c24:	e756      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47c26:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47c28:	4631      	mov	r1, r6
   47c2a:	9309      	str	r3, [sp, #36]	; 0x24
   47c2c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47c2e:	4628      	mov	r0, r5
   47c30:	9308      	str	r3, [sp, #32]
   47c32:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47c34:	9307      	str	r3, [sp, #28]
   47c36:	6a23      	ldr	r3, [r4, #32]
   47c38:	9306      	str	r3, [sp, #24]
   47c3a:	69e3      	ldr	r3, [r4, #28]
   47c3c:	9305      	str	r3, [sp, #20]
   47c3e:	69a3      	ldr	r3, [r4, #24]
   47c40:	9304      	str	r3, [sp, #16]
   47c42:	6963      	ldr	r3, [r4, #20]
   47c44:	9303      	str	r3, [sp, #12]
   47c46:	6923      	ldr	r3, [r4, #16]
   47c48:	9302      	str	r3, [sp, #8]
   47c4a:	68e3      	ldr	r3, [r4, #12]
   47c4c:	9301      	str	r3, [sp, #4]
   47c4e:	68a3      	ldr	r3, [r4, #8]
   47c50:	9300      	str	r3, [sp, #0]
   47c52:	e9d4 2300 	ldrd	r2, r3, [r4]
   47c56:	f7f9 fcb5 	bl	415c4 <print_formatted>
		break;
   47c5a:	e73b      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47c5c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47c5e:	4631      	mov	r1, r6
   47c60:	930a      	str	r3, [sp, #40]	; 0x28
   47c62:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47c64:	4628      	mov	r0, r5
   47c66:	9309      	str	r3, [sp, #36]	; 0x24
   47c68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47c6a:	9308      	str	r3, [sp, #32]
   47c6c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47c6e:	9307      	str	r3, [sp, #28]
   47c70:	6a23      	ldr	r3, [r4, #32]
   47c72:	9306      	str	r3, [sp, #24]
   47c74:	69e3      	ldr	r3, [r4, #28]
   47c76:	9305      	str	r3, [sp, #20]
   47c78:	69a3      	ldr	r3, [r4, #24]
   47c7a:	9304      	str	r3, [sp, #16]
   47c7c:	6963      	ldr	r3, [r4, #20]
   47c7e:	9303      	str	r3, [sp, #12]
   47c80:	6923      	ldr	r3, [r4, #16]
   47c82:	9302      	str	r3, [sp, #8]
   47c84:	68e3      	ldr	r3, [r4, #12]
   47c86:	9301      	str	r3, [sp, #4]
   47c88:	68a3      	ldr	r3, [r4, #8]
   47c8a:	9300      	str	r3, [sp, #0]
   47c8c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47c90:	f7f9 fc98 	bl	415c4 <print_formatted>
		break;
   47c94:	e71e      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47c96:	6b63      	ldr	r3, [r4, #52]	; 0x34
   47c98:	4631      	mov	r1, r6
   47c9a:	930b      	str	r3, [sp, #44]	; 0x2c
   47c9c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47c9e:	4628      	mov	r0, r5
   47ca0:	930a      	str	r3, [sp, #40]	; 0x28
   47ca2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47ca4:	9309      	str	r3, [sp, #36]	; 0x24
   47ca6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47ca8:	9308      	str	r3, [sp, #32]
   47caa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47cac:	9307      	str	r3, [sp, #28]
   47cae:	6a23      	ldr	r3, [r4, #32]
   47cb0:	9306      	str	r3, [sp, #24]
   47cb2:	69e3      	ldr	r3, [r4, #28]
   47cb4:	9305      	str	r3, [sp, #20]
   47cb6:	69a3      	ldr	r3, [r4, #24]
   47cb8:	9304      	str	r3, [sp, #16]
   47cba:	6963      	ldr	r3, [r4, #20]
   47cbc:	9303      	str	r3, [sp, #12]
   47cbe:	6923      	ldr	r3, [r4, #16]
   47cc0:	9302      	str	r3, [sp, #8]
   47cc2:	68e3      	ldr	r3, [r4, #12]
   47cc4:	9301      	str	r3, [sp, #4]
   47cc6:	68a3      	ldr	r3, [r4, #8]
   47cc8:	9300      	str	r3, [sp, #0]
   47cca:	e9d4 2300 	ldrd	r2, r3, [r4]
   47cce:	f7f9 fc79 	bl	415c4 <print_formatted>
		break;
   47cd2:	e6ff      	b.n	47ad4 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47cd4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   47cd6:	4631      	mov	r1, r6
   47cd8:	930c      	str	r3, [sp, #48]	; 0x30
   47cda:	6b63      	ldr	r3, [r4, #52]	; 0x34
   47cdc:	4628      	mov	r0, r5
   47cde:	930b      	str	r3, [sp, #44]	; 0x2c
   47ce0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47ce2:	930a      	str	r3, [sp, #40]	; 0x28
   47ce4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47ce6:	9309      	str	r3, [sp, #36]	; 0x24
   47ce8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47cea:	9308      	str	r3, [sp, #32]
   47cec:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47cee:	9307      	str	r3, [sp, #28]
   47cf0:	6a23      	ldr	r3, [r4, #32]
   47cf2:	9306      	str	r3, [sp, #24]
   47cf4:	69e3      	ldr	r3, [r4, #28]
   47cf6:	9305      	str	r3, [sp, #20]
   47cf8:	69a3      	ldr	r3, [r4, #24]
   47cfa:	9304      	str	r3, [sp, #16]
   47cfc:	6963      	ldr	r3, [r4, #20]
   47cfe:	9303      	str	r3, [sp, #12]
   47d00:	6923      	ldr	r3, [r4, #16]
   47d02:	9302      	str	r3, [sp, #8]
   47d04:	68e3      	ldr	r3, [r4, #12]
   47d06:	9301      	str	r3, [sp, #4]
   47d08:	68a3      	ldr	r3, [r4, #8]
   47d0a:	9300      	str	r3, [sp, #0]
   47d0c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47d10:	f7f9 fc58 	bl	415c4 <print_formatted>
}
   47d14:	e6de      	b.n	47ad4 <std_print+0x78>

00047d16 <log_output_flush>:
		     output->control_block->offset,
   47d16:	6842      	ldr	r2, [r0, #4]
{
   47d18:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
   47d1a:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   47d1e:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   47d20:	6881      	ldr	r1, [r0, #8]
   47d22:	6800      	ldr	r0, [r0, #0]
   47d24:	f7ff fe8d 	bl	47a42 <buffer_write>
	output->control_block->offset = 0;
   47d28:	2200      	movs	r2, #0
   47d2a:	6863      	ldr	r3, [r4, #4]
   47d2c:	601a      	str	r2, [r3, #0]
}
   47d2e:	bd10      	pop	{r4, pc}

00047d30 <out_func>:
{
   47d30:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   47d32:	684b      	ldr	r3, [r1, #4]
{
   47d34:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
   47d36:	681a      	ldr	r2, [r3, #0]
   47d38:	68cb      	ldr	r3, [r1, #12]
{
   47d3a:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   47d3c:	429a      	cmp	r2, r3
   47d3e:	d102      	bne.n	47d46 <out_func+0x16>
		log_output_flush(out_ctx);
   47d40:	4608      	mov	r0, r1
   47d42:	f7ff ffe8 	bl	47d16 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   47d46:	6863      	ldr	r3, [r4, #4]
   47d48:	e8d3 2fef 	ldaex	r2, [r3]
   47d4c:	1c51      	adds	r1, r2, #1
   47d4e:	e8c3 1fe0 	stlex	r0, r1, [r3]
   47d52:	2800      	cmp	r0, #0
   47d54:	d1f8      	bne.n	47d48 <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
   47d56:	68a3      	ldr	r3, [r4, #8]
}
   47d58:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
   47d5a:	549d      	strb	r5, [r3, r2]
}
   47d5c:	bd38      	pop	{r3, r4, r5, pc}

00047d5e <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   47d5e:	2200      	movs	r2, #0
   47d60:	e9c0 2200 	strd	r2, r2, [r0]
   47d64:	6082      	str	r2, [r0, #8]
}
   47d66:	4770      	bx	lr

00047d68 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   47d68:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   47d6a:	6800      	ldr	r0, [r0, #0]
   47d6c:	f7fa b816 	b.w	41d9c <z_arm_fatal_error>

00047d70 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   47d70:	2100      	movs	r1, #0
   47d72:	2001      	movs	r0, #1
   47d74:	f7fa b812 	b.w	41d9c <z_arm_fatal_error>

00047d78 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   47d78:	b508      	push	{r3, lr}
	handler();
   47d7a:	f7fa f889 	bl	41e90 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   47d7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   47d82:	f7fa b951 	b.w	42028 <z_arm_exc_exit>

00047d86 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   47d86:	6e43      	ldr	r3, [r0, #100]	; 0x64
   47d88:	f383 880b 	msr	PSPLIM, r3
}
   47d8c:	4770      	bx	lr

00047d8e <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   47d8e:	4770      	bx	lr

00047d90 <z_arm_restore_fp_context>:
   47d90:	4770      	bx	lr

00047d92 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   47d92:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   47d96:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   47d9a:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   47d9c:	bf08      	it	eq
   47d9e:	f06f 0015 	mvneq.w	r0, #21
   47da2:	4770      	bx	lr

00047da4 <mpu_configure_region>:
{
   47da4:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   47da6:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   47da8:	680c      	ldr	r4, [r1, #0]
{
   47daa:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   47dac:	890a      	ldrh	r2, [r1, #8]
   47dae:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   47db0:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47db2:	3b01      	subs	r3, #1
   47db4:	f024 041f 	bic.w	r4, r4, #31
   47db8:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   47dba:	f002 021f 	and.w	r2, r2, #31
   47dbe:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47dc2:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   47dc6:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
   47dc8:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47dcc:	9303      	str	r3, [sp, #12]
   47dce:	f7fa fc37 	bl	42640 <region_allocate_and_init>
}
   47dd2:	b005      	add	sp, #20
   47dd4:	bd30      	pop	{r4, r5, pc}

00047dd6 <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
   47dd6:	4770      	bx	lr

00047dd8 <calloc>:

#endif /* CONFIG_MINIMAL_LIBC_MALLOC */

#ifdef CONFIG_MINIMAL_LIBC_CALLOC
void *calloc(size_t nmemb, size_t size)
{
   47dd8:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   47dda:	fba0 4501 	umull	r4, r5, r0, r1
   47dde:	b935      	cbnz	r5, 47dee <calloc+0x16>
	if (size_mul_overflow(nmemb, size, &size)) {
		errno = ENOMEM;
		return NULL;
	}

	ret = malloc(size);
   47de0:	4620      	mov	r0, r4
   47de2:	f7fa fd99 	bl	42918 <malloc>

	if (ret != NULL) {
   47de6:	4606      	mov	r6, r0
   47de8:	b938      	cbnz	r0, 47dfa <calloc+0x22>
		(void)memset(ret, 0, size);
	}

	return ret;
}
   47dea:	4630      	mov	r0, r6
   47dec:	bd70      	pop	{r4, r5, r6, pc}
   47dee:	f7fe f84f 	bl	45e90 <z_impl_z_errno>
		errno = ENOMEM;
   47df2:	230c      	movs	r3, #12
		return NULL;
   47df4:	2600      	movs	r6, #0
		errno = ENOMEM;
   47df6:	6003      	str	r3, [r0, #0]
		return NULL;
   47df8:	e7f7      	b.n	47dea <calloc+0x12>
		(void)memset(ret, 0, size);
   47dfa:	4622      	mov	r2, r4
   47dfc:	4629      	mov	r1, r5
   47dfe:	f000 f839 	bl	47e74 <memset>
   47e02:	e7f2      	b.n	47dea <calloc+0x12>

00047e04 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   47e04:	4603      	mov	r3, r0
   47e06:	3901      	subs	r1, #1
   47e08:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   47e0c:	b90a      	cbnz	r2, 47e12 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   47e0e:	701a      	strb	r2, [r3, #0]

	return dest;
}
   47e10:	4770      	bx	lr
		*d = *s;
   47e12:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   47e16:	e7f7      	b.n	47e08 <strcpy+0x4>

00047e18 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
   47e18:	b570      	push	{r4, r5, r6, lr}
   47e1a:	4605      	mov	r5, r0
   47e1c:	3901      	subs	r1, #1
   47e1e:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   47e20:	b142      	cbz	r2, 47e34 <strncpy+0x1c>
   47e22:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   47e26:	1e56      	subs	r6, r2, #1
   47e28:	b92b      	cbnz	r3, 47e36 <strncpy+0x1e>
   47e2a:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   47e2c:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   47e30:	42a2      	cmp	r2, r4
   47e32:	d1fb      	bne.n	47e2c <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   47e34:	bd70      	pop	{r4, r5, r6, pc}
		n--;
   47e36:	4632      	mov	r2, r6
		*d = *s;
   47e38:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   47e3c:	e7ef      	b.n	47e1e <strncpy+0x6>

00047e3e <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   47e3e:	4603      	mov	r3, r0
	size_t n = 0;
   47e40:	2000      	movs	r0, #0

	while (*s != '\0') {
   47e42:	5c1a      	ldrb	r2, [r3, r0]
   47e44:	b902      	cbnz	r2, 47e48 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   47e46:	4770      	bx	lr
		n++;
   47e48:	3001      	adds	r0, #1
   47e4a:	e7fa      	b.n	47e42 <strlen+0x4>

00047e4c <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   47e4c:	4603      	mov	r3, r0
	size_t n = 0;
   47e4e:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   47e50:	5c1a      	ldrb	r2, [r3, r0]
   47e52:	b10a      	cbz	r2, 47e58 <strnlen+0xc>
   47e54:	4288      	cmp	r0, r1
   47e56:	d100      	bne.n	47e5a <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   47e58:	4770      	bx	lr
		n++;
   47e5a:	3001      	adds	r0, #1
   47e5c:	e7f8      	b.n	47e50 <strnlen+0x4>

00047e5e <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   47e5e:	b510      	push	{r4, lr}
   47e60:	1e43      	subs	r3, r0, #1
   47e62:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   47e64:	4291      	cmp	r1, r2
   47e66:	d100      	bne.n	47e6a <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   47e68:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   47e6a:	f811 4b01 	ldrb.w	r4, [r1], #1
   47e6e:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   47e72:	e7f7      	b.n	47e64 <memcpy+0x6>

00047e74 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   47e74:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   47e76:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   47e78:	4402      	add	r2, r0
   47e7a:	4293      	cmp	r3, r2
   47e7c:	d100      	bne.n	47e80 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   47e7e:	4770      	bx	lr
		*(d_byte++) = c_byte;
   47e80:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   47e84:	e7f9      	b.n	47e7a <memset+0x6>

00047e86 <_stdout_hook_default>:
}
   47e86:	f04f 30ff 	mov.w	r0, #4294967295
   47e8a:	4770      	bx	lr

00047e8c <fputc>:
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
   47e8c:	f7fa bd6a 	b.w	42964 <z_impl_zephyr_fputc>

00047e90 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   47e90:	b2cb      	uxtb	r3, r1
   47e92:	210c      	movs	r1, #12
   47e94:	6902      	ldr	r2, [r0, #16]
   47e96:	fb03 2101 	mla	r1, r3, r1, r2
   47e9a:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   47e9c:	f000 0007 	and.w	r0, r0, #7
   47ea0:	4770      	bx	lr

00047ea2 <set_off_state>:
	__asm__ volatile(
   47ea2:	f04f 0320 	mov.w	r3, #32
   47ea6:	f3ef 8211 	mrs	r2, BASEPRI
   47eaa:	f383 8812 	msr	BASEPRI_MAX, r3
   47eae:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   47eb2:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   47eb4:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   47eb8:	d001      	beq.n	47ebe <set_off_state+0x1c>
   47eba:	428b      	cmp	r3, r1
   47ebc:	d107      	bne.n	47ece <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   47ebe:	2301      	movs	r3, #1
   47ec0:	6003      	str	r3, [r0, #0]
	int err = 0;
   47ec2:	2000      	movs	r0, #0
	__asm__ volatile(
   47ec4:	f382 8811 	msr	BASEPRI, r2
   47ec8:	f3bf 8f6f 	isb	sy
}
   47ecc:	4770      	bx	lr
		err = -EPERM;
   47ece:	f04f 30ff 	mov.w	r0, #4294967295
   47ed2:	e7f7      	b.n	47ec4 <set_off_state+0x22>

00047ed4 <set_starting_state>:
{
   47ed4:	b510      	push	{r4, lr}
	__asm__ volatile(
   47ed6:	f04f 0320 	mov.w	r3, #32
   47eda:	f3ef 8211 	mrs	r2, BASEPRI
   47ede:	f383 8812 	msr	BASEPRI_MAX, r3
   47ee2:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   47ee6:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   47ee8:	f003 0407 	and.w	r4, r3, #7
   47eec:	2c01      	cmp	r4, #1
   47eee:	d106      	bne.n	47efe <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   47ef0:	6001      	str	r1, [r0, #0]
	int err = 0;
   47ef2:	2000      	movs	r0, #0
	__asm__ volatile(
   47ef4:	f382 8811 	msr	BASEPRI, r2
   47ef8:	f3bf 8f6f 	isb	sy
}
   47efc:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   47efe:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   47f02:	428b      	cmp	r3, r1
		err = -EALREADY;
   47f04:	bf14      	ite	ne
   47f06:	f04f 30ff 	movne.w	r0, #4294967295
   47f0a:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   47f0e:	e7f1      	b.n	47ef4 <set_starting_state+0x20>

00047f10 <set_on_state>:
	__asm__ volatile(
   47f10:	f04f 0320 	mov.w	r3, #32
   47f14:	f3ef 8211 	mrs	r2, BASEPRI
   47f18:	f383 8812 	msr	BASEPRI_MAX, r3
   47f1c:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   47f20:	6803      	ldr	r3, [r0, #0]
   47f22:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   47f26:	f043 0302 	orr.w	r3, r3, #2
   47f2a:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   47f2c:	f382 8811 	msr	BASEPRI, r2
   47f30:	f3bf 8f6f 	isb	sy
}
   47f34:	4770      	bx	lr

00047f36 <onoff_started_callback>:
{
   47f36:	b410      	push	{r4}
	notify(mgr, 0);
   47f38:	241c      	movs	r4, #28
	return &data->mgr[type];
   47f3a:	6900      	ldr	r0, [r0, #16]
   47f3c:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   47f3e:	fb03 0004 	mla	r0, r3, r4, r0
   47f42:	2100      	movs	r1, #0
}
   47f44:	bc10      	pop	{r4}
	notify(mgr, 0);
   47f46:	4710      	bx	r2

00047f48 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   47f48:	2000      	movs	r0, #0
   47f4a:	f7fb be83 	b.w	43c54 <nrfx_clock_start>

00047f4e <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   47f4e:	2000      	movs	r0, #0
   47f50:	f7fb beb2 	b.w	43cb8 <nrfx_clock_stop>

00047f54 <blocking_start_callback>:
{
   47f54:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   47f56:	f7fe baa7 	b.w	464a8 <z_impl_k_sem_give>

00047f5a <api_stop>:
{
   47f5a:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   47f5c:	240c      	movs	r4, #12
   47f5e:	b2c9      	uxtb	r1, r1
   47f60:	434c      	muls	r4, r1
{
   47f62:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   47f64:	6900      	ldr	r0, [r0, #16]
   47f66:	f104 0340 	add.w	r3, r4, #64	; 0x40
   47f6a:	2180      	movs	r1, #128	; 0x80
   47f6c:	4418      	add	r0, r3
   47f6e:	f7ff ff98 	bl	47ea2 <set_off_state>
	if (err < 0) {
   47f72:	2800      	cmp	r0, #0
   47f74:	db04      	blt.n	47f80 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   47f76:	6869      	ldr	r1, [r5, #4]
   47f78:	440c      	add	r4, r1
   47f7a:	6863      	ldr	r3, [r4, #4]
   47f7c:	4798      	blx	r3
	return 0;
   47f7e:	2000      	movs	r0, #0
}
   47f80:	bd38      	pop	{r3, r4, r5, pc}

00047f82 <api_start>:
{
   47f82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   47f86:	240c      	movs	r4, #12
   47f88:	b2c9      	uxtb	r1, r1
   47f8a:	434c      	muls	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   47f8c:	6905      	ldr	r5, [r0, #16]
{
   47f8e:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   47f90:	f104 0040 	add.w	r0, r4, #64	; 0x40
   47f94:	2180      	movs	r1, #128	; 0x80
   47f96:	4428      	add	r0, r5
{
   47f98:	4690      	mov	r8, r2
   47f9a:	461f      	mov	r7, r3
	err = set_starting_state(&subdata->flags, ctx);
   47f9c:	f7ff ff9a 	bl	47ed4 <set_starting_state>
	if (err < 0) {
   47fa0:	2800      	cmp	r0, #0
   47fa2:	db06      	blt.n	47fb2 <api_start+0x30>
	subdata->cb = cb;
   47fa4:	4425      	add	r5, r4
	subdata->user_data = user_data;
   47fa6:	e9c5 870e 	strd	r8, r7, [r5, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   47faa:	6873      	ldr	r3, [r6, #4]
   47fac:	591b      	ldr	r3, [r3, r4]
   47fae:	4798      	blx	r3
	return 0;
   47fb0:	2000      	movs	r0, #0
}
   47fb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047fb6 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fb6:	6843      	ldr	r3, [r0, #4]
}
   47fb8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fba:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   47fbc:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   47fbe:	600b      	str	r3, [r1, #0]
}
   47fc0:	4770      	bx	lr

00047fc2 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fc2:	6843      	ldr	r3, [r0, #4]
   47fc4:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   47fc6:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   47fc8:	4042      	eors	r2, r0
   47fca:	400a      	ands	r2, r1
   47fcc:	4042      	eors	r2, r0
    p_reg->OUT = value;
   47fce:	605a      	str	r2, [r3, #4]
}
   47fd0:	2000      	movs	r0, #0
   47fd2:	4770      	bx	lr

00047fd4 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fd4:	6843      	ldr	r3, [r0, #4]
}
   47fd6:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fd8:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   47fda:	6099      	str	r1, [r3, #8]
}
   47fdc:	4770      	bx	lr

00047fde <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fde:	6843      	ldr	r3, [r0, #4]
}
   47fe0:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fe2:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   47fe4:	60d9      	str	r1, [r3, #12]
}
   47fe6:	4770      	bx	lr

00047fe8 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fe8:	6843      	ldr	r3, [r0, #4]
}
   47fea:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   47fec:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   47fee:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   47ff0:	404b      	eors	r3, r1
    p_reg->OUT = value;
   47ff2:	6053      	str	r3, [r2, #4]
}
   47ff4:	4770      	bx	lr

00047ff6 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   47ff6:	6903      	ldr	r3, [r0, #16]
{
   47ff8:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   47ffa:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   47ffc:	b158      	cbz	r0, 48016 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   47ffe:	2400      	movs	r4, #0
   48000:	4281      	cmp	r1, r0
   48002:	d113      	bne.n	4802c <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   48004:	6808      	ldr	r0, [r1, #0]
   48006:	b95c      	cbnz	r4, 48020 <gpio_nrfx_manage_callback+0x2a>
   48008:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   4800a:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   4800c:	42a1      	cmp	r1, r4
   4800e:	d100      	bne.n	48012 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   48010:	6098      	str	r0, [r3, #8]
	parent->next = child;
   48012:	2000      	movs	r0, #0
   48014:	6008      	str	r0, [r1, #0]
	if (set) {
   48016:	b972      	cbnz	r2, 48036 <gpio_nrfx_manage_callback+0x40>
	return 0;
   48018:	2000      	movs	r0, #0
}
   4801a:	bd30      	pop	{r4, r5, pc}
   4801c:	4628      	mov	r0, r5
   4801e:	e7ef      	b.n	48000 <gpio_nrfx_manage_callback+0xa>
   48020:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   48022:	6898      	ldr	r0, [r3, #8]
   48024:	4281      	cmp	r1, r0
	list->tail = node;
   48026:	bf08      	it	eq
   48028:	609c      	streq	r4, [r3, #8]
}
   4802a:	e7f2      	b.n	48012 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   4802c:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   4802e:	4604      	mov	r4, r0
   48030:	2d00      	cmp	r5, #0
   48032:	d1f3      	bne.n	4801c <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   48034:	b13a      	cbz	r2, 48046 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   48036:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   48038:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   4803a:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   4803c:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   4803e:	2800      	cmp	r0, #0
   48040:	d1ea      	bne.n	48018 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   48042:	6099      	str	r1, [r3, #8]
}
   48044:	e7e9      	b.n	4801a <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   48046:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   4804a:	e7e6      	b.n	4801a <gpio_nrfx_manage_callback+0x24>

0004804c <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   4804c:	6843      	ldr	r3, [r0, #4]
   4804e:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   48050:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   48054:	05d1      	lsls	r1, r2, #23
   48056:	d518      	bpl.n	4808a <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48058:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   4805c:	b1aa      	cbz	r2, 4808a <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   4805e:	f04f 0120 	mov.w	r1, #32
   48062:	f3ef 8211 	mrs	r2, BASEPRI
   48066:	f381 8812 	msr	BASEPRI_MAX, r1
   4806a:	f3bf 8f6f 	isb	sy
   4806e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   48072:	b131      	cbz	r1, 48082 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48074:	2100      	movs	r1, #0
   48076:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   4807a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4807e:	2101      	movs	r1, #1
   48080:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   48082:	f382 8811 	msr	BASEPRI, r2
   48086:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   4808a:	6842      	ldr	r2, [r0, #4]
   4808c:	6852      	ldr	r2, [r2, #4]
   4808e:	06d2      	lsls	r2, r2, #27
   48090:	d515      	bpl.n	480be <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   48092:	f04f 0120 	mov.w	r1, #32
   48096:	f3ef 8211 	mrs	r2, BASEPRI
   4809a:	f381 8812 	msr	BASEPRI_MAX, r1
   4809e:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   480a2:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   480a6:	b111      	cbz	r1, 480ae <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   480a8:	2100      	movs	r1, #0
   480aa:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   480ae:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   480b2:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   480b6:	f382 8811 	msr	BASEPRI, r2
   480ba:	f3bf 8f6f 	isb	sy
}
   480be:	4770      	bx	lr

000480c0 <uarte_nrfx_config_get>:
{
   480c0:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   480c2:	6902      	ldr	r2, [r0, #16]
   480c4:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   480c8:	e883 0003 	stmia.w	r3, {r0, r1}
}
   480cc:	2000      	movs	r0, #0
   480ce:	4770      	bx	lr

000480d0 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   480d0:	6843      	ldr	r3, [r0, #4]
   480d2:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   480d4:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   480d8:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   480dc:	4770      	bx	lr

000480de <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   480de:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   480e0:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   480e2:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   480e6:	b940      	cbnz	r0, 480fa <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   480e8:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   480ea:	0792      	lsls	r2, r2, #30
   480ec:	d406      	bmi.n	480fc <is_tx_ready+0x1e>
   480ee:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   480f2:	3800      	subs	r0, #0
   480f4:	bf18      	it	ne
   480f6:	2001      	movne	r0, #1
   480f8:	4770      	bx	lr
   480fa:	2001      	movs	r0, #1
}
   480fc:	4770      	bx	lr

000480fe <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   480fe:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   48100:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   48102:	681b      	ldr	r3, [r3, #0]
   48104:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   48108:	b148      	cbz	r0, 4811e <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4810a:	2000      	movs	r0, #0
	*c = data->rx_data;
   4810c:	7c52      	ldrb	r2, [r2, #17]
   4810e:	700a      	strb	r2, [r1, #0]
   48110:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   48114:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48118:	2201      	movs	r2, #1
   4811a:	601a      	str	r2, [r3, #0]
	return 0;
   4811c:	4770      	bx	lr
		return -1;
   4811e:	f04f 30ff 	mov.w	r0, #4294967295
}
   48122:	4770      	bx	lr

00048124 <entropy_cc3xx_rng_get_entropy>:

static int entropy_cc3xx_rng_get_entropy(
	const struct device *dev,
	uint8_t *buffer,
	uint16_t length)
{
   48124:	4608      	mov	r0, r1
   48126:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buffer != NULL);


#if defined(CONFIG_BUILD_WITH_TFM)

	res = psa_generate_random(buffer, length);
   48128:	4611      	mov	r1, r2
   4812a:	f7fe ff83 	bl	47034 <psa_generate_random>
	if (res != PSA_SUCCESS) {
   4812e:	2800      	cmp	r0, #0
		offset += chunk_size;
	}
#endif

	return res;
}
   48130:	bf18      	it	ne
   48132:	f06f 0015 	mvnne.w	r0, #21
   48136:	bd08      	pop	{r3, pc}

00048138 <entropy_cc3xx_rng_init>:

static int entropy_cc3xx_rng_init(const struct device *dev)
{
   48138:	b508      	push	{r3, lr}
	(void)dev;

	#if defined(CONFIG_BUILD_WITH_TFM)
		int ret = -1;

		ret = psa_crypto_init();
   4813a:	f000 fbb0 	bl	4889e <psa_crypto_init>
		if (ret != PSA_SUCCESS) {
   4813e:	2800      	cmp	r0, #0
			return -EINVAL;
		}
	#endif

	return 0;
}
   48140:	bf18      	it	ne
   48142:	f06f 0015 	mvnne.w	r0, #21
   48146:	bd08      	pop	{r3, pc}

00048148 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   48148:	4770      	bx	lr

0004814a <sys_clock_cycle_get_32>:
{
   4814a:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   4814c:	f7fb f990 	bl	43470 <z_nrf_rtc_timer_read>
}
   48150:	bd08      	pop	{r3, pc}

00048152 <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   48152:	f000 bb4d 	b.w	487f0 <z_impl_k_busy_wait>

00048156 <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   48156:	f000 b9ee 	b.w	48536 <k_is_in_isr>

0004815a <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   4815a:	f7fe b9a5 	b.w	464a8 <z_impl_k_sem_give>

0004815e <nrf_modem_os_sem_take>:
{
   4815e:	b508      	push	{r3, lr}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   48160:	1c4b      	adds	r3, r1, #1
   48162:	bf13      	iteet	ne
   48164:	ea21 72e1 	bicne.w	r2, r1, r1, asr #31
   48168:	f04f 32ff 	moveq.w	r2, #4294967295
   4816c:	f04f 33ff 	moveq.w	r3, #4294967295
   48170:	17d3      	asrne	r3, r2, #31
	return z_impl_k_sem_take(sem, timeout);
   48172:	f7fe f9b9 	bl	464e8 <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   48176:	f110 0f0b 	cmn.w	r0, #11
}
   4817a:	bf0c      	ite	eq
   4817c:	2074      	moveq	r0, #116	; 0x74
   4817e:	2000      	movne	r0, #0
   48180:	bd08      	pop	{r3, pc}

00048182 <read_task_create>:
{
   48182:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   48184:	201c      	movs	r0, #28
   48186:	2200      	movs	r2, #0
   48188:	2106      	movs	r1, #6
   4818a:	f7f9 fe5d 	bl	41e48 <z_arm_irq_priority_set>
}
   4818e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   48192:	201c      	movs	r0, #28
   48194:	f7f9 be3a 	b.w	41e0c <arch_irq_enable>

00048198 <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   48198:	2000      	movs	r0, #0
   4819a:	4770      	bx	lr

0004819c <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   4819c:	2000      	movs	r0, #0
   4819e:	4770      	bx	lr

000481a0 <sys_arch_reboot>:
#if defined(CONFIG_TFM_PARTITION_PLATFORM)
void sys_arch_reboot(int type)
{
	ARG_UNUSED(type);

	(void)tfm_platform_system_reset();
   481a0:	f7fe bf3a 	b.w	47018 <tfm_platform_system_reset>

000481a4 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   481a4:	4700      	bx	r0

000481a6 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   481a6:	f000 bb23 	b.w	487f0 <z_impl_k_busy_wait>

000481aa <nrfx_clock_enable>:
{
   481aa:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   481ac:	2005      	movs	r0, #5
   481ae:	f7f9 fe3d 	bl	41e2c <arch_irq_is_enabled>
   481b2:	b920      	cbnz	r0, 481be <nrfx_clock_enable+0x14>
}
   481b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   481b8:	2005      	movs	r0, #5
   481ba:	f7f9 be27 	b.w	41e0c <arch_irq_enable>
   481be:	bd08      	pop	{r3, pc}

000481c0 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   481c0:	f7fc b9ac 	b.w	4451c <_DoInit>

000481c4 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   481c4:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   481c6:	f7ff fffb 	bl	481c0 <SEGGER_RTT_Init>

	return 0;
}
   481ca:	2000      	movs	r0, #0
   481cc:	bd08      	pop	{r3, pc}

000481ce <rpc_handle_ctrl_message>:
   481ce:	2902      	cmp	r1, #2
   481d0:	b510      	push	{r4, lr}
   481d2:	4604      	mov	r4, r0
   481d4:	d005      	beq.n	481e2 <rpc_handle_ctrl_message+0x14>
   481d6:	2904      	cmp	r1, #4
   481d8:	d001      	beq.n	481de <rpc_handle_ctrl_message+0x10>
   481da:	2901      	cmp	r1, #1
   481dc:	d107      	bne.n	481ee <rpc_handle_ctrl_message+0x20>
   481de:	2000      	movs	r0, #0
   481e0:	bd10      	pop	{r4, pc}
   481e2:	6880      	ldr	r0, [r0, #8]
   481e4:	2800      	cmp	r0, #0
   481e6:	d0fa      	beq.n	481de <rpc_handle_ctrl_message+0x10>
   481e8:	f000 f831 	bl	4824e <rpc_transport_local_data_free>
   481ec:	e7f7      	b.n	481de <rpc_handle_ctrl_message+0x10>
   481ee:	6880      	ldr	r0, [r0, #8]
   481f0:	b108      	cbz	r0, 481f6 <rpc_handle_ctrl_message+0x28>
   481f2:	f000 f82c 	bl	4824e <rpc_transport_local_data_free>
   481f6:	4620      	mov	r0, r4
   481f8:	f000 f825 	bl	48246 <rpc_transport_msg_free>
   481fc:	e7ef      	b.n	481de <rpc_handle_ctrl_message+0x10>

000481fe <rpc_message_send>:
   481fe:	6843      	ldr	r3, [r0, #4]
   48200:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   48204:	f043 0302 	orr.w	r3, r3, #2
   48208:	6043      	str	r3, [r0, #4]
   4820a:	f000 b824 	b.w	48256 <rpc_transport_data_msg_send>

0004820e <rpc_message_alloc>:
   4820e:	b570      	push	{r4, r5, r6, lr}
   48210:	4606      	mov	r6, r0
   48212:	b130      	cbz	r0, 48222 <rpc_message_alloc+0x14>
   48214:	f000 f819 	bl	4824a <rpc_transport_data_alloc>
   48218:	4605      	mov	r5, r0
   4821a:	b918      	cbnz	r0, 48224 <rpc_message_alloc+0x16>
   4821c:	2400      	movs	r4, #0
   4821e:	4620      	mov	r0, r4
   48220:	bd70      	pop	{r4, r5, r6, pc}
   48222:	4605      	mov	r5, r0
   48224:	f000 f80d 	bl	48242 <rpc_transport_data_msg_alloc>
   48228:	4604      	mov	r4, r0
   4822a:	b110      	cbz	r0, 48232 <rpc_message_alloc+0x24>
   4822c:	60c6      	str	r6, [r0, #12]
   4822e:	6085      	str	r5, [r0, #8]
   48230:	e7f5      	b.n	4821e <rpc_message_alloc+0x10>
   48232:	2d00      	cmp	r5, #0
   48234:	d0f2      	beq.n	4821c <rpc_message_alloc+0xe>
   48236:	4628      	mov	r0, r5
   48238:	f000 f809 	bl	4824e <rpc_transport_local_data_free>
   4823c:	e7ef      	b.n	4821e <rpc_message_alloc+0x10>

0004823e <rpc_message_data_free>:
   4823e:	f000 b808 	b.w	48252 <rpc_transport_peer_data_free>

00048242 <rpc_transport_data_msg_alloc>:
   48242:	f7fc bc53 	b.w	44aec <rpc_transport_ipc_data_msg_alloc>

00048246 <rpc_transport_msg_free>:
   48246:	f7fc bc9d 	b.w	44b84 <rpc_transport_ipc_msg_free>

0004824a <rpc_transport_data_alloc>:
   4824a:	f7fc bc81 	b.w	44b50 <rpc_transport_ipc_data_alloc>

0004824e <rpc_transport_local_data_free>:
   4824e:	f000 b804 	b.w	4825a <rpc_transport_ipc_local_data_free>

00048252 <rpc_transport_peer_data_free>:
   48252:	f000 b809 	b.w	48268 <rpc_transport_ipc_peer_data_free>

00048256 <rpc_transport_data_msg_send>:
   48256:	f7fc bc0d 	b.w	44a74 <rpc_transport_ipc_data_msg_send>

0004825a <rpc_transport_ipc_local_data_free>:
   4825a:	b508      	push	{r3, lr}
   4825c:	f7fb fc38 	bl	43ad0 <nrf_modem_os_shm_tx_free>
   48260:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   48264:	f7fb bbfe 	b.w	43a64 <nrf_modem_os_application_irq_set>

00048268 <rpc_transport_ipc_peer_data_free>:
   48268:	b510      	push	{r4, lr}
   4826a:	4604      	mov	r4, r0
   4826c:	f7fc fc50 	bl	44b10 <rpc_transport_ipc_ctrl_msg_alloc>
   48270:	2101      	movs	r1, #1
   48272:	2200      	movs	r2, #0
   48274:	7001      	strb	r1, [r0, #0]
   48276:	2102      	movs	r1, #2
   48278:	6084      	str	r4, [r0, #8]
   4827a:	7042      	strb	r2, [r0, #1]
   4827c:	7081      	strb	r1, [r0, #2]
   4827e:	70c2      	strb	r2, [r0, #3]
   48280:	f7fc fc16 	bl	44ab0 <rpc_transport_ipc_ctrl_msg_send>
   48284:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   48288:	f7fb bbec 	b.w	43a64 <nrf_modem_os_application_irq_set>

0004828c <rpc_client_request_alloc>:
   4828c:	b508      	push	{r3, lr}
   4828e:	f7ff ffbe 	bl	4820e <rpc_message_alloc>
   48292:	b100      	cbz	r0, 48296 <rpc_client_request_alloc+0xa>
   48294:	3008      	adds	r0, #8
   48296:	bd08      	pop	{r3, pc}

00048298 <rpc_client_request_send>:
   48298:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   4829c:	4610      	mov	r0, r2
   4829e:	f840 1d08 	str.w	r1, [r0, #-8]!
   482a2:	f7ff bfac 	b.w	481fe <rpc_message_send>

000482a6 <rpc_client_data_free>:
   482a6:	f7ff bfca 	b.w	4823e <rpc_message_data_free>

000482aa <ip_interface_request_create>:
   482aa:	b570      	push	{r4, r5, r6, lr}
   482ac:	4606      	mov	r6, r0
   482ae:	4618      	mov	r0, r3
   482b0:	460d      	mov	r5, r1
   482b2:	4614      	mov	r4, r2
   482b4:	f7ff ffea 	bl	4828c <rpc_client_request_alloc>
   482b8:	b148      	cbz	r0, 482ce <ip_interface_request_create+0x24>
   482ba:	2300      	movs	r3, #0
   482bc:	2208      	movs	r2, #8
   482be:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   482c2:	60c4      	str	r4, [r0, #12]
   482c4:	6105      	str	r5, [r0, #16]
   482c6:	7202      	strb	r2, [r0, #8]
   482c8:	7243      	strb	r3, [r0, #9]
   482ca:	7283      	strb	r3, [r0, #10]
   482cc:	72c3      	strb	r3, [r0, #11]
   482ce:	bd70      	pop	{r4, r5, r6, pc}

000482d0 <ip_interface_wait>:
   482d0:	b538      	push	{r3, r4, r5, lr}
   482d2:	4605      	mov	r5, r0
   482d4:	f7fc fddc 	bl	44e90 <interface_socket_wait>
   482d8:	4604      	mov	r4, r0
   482da:	b938      	cbnz	r0, 482ec <ip_interface_wait+0x1c>
   482dc:	4628      	mov	r0, r5
   482de:	f7fc fe51 	bl	44f84 <interface_socket_from_handle_get>
   482e2:	b118      	cbz	r0, 482ec <ip_interface_wait+0x1c>
   482e4:	6844      	ldr	r4, [r0, #4]
   482e6:	b10c      	cbz	r4, 482ec <ip_interface_wait+0x1c>
   482e8:	2300      	movs	r3, #0
   482ea:	6043      	str	r3, [r0, #4]
   482ec:	4620      	mov	r0, r4
   482ee:	bd38      	pop	{r3, r4, r5, pc}

000482f0 <secure_client_socket>:
   482f0:	f04f 33ff 	mov.w	r3, #4294967295
   482f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   482f6:	9301      	str	r3, [sp, #4]
   482f8:	680b      	ldr	r3, [r1, #0]
   482fa:	4606      	mov	r6, r0
   482fc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   48300:	600b      	str	r3, [r1, #0]
   48302:	680b      	ldr	r3, [r1, #0]
   48304:	460c      	mov	r4, r1
   48306:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   4830a:	600b      	str	r3, [r1, #0]
   4830c:	680f      	ldr	r7, [r1, #0]
   4830e:	463a      	mov	r2, r7
   48310:	f7fd f904 	bl	4551c <secure_socket_attach_initiate>
   48314:	4605      	mov	r5, r0
   48316:	b950      	cbnz	r0, 4832e <secure_client_socket+0x3e>
   48318:	220c      	movs	r2, #12
   4831a:	4630      	mov	r0, r6
   4831c:	4611      	mov	r1, r2
   4831e:	ab01      	add	r3, sp, #4
   48320:	f7ff ffd6 	bl	482d0 <ip_interface_wait>
   48324:	4605      	mov	r5, r0
   48326:	b128      	cbz	r0, 48334 <secure_client_socket+0x44>
   48328:	2877      	cmp	r0, #119	; 0x77
   4832a:	d000      	beq.n	4832e <secure_client_socket+0x3e>
   4832c:	6027      	str	r7, [r4, #0]
   4832e:	4628      	mov	r0, r5
   48330:	b003      	add	sp, #12
   48332:	bdf0      	pop	{r4, r5, r6, r7, pc}
   48334:	4630      	mov	r0, r6
   48336:	f7fd f8df 	bl	454f8 <hostname_free>
   4833a:	6823      	ldr	r3, [r4, #0]
   4833c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   48340:	6023      	str	r3, [r4, #0]
   48342:	6823      	ldr	r3, [r4, #0]
   48344:	0c1b      	lsrs	r3, r3, #16
   48346:	041b      	lsls	r3, r3, #16
   48348:	f043 030c 	orr.w	r3, r3, #12
   4834c:	6023      	str	r3, [r4, #0]
   4834e:	6823      	ldr	r3, [r4, #0]
   48350:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   48354:	6023      	str	r3, [r4, #0]
   48356:	6823      	ldr	r3, [r4, #0]
   48358:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   4835c:	6023      	str	r3, [r4, #0]
   4835e:	e7e6      	b.n	4832e <secure_client_socket+0x3e>

00048360 <nrf_modem_recoverable_error_handler>:
   48360:	4770      	bx	lr

00048362 <nrf_modem_platform_error_handler>:
   48362:	b508      	push	{r3, lr}
   48364:	f7ff fffc 	bl	48360 <nrf_modem_recoverable_error_handler>
   48368:	bd08      	pop	{r3, pc}

0004836a <rpc_transport_ipc_fault_handler>:
   4836a:	f7ff bffa 	b.w	48362 <nrf_modem_platform_error_handler>

0004836e <nrf_modem_platform_init>:
   4836e:	b513      	push	{r0, r1, r4, lr}
   48370:	4604      	mov	r4, r0
   48372:	f7fb fbb3 	bl	43adc <nrf_modem_os_init>
   48376:	6a23      	ldr	r3, [r4, #32]
   48378:	4668      	mov	r0, sp
   4837a:	9400      	str	r4, [sp, #0]
   4837c:	f88d 3004 	strb.w	r3, [sp, #4]
   48380:	f7fc fc26 	bl	44bd0 <rpc_transport_ipc_init>
   48384:	4604      	mov	r4, r0
   48386:	b948      	cbnz	r0, 4839c <nrf_modem_platform_init+0x2e>
   48388:	f7fc fd76 	bl	44e78 <interface_init>
   4838c:	f7fd f9ba 	bl	45704 <nrf_modem_at_init>
   48390:	4604      	mov	r4, r0
   48392:	b918      	cbnz	r0, 4839c <nrf_modem_platform_init+0x2e>
   48394:	f7fc fe2e 	bl	44ff4 <ip_interface_init>
   48398:	f7fd f912 	bl	455c0 <tls_interface_init>
   4839c:	4620      	mov	r0, r4
   4839e:	b002      	add	sp, #8
   483a0:	bd10      	pop	{r4, pc}

000483a2 <mbedtls_heap_init>:
{
	mbedtls_memory_buffer_alloc_free();
}

static int mbedtls_heap_init(const struct device *dev)
{
   483a2:	b508      	push	{r3, lr}
	ARG_UNUSED(dev);

	_heap_init();
   483a4:	f7fd fbd6 	bl	45b54 <_heap_init>

	return 0;
}
   483a8:	2000      	movs	r0, #0
   483aa:	bd08      	pop	{r3, pc}

000483ac <z_device_state_init>:
}
   483ac:	4770      	bx	lr

000483ae <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   483ae:	b138      	cbz	r0, 483c0 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   483b0:	68c3      	ldr	r3, [r0, #12]
   483b2:	8818      	ldrh	r0, [r3, #0]
   483b4:	f3c0 0008 	ubfx	r0, r0, #0, #9
   483b8:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   483bc:	4258      	negs	r0, r3
   483be:	4158      	adcs	r0, r3
}
   483c0:	4770      	bx	lr

000483c2 <k_heap_init>:
{
   483c2:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   483c4:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   483c8:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   483cc:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   483ce:	f7ff b94e 	b.w	4766e <sys_heap_init>

000483d2 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   483d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   483d6:	b087      	sub	sp, #28
   483d8:	4604      	mov	r4, r0
   483da:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   483dc:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   483e0:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   483e2:	f000 fa09 	bl	487f8 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   483e6:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   483ea:	4605      	mov	r5, r0
   483ec:	4688      	mov	r8, r1
	__asm__ volatile(
   483ee:	f04f 0320 	mov.w	r3, #32
   483f2:	f3ef 8b11 	mrs	fp, BASEPRI
   483f6:	f383 8812 	msr	BASEPRI_MAX, r3
   483fa:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   483fe:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   48402:	463a      	mov	r2, r7
   48404:	4631      	mov	r1, r6
   48406:	4620      	mov	r0, r4
   48408:	f7ff f8c9 	bl	4759e <sys_heap_aligned_alloc>
   4840c:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   4840e:	f7fe fd39 	bl	46e84 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   48412:	9b05      	ldr	r3, [sp, #20]
   48414:	b13b      	cbz	r3, 48426 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   48416:	f38b 8811 	msr	BASEPRI, fp
   4841a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   4841e:	4618      	mov	r0, r3
   48420:	b007      	add	sp, #28
   48422:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   48426:	1a2a      	subs	r2, r5, r0
   48428:	9202      	str	r2, [sp, #8]
   4842a:	eb68 0201 	sbc.w	r2, r8, r1
   4842e:	9203      	str	r2, [sp, #12]
   48430:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   48434:	2901      	cmp	r1, #1
   48436:	f172 0200 	sbcs.w	r2, r2, #0
   4843a:	dbec      	blt.n	48416 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   4843c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   48440:	4659      	mov	r1, fp
   48442:	e9cd 2300 	strd	r2, r3, [sp]
   48446:	4648      	mov	r0, r9
   48448:	4652      	mov	r2, sl
   4844a:	f7fe fa0b 	bl	46864 <z_pend_curr>
	__asm__ volatile(
   4844e:	f04f 0320 	mov.w	r3, #32
   48452:	f3ef 8b11 	mrs	fp, BASEPRI
   48456:	f383 8812 	msr	BASEPRI_MAX, r3
   4845a:	f3bf 8f6f 	isb	sy
   4845e:	e7d0      	b.n	48402 <k_heap_aligned_alloc+0x30>

00048460 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   48460:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   48462:	e9cd 2300 	strd	r2, r3, [sp]
   48466:	460a      	mov	r2, r1
   48468:	2104      	movs	r1, #4
   4846a:	f7ff ffb2 	bl	483d2 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   4846e:	b003      	add	sp, #12
   48470:	f85d fb04 	ldr.w	pc, [sp], #4

00048474 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   48474:	b538      	push	{r3, r4, r5, lr}
   48476:	4604      	mov	r4, r0
   48478:	f04f 0320 	mov.w	r3, #32
   4847c:	f3ef 8511 	mrs	r5, BASEPRI
   48480:	f383 8812 	msr	BASEPRI_MAX, r3
   48484:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   48488:	f7ff f850 	bl	4752c <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   4848c:	f104 000c 	add.w	r0, r4, #12
   48490:	f000 f958 	bl	48744 <z_unpend_all>
   48494:	b130      	cbz	r0, 484a4 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   48496:	4629      	mov	r1, r5
   48498:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   4849c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   484a0:	f7fe b886 	b.w	465b0 <z_reschedule>
	__asm__ volatile(
   484a4:	f385 8811 	msr	BASEPRI, r5
   484a8:	f3bf 8f6f 	isb	sy
}
   484ac:	bd38      	pop	{r3, r4, r5, pc}

000484ae <k_mem_slab_init>:
{
   484ae:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   484b0:	2400      	movs	r4, #0
   484b2:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   484b4:	ea41 0402 	orr.w	r4, r1, r2
   484b8:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   484bc:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   484c0:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   484c2:	d10c      	bne.n	484de <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   484c4:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   484c6:	42a3      	cmp	r3, r4
   484c8:	d103      	bne.n	484d2 <k_mem_slab_init+0x24>
   484ca:	e9c0 0000 	strd	r0, r0, [r0]
}
   484ce:	2000      	movs	r0, #0
}
   484d0:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   484d2:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   484d4:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   484d6:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   484d8:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   484da:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   484dc:	e7f3      	b.n	484c6 <k_mem_slab_init+0x18>
		return -EINVAL;
   484de:	f06f 0015 	mvn.w	r0, #21
	return rc;
   484e2:	e7f5      	b.n	484d0 <k_mem_slab_init+0x22>

000484e4 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   484e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   484e6:	4604      	mov	r4, r0
   484e8:	460d      	mov	r5, r1
	__asm__ volatile(
   484ea:	f04f 0320 	mov.w	r3, #32
   484ee:	f3ef 8611 	mrs	r6, BASEPRI
   484f2:	f383 8812 	msr	BASEPRI_MAX, r3
   484f6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   484fa:	6947      	ldr	r7, [r0, #20]
   484fc:	b977      	cbnz	r7, 4851c <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   484fe:	f000 f909 	bl	48714 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   48502:	b158      	cbz	r0, 4851c <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   48504:	682a      	ldr	r2, [r5, #0]
   48506:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   48508:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   4850a:	f000 f88f 	bl	4862c <z_ready_thread>
			z_reschedule(&slab->lock, key);
   4850e:	4631      	mov	r1, r6
   48510:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   48514:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   48518:	f7fe b84a 	b.w	465b0 <z_reschedule>
	**(char ***) mem = slab->free_list;
   4851c:	682b      	ldr	r3, [r5, #0]
   4851e:	6962      	ldr	r2, [r4, #20]
   48520:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   48522:	682b      	ldr	r3, [r5, #0]
   48524:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   48526:	69a3      	ldr	r3, [r4, #24]
   48528:	3b01      	subs	r3, #1
   4852a:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   4852c:	f386 8811 	msr	BASEPRI, r6
   48530:	f3bf 8f6f 	isb	sy
}
   48534:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00048536 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   48536:	f3ef 8005 	mrs	r0, IPSR
}
   4853a:	3800      	subs	r0, #0
   4853c:	bf18      	it	ne
   4853e:	2001      	movne	r0, #1
   48540:	4770      	bx	lr

00048542 <z_impl_k_thread_name_set>:
}
   48542:	f06f 0057 	mvn.w	r0, #87	; 0x57
   48546:	4770      	bx	lr

00048548 <k_thread_name_get>:
}
   48548:	2000      	movs	r0, #0
   4854a:	4770      	bx	lr

0004854c <z_pm_save_idle_exit>:
{
   4854c:	b508      	push	{r3, lr}
	pm_system_resume();
   4854e:	f7f9 fb47 	bl	41be0 <pm_system_resume>
}
   48552:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   48556:	f7ff bdf7 	b.w	48148 <sys_clock_idle_exit>

0004855a <z_impl_k_mutex_init>:
{
   4855a:	4603      	mov	r3, r0
	mutex->owner = NULL;
   4855c:	2000      	movs	r0, #0
   4855e:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   48562:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   48566:	4770      	bx	lr

00048568 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   48568:	b13a      	cbz	r2, 4857a <z_impl_k_sem_init+0x12>
   4856a:	428a      	cmp	r2, r1
   4856c:	d305      	bcc.n	4857a <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   4856e:	e9c0 1202 	strd	r1, r2, [r0, #8]
   48572:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   48576:	2000      	movs	r0, #0
   48578:	4770      	bx	lr
		return -EINVAL;
   4857a:	f06f 0015 	mvn.w	r0, #21
}
   4857e:	4770      	bx	lr

00048580 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   48580:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   48584:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   48586:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   48588:	2300      	movs	r3, #0
	node->prev = NULL;
   4858a:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   4858e:	4770      	bx	lr

00048590 <unpend_thread_no_timeout>:
{
   48590:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   48592:	f7ff fff5 	bl	48580 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   48596:	7b43      	ldrb	r3, [r0, #13]
   48598:	f023 0302 	bic.w	r3, r3, #2
   4859c:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   4859e:	2300      	movs	r3, #0
   485a0:	6083      	str	r3, [r0, #8]
}
   485a2:	bd08      	pop	{r3, pc}

000485a4 <z_unpend_thread_no_timeout>:
{
   485a4:	b508      	push	{r3, lr}
	__asm__ volatile(
   485a6:	f04f 0320 	mov.w	r3, #32
   485aa:	f3ef 8111 	mrs	r1, BASEPRI
   485ae:	f383 8812 	msr	BASEPRI_MAX, r3
   485b2:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   485b6:	f7ff ffeb 	bl	48590 <unpend_thread_no_timeout>
	__asm__ volatile(
   485ba:	f381 8811 	msr	BASEPRI, r1
   485be:	f3bf 8f6f 	isb	sy
}
   485c2:	bd08      	pop	{r3, pc}

000485c4 <z_unpend_thread>:
{
   485c4:	b510      	push	{r4, lr}
	__asm__ volatile(
   485c6:	f04f 0320 	mov.w	r3, #32
   485ca:	f3ef 8411 	mrs	r4, BASEPRI
   485ce:	f383 8812 	msr	BASEPRI_MAX, r3
   485d2:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   485d6:	f7ff ffdb 	bl	48590 <unpend_thread_no_timeout>
	__asm__ volatile(
   485da:	f384 8811 	msr	BASEPRI, r4
   485de:	f3bf 8f6f 	isb	sy
}
   485e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   485e6:	3018      	adds	r0, #24
   485e8:	f000 b8bc 	b.w	48764 <z_abort_timeout>

000485ec <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   485ec:	4603      	mov	r3, r0
   485ee:	b920      	cbnz	r0, 485fa <z_reschedule_irqlock+0xe>
   485f0:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   485f4:	b90a      	cbnz	r2, 485fa <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   485f6:	f7f9 bc6b 	b.w	41ed0 <arch_swap>
   485fa:	f383 8811 	msr	BASEPRI, r3
   485fe:	f3bf 8f6f 	isb	sy
}
   48602:	4770      	bx	lr

00048604 <z_reschedule_unlocked>:
	__asm__ volatile(
   48604:	f04f 0320 	mov.w	r3, #32
   48608:	f3ef 8011 	mrs	r0, BASEPRI
   4860c:	f383 8812 	msr	BASEPRI_MAX, r3
   48610:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   48614:	f7ff bfea 	b.w	485ec <z_reschedule_irqlock>

00048618 <z_priq_dumb_best>:
{
   48618:	4603      	mov	r3, r0
	return list->head == list;
   4861a:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4861c:	4283      	cmp	r3, r0
   4861e:	d003      	beq.n	48628 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   48620:	2800      	cmp	r0, #0
   48622:	bf38      	it	cc
   48624:	2000      	movcc	r0, #0
   48626:	4770      	bx	lr
	struct k_thread *thread = NULL;
   48628:	2000      	movs	r0, #0
}
   4862a:	4770      	bx	lr

0004862c <z_ready_thread>:
{
   4862c:	b510      	push	{r4, lr}
   4862e:	f04f 0320 	mov.w	r3, #32
   48632:	f3ef 8411 	mrs	r4, BASEPRI
   48636:	f383 8812 	msr	BASEPRI_MAX, r3
   4863a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   4863e:	f7fe f87d 	bl	4673c <ready_thread>
	__asm__ volatile(
   48642:	f384 8811 	msr	BASEPRI, r4
   48646:	f3bf 8f6f 	isb	sy
}
   4864a:	bd10      	pop	{r4, pc}

0004864c <z_thread_timeout>:
{
   4864c:	4601      	mov	r1, r0
   4864e:	b510      	push	{r4, lr}
	__asm__ volatile(
   48650:	f04f 0320 	mov.w	r3, #32
   48654:	f3ef 8411 	mrs	r4, BASEPRI
   48658:	f383 8812 	msr	BASEPRI_MAX, r3
   4865c:	f3bf 8f6f 	isb	sy
		if (!killed) {
   48660:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   48664:	f013 0f28 	tst.w	r3, #40	; 0x28
   48668:	d10d      	bne.n	48686 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   4866a:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   4866e:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   48670:	b10b      	cbz	r3, 48676 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   48672:	f7ff ff8d 	bl	48590 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   48676:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   4867a:	f023 0314 	bic.w	r3, r3, #20
   4867e:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   48682:	f7fe f85b 	bl	4673c <ready_thread>
	__asm__ volatile(
   48686:	f384 8811 	msr	BASEPRI, r4
   4868a:	f3bf 8f6f 	isb	sy
}
   4868e:	bd10      	pop	{r4, pc}

00048690 <add_to_waitq_locked>:
{
   48690:	b538      	push	{r3, r4, r5, lr}
   48692:	4604      	mov	r4, r0
   48694:	460d      	mov	r5, r1
	unready_thread(thread);
   48696:	f7fe f8a7 	bl	467e8 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   4869a:	7b63      	ldrb	r3, [r4, #13]
   4869c:	f043 0302 	orr.w	r3, r3, #2
   486a0:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   486a2:	b1b5      	cbz	r5, 486d2 <add_to_waitq_locked+0x42>
	return list->head == list;
   486a4:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   486a6:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   486a8:	429d      	cmp	r5, r3
   486aa:	bf08      	it	eq
   486ac:	2300      	moveq	r3, #0
   486ae:	2b00      	cmp	r3, #0
   486b0:	bf38      	it	cc
   486b2:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   486b4:	b19b      	cbz	r3, 486de <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   486b6:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   486ba:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   486be:	4291      	cmp	r1, r2
   486c0:	d008      	beq.n	486d4 <add_to_waitq_locked+0x44>
		return b2 - b1;
   486c2:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   486c4:	2a00      	cmp	r2, #0
   486c6:	dd05      	ble.n	486d4 <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   486c8:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   486ca:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   486ce:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   486d0:	605c      	str	r4, [r3, #4]
}
   486d2:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   486d4:	686a      	ldr	r2, [r5, #4]
   486d6:	4293      	cmp	r3, r2
   486d8:	d001      	beq.n	486de <add_to_waitq_locked+0x4e>
   486da:	681b      	ldr	r3, [r3, #0]
   486dc:	e7ea      	b.n	486b4 <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   486de:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   486e0:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   486e4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   486e6:	606c      	str	r4, [r5, #4]
   486e8:	e7f3      	b.n	486d2 <add_to_waitq_locked+0x42>

000486ea <z_unpend1_no_timeout>:
{
   486ea:	b510      	push	{r4, lr}
	__asm__ volatile(
   486ec:	f04f 0320 	mov.w	r3, #32
   486f0:	f3ef 8411 	mrs	r4, BASEPRI
   486f4:	f383 8812 	msr	BASEPRI_MAX, r3
   486f8:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   486fc:	f7ff ff8c 	bl	48618 <z_priq_dumb_best>
		if (thread != NULL) {
   48700:	4601      	mov	r1, r0
   48702:	b108      	cbz	r0, 48708 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   48704:	f7ff ff44 	bl	48590 <unpend_thread_no_timeout>
	__asm__ volatile(
   48708:	f384 8811 	msr	BASEPRI, r4
   4870c:	f3bf 8f6f 	isb	sy
}
   48710:	4608      	mov	r0, r1
   48712:	bd10      	pop	{r4, pc}

00048714 <z_unpend_first_thread>:
{
   48714:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   48716:	f04f 0320 	mov.w	r3, #32
   4871a:	f3ef 8511 	mrs	r5, BASEPRI
   4871e:	f383 8812 	msr	BASEPRI_MAX, r3
   48722:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48726:	f7ff ff77 	bl	48618 <z_priq_dumb_best>
		if (thread != NULL) {
   4872a:	4604      	mov	r4, r0
   4872c:	b120      	cbz	r0, 48738 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   4872e:	f7ff ff2f 	bl	48590 <unpend_thread_no_timeout>
   48732:	3018      	adds	r0, #24
   48734:	f000 f816 	bl	48764 <z_abort_timeout>
	__asm__ volatile(
   48738:	f385 8811 	msr	BASEPRI, r5
   4873c:	f3bf 8f6f 	isb	sy
}
   48740:	4620      	mov	r0, r4
   48742:	bd38      	pop	{r3, r4, r5, pc}

00048744 <z_unpend_all>:
{
   48744:	b538      	push	{r3, r4, r5, lr}
   48746:	4605      	mov	r5, r0
	int need_sched = 0;
   48748:	2000      	movs	r0, #0
	return list->head == list;
   4874a:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4874c:	42a5      	cmp	r5, r4
   4874e:	d000      	beq.n	48752 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   48750:	b904      	cbnz	r4, 48754 <z_unpend_all+0x10>
}
   48752:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   48754:	4620      	mov	r0, r4
   48756:	f7ff ff35 	bl	485c4 <z_unpend_thread>
		z_ready_thread(thread);
   4875a:	4620      	mov	r0, r4
   4875c:	f7ff ff66 	bl	4862c <z_ready_thread>
		need_sched = 1;
   48760:	2001      	movs	r0, #1
   48762:	e7f2      	b.n	4874a <z_unpend_all+0x6>

00048764 <z_abort_timeout>:
{
   48764:	b510      	push	{r4, lr}
	__asm__ volatile(
   48766:	f04f 0220 	mov.w	r2, #32
   4876a:	f3ef 8411 	mrs	r4, BASEPRI
   4876e:	f382 8812 	msr	BASEPRI_MAX, r2
   48772:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   48776:	6803      	ldr	r3, [r0, #0]
   48778:	b13b      	cbz	r3, 4878a <z_abort_timeout+0x26>
			remove_timeout(to);
   4877a:	f7fe fa4b 	bl	46c14 <remove_timeout>
			ret = 0;
   4877e:	2000      	movs	r0, #0
	__asm__ volatile(
   48780:	f384 8811 	msr	BASEPRI, r4
   48784:	f3bf 8f6f 	isb	sy
}
   48788:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   4878a:	f06f 0015 	mvn.w	r0, #21
   4878e:	e7f7      	b.n	48780 <z_abort_timeout+0x1c>

00048790 <z_get_next_timeout_expiry>:
{
   48790:	b510      	push	{r4, lr}
	__asm__ volatile(
   48792:	f04f 0320 	mov.w	r3, #32
   48796:	f3ef 8411 	mrs	r4, BASEPRI
   4879a:	f383 8812 	msr	BASEPRI_MAX, r3
   4879e:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   487a2:	f7fe fa51 	bl	46c48 <next_timeout>
	__asm__ volatile(
   487a6:	f384 8811 	msr	BASEPRI, r4
   487aa:	f3bf 8f6f 	isb	sy
}
   487ae:	bd10      	pop	{r4, pc}

000487b0 <z_set_timeout_expiry>:
{
   487b0:	b570      	push	{r4, r5, r6, lr}
   487b2:	4604      	mov	r4, r0
   487b4:	460d      	mov	r5, r1
	__asm__ volatile(
   487b6:	f04f 0320 	mov.w	r3, #32
   487ba:	f3ef 8611 	mrs	r6, BASEPRI
   487be:	f383 8812 	msr	BASEPRI_MAX, r3
   487c2:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   487c6:	f7fe fa3f 	bl	46c48 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   487ca:	2801      	cmp	r0, #1
   487cc:	dd05      	ble.n	487da <z_set_timeout_expiry+0x2a>
   487ce:	42a0      	cmp	r0, r4
   487d0:	db03      	blt.n	487da <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   487d2:	4629      	mov	r1, r5
   487d4:	4620      	mov	r0, r4
   487d6:	f7fa ffc3 	bl	43760 <sys_clock_set_timeout>
	__asm__ volatile(
   487da:	f386 8811 	msr	BASEPRI, r6
   487de:	f3bf 8f6f 	isb	sy
}
   487e2:	bd70      	pop	{r4, r5, r6, pc}

000487e4 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   487e4:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   487e6:	f7fe fb4d 	bl	46e84 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   487ea:	bd08      	pop	{r3, pc}

000487ec <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   487ec:	f7fe bb4a 	b.w	46e84 <sys_clock_tick_get>

000487f0 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   487f0:	b108      	cbz	r0, 487f6 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   487f2:	f7f8 bbcf 	b.w	40f94 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   487f6:	4770      	bx	lr

000487f8 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   487f8:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   487fa:	1c4b      	adds	r3, r1, #1
   487fc:	bf08      	it	eq
   487fe:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   48802:	4604      	mov	r4, r0
   48804:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48806:	d013      	beq.n	48830 <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   48808:	ea54 0105 	orrs.w	r1, r4, r5
   4880c:	d103      	bne.n	48816 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   4880e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   48812:	f7fe bb37 	b.w	46e84 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   48816:	f06f 0101 	mvn.w	r1, #1
   4881a:	1a0a      	subs	r2, r1, r0
   4881c:	f04f 31ff 	mov.w	r1, #4294967295
   48820:	eb61 0305 	sbc.w	r3, r1, r5
   48824:	2a00      	cmp	r2, #0
   48826:	f173 0100 	sbcs.w	r1, r3, #0
   4882a:	db02      	blt.n	48832 <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   4882c:	4610      	mov	r0, r2
   4882e:	4619      	mov	r1, r3
}
   48830:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   48832:	f7fe fb27 	bl	46e84 <sys_clock_tick_get>
   48836:	2c01      	cmp	r4, #1
   48838:	f175 0300 	sbcs.w	r3, r5, #0
   4883c:	bfbc      	itt	lt
   4883e:	2401      	movlt	r4, #1
   48840:	2500      	movlt	r5, #0
   48842:	1820      	adds	r0, r4, r0
   48844:	eb45 0101 	adc.w	r1, r5, r1
   48848:	e7f2      	b.n	48830 <sys_clock_timeout_end_calc+0x38>

0004884a <k_timer_init>:
	timer->status = 0U;
   4884a:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   4884c:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
   48850:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   48854:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   48858:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   4885c:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   4885e:	6343      	str	r3, [r0, #52]	; 0x34
}
   48860:	4770      	bx	lr

00048862 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   48862:	b510      	push	{r4, lr}
   48864:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   48866:	f7ff ff7d 	bl	48764 <z_abort_timeout>

	if (inactive) {
   4886a:	b9b0      	cbnz	r0, 4889a <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   4886c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4886e:	b10b      	cbz	r3, 48874 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   48870:	4620      	mov	r0, r4
   48872:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   48874:	f104 0018 	add.w	r0, r4, #24
   48878:	f7ff ff37 	bl	486ea <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   4887c:	b168      	cbz	r0, 4889a <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   4887e:	f7ff fed5 	bl	4862c <z_ready_thread>
	__asm__ volatile(
   48882:	f04f 0320 	mov.w	r3, #32
   48886:	f3ef 8011 	mrs	r0, BASEPRI
   4888a:	f383 8812 	msr	BASEPRI_MAX, r3
   4888e:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   48892:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   48896:	f7ff bea9 	b.w	485ec <z_reschedule_irqlock>
   4889a:	bd10      	pop	{r4, pc}

0004889c <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   4889c:	4770      	bx	lr

0004889e <psa_crypto_init>:
}
   4889e:	2000      	movs	r0, #0
   488a0:	4770      	bx	lr
	...

000488a4 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   488a4:	f7fb b980 	b.w	43ba8 <SystemInit>
