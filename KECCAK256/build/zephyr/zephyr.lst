
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00040000 <_vector_start>:
   40000:	200231a0 	.word	0x200231a0
   40004:	00042639 	.word	0x00042639
   40008:	00047f03 	.word	0x00047f03
   4000c:	0004260d 	.word	0x0004260d
   40010:	0004260d 	.word	0x0004260d
   40014:	0004260d 	.word	0x0004260d
   40018:	0004260d 	.word	0x0004260d
   4001c:	0004260d 	.word	0x0004260d
	...
   4002c:	000420b5 	.word	0x000420b5
   40030:	0004260d 	.word	0x0004260d
   40034:	00000000 	.word	0x00000000
   40038:	00042055 	.word	0x00042055
   4003c:	0004260d 	.word	0x0004260d

00040040 <_irq_vector_table>:
   40040:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40050:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40060:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40070:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40080:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40090:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   400a0:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   400b0:	000439f5 00042139 00042139 00042139     .9..9!..9!..9!..
   400c0:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   400d0:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   400e0:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   400f0:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40100:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40110:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40120:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40130:	00042139 00042139 00042139 00042139     9!..9!..9!..9!..
   40140:	00042139                                9!..

Disassembly of section text:

00040144 <__aeabi_uldivmod>:
   40144:	b953      	cbnz	r3, 4015c <__aeabi_uldivmod+0x18>
   40146:	b94a      	cbnz	r2, 4015c <__aeabi_uldivmod+0x18>
   40148:	2900      	cmp	r1, #0
   4014a:	bf08      	it	eq
   4014c:	2800      	cmpeq	r0, #0
   4014e:	bf1c      	itt	ne
   40150:	f04f 31ff 	movne.w	r1, #4294967295
   40154:	f04f 30ff 	movne.w	r0, #4294967295
   40158:	f000 b970 	b.w	4043c <__aeabi_idiv0>
   4015c:	f1ad 0c08 	sub.w	ip, sp, #8
   40160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   40164:	f000 f806 	bl	40174 <__udivmoddi4>
   40168:	f8dd e004 	ldr.w	lr, [sp, #4]
   4016c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   40170:	b004      	add	sp, #16
   40172:	4770      	bx	lr

00040174 <__udivmoddi4>:
   40174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   40178:	9e08      	ldr	r6, [sp, #32]
   4017a:	460d      	mov	r5, r1
   4017c:	4604      	mov	r4, r0
   4017e:	468a      	mov	sl, r1
   40180:	2b00      	cmp	r3, #0
   40182:	d17f      	bne.n	40284 <__udivmoddi4+0x110>
   40184:	428a      	cmp	r2, r1
   40186:	4617      	mov	r7, r2
   40188:	d941      	bls.n	4020e <__udivmoddi4+0x9a>
   4018a:	fab2 f282 	clz	r2, r2
   4018e:	b14a      	cbz	r2, 401a4 <__udivmoddi4+0x30>
   40190:	f1c2 0120 	rsb	r1, r2, #32
   40194:	fa05 f302 	lsl.w	r3, r5, r2
   40198:	4097      	lsls	r7, r2
   4019a:	4094      	lsls	r4, r2
   4019c:	fa20 f101 	lsr.w	r1, r0, r1
   401a0:	ea41 0a03 	orr.w	sl, r1, r3
   401a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
   401a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   401ac:	fa1f f987 	uxth.w	r9, r7
   401b0:	fbba fef8 	udiv	lr, sl, r8
   401b4:	fb08 a31e 	mls	r3, r8, lr, sl
   401b8:	fb0e f109 	mul.w	r1, lr, r9
   401bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   401c0:	4299      	cmp	r1, r3
   401c2:	d906      	bls.n	401d2 <__udivmoddi4+0x5e>
   401c4:	18fb      	adds	r3, r7, r3
   401c6:	d202      	bcs.n	401ce <__udivmoddi4+0x5a>
   401c8:	4299      	cmp	r1, r3
   401ca:	f200 8124 	bhi.w	40416 <__udivmoddi4+0x2a2>
   401ce:	f10e 3eff 	add.w	lr, lr, #4294967295
   401d2:	1a59      	subs	r1, r3, r1
   401d4:	b2a3      	uxth	r3, r4
   401d6:	fbb1 f0f8 	udiv	r0, r1, r8
   401da:	fb08 1110 	mls	r1, r8, r0, r1
   401de:	fb00 f909 	mul.w	r9, r0, r9
   401e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   401e6:	45a1      	cmp	r9, r4
   401e8:	d905      	bls.n	401f6 <__udivmoddi4+0x82>
   401ea:	193c      	adds	r4, r7, r4
   401ec:	d202      	bcs.n	401f4 <__udivmoddi4+0x80>
   401ee:	45a1      	cmp	r9, r4
   401f0:	f200 810e 	bhi.w	40410 <__udivmoddi4+0x29c>
   401f4:	3801      	subs	r0, #1
   401f6:	eba4 0409 	sub.w	r4, r4, r9
   401fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   401fe:	2100      	movs	r1, #0
   40200:	b11e      	cbz	r6, 4020a <__udivmoddi4+0x96>
   40202:	40d4      	lsrs	r4, r2
   40204:	2300      	movs	r3, #0
   40206:	e9c6 4300 	strd	r4, r3, [r6]
   4020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4020e:	b902      	cbnz	r2, 40212 <__udivmoddi4+0x9e>
   40210:	deff      	udf	#255	; 0xff
   40212:	fab2 f282 	clz	r2, r2
   40216:	2a00      	cmp	r2, #0
   40218:	d14f      	bne.n	402ba <__udivmoddi4+0x146>
   4021a:	1bcb      	subs	r3, r1, r7
   4021c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   40220:	fa1f f887 	uxth.w	r8, r7
   40224:	2101      	movs	r1, #1
   40226:	0c25      	lsrs	r5, r4, #16
   40228:	fbb3 fcfe 	udiv	ip, r3, lr
   4022c:	fb0e 301c 	mls	r0, lr, ip, r3
   40230:	462b      	mov	r3, r5
   40232:	fb08 f90c 	mul.w	r9, r8, ip
   40236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   4023a:	45a9      	cmp	r9, r5
   4023c:	d90a      	bls.n	40254 <__udivmoddi4+0xe0>
   4023e:	197d      	adds	r5, r7, r5
   40240:	bf2c      	ite	cs
   40242:	2301      	movcs	r3, #1
   40244:	2300      	movcc	r3, #0
   40246:	45a9      	cmp	r9, r5
   40248:	d902      	bls.n	40250 <__udivmoddi4+0xdc>
   4024a:	2b00      	cmp	r3, #0
   4024c:	f000 80d9 	beq.w	40402 <__udivmoddi4+0x28e>
   40250:	f10c 3cff 	add.w	ip, ip, #4294967295
   40254:	eba5 0509 	sub.w	r5, r5, r9
   40258:	b2a3      	uxth	r3, r4
   4025a:	fbb5 f0fe 	udiv	r0, r5, lr
   4025e:	fb0e 5510 	mls	r5, lr, r0, r5
   40262:	fb08 f800 	mul.w	r8, r8, r0
   40266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   4026a:	45a0      	cmp	r8, r4
   4026c:	d905      	bls.n	4027a <__udivmoddi4+0x106>
   4026e:	193c      	adds	r4, r7, r4
   40270:	d202      	bcs.n	40278 <__udivmoddi4+0x104>
   40272:	45a0      	cmp	r8, r4
   40274:	f200 80c9 	bhi.w	4040a <__udivmoddi4+0x296>
   40278:	3801      	subs	r0, #1
   4027a:	eba4 0408 	sub.w	r4, r4, r8
   4027e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   40282:	e7bd      	b.n	40200 <__udivmoddi4+0x8c>
   40284:	428b      	cmp	r3, r1
   40286:	d908      	bls.n	4029a <__udivmoddi4+0x126>
   40288:	2e00      	cmp	r6, #0
   4028a:	f000 80b1 	beq.w	403f0 <__udivmoddi4+0x27c>
   4028e:	2100      	movs	r1, #0
   40290:	e9c6 0500 	strd	r0, r5, [r6]
   40294:	4608      	mov	r0, r1
   40296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4029a:	fab3 f183 	clz	r1, r3
   4029e:	2900      	cmp	r1, #0
   402a0:	d146      	bne.n	40330 <__udivmoddi4+0x1bc>
   402a2:	42ab      	cmp	r3, r5
   402a4:	f0c0 80a7 	bcc.w	403f6 <__udivmoddi4+0x282>
   402a8:	4282      	cmp	r2, r0
   402aa:	f240 80a4 	bls.w	403f6 <__udivmoddi4+0x282>
   402ae:	4608      	mov	r0, r1
   402b0:	2e00      	cmp	r6, #0
   402b2:	d0aa      	beq.n	4020a <__udivmoddi4+0x96>
   402b4:	e9c6 4a00 	strd	r4, sl, [r6]
   402b8:	e7a7      	b.n	4020a <__udivmoddi4+0x96>
   402ba:	f1c2 0020 	rsb	r0, r2, #32
   402be:	4097      	lsls	r7, r2
   402c0:	fa01 f302 	lsl.w	r3, r1, r2
   402c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   402c8:	40c1      	lsrs	r1, r0
   402ca:	fa24 f500 	lsr.w	r5, r4, r0
   402ce:	fa1f f887 	uxth.w	r8, r7
   402d2:	4094      	lsls	r4, r2
   402d4:	431d      	orrs	r5, r3
   402d6:	fbb1 f0fe 	udiv	r0, r1, lr
   402da:	0c2b      	lsrs	r3, r5, #16
   402dc:	fb0e 1110 	mls	r1, lr, r0, r1
   402e0:	fb00 fc08 	mul.w	ip, r0, r8
   402e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   402e8:	459c      	cmp	ip, r3
   402ea:	d909      	bls.n	40300 <__udivmoddi4+0x18c>
   402ec:	18fb      	adds	r3, r7, r3
   402ee:	bf2c      	ite	cs
   402f0:	2101      	movcs	r1, #1
   402f2:	2100      	movcc	r1, #0
   402f4:	459c      	cmp	ip, r3
   402f6:	d902      	bls.n	402fe <__udivmoddi4+0x18a>
   402f8:	2900      	cmp	r1, #0
   402fa:	f000 8095 	beq.w	40428 <__udivmoddi4+0x2b4>
   402fe:	3801      	subs	r0, #1
   40300:	eba3 030c 	sub.w	r3, r3, ip
   40304:	b2ad      	uxth	r5, r5
   40306:	fbb3 f1fe 	udiv	r1, r3, lr
   4030a:	fb0e 3311 	mls	r3, lr, r1, r3
   4030e:	fb01 fc08 	mul.w	ip, r1, r8
   40312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   40316:	45ac      	cmp	ip, r5
   40318:	d905      	bls.n	40326 <__udivmoddi4+0x1b2>
   4031a:	197d      	adds	r5, r7, r5
   4031c:	d202      	bcs.n	40324 <__udivmoddi4+0x1b0>
   4031e:	45ac      	cmp	ip, r5
   40320:	f200 8089 	bhi.w	40436 <__udivmoddi4+0x2c2>
   40324:	3901      	subs	r1, #1
   40326:	eba5 030c 	sub.w	r3, r5, ip
   4032a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   4032e:	e77a      	b.n	40226 <__udivmoddi4+0xb2>
   40330:	f1c1 0420 	rsb	r4, r1, #32
   40334:	408b      	lsls	r3, r1
   40336:	fa02 f701 	lsl.w	r7, r2, r1
   4033a:	fa05 fc01 	lsl.w	ip, r5, r1
   4033e:	40e2      	lsrs	r2, r4
   40340:	fa20 f804 	lsr.w	r8, r0, r4
   40344:	40e5      	lsrs	r5, r4
   40346:	fa00 fe01 	lsl.w	lr, r0, r1
   4034a:	4313      	orrs	r3, r2
   4034c:	ea48 020c 	orr.w	r2, r8, ip
   40350:	ea4f 4813 	mov.w	r8, r3, lsr #16
   40354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   40358:	fa1f f983 	uxth.w	r9, r3
   4035c:	fbb5 faf8 	udiv	sl, r5, r8
   40360:	fb08 551a 	mls	r5, r8, sl, r5
   40364:	fb0a f009 	mul.w	r0, sl, r9
   40368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   4036c:	4560      	cmp	r0, ip
   4036e:	d90a      	bls.n	40386 <__udivmoddi4+0x212>
   40370:	eb13 0c0c 	adds.w	ip, r3, ip
   40374:	bf2c      	ite	cs
   40376:	2501      	movcs	r5, #1
   40378:	2500      	movcc	r5, #0
   4037a:	4560      	cmp	r0, ip
   4037c:	d901      	bls.n	40382 <__udivmoddi4+0x20e>
   4037e:	2d00      	cmp	r5, #0
   40380:	d055      	beq.n	4042e <__udivmoddi4+0x2ba>
   40382:	f10a 3aff 	add.w	sl, sl, #4294967295
   40386:	ebac 0c00 	sub.w	ip, ip, r0
   4038a:	b292      	uxth	r2, r2
   4038c:	fbbc f0f8 	udiv	r0, ip, r8
   40390:	fb08 cc10 	mls	ip, r8, r0, ip
   40394:	fb00 f909 	mul.w	r9, r0, r9
   40398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   4039c:	45e1      	cmp	r9, ip
   4039e:	d905      	bls.n	403ac <__udivmoddi4+0x238>
   403a0:	eb13 0c0c 	adds.w	ip, r3, ip
   403a4:	d201      	bcs.n	403aa <__udivmoddi4+0x236>
   403a6:	45e1      	cmp	r9, ip
   403a8:	d83b      	bhi.n	40422 <__udivmoddi4+0x2ae>
   403aa:	3801      	subs	r0, #1
   403ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   403b0:	ebac 0c09 	sub.w	ip, ip, r9
   403b4:	fba0 8907 	umull	r8, r9, r0, r7
   403b8:	45cc      	cmp	ip, r9
   403ba:	4645      	mov	r5, r8
   403bc:	464a      	mov	r2, r9
   403be:	d302      	bcc.n	403c6 <__udivmoddi4+0x252>
   403c0:	d106      	bne.n	403d0 <__udivmoddi4+0x25c>
   403c2:	45c6      	cmp	lr, r8
   403c4:	d204      	bcs.n	403d0 <__udivmoddi4+0x25c>
   403c6:	3801      	subs	r0, #1
   403c8:	ebb8 0507 	subs.w	r5, r8, r7
   403cc:	eb69 0203 	sbc.w	r2, r9, r3
   403d0:	b32e      	cbz	r6, 4041e <__udivmoddi4+0x2aa>
   403d2:	ebbe 0305 	subs.w	r3, lr, r5
   403d6:	eb6c 0c02 	sbc.w	ip, ip, r2
   403da:	fa23 f201 	lsr.w	r2, r3, r1
   403de:	fa0c f404 	lsl.w	r4, ip, r4
   403e2:	fa2c f301 	lsr.w	r3, ip, r1
   403e6:	2100      	movs	r1, #0
   403e8:	4314      	orrs	r4, r2
   403ea:	e9c6 4300 	strd	r4, r3, [r6]
   403ee:	e70c      	b.n	4020a <__udivmoddi4+0x96>
   403f0:	4631      	mov	r1, r6
   403f2:	4630      	mov	r0, r6
   403f4:	e709      	b.n	4020a <__udivmoddi4+0x96>
   403f6:	1a84      	subs	r4, r0, r2
   403f8:	eb65 0303 	sbc.w	r3, r5, r3
   403fc:	2001      	movs	r0, #1
   403fe:	469a      	mov	sl, r3
   40400:	e756      	b.n	402b0 <__udivmoddi4+0x13c>
   40402:	f1ac 0c02 	sub.w	ip, ip, #2
   40406:	443d      	add	r5, r7
   40408:	e724      	b.n	40254 <__udivmoddi4+0xe0>
   4040a:	3802      	subs	r0, #2
   4040c:	443c      	add	r4, r7
   4040e:	e734      	b.n	4027a <__udivmoddi4+0x106>
   40410:	3802      	subs	r0, #2
   40412:	443c      	add	r4, r7
   40414:	e6ef      	b.n	401f6 <__udivmoddi4+0x82>
   40416:	f1ae 0e02 	sub.w	lr, lr, #2
   4041a:	443b      	add	r3, r7
   4041c:	e6d9      	b.n	401d2 <__udivmoddi4+0x5e>
   4041e:	4631      	mov	r1, r6
   40420:	e6f3      	b.n	4020a <__udivmoddi4+0x96>
   40422:	3802      	subs	r0, #2
   40424:	449c      	add	ip, r3
   40426:	e7c1      	b.n	403ac <__udivmoddi4+0x238>
   40428:	3802      	subs	r0, #2
   4042a:	443b      	add	r3, r7
   4042c:	e768      	b.n	40300 <__udivmoddi4+0x18c>
   4042e:	f1aa 0a02 	sub.w	sl, sl, #2
   40432:	449c      	add	ip, r3
   40434:	e7a7      	b.n	40386 <__udivmoddi4+0x212>
   40436:	3902      	subs	r1, #2
   40438:	443d      	add	r5, r7
   4043a:	e774      	b.n	40326 <__udivmoddi4+0x1b2>

0004043c <__aeabi_idiv0>:
   4043c:	4770      	bx	lr
   4043e:	bf00      	nop

00040440 <main>:
          printf("%x",a[i-1]);
     }
     printf("\n");
}

int main() {
   40440:	b5f0      	push	{r4, r5, r6, r7, lr}
 uint8_t publicKey[11]="CICCIOBELLO";
   40442:	4a11      	ldr	r2, [pc, #68]	; (40488 <main+0x48>)
int main() {
   40444:	b08d      	sub	sp, #52	; 0x34
 uint8_t publicKey[11]="CICCIOBELLO";
   40446:	6810      	ldr	r0, [r2, #0]
   40448:	6851      	ldr	r1, [r2, #4]
   4044a:	ab01      	add	r3, sp, #4
   4044c:	c303      	stmia	r3!, {r0, r1}
   4044e:	8911      	ldrh	r1, [r2, #8]
   40450:	7a92      	ldrb	r2, [r2, #10]
   40452:	8019      	strh	r1, [r3, #0]
   40454:	709a      	strb	r2, [r3, #2]
 uint8_t hashed[32];
 
 ethers_keccak256(publicKey, 11, hashed);
   40456:	210b      	movs	r1, #11
   40458:	aa04      	add	r2, sp, #16
   4045a:	a801      	add	r0, sp, #4
   4045c:	f006 feb2 	bl	471c4 <ethers_keccak256>
   40460:	2520      	movs	r5, #32
          printf("%x",a[i-1]);
   40462:	4e0a      	ldr	r6, [pc, #40]	; (4048c <main+0x4c>)
          printf("0%x",a[i-1]);
   40464:	4f0a      	ldr	r7, [pc, #40]	; (40490 <main+0x50>)
   40466:	ac04      	add	r4, sp, #16
       if(a[i-1] < 0x10)
   40468:	f814 1b01 	ldrb.w	r1, [r4], #1
   4046c:	290f      	cmp	r1, #15
          printf("0%x",a[i-1]);
   4046e:	bf94      	ite	ls
   40470:	4638      	movls	r0, r7
          printf("%x",a[i-1]);
   40472:	4630      	movhi	r0, r6
   40474:	f002 fb2a 	bl	42acc <printf>
     for (unsigned long int i = 1; i <= b; i++) {
   40478:	3d01      	subs	r5, #1
   4047a:	d1f5      	bne.n	40468 <main+0x28>
     printf("\n");
   4047c:	4805      	ldr	r0, [pc, #20]	; (40494 <main+0x54>)
   4047e:	f002 fb25 	bl	42acc <printf>
debug_hexstring(hashed, 32);

  return 0;

   40482:	4628      	mov	r0, r5
   40484:	b00d      	add	sp, #52	; 0x34
   40486:	bdf0      	pop	{r4, r5, r6, r7, pc}
   40488:	00048f8c 	.word	0x00048f8c
   4048c:	00048f89 	.word	0x00048f89
   40490:	00048f88 	.word	0x00048f88
   40494:	00049091 	.word	0x00049091

00040498 <sha3_process_block>:
 *
 * @param hash the algorithm state
 * @param block the message block to process
 * @param block_size the size of the processed block in bytes
 */
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   40498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4049c:	f1a0 0a08 	sub.w	sl, r0, #8
   404a0:	4653      	mov	r3, sl
   404a2:	b099      	sub	sp, #100	; 0x64
   404a4:	3908      	subs	r1, #8
   404a6:	f100 0680 	add.w	r6, r0, #128	; 0x80
    for (uint8_t i = 0; i < 17; i++) {
        hash[i] ^= le2me_64(block[i]);
   404aa:	f853 4f08 	ldr.w	r4, [r3, #8]!
   404ae:	f851 7f08 	ldr.w	r7, [r1, #8]!
   404b2:	685a      	ldr	r2, [r3, #4]
   404b4:	684d      	ldr	r5, [r1, #4]
   404b6:	407c      	eors	r4, r7
   404b8:	406a      	eors	r2, r5
    for (uint8_t i = 0; i < 17; i++) {
   404ba:	429e      	cmp	r6, r3
        hash[i] ^= le2me_64(block[i]);
   404bc:	e9c3 4200 	strd	r4, r2, [r3]
    for (uint8_t i = 0; i < 17; i++) {
   404c0:	d1f3      	bne.n	404aa <sha3_process_block+0x12>
   404c2:	f04f 0b18 	mov.w	fp, #24
   404c6:	4b8f      	ldr	r3, [pc, #572]	; (40704 <sha3_process_block+0x26c>)
   404c8:	9301      	str	r3, [sp, #4]
   404ca:	f100 03c0 	add.w	r3, r0, #192	; 0xc0
   404ce:	9302      	str	r3, [sp, #8]
   404d0:	f100 03c8 	add.w	r3, r0, #200	; 0xc8
   404d4:	9303      	str	r3, [sp, #12]
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   404d6:	4651      	mov	r1, sl
   404d8:	2700      	movs	r7, #0
   404da:	ab04      	add	r3, sp, #16
        C[i] = A[i];
   404dc:	2405      	movs	r4, #5
   404de:	f851 6f08 	ldr.w	r6, [r1, #8]!
   404e2:	684d      	ldr	r5, [r1, #4]
   404e4:	e9c3 6500 	strd	r6, r5, [r3]
   404e8:	3308      	adds	r3, #8
        for (uint8_t j = 5; j < 25; j += 5) { C[i] ^= A[i + j]; }
   404ea:	eb01 0cc4 	add.w	ip, r1, r4, lsl #3
   404ee:	f851 2034 	ldr.w	r2, [r1, r4, lsl #3]
   404f2:	f8dc c004 	ldr.w	ip, [ip, #4]
   404f6:	3405      	adds	r4, #5
   404f8:	2c19      	cmp	r4, #25
   404fa:	ea86 0602 	eor.w	r6, r6, r2
   404fe:	ea85 050c 	eor.w	r5, r5, ip
   40502:	d1f2      	bne.n	404ea <sha3_process_block+0x52>
   40504:	3701      	adds	r7, #1
    for (uint8_t i = 0; i < 5; i++) {
   40506:	2f05      	cmp	r7, #5
   40508:	e943 6502 	strd	r6, r5, [r3, #-8]
   4050c:	d1e6      	bne.n	404dc <sha3_process_block+0x44>
   4050e:	ac0e      	add	r4, sp, #56	; 0x38
   40510:	4621      	mov	r1, r4
   40512:	2201      	movs	r2, #1
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   40514:	f04f 0c05 	mov.w	ip, #5
   40518:	fbb2 f3fc 	udiv	r3, r2, ip
   4051c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   40520:	1ad3      	subs	r3, r2, r3
   40522:	ad18      	add	r5, sp, #96	; 0x60
   40524:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
   40528:	e953 5714 	ldrd	r5, r7, [r3, #-80]	; 0x50
   4052c:	007e      	lsls	r6, r7, #1
   4052e:	ea46 76d5 	orr.w	r6, r6, r5, lsr #31
   40532:	006b      	lsls	r3, r5, #1
   40534:	1cd5      	adds	r5, r2, #3
   40536:	ea43 73d7 	orr.w	r3, r3, r7, lsr #31
   4053a:	fbb5 f7fc 	udiv	r7, r5, ip
   4053e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
   40542:	1bed      	subs	r5, r5, r7
   40544:	af18      	add	r7, sp, #96	; 0x60
   40546:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
   4054a:	3201      	adds	r2, #1
   4054c:	e955 7514 	ldrd	r7, r5, [r5, #-80]	; 0x50
    for (uint8_t i = 0; i < 5; i++) {
   40550:	2a06      	cmp	r2, #6
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   40552:	ea83 0307 	eor.w	r3, r3, r7
   40556:	ea86 0605 	eor.w	r6, r6, r5
   4055a:	e9c1 3600 	strd	r3, r6, [r1]
   4055e:	f101 0108 	add.w	r1, r1, #8
    for (uint8_t i = 0; i < 5; i++) {
   40562:	d1d7      	bne.n	40514 <sha3_process_block+0x7c>
   40564:	2500      	movs	r5, #0
        for (uint8_t j = 0; j < 25; j += 5) { A[i + j] ^= D[i]; }
   40566:	e9d4 c700 	ldrd	ip, r7, [r4]
   4056a:	2600      	movs	r6, #0
   4056c:	3408      	adds	r4, #8
   4056e:	eb00 01c5 	add.w	r1, r0, r5, lsl #3
   40572:	3601      	adds	r6, #1
   40574:	e9d1 2300 	ldrd	r2, r3, [r1]
   40578:	2e05      	cmp	r6, #5
   4057a:	ea82 020c 	eor.w	r2, r2, ip
   4057e:	ea83 0307 	eor.w	r3, r3, r7
   40582:	e9c1 2300 	strd	r2, r3, [r1]
   40586:	f101 0128 	add.w	r1, r1, #40	; 0x28
   4058a:	d1f2      	bne.n	40572 <sha3_process_block+0xda>
    for (uint8_t i = 0; i < 5; i++) {
   4058c:	3501      	adds	r5, #1
   4058e:	2d05      	cmp	r5, #5
   40590:	d1e9      	bne.n	40566 <sha3_process_block+0xce>
        for (uint8_t i = 1; i < 25; i++) {
   40592:	4604      	mov	r4, r0
   40594:	f8df e174 	ldr.w	lr, [pc, #372]	; 4070c <sha3_process_block+0x274>
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40598:	f854 2f08 	ldr.w	r2, [r4, #8]!
    return constants[type + index];
   4059c:	f81e 3b01 	ldrb.w	r3, [lr], #1
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   405a0:	6865      	ldr	r5, [r4, #4]
   405a2:	f1a3 0720 	sub.w	r7, r3, #32
   405a6:	fa02 f707 	lsl.w	r7, r2, r7
   405aa:	f1c3 0620 	rsb	r6, r3, #32
   405ae:	fa05 f103 	lsl.w	r1, r5, r3
   405b2:	fa22 f606 	lsr.w	r6, r2, r6
   405b6:	4339      	orrs	r1, r7
   405b8:	4331      	orrs	r1, r6
   405ba:	fa02 f603 	lsl.w	r6, r2, r3
   405be:	425b      	negs	r3, r3
   405c0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   405c4:	f1c3 0c20 	rsb	ip, r3, #32
   405c8:	f1a3 0720 	sub.w	r7, r3, #32
   405cc:	40da      	lsrs	r2, r3
   405ce:	fa05 fc0c 	lsl.w	ip, r5, ip
   405d2:	fa25 f303 	lsr.w	r3, r5, r3
   405d6:	4319      	orrs	r1, r3
   405d8:	ea42 020c 	orr.w	r2, r2, ip
        for (uint8_t i = 1; i < 25; i++) {
   405dc:	9b02      	ldr	r3, [sp, #8]
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   405de:	fa25 f707 	lsr.w	r7, r5, r7
   405e2:	433a      	orrs	r2, r7
   405e4:	4332      	orrs	r2, r6
        for (uint8_t i = 1; i < 25; i++) {
   405e6:	42a3      	cmp	r3, r4
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   405e8:	e9c4 2100 	strd	r2, r1, [r4]
        for (uint8_t i = 1; i < 25; i++) {
   405ec:	d1d4      	bne.n	40598 <sha3_process_block+0x100>
    for (uint8_t i = 1; i < 24; i++) {
   405ee:	2101      	movs	r1, #1
    uint64_t A1 = A[1];
   405f0:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
    for (uint8_t i = 1; i < 24; i++) {
   405f4:	4f44      	ldr	r7, [pc, #272]	; (40708 <sha3_process_block+0x270>)
    return constants[type + index];
   405f6:	463e      	mov	r6, r7
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   405f8:	787c      	ldrb	r4, [r7, #1]
   405fa:	7836      	ldrb	r6, [r6, #0]
    for (uint8_t i = 1; i < 24; i++) {
   405fc:	3101      	adds	r1, #1
   405fe:	b2c9      	uxtb	r1, r1
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   40600:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   40604:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
    for (uint8_t i = 1; i < 24; i++) {
   40608:	2918      	cmp	r1, #24
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   4060a:	e9d4 4500 	ldrd	r4, r5, [r4]
   4060e:	f107 0701 	add.w	r7, r7, #1
   40612:	e9c6 4500 	strd	r4, r5, [r6]
    for (uint8_t i = 1; i < 24; i++) {
   40616:	d1ee      	bne.n	405f6 <sha3_process_block+0x15e>
    A[10] = A1;
   40618:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
   4061c:	4603      	mov	r3, r0
        uint64_t A0 = A[0 + i], A1 = A[1 + i];
   4061e:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
   40622:	e9d3 7600 	ldrd	r7, r6, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   40626:	e9d3 ec06 	ldrd	lr, ip, [r3, #24]
        A[0 + i] ^= ~A1 & A[2 + i];
   4062a:	691c      	ldr	r4, [r3, #16]
   4062c:	ea24 0501 	bic.w	r5, r4, r1
   40630:	695c      	ldr	r4, [r3, #20]
   40632:	407d      	eors	r5, r7
   40634:	ea24 0402 	bic.w	r4, r4, r2
   40638:	4074      	eors	r4, r6
   4063a:	e9c3 5400 	strd	r5, r4, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   4063e:	691c      	ldr	r4, [r3, #16]
   40640:	ea2e 0504 	bic.w	r5, lr, r4
   40644:	695c      	ldr	r4, [r3, #20]
   40646:	404d      	eors	r5, r1
   40648:	ea2c 0404 	bic.w	r4, ip, r4
   4064c:	4054      	eors	r4, r2
   4064e:	e9c3 5402 	strd	r5, r4, [r3, #8]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   40652:	e9d3 5408 	ldrd	r5, r4, [r3, #32]
   40656:	ea24 080c 	bic.w	r8, r4, ip
   4065a:	9400      	str	r4, [sp, #0]
   4065c:	691c      	ldr	r4, [r3, #16]
   4065e:	ea25 090e 	bic.w	r9, r5, lr
   40662:	ea89 0904 	eor.w	r9, r9, r4
   40666:	695c      	ldr	r4, [r3, #20]
        A[4 + i] ^= ~A0 & A1;
   40668:	ea22 0206 	bic.w	r2, r2, r6
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   4066c:	ea88 0804 	eor.w	r8, r8, r4
        A[3 + i] ^= ~A[4 + i] & A0;
   40670:	9c00      	ldr	r4, [sp, #0]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   40672:	e9c3 9804 	strd	r9, r8, [r3, #16]
        A[4 + i] ^= ~A0 & A1;
   40676:	ea21 0107 	bic.w	r1, r1, r7
        A[3 + i] ^= ~A[4 + i] & A0;
   4067a:	ea27 0905 	bic.w	r9, r7, r5
   4067e:	ea26 0804 	bic.w	r8, r6, r4
   40682:	ea89 0e0e 	eor.w	lr, r9, lr
        A[4 + i] ^= ~A0 & A1;
   40686:	4054      	eors	r4, r2
        A[3 + i] ^= ~A[4 + i] & A0;
   40688:	ea88 0c0c 	eor.w	ip, r8, ip
    for (uint8_t i = 0; i < 25; i += 5) {
   4068c:	9a03      	ldr	r2, [sp, #12]
        A[4 + i] ^= ~A0 & A1;
   4068e:	404d      	eors	r5, r1
        A[3 + i] ^= ~A[4 + i] & A0;
   40690:	e9c3 ec06 	strd	lr, ip, [r3, #24]
        A[4 + i] ^= ~A0 & A1;
   40694:	e9c3 5408 	strd	r5, r4, [r3, #32]
    for (uint8_t i = 0; i < 25; i += 5) {
   40698:	3328      	adds	r3, #40	; 0x28
   4069a:	429a      	cmp	r2, r3
   4069c:	d1bf      	bne.n	4061e <sha3_process_block+0x186>
    return constants[type + index];
   4069e:	9b01      	ldr	r3, [sp, #4]
   406a0:	f813 2b01 	ldrb.w	r2, [r3], #1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   406a4:	f012 0140 	ands.w	r1, r2, #64	; 0x40
   406a8:	bf16      	itet	ne
   406aa:	2100      	movne	r1, #0
    uint64_t result = 0;
   406ac:	460c      	moveq	r4, r1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   406ae:	f04f 4400 	movne.w	r4, #2147483648	; 0x80000000
    if (roundInfo & (1 << 5)) { result |= ((uint64_t)1 << 31); }
   406b2:	f012 0f20 	tst.w	r2, #32
   406b6:	bf18      	it	ne
   406b8:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
    return constants[type + index];
   406bc:	9301      	str	r3, [sp, #4]
    if (roundInfo & (1 << 4)) { result |= ((uint64_t)1 << 15); }
   406be:	06d3      	lsls	r3, r2, #27
   406c0:	bf48      	it	mi
   406c2:	f441 4100 	orrmi.w	r1, r1, #32768	; 0x8000
    if (roundInfo & (1 << 3)) { result |= ((uint64_t)1 << 7); }
   406c6:	0717      	lsls	r7, r2, #28
   406c8:	bf48      	it	mi
   406ca:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
    if (roundInfo & (1 << 2)) { result |= ((uint64_t)1 << 3); }
   406ce:	0756      	lsls	r6, r2, #29
   406d0:	bf48      	it	mi
   406d2:	f041 0108 	orrmi.w	r1, r1, #8
    if (roundInfo & (1 << 1)) { result |= ((uint64_t)1 << 1); }
   406d6:	0795      	lsls	r5, r2, #30
   406d8:	bf48      	it	mi
   406da:	f041 0102 	orrmi.w	r1, r1, #2
    if (roundInfo & (1 << 0)) { result |= ((uint64_t)1 << 0); }
   406de:	07d3      	lsls	r3, r2, #31
   406e0:	bf48      	it	mi
   406e2:	f041 0101 	orrmi.w	r1, r1, #1
        *state ^= get_round_constant(round);
   406e6:	e9d0 2300 	ldrd	r2, r3, [r0]
   406ea:	4063      	eors	r3, r4
   406ec:	404a      	eors	r2, r1
   406ee:	e9c0 2300 	strd	r2, r3, [r0]
    for (uint8_t round = 0; round < 24; round++) {
   406f2:	f10b 33ff 	add.w	r3, fp, #4294967295
   406f6:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   406fa:	f47f aeec 	bne.w	404d6 <sha3_process_block+0x3e>
    }

    /* make a permutation of the hash */
    sha3_permutation(hash);
}
   406fe:	b019      	add	sp, #100	; 0x64
   40700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   40704:	00048f98 	.word	0x00048f98
   40708:	00048fb0 	.word	0x00048fb0
   4070c:	00048fc8 	.word	0x00048fc8

00040710 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   40710:	680b      	ldr	r3, [r1, #0]
   40712:	3301      	adds	r3, #1
   40714:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   40716:	4b01      	ldr	r3, [pc, #4]	; (4071c <char_out+0xc>)
   40718:	681b      	ldr	r3, [r3, #0]
   4071a:	4718      	bx	r3
   4071c:	2001a500 	.word	0x2001a500

00040720 <__printk_hook_install>:
	_char_out = fn;
   40720:	4b01      	ldr	r3, [pc, #4]	; (40728 <__printk_hook_install+0x8>)
   40722:	6018      	str	r0, [r3, #0]
}
   40724:	4770      	bx	lr
   40726:	bf00      	nop
   40728:	2001a500 	.word	0x2001a500

0004072c <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   4072c:	b507      	push	{r0, r1, r2, lr}
   4072e:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   40730:	2100      	movs	r1, #0
{
   40732:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   40734:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   40736:	4803      	ldr	r0, [pc, #12]	; (40744 <vprintk+0x18>)
   40738:	a901      	add	r1, sp, #4
   4073a:	f000 f8ff 	bl	4093c <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   4073e:	b003      	add	sp, #12
   40740:	f85d fb04 	ldr.w	pc, [sp], #4
   40744:	00040711 	.word	0x00040711

00040748 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   40748:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   4074a:	2500      	movs	r5, #0
{
   4074c:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   4074e:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   40752:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
   40754:	a901      	add	r1, sp, #4
   40756:	4805      	ldr	r0, [pc, #20]	; (4076c <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   40758:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
   4075a:	f000 f8ef 	bl	4093c <cbvprintf>

	if (ctx.count < ctx.max) {
   4075e:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   40762:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   40764:	bfb8      	it	lt
   40766:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   40768:	b005      	add	sp, #20
   4076a:	bd30      	pop	{r4, r5, pc}
   4076c:	00047317 	.word	0x00047317

00040770 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   40770:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40774:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   40778:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   4077a:	f019 0808 	ands.w	r8, r9, #8
{
   4077e:	4693      	mov	fp, r2
	if (processing) {
   40780:	d00d      	beq.n	4079e <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   40782:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   40784:	bf0c      	ite	eq
   40786:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   4078a:	f049 0920 	orrne.w	r9, r9, #32
   4078e:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   40792:	f38b 8811 	msr	BASEPRI, fp
   40796:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   4079a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4079e:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   407a2:	2902      	cmp	r1, #2
   407a4:	d107      	bne.n	407b6 <process_event+0x46>
			evt = process_recheck(mgr);
   407a6:	4620      	mov	r0, r4
   407a8:	f006 fde2 	bl	47370 <process_recheck>
		if (evt == EVT_NOP) {
   407ac:	2800      	cmp	r0, #0
   407ae:	d0f0      	beq.n	40792 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   407b0:	2801      	cmp	r0, #1
   407b2:	8b23      	ldrh	r3, [r4, #24]
   407b4:	d150      	bne.n	40858 <process_event+0xe8>
			res = mgr->last_res;
   407b6:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   407b8:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   407ba:	2f00      	cmp	r7, #0
   407bc:	da15      	bge.n	407ea <process_event+0x7a>
		*clients = mgr->clients;
   407be:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   407c0:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   407c4:	e9c4 8800 	strd	r8, r8, [r4]
   407c8:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   407cc:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   407ce:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   407d0:	8b21      	ldrh	r1, [r4, #24]
   407d2:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   407d6:	45ca      	cmp	sl, r9
   407d8:	d002      	beq.n	407e0 <process_event+0x70>
		if (do_monitors
   407da:	68a3      	ldr	r3, [r4, #8]
   407dc:	2b00      	cmp	r3, #0
   407de:	d15c      	bne.n	4089a <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   407e0:	b90d      	cbnz	r5, 407e6 <process_event+0x76>
		    || (transit != NULL)) {
   407e2:	2e00      	cmp	r6, #0
   407e4:	d074      	beq.n	408d0 <process_event+0x160>
   407e6:	2300      	movs	r3, #0
   407e8:	e058      	b.n	4089c <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   407ea:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   407ee:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   407f0:	2a01      	cmp	r2, #1
   407f2:	d820      	bhi.n	40836 <process_event+0xc6>
		*clients = mgr->clients;
   407f4:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   407f8:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   407fa:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   407fc:	b289      	uxth	r1, r1
	list->tail = NULL;
   407fe:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   40802:	d10c      	bne.n	4081e <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   40804:	2d00      	cmp	r5, #0
   40806:	462b      	mov	r3, r5
   40808:	bf38      	it	cc
   4080a:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   4080c:	b12b      	cbz	r3, 4081a <process_event+0xaa>
				mgr->refs += 1U;
   4080e:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   40810:	681b      	ldr	r3, [r3, #0]
   40812:	3201      	adds	r2, #1
   40814:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   40816:	2b00      	cmp	r3, #0
   40818:	d1f8      	bne.n	4080c <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4081a:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   4081e:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   40820:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   40822:	f006 fda5 	bl	47370 <process_recheck>
   40826:	4606      	mov	r6, r0
   40828:	2800      	cmp	r0, #0
   4082a:	d0d1      	beq.n	407d0 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   4082c:	8b23      	ldrh	r3, [r4, #24]
   4082e:	f043 0320 	orr.w	r3, r3, #32
   40832:	8323      	strh	r3, [r4, #24]
   40834:	e7cb      	b.n	407ce <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   40836:	2b04      	cmp	r3, #4
   40838:	d10c      	bne.n	40854 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4083a:	f021 0107 	bic.w	r1, r1, #7
   4083e:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   40840:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   40842:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   40844:	f006 fd94 	bl	47370 <process_recheck>
   40848:	4605      	mov	r5, r0
   4084a:	2800      	cmp	r0, #0
   4084c:	d0bf      	beq.n	407ce <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   4084e:	f041 0120 	orr.w	r1, r1, #32
   40852:	8321      	strh	r1, [r4, #24]
   40854:	2500      	movs	r5, #0
   40856:	e7ba      	b.n	407ce <process_event+0x5e>
		} else if (evt == EVT_START) {
   40858:	2803      	cmp	r0, #3
   4085a:	d109      	bne.n	40870 <process_event+0x100>
			transit = mgr->transitions->start;
   4085c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4085e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   40862:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40864:	f043 0306 	orr.w	r3, r3, #6
}
   40868:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   4086a:	8323      	strh	r3, [r4, #24]
		res = 0;
   4086c:	462f      	mov	r7, r5
   4086e:	e7af      	b.n	407d0 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   40870:	2804      	cmp	r0, #4
   40872:	d106      	bne.n	40882 <process_event+0x112>
			transit = mgr->transitions->stop;
   40874:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40876:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   4087a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4087c:	f043 0304 	orr.w	r3, r3, #4
   40880:	e7f2      	b.n	40868 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   40882:	2805      	cmp	r0, #5
   40884:	d106      	bne.n	40894 <process_event+0x124>
			transit = mgr->transitions->reset;
   40886:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40888:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   4088c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4088e:	f043 0305 	orr.w	r3, r3, #5
   40892:	e7e9      	b.n	40868 <process_event+0xf8>
   40894:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   40896:	462e      	mov	r6, r5
   40898:	e7e8      	b.n	4086c <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   4089a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   4089c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   408a0:	8321      	strh	r1, [r4, #24]
   408a2:	f38b 8811 	msr	BASEPRI, fp
   408a6:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   408aa:	bb03      	cbnz	r3, 408ee <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   408ac:	2d00      	cmp	r5, #0
   408ae:	d133      	bne.n	40918 <process_event+0x1a8>
			if (transit != NULL) {
   408b0:	b116      	cbz	r6, 408b8 <process_event+0x148>
				transit(mgr, transition_complete);
   408b2:	4620      	mov	r0, r4
   408b4:	4920      	ldr	r1, [pc, #128]	; (40938 <process_event+0x1c8>)
   408b6:	47b0      	blx	r6
	__asm__ volatile(
   408b8:	f04f 0320 	mov.w	r3, #32
   408bc:	f3ef 8b11 	mrs	fp, BASEPRI
   408c0:	f383 8812 	msr	BASEPRI_MAX, r3
   408c4:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   408c8:	8b23      	ldrh	r3, [r4, #24]
   408ca:	f023 0308 	bic.w	r3, r3, #8
   408ce:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   408d0:	8b23      	ldrh	r3, [r4, #24]
   408d2:	06da      	lsls	r2, r3, #27
   408d4:	d528      	bpl.n	40928 <process_event+0x1b8>
			evt = EVT_COMPLETE;
   408d6:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   408d8:	f023 0310 	bic.w	r3, r3, #16
   408dc:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   408de:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   408e2:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   408e6:	2900      	cmp	r1, #0
   408e8:	f47f af5b 	bne.w	407a2 <process_event+0x32>
out:
   408ec:	e751      	b.n	40792 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   408ee:	68a1      	ldr	r1, [r4, #8]
   408f0:	2900      	cmp	r1, #0
   408f2:	d0db      	beq.n	408ac <process_event+0x13c>
	return node->next;
   408f4:	680b      	ldr	r3, [r1, #0]
   408f6:	2b00      	cmp	r3, #0
   408f8:	bf38      	it	cc
   408fa:	2300      	movcc	r3, #0
   408fc:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   408fe:	4652      	mov	r2, sl
   40900:	463b      	mov	r3, r7
   40902:	4620      	mov	r0, r4
   40904:	f8d1 b004 	ldr.w	fp, [r1, #4]
   40908:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   4090a:	f1b9 0f00 	cmp.w	r9, #0
   4090e:	d0cd      	beq.n	408ac <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   40910:	4649      	mov	r1, r9
   40912:	f8d9 3000 	ldr.w	r3, [r9]
   40916:	e7ee      	b.n	408f6 <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   40918:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   4091a:	463b      	mov	r3, r7
   4091c:	4652      	mov	r2, sl
   4091e:	4620      	mov	r0, r4
   40920:	682d      	ldr	r5, [r5, #0]
   40922:	f006 fd41 	bl	473a8 <notify_one>
   40926:	e7c1      	b.n	408ac <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   40928:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   4092c:	bf1e      	ittt	ne
   4092e:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   40932:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   40934:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   40936:	e7d2      	b.n	408de <process_event+0x16e>
   40938:	000473d5 	.word	0x000473d5

0004093c <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   4093c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   40940:	468b      	mov	fp, r1
   40942:	4692      	mov	sl, r2
   40944:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   40946:	2500      	movs	r5, #0
{
   40948:	b091      	sub	sp, #68	; 0x44
   4094a:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   4094c:	f89a 0000 	ldrb.w	r0, [sl]
   40950:	b908      	cbnz	r0, 40956 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   40952:	4628      	mov	r0, r5
   40954:	e35e      	b.n	41014 <cbvprintf+0x6d8>
		if (*fp != '%') {
   40956:	2825      	cmp	r0, #37	; 0x25
   40958:	f10a 0701 	add.w	r7, sl, #1
   4095c:	d007      	beq.n	4096e <cbvprintf+0x32>
			OUTC('%');
   4095e:	4659      	mov	r1, fp
   40960:	9b02      	ldr	r3, [sp, #8]
   40962:	4798      	blx	r3
   40964:	2800      	cmp	r0, #0
   40966:	f2c0 8355 	blt.w	41014 <cbvprintf+0x6d8>
   4096a:	3501      	adds	r5, #1
			break;
   4096c:	e210      	b.n	40d90 <cbvprintf+0x454>
		} state = {
   4096e:	2218      	movs	r2, #24
   40970:	2100      	movs	r1, #0
   40972:	a80a      	add	r0, sp, #40	; 0x28
   40974:	f007 fb43 	bl	47ffe <memset>
	if (*sp == '%') {
   40978:	f89a 3001 	ldrb.w	r3, [sl, #1]
   4097c:	2b25      	cmp	r3, #37	; 0x25
   4097e:	d078      	beq.n	40a72 <cbvprintf+0x136>
   40980:	2200      	movs	r2, #0
   40982:	4694      	mov	ip, r2
   40984:	4616      	mov	r6, r2
   40986:	4696      	mov	lr, r2
   40988:	4610      	mov	r0, r2
   4098a:	4639      	mov	r1, r7
		switch (*sp) {
   4098c:	f817 3b01 	ldrb.w	r3, [r7], #1
   40990:	2b2b      	cmp	r3, #43	; 0x2b
   40992:	f000 809d 	beq.w	40ad0 <cbvprintf+0x194>
   40996:	f200 8094 	bhi.w	40ac2 <cbvprintf+0x186>
   4099a:	2b20      	cmp	r3, #32
   4099c:	f000 809b 	beq.w	40ad6 <cbvprintf+0x19a>
   409a0:	2b23      	cmp	r3, #35	; 0x23
   409a2:	f000 809a 	beq.w	40ada <cbvprintf+0x19e>
   409a6:	b128      	cbz	r0, 409b4 <cbvprintf+0x78>
   409a8:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   409ac:	f040 0004 	orr.w	r0, r0, #4
   409b0:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   409b4:	f1be 0f00 	cmp.w	lr, #0
   409b8:	d005      	beq.n	409c6 <cbvprintf+0x8a>
   409ba:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   409be:	f040 0008 	orr.w	r0, r0, #8
   409c2:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   409c6:	b12e      	cbz	r6, 409d4 <cbvprintf+0x98>
   409c8:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   409cc:	f040 0010 	orr.w	r0, r0, #16
   409d0:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   409d4:	f1bc 0f00 	cmp.w	ip, #0
   409d8:	d005      	beq.n	409e6 <cbvprintf+0xaa>
   409da:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   409de:	f040 0020 	orr.w	r0, r0, #32
   409e2:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   409e6:	b12a      	cbz	r2, 409f4 <cbvprintf+0xb8>
   409e8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   409ec:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   409f0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   409f4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   409f8:	f002 0044 	and.w	r0, r2, #68	; 0x44
   409fc:	2844      	cmp	r0, #68	; 0x44
   409fe:	d103      	bne.n	40a08 <cbvprintf+0xcc>
		conv->flag_zero = false;
   40a00:	f36f 1286 	bfc	r2, #6, #1
   40a04:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   40a08:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40a0c:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   40a0e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   40a12:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40a16:	d17b      	bne.n	40b10 <cbvprintf+0x1d4>
		conv->width_star = true;
   40a18:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40a1c:	1c4b      	adds	r3, r1, #1
   40a1e:	f042 0201 	orr.w	r2, r2, #1
   40a22:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   40a26:	781a      	ldrb	r2, [r3, #0]
   40a28:	2a2e      	cmp	r2, #46	; 0x2e
   40a2a:	bf0c      	ite	eq
   40a2c:	2101      	moveq	r1, #1
   40a2e:	2100      	movne	r1, #0
   40a30:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40a34:	f361 0241 	bfi	r2, r1, #1, #1
   40a38:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   40a3c:	d174      	bne.n	40b28 <cbvprintf+0x1ec>
	if (*sp == '*') {
   40a3e:	785a      	ldrb	r2, [r3, #1]
   40a40:	2a2a      	cmp	r2, #42	; 0x2a
   40a42:	d06a      	beq.n	40b1a <cbvprintf+0x1de>
	size_t val = 0;
   40a44:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   40a46:	260a      	movs	r6, #10
   40a48:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   40a4a:	4618      	mov	r0, r3
   40a4c:	f810 2b01 	ldrb.w	r2, [r0], #1
   40a50:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40a54:	2f09      	cmp	r7, #9
   40a56:	f240 808e 	bls.w	40b76 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   40a5a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   40a5e:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   40a60:	f3c2 0040 	ubfx	r0, r2, #1, #1
   40a64:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   40a68:	f361 0241 	bfi	r2, r1, #1, #1
   40a6c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40a70:	e05a      	b.n	40b28 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   40a72:	f10a 0702 	add.w	r7, sl, #2
   40a76:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   40a7a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40a7e:	07d9      	lsls	r1, r3, #31
   40a80:	f140 8149 	bpl.w	40d16 <cbvprintf+0x3da>
			width = va_arg(ap, int);
   40a84:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   40a88:	f1b9 0f00 	cmp.w	r9, #0
   40a8c:	da07      	bge.n	40a9e <cbvprintf+0x162>
				conv->flag_dash = true;
   40a8e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   40a92:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   40a96:	f042 0204 	orr.w	r2, r2, #4
   40a9a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   40a9e:	075a      	lsls	r2, r3, #29
   40aa0:	f140 8142 	bpl.w	40d28 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   40aa4:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   40aa8:	f1b8 0f00 	cmp.w	r8, #0
   40aac:	f280 8141 	bge.w	40d32 <cbvprintf+0x3f6>
				conv->prec_present = false;
   40ab0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40ab4:	f36f 0341 	bfc	r3, #1, #1
   40ab8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   40abc:	f04f 38ff 	mov.w	r8, #4294967295
   40ac0:	e137      	b.n	40d32 <cbvprintf+0x3f6>
		switch (*sp) {
   40ac2:	2b2d      	cmp	r3, #45	; 0x2d
   40ac4:	d00c      	beq.n	40ae0 <cbvprintf+0x1a4>
   40ac6:	2b30      	cmp	r3, #48	; 0x30
   40ac8:	f47f af6d 	bne.w	409a6 <cbvprintf+0x6a>
			conv->flag_zero = true;
   40acc:	2201      	movs	r2, #1
	} while (loop);
   40ace:	e75c      	b.n	4098a <cbvprintf+0x4e>
			conv->flag_plus = true;
   40ad0:	f04f 0e01 	mov.w	lr, #1
   40ad4:	e759      	b.n	4098a <cbvprintf+0x4e>
			conv->flag_space = true;
   40ad6:	2601      	movs	r6, #1
   40ad8:	e757      	b.n	4098a <cbvprintf+0x4e>
			conv->flag_hash = true;
   40ada:	f04f 0c01 	mov.w	ip, #1
   40ade:	e754      	b.n	4098a <cbvprintf+0x4e>
		switch (*sp) {
   40ae0:	2001      	movs	r0, #1
   40ae2:	e752      	b.n	4098a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   40ae4:	4633      	mov	r3, r6
   40ae6:	fb0c 0202 	mla	r2, ip, r2, r0
   40aea:	3a30      	subs	r2, #48	; 0x30
   40aec:	461e      	mov	r6, r3
   40aee:	f816 0b01 	ldrb.w	r0, [r6], #1
   40af2:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40af6:	2f09      	cmp	r7, #9
   40af8:	d9f4      	bls.n	40ae4 <cbvprintf+0x1a8>
	if (sp != wp) {
   40afa:	4299      	cmp	r1, r3
   40afc:	d093      	beq.n	40a26 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   40afe:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   40b02:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   40b04:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   40b06:	f362 0141 	bfi	r1, r2, #1, #1
   40b0a:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   40b0e:	e78a      	b.n	40a26 <cbvprintf+0xea>
   40b10:	460b      	mov	r3, r1
	size_t val = 0;
   40b12:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   40b14:	f04f 0c0a 	mov.w	ip, #10
   40b18:	e7e8      	b.n	40aec <cbvprintf+0x1b0>
		conv->prec_star = true;
   40b1a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   40b1e:	3302      	adds	r3, #2
		conv->prec_star = true;
   40b20:	f042 0204 	orr.w	r2, r2, #4
   40b24:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   40b28:	461f      	mov	r7, r3
   40b2a:	f817 2b01 	ldrb.w	r2, [r7], #1
   40b2e:	2a6c      	cmp	r2, #108	; 0x6c
   40b30:	d041      	beq.n	40bb6 <cbvprintf+0x27a>
   40b32:	d825      	bhi.n	40b80 <cbvprintf+0x244>
   40b34:	2a68      	cmp	r2, #104	; 0x68
   40b36:	d02b      	beq.n	40b90 <cbvprintf+0x254>
   40b38:	2a6a      	cmp	r2, #106	; 0x6a
   40b3a:	d046      	beq.n	40bca <cbvprintf+0x28e>
   40b3c:	2a4c      	cmp	r2, #76	; 0x4c
   40b3e:	d04c      	beq.n	40bda <cbvprintf+0x29e>
   40b40:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   40b42:	f817 2b01 	ldrb.w	r2, [r7], #1
   40b46:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   40b4a:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   40b4c:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   40b50:	f200 80d9 	bhi.w	40d06 <cbvprintf+0x3ca>
   40b54:	2a57      	cmp	r2, #87	; 0x57
   40b56:	d84d      	bhi.n	40bf4 <cbvprintf+0x2b8>
   40b58:	2a41      	cmp	r2, #65	; 0x41
   40b5a:	d003      	beq.n	40b64 <cbvprintf+0x228>
   40b5c:	3a45      	subs	r2, #69	; 0x45
   40b5e:	2a02      	cmp	r2, #2
   40b60:	f200 80d1 	bhi.w	40d06 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   40b64:	2204      	movs	r2, #4
   40b66:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40b6a:	f362 0302 	bfi	r3, r2, #0, #3
   40b6e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   40b72:	2301      	movs	r3, #1
			break;
   40b74:	e09e      	b.n	40cb4 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   40b76:	fb06 2101 	mla	r1, r6, r1, r2
   40b7a:	4603      	mov	r3, r0
   40b7c:	3930      	subs	r1, #48	; 0x30
   40b7e:	e764      	b.n	40a4a <cbvprintf+0x10e>
	switch (*sp) {
   40b80:	2a74      	cmp	r2, #116	; 0x74
   40b82:	d026      	beq.n	40bd2 <cbvprintf+0x296>
   40b84:	2a7a      	cmp	r2, #122	; 0x7a
   40b86:	d1db      	bne.n	40b40 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   40b88:	2206      	movs	r2, #6
   40b8a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40b8e:	e00d      	b.n	40bac <cbvprintf+0x270>
		if (*++sp == 'h') {
   40b90:	785a      	ldrb	r2, [r3, #1]
   40b92:	2a68      	cmp	r2, #104	; 0x68
   40b94:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40b98:	d106      	bne.n	40ba8 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   40b9a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   40b9c:	f361 02c6 	bfi	r2, r1, #3, #4
   40ba0:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   40ba4:	1c9f      	adds	r7, r3, #2
   40ba6:	e7cc      	b.n	40b42 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   40ba8:	4613      	mov	r3, r2
   40baa:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   40bac:	f362 03c6 	bfi	r3, r2, #3, #4
   40bb0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   40bb4:	e7c5      	b.n	40b42 <cbvprintf+0x206>
		if (*++sp == 'l') {
   40bb6:	785a      	ldrb	r2, [r3, #1]
   40bb8:	2a6c      	cmp	r2, #108	; 0x6c
   40bba:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40bbe:	d101      	bne.n	40bc4 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   40bc0:	2104      	movs	r1, #4
   40bc2:	e7eb      	b.n	40b9c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   40bc4:	4613      	mov	r3, r2
   40bc6:	2203      	movs	r2, #3
   40bc8:	e7f0      	b.n	40bac <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   40bca:	2205      	movs	r2, #5
   40bcc:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40bd0:	e7ec      	b.n	40bac <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   40bd2:	2207      	movs	r2, #7
   40bd4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40bd8:	e7e8      	b.n	40bac <cbvprintf+0x270>
		conv->unsupported = true;
   40bda:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   40bde:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   40be2:	f023 0302 	bic.w	r3, r3, #2
   40be6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   40bea:	f043 0302 	orr.w	r3, r3, #2
   40bee:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   40bf2:	e7a6      	b.n	40b42 <cbvprintf+0x206>
   40bf4:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   40bf8:	2920      	cmp	r1, #32
   40bfa:	f200 8084 	bhi.w	40d06 <cbvprintf+0x3ca>
   40bfe:	a001      	add	r0, pc, #4	; (adr r0, 40c04 <cbvprintf+0x2c8>)
   40c00:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   40c04:	00040cc9 	.word	0x00040cc9
   40c08:	00040d07 	.word	0x00040d07
   40c0c:	00040d07 	.word	0x00040d07
   40c10:	00040d07 	.word	0x00040d07
   40c14:	00040d07 	.word	0x00040d07
   40c18:	00040d07 	.word	0x00040d07
   40c1c:	00040d07 	.word	0x00040d07
   40c20:	00040d07 	.word	0x00040d07
   40c24:	00040d07 	.word	0x00040d07
   40c28:	00040b65 	.word	0x00040b65
   40c2c:	00040d07 	.word	0x00040d07
   40c30:	00040cc9 	.word	0x00040cc9
   40c34:	00040c89 	.word	0x00040c89
   40c38:	00040b65 	.word	0x00040b65
   40c3c:	00040b65 	.word	0x00040b65
   40c40:	00040b65 	.word	0x00040b65
   40c44:	00040d07 	.word	0x00040d07
   40c48:	00040c89 	.word	0x00040c89
   40c4c:	00040d07 	.word	0x00040d07
   40c50:	00040d07 	.word	0x00040d07
   40c54:	00040d07 	.word	0x00040d07
   40c58:	00040d07 	.word	0x00040d07
   40c5c:	00040cd1 	.word	0x00040cd1
   40c60:	00040cc9 	.word	0x00040cc9
   40c64:	00040ced 	.word	0x00040ced
   40c68:	00040d07 	.word	0x00040d07
   40c6c:	00040d07 	.word	0x00040d07
   40c70:	00040ced 	.word	0x00040ced
   40c74:	00040d07 	.word	0x00040d07
   40c78:	00040cc9 	.word	0x00040cc9
   40c7c:	00040d07 	.word	0x00040d07
   40c80:	00040d07 	.word	0x00040d07
   40c84:	00040cc9 	.word	0x00040cc9
		conv->specifier_cat = SPECIFIER_SINT;
   40c88:	2001      	movs	r0, #1
   40c8a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40c8e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   40c92:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40c96:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   40c98:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   40c9c:	bf02      	ittt	eq
   40c9e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   40ca2:	f041 0101 	orreq.w	r1, r1, #1
   40ca6:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   40caa:	2a63      	cmp	r2, #99	; 0x63
   40cac:	d131      	bne.n	40d12 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   40cae:	3b00      	subs	r3, #0
   40cb0:	bf18      	it	ne
   40cb2:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   40cb4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40cb8:	f3c2 0140 	ubfx	r1, r2, #1, #1
   40cbc:	430b      	orrs	r3, r1
   40cbe:	f363 0241 	bfi	r2, r3, #1, #1
   40cc2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40cc6:	e6d8      	b.n	40a7a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   40cc8:	2002      	movs	r0, #2
   40cca:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   40cce:	e7de      	b.n	40c8e <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   40cd0:	2103      	movs	r1, #3
   40cd2:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40cd6:	f003 0378 	and.w	r3, r3, #120	; 0x78
   40cda:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   40cde:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40ce2:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   40ce4:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40ce8:	4143      	adcs	r3, r0
   40cea:	e7e3      	b.n	40cb4 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   40cec:	2103      	movs	r1, #3
   40cee:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40cf2:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   40cf6:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   40cfa:	bf14      	ite	ne
   40cfc:	2301      	movne	r3, #1
   40cfe:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   40d00:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40d04:	e7d6      	b.n	40cb4 <cbvprintf+0x378>
		conv->invalid = true;
   40d06:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40d0a:	f043 0301 	orr.w	r3, r3, #1
   40d0e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   40d12:	2300      	movs	r3, #0
   40d14:	e7ce      	b.n	40cb4 <cbvprintf+0x378>
		} else if (conv->width_present) {
   40d16:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   40d1a:	2a00      	cmp	r2, #0
		int width = -1;
   40d1c:	bfac      	ite	ge
   40d1e:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
   40d22:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   40d26:	e6ba      	b.n	40a9e <cbvprintf+0x162>
		} else if (conv->prec_present) {
   40d28:	079b      	lsls	r3, r3, #30
   40d2a:	f57f aec7 	bpl.w	40abc <cbvprintf+0x180>
			precision = conv->prec_value;
   40d2e:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   40d32:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   40d34:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   40d38:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   40d3c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   40d40:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   40d44:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   40d46:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   40d4a:	d136      	bne.n	40dba <cbvprintf+0x47e>
			switch (length_mod) {
   40d4c:	1ed3      	subs	r3, r2, #3
   40d4e:	2b04      	cmp	r3, #4
   40d50:	d820      	bhi.n	40d94 <cbvprintf+0x458>
   40d52:	e8df f003 	tbb	[pc, r3]
   40d56:	0703      	.short	0x0703
   40d58:	1f07      	.short	0x1f07
   40d5a:	1f          	.byte	0x1f
   40d5b:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   40d5c:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   40d60:	17c1      	asrs	r1, r0, #31
   40d62:	e004      	b.n	40d6e <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   40d64:	3407      	adds	r4, #7
   40d66:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   40d6a:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   40d6e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   40d72:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40d76:	f013 0603 	ands.w	r6, r3, #3
   40d7a:	d054      	beq.n	40e26 <cbvprintf+0x4ea>
			OUTS(sp, fp);
   40d7c:	463b      	mov	r3, r7
   40d7e:	4652      	mov	r2, sl
   40d80:	4659      	mov	r1, fp
   40d82:	9802      	ldr	r0, [sp, #8]
   40d84:	f006 fdb9 	bl	478fa <outs>
   40d88:	2800      	cmp	r0, #0
   40d8a:	f2c0 8143 	blt.w	41014 <cbvprintf+0x6d8>
   40d8e:	4405      	add	r5, r0
			continue;
   40d90:	46ba      	mov	sl, r7
   40d92:	e5db      	b.n	4094c <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40d94:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   40d98:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40d9a:	ea4f 71e0 	mov.w	r1, r0, asr #31
   40d9e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   40da2:	d105      	bne.n	40db0 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   40da4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   40da8:	930a      	str	r3, [sp, #40]	; 0x28
   40daa:	2300      	movs	r3, #0
   40dac:	930b      	str	r3, [sp, #44]	; 0x2c
   40dae:	e7e0      	b.n	40d72 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   40db0:	2a02      	cmp	r2, #2
   40db2:	d1de      	bne.n	40d72 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   40db4:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   40db8:	e7d2      	b.n	40d60 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   40dba:	2b02      	cmp	r3, #2
   40dbc:	d123      	bne.n	40e06 <cbvprintf+0x4ca>
			switch (length_mod) {
   40dbe:	1ed3      	subs	r3, r2, #3
   40dc0:	2b04      	cmp	r3, #4
   40dc2:	d813      	bhi.n	40dec <cbvprintf+0x4b0>
   40dc4:	e8df f003 	tbb	[pc, r3]
   40dc8:	120a0a03 	.word	0x120a0a03
   40dcc:	12          	.byte	0x12
   40dcd:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   40dce:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   40dd0:	6820      	ldr	r0, [r4, #0]
   40dd2:	1d23      	adds	r3, r4, #4
   40dd4:	900a      	str	r0, [sp, #40]	; 0x28
   40dd6:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   40dd8:	461c      	mov	r4, r3
   40dda:	e7ca      	b.n	40d72 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   40ddc:	3407      	adds	r4, #7
   40dde:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   40de2:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   40de6:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   40dea:	e7f5      	b.n	40dd8 <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   40dec:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   40df0:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   40df2:	930a      	str	r3, [sp, #40]	; 0x28
   40df4:	f04f 0300 	mov.w	r3, #0
   40df8:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   40dfa:	d0d3      	beq.n	40da4 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   40dfc:	2a02      	cmp	r2, #2
   40dfe:	d1b8      	bne.n	40d72 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   40e00:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   40e04:	e7d0      	b.n	40da8 <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   40e06:	2b04      	cmp	r3, #4
   40e08:	d107      	bne.n	40e1a <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   40e0a:	3407      	adds	r4, #7
   40e0c:	f024 0407 	bic.w	r4, r4, #7
   40e10:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   40e14:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   40e18:	e7ab      	b.n	40d72 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   40e1a:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   40e1c:	bf04      	itt	eq
   40e1e:	f854 3b04 	ldreq.w	r3, [r4], #4
   40e22:	930a      	streq	r3, [sp, #40]	; 0x28
   40e24:	e7a5      	b.n	40d72 <cbvprintf+0x436>
		switch (conv->specifier) {
   40e26:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   40e2a:	2878      	cmp	r0, #120	; 0x78
   40e2c:	d8b0      	bhi.n	40d90 <cbvprintf+0x454>
   40e2e:	2862      	cmp	r0, #98	; 0x62
   40e30:	d822      	bhi.n	40e78 <cbvprintf+0x53c>
   40e32:	2825      	cmp	r0, #37	; 0x25
   40e34:	f43f ad93 	beq.w	4095e <cbvprintf+0x22>
   40e38:	2858      	cmp	r0, #88	; 0x58
   40e3a:	d1a9      	bne.n	40d90 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   40e3c:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   40e40:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40e44:	9300      	str	r3, [sp, #0]
   40e46:	aa0c      	add	r2, sp, #48	; 0x30
   40e48:	ab04      	add	r3, sp, #16
   40e4a:	f006 fd0b 	bl	47864 <encode_uint>
   40e4e:	4682      	mov	sl, r0
			if (precision >= 0) {
   40e50:	f1b8 0f00 	cmp.w	r8, #0
   40e54:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   40e58:	db0c      	blt.n	40e74 <cbvprintf+0x538>
				conv->flag_zero = false;
   40e5a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   40e5e:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   40e62:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   40e66:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   40e68:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   40e6c:	d902      	bls.n	40e74 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   40e6e:	eba8 0303 	sub.w	r3, r8, r3
   40e72:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   40e74:	4680      	mov	r8, r0
   40e76:	e03d      	b.n	40ef4 <cbvprintf+0x5b8>
   40e78:	3863      	subs	r0, #99	; 0x63
   40e7a:	2815      	cmp	r0, #21
   40e7c:	d888      	bhi.n	40d90 <cbvprintf+0x454>
   40e7e:	a101      	add	r1, pc, #4	; (adr r1, 40e84 <cbvprintf+0x548>)
   40e80:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   40e84:	00040f05 	.word	0x00040f05
   40e88:	00040f69 	.word	0x00040f69
   40e8c:	00040d91 	.word	0x00040d91
   40e90:	00040d91 	.word	0x00040d91
   40e94:	00040d91 	.word	0x00040d91
   40e98:	00040d91 	.word	0x00040d91
   40e9c:	00040f69 	.word	0x00040f69
   40ea0:	00040d91 	.word	0x00040d91
   40ea4:	00040d91 	.word	0x00040d91
   40ea8:	00040d91 	.word	0x00040d91
   40eac:	00040d91 	.word	0x00040d91
   40eb0:	00040fc7 	.word	0x00040fc7
   40eb4:	00040f95 	.word	0x00040f95
   40eb8:	00040f99 	.word	0x00040f99
   40ebc:	00040d91 	.word	0x00040d91
   40ec0:	00040d91 	.word	0x00040d91
   40ec4:	00040edd 	.word	0x00040edd
   40ec8:	00040d91 	.word	0x00040d91
   40ecc:	00040f95 	.word	0x00040f95
   40ed0:	00040d91 	.word	0x00040d91
   40ed4:	00040d91 	.word	0x00040d91
   40ed8:	00040f95 	.word	0x00040f95
			if (precision >= 0) {
   40edc:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   40ee0:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   40ee4:	db0a      	blt.n	40efc <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   40ee6:	4641      	mov	r1, r8
   40ee8:	4650      	mov	r0, sl
   40eea:	f007 f874 	bl	47fd6 <strnlen>
		char sign = 0;
   40eee:	2600      	movs	r6, #0
			bpe = bps + len;
   40ef0:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   40ef4:	f1ba 0f00 	cmp.w	sl, #0
   40ef8:	d10c      	bne.n	40f14 <cbvprintf+0x5d8>
   40efa:	e749      	b.n	40d90 <cbvprintf+0x454>
				len = strlen(bps);
   40efc:	4650      	mov	r0, sl
   40efe:	f007 f863 	bl	47fc8 <strlen>
   40f02:	e7f4      	b.n	40eee <cbvprintf+0x5b2>
			break;
   40f04:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40f06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   40f08:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40f0c:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   40f10:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   40f14:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   40f18:	b106      	cbz	r6, 40f1c <cbvprintf+0x5e0>
			nj_len += 1U;
   40f1a:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   40f1c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   40f20:	06d0      	lsls	r0, r2, #27
   40f22:	d56b      	bpl.n	40ffc <cbvprintf+0x6c0>
			nj_len += 2U;
   40f24:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   40f26:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   40f28:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   40f2a:	bf48      	it	mi
   40f2c:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   40f2e:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   40f30:	bf48      	it	mi
   40f32:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   40f34:	f1b9 0f00 	cmp.w	r9, #0
   40f38:	dd79      	ble.n	4102e <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   40f3a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   40f3e:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   40f42:	f3c2 0380 	ubfx	r3, r2, #2, #1
   40f46:	9303      	str	r3, [sp, #12]
   40f48:	0753      	lsls	r3, r2, #29
   40f4a:	d470      	bmi.n	4102e <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   40f4c:	0650      	lsls	r0, r2, #25
   40f4e:	d564      	bpl.n	4101a <cbvprintf+0x6de>
					if (sign != 0) {
   40f50:	b146      	cbz	r6, 40f64 <cbvprintf+0x628>
						OUTC(sign);
   40f52:	4659      	mov	r1, fp
   40f54:	4630      	mov	r0, r6
   40f56:	9b02      	ldr	r3, [sp, #8]
   40f58:	4798      	blx	r3
   40f5a:	2800      	cmp	r0, #0
   40f5c:	db5a      	blt.n	41014 <cbvprintf+0x6d8>
						sign = 0;
   40f5e:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   40f60:	3501      	adds	r5, #1
						sign = 0;
   40f62:	461e      	mov	r6, r3
					pad = '0';
   40f64:	2330      	movs	r3, #48	; 0x30
   40f66:	e059      	b.n	4101c <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   40f68:	071e      	lsls	r6, r3, #28
   40f6a:	d411      	bmi.n	40f90 <cbvprintf+0x654>
				sign = ' ';
   40f6c:	f013 0610 	ands.w	r6, r3, #16
   40f70:	bf18      	it	ne
   40f72:	2620      	movne	r6, #32
			sint = value->sint;
   40f74:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   40f78:	2a00      	cmp	r2, #0
   40f7a:	f173 0100 	sbcs.w	r1, r3, #0
   40f7e:	f6bf af5d 	bge.w	40e3c <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   40f82:	4252      	negs	r2, r2
   40f84:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   40f88:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   40f8a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   40f8e:	e755      	b.n	40e3c <cbvprintf+0x500>
				sign = '+';
   40f90:	262b      	movs	r6, #43	; 0x2b
   40f92:	e7ef      	b.n	40f74 <cbvprintf+0x638>
		switch (conv->specifier) {
   40f94:	2600      	movs	r6, #0
   40f96:	e751      	b.n	40e3c <cbvprintf+0x500>
			if (value->ptr != NULL) {
   40f98:	980a      	ldr	r0, [sp, #40]	; 0x28
   40f9a:	b348      	cbz	r0, 40ff0 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   40f9c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40fa0:	9300      	str	r3, [sp, #0]
   40fa2:	2100      	movs	r1, #0
   40fa4:	ab04      	add	r3, sp, #16
   40fa6:	aa0c      	add	r2, sp, #48	; 0x30
   40fa8:	f006 fc5c 	bl	47864 <encode_uint>
				conv->altform_0c = true;
   40fac:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   40fb0:	4682      	mov	sl, r0
				conv->altform_0c = true;
   40fb2:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   40fb6:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   40fba:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   40fbe:	2600      	movs	r6, #0
				conv->altform_0c = true;
   40fc0:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   40fc4:	e744      	b.n	40e50 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   40fc6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   40fc8:	2a07      	cmp	r2, #7
   40fca:	f63f aee1 	bhi.w	40d90 <cbvprintf+0x454>
   40fce:	e8df f002 	tbb	[pc, r2]
   40fd2:	040d      	.short	0x040d
   40fd4:	08080d06 	.word	0x08080d06
   40fd8:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   40fda:	701d      	strb	r5, [r3, #0]
		break;
   40fdc:	e6d8      	b.n	40d90 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   40fde:	801d      	strh	r5, [r3, #0]
		break;
   40fe0:	e6d6      	b.n	40d90 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   40fe2:	4628      	mov	r0, r5
   40fe4:	17e9      	asrs	r1, r5, #31
   40fe6:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   40fea:	e6d1      	b.n	40d90 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   40fec:	601d      	str	r5, [r3, #0]
		break;
   40fee:	e6cf      	b.n	40d90 <cbvprintf+0x454>
			bpe = bps + 5;
   40ff0:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 410b8 <cbvprintf+0x77c>
   40ff4:	4606      	mov	r6, r0
			bps = "(nil)";
   40ff6:	f1a8 0a05 	sub.w	sl, r8, #5
   40ffa:	e78b      	b.n	40f14 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   40ffc:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   40ffe:	bf48      	it	mi
   41000:	3301      	addmi	r3, #1
   41002:	e790      	b.n	40f26 <cbvprintf+0x5ea>
					OUTC(pad);
   41004:	4618      	mov	r0, r3
   41006:	9303      	str	r3, [sp, #12]
   41008:	4659      	mov	r1, fp
   4100a:	9b02      	ldr	r3, [sp, #8]
   4100c:	4798      	blx	r3
   4100e:	2800      	cmp	r0, #0
   41010:	9b03      	ldr	r3, [sp, #12]
   41012:	da04      	bge.n	4101e <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   41014:	b011      	add	sp, #68	; 0x44
   41016:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   4101a:	2320      	movs	r3, #32
   4101c:	444d      	add	r5, r9
   4101e:	464a      	mov	r2, r9
				while (width-- > 0) {
   41020:	2a00      	cmp	r2, #0
   41022:	eba5 0109 	sub.w	r1, r5, r9
   41026:	f109 39ff 	add.w	r9, r9, #4294967295
   4102a:	dceb      	bgt.n	41004 <cbvprintf+0x6c8>
   4102c:	460d      	mov	r5, r1
		if (sign != 0) {
   4102e:	b136      	cbz	r6, 4103e <cbvprintf+0x702>
			OUTC(sign);
   41030:	4659      	mov	r1, fp
   41032:	4630      	mov	r0, r6
   41034:	9b02      	ldr	r3, [sp, #8]
   41036:	4798      	blx	r3
   41038:	2800      	cmp	r0, #0
   4103a:	dbeb      	blt.n	41014 <cbvprintf+0x6d8>
   4103c:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   4103e:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   41042:	06d9      	lsls	r1, r3, #27
   41044:	d401      	bmi.n	4104a <cbvprintf+0x70e>
   41046:	071a      	lsls	r2, r3, #28
   41048:	d506      	bpl.n	41058 <cbvprintf+0x71c>
				OUTC('0');
   4104a:	4659      	mov	r1, fp
   4104c:	2030      	movs	r0, #48	; 0x30
   4104e:	9b02      	ldr	r3, [sp, #8]
   41050:	4798      	blx	r3
   41052:	2800      	cmp	r0, #0
   41054:	dbde      	blt.n	41014 <cbvprintf+0x6d8>
   41056:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   41058:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   4105c:	06db      	lsls	r3, r3, #27
   4105e:	d507      	bpl.n	41070 <cbvprintf+0x734>
				OUTC(conv->specifier);
   41060:	4659      	mov	r1, fp
   41062:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   41066:	9b02      	ldr	r3, [sp, #8]
   41068:	4798      	blx	r3
   4106a:	2800      	cmp	r0, #0
   4106c:	dbd2      	blt.n	41014 <cbvprintf+0x6d8>
   4106e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   41070:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   41072:	442e      	add	r6, r5
   41074:	1b73      	subs	r3, r6, r5
   41076:	2b00      	cmp	r3, #0
   41078:	dc16      	bgt.n	410a8 <cbvprintf+0x76c>
			OUTS(bps, bpe);
   4107a:	4643      	mov	r3, r8
   4107c:	4652      	mov	r2, sl
   4107e:	4659      	mov	r1, fp
   41080:	9802      	ldr	r0, [sp, #8]
   41082:	f006 fc3a 	bl	478fa <outs>
   41086:	2800      	cmp	r0, #0
   41088:	dbc4      	blt.n	41014 <cbvprintf+0x6d8>
   4108a:	4405      	add	r5, r0
		while (width > 0) {
   4108c:	44a9      	add	r9, r5
   4108e:	eba9 0305 	sub.w	r3, r9, r5
   41092:	2b00      	cmp	r3, #0
   41094:	f77f ae7c 	ble.w	40d90 <cbvprintf+0x454>
			OUTC(' ');
   41098:	4659      	mov	r1, fp
   4109a:	2020      	movs	r0, #32
   4109c:	9b02      	ldr	r3, [sp, #8]
   4109e:	4798      	blx	r3
   410a0:	2800      	cmp	r0, #0
   410a2:	dbb7      	blt.n	41014 <cbvprintf+0x6d8>
   410a4:	3501      	adds	r5, #1
			--width;
   410a6:	e7f2      	b.n	4108e <cbvprintf+0x752>
				OUTC('0');
   410a8:	4659      	mov	r1, fp
   410aa:	2030      	movs	r0, #48	; 0x30
   410ac:	9b02      	ldr	r3, [sp, #8]
   410ae:	4798      	blx	r3
   410b0:	2800      	cmp	r0, #0
   410b2:	dbaf      	blt.n	41014 <cbvprintf+0x6d8>
   410b4:	3501      	adds	r5, #1
   410b6:	e7dd      	b.n	41074 <cbvprintf+0x738>
   410b8:	00048fe5 	.word	0x00048fe5

000410bc <nordicsemi_nrf91_init>:
   410bc:	f04f 0220 	mov.w	r2, #32
   410c0:	f3ef 8311 	mrs	r3, BASEPRI
   410c4:	f382 8812 	msr	BASEPRI_MAX, r2
   410c8:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   410cc:	2101      	movs	r1, #1
   410ce:	4a04      	ldr	r2, [pc, #16]	; (410e0 <nordicsemi_nrf91_init+0x24>)
   410d0:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   410d4:	f383 8811 	msr	BASEPRI, r3
   410d8:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   410dc:	2000      	movs	r0, #0
   410de:	4770      	bx	lr
   410e0:	40039000 	.word	0x40039000

000410e4 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   410e4:	b120      	cbz	r0, 410f0 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   410e6:	4b03      	ldr	r3, [pc, #12]	; (410f4 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   410e8:	0180      	lsls	r0, r0, #6
   410ea:	f043 0301 	orr.w	r3, r3, #1
   410ee:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   410f0:	4770      	bx	lr
   410f2:	bf00      	nop
   410f4:	00048da0 	.word	0x00048da0

000410f8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
   410f8:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   410fa:	2200      	movs	r2, #0
{
   410fc:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
   410fe:	490f      	ldr	r1, [pc, #60]	; (4113c <enable_logger+0x44>)
   41100:	480f      	ldr	r0, [pc, #60]	; (41140 <enable_logger+0x48>)
   41102:	f007 fc67 	bl	489d4 <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   41106:	2200      	movs	r2, #0
   41108:	2300      	movs	r3, #0
   4110a:	2400      	movs	r4, #0
   4110c:	e9cd 2306 	strd	r2, r3, [sp, #24]
   41110:	230e      	movs	r3, #14
   41112:	4d0c      	ldr	r5, [pc, #48]	; (41144 <enable_logger+0x4c>)
   41114:	e9cd 3403 	strd	r3, r4, [sp, #12]
   41118:	f44f 7240 	mov.w	r2, #768	; 0x300
   4111c:	4628      	mov	r0, r5
   4111e:	e9cd 4401 	strd	r4, r4, [sp, #4]
   41122:	4b09      	ldr	r3, [pc, #36]	; (41148 <enable_logger+0x50>)
   41124:	4909      	ldr	r1, [pc, #36]	; (4114c <enable_logger+0x54>)
   41126:	9400      	str	r4, [sp, #0]
   41128:	f005 f918 	bl	4635c <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
   4112c:	4908      	ldr	r1, [pc, #32]	; (41150 <enable_logger+0x58>)
   4112e:	4628      	mov	r0, r5
   41130:	f007 facc 	bl	486cc <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   41134:	4620      	mov	r0, r4
   41136:	b009      	add	sp, #36	; 0x24
   41138:	bd30      	pop	{r4, r5, pc}
   4113a:	bf00      	nop
   4113c:	00041155 	.word	0x00041155
   41140:	2001a5f0 	.word	0x2001a5f0
   41144:	2001a628 	.word	0x2001a628
   41148:	00041535 	.word	0x00041535
   4114c:	20020aa0 	.word	0x20020aa0
   41150:	00048fea 	.word	0x00048fea

00041154 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   41154:	4801      	ldr	r0, [pc, #4]	; (4115c <log_process_thread_timer_expiry_fn+0x8>)
   41156:	f005 ba4f 	b.w	465f8 <z_impl_k_sem_give>
   4115a:	bf00      	nop
   4115c:	2001a5e0 	.word	0x2001a5e0

00041160 <log_core_init>:
	panic_mode = false;
   41160:	2300      	movs	r3, #0
   41162:	4a0c      	ldr	r2, [pc, #48]	; (41194 <log_core_init+0x34>)
{
   41164:	b510      	push	{r4, lr}
	panic_mode = false;
   41166:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
   41168:	4a0b      	ldr	r2, [pc, #44]	; (41198 <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
   4116a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	dropped_cnt = 0;
   4116e:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
   41170:	4b0a      	ldr	r3, [pc, #40]	; (4119c <log_core_init+0x3c>)
   41172:	4a0b      	ldr	r2, [pc, #44]	; (411a0 <log_core_init+0x40>)
   41174:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   41176:	f000 fcb5 	bl	41ae4 <log_output_timestamp_freq_set>
		log_msg_pool_init();
   4117a:	f000 fa55 	bl	41628 <log_msg_pool_init>
		log_list_init(&list);
   4117e:	4809      	ldr	r0, [pc, #36]	; (411a4 <log_core_init+0x44>)
   41180:	f006 fbf0 	bl	47964 <log_list_init>
}
   41184:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   41188:	2304      	movs	r3, #4
   4118a:	2228      	movs	r2, #40	; 0x28
   4118c:	4906      	ldr	r1, [pc, #24]	; (411a8 <log_core_init+0x48>)
   4118e:	4807      	ldr	r0, [pc, #28]	; (411ac <log_core_init+0x4c>)
   41190:	f007 ba52 	b.w	48638 <k_mem_slab_init>
   41194:	2001ad43 	.word	0x2001ad43
   41198:	2001a7ec 	.word	0x2001a7ec
   4119c:	2001a504 	.word	0x2001a504
   411a0:	000479a3 	.word	0x000479a3
   411a4:	2001a7f4 	.word	0x2001a7f4
   411a8:	20023ae0 	.word	0x20023ae0
   411ac:	2001a7fc 	.word	0x2001a7fc

000411b0 <log_init>:
{
   411b0:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   411b2:	4b10      	ldr	r3, [pc, #64]	; (411f4 <log_init+0x44>)
   411b4:	e8d3 5fef 	ldaex	r5, [r3]
   411b8:	1c6a      	adds	r2, r5, #1
   411ba:	e8c3 2fe1 	stlex	r1, r2, [r3]
   411be:	2900      	cmp	r1, #0
   411c0:	d1f8      	bne.n	411b4 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
   411c2:	b92d      	cbnz	r5, 411d0 <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   411c4:	4c0c      	ldr	r4, [pc, #48]	; (411f8 <log_init+0x48>)
   411c6:	4e0d      	ldr	r6, [pc, #52]	; (411fc <log_init+0x4c>)
   411c8:	1b36      	subs	r6, r6, r4
   411ca:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   411cc:	42b5      	cmp	r5, r6
   411ce:	db00      	blt.n	411d2 <log_init+0x22>
}
   411d0:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   411d2:	7b23      	ldrb	r3, [r4, #12]
   411d4:	b153      	cbz	r3, 411ec <log_init+0x3c>
			if (backend->api->init != NULL) {
   411d6:	6823      	ldr	r3, [r4, #0]
   411d8:	699b      	ldr	r3, [r3, #24]
   411da:	b10b      	cbz	r3, 411e0 <log_init+0x30>
				backend->api->init(backend);
   411dc:	4620      	mov	r0, r4
   411de:	4798      	blx	r3
			log_backend_enable(backend,
   411e0:	6863      	ldr	r3, [r4, #4]
   411e2:	2204      	movs	r2, #4
   411e4:	4620      	mov	r0, r4
   411e6:	6819      	ldr	r1, [r3, #0]
   411e8:	f000 fa10 	bl	4160c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   411ec:	3501      	adds	r5, #1
   411ee:	3410      	adds	r4, #16
   411f0:	e7ec      	b.n	411cc <log_init+0x1c>
   411f2:	bf00      	nop
   411f4:	2001a7f0 	.word	0x2001a7f0
   411f8:	00048d60 	.word	0x00048d60
   411fc:	00048d80 	.word	0x00048d80

00041200 <get_msg>:
{
   41200:	b510      	push	{r4, lr}
	__asm__ volatile(
   41202:	f04f 0320 	mov.w	r3, #32
   41206:	f3ef 8411 	mrs	r4, BASEPRI
   4120a:	f383 8812 	msr	BASEPRI_MAX, r3
   4120e:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
   41212:	4804      	ldr	r0, [pc, #16]	; (41224 <get_msg+0x24>)
   41214:	f006 fbb6 	bl	47984 <log_list_head_get>
	__asm__ volatile(
   41218:	f384 8811 	msr	BASEPRI, r4
   4121c:	f3bf 8f6f 	isb	sy
}
   41220:	bd10      	pop	{r4, pc}
   41222:	bf00      	nop
   41224:	2001a7f4 	.word	0x2001a7f4

00041228 <z_log_notify_backend_enabled>:
{
   41228:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
   4122a:	4c04      	ldr	r4, [pc, #16]	; (4123c <z_log_notify_backend_enabled+0x14>)
   4122c:	7822      	ldrb	r2, [r4, #0]
   4122e:	b912      	cbnz	r2, 41236 <z_log_notify_backend_enabled+0xe>
   41230:	4803      	ldr	r0, [pc, #12]	; (41240 <z_log_notify_backend_enabled+0x18>)
   41232:	f005 f9e1 	bl	465f8 <z_impl_k_sem_give>
	backend_attached = true;
   41236:	2301      	movs	r3, #1
   41238:	7023      	strb	r3, [r4, #0]
}
   4123a:	bd10      	pop	{r4, pc}
   4123c:	2001ad42 	.word	0x2001ad42
   41240:	2001a5e0 	.word	0x2001a5e0

00041244 <z_log_dropped>:
   41244:	4b08      	ldr	r3, [pc, #32]	; (41268 <z_log_dropped+0x24>)
   41246:	e8d3 2fef 	ldaex	r2, [r3]
   4124a:	3201      	adds	r2, #1
   4124c:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41250:	2900      	cmp	r1, #0
   41252:	d1f8      	bne.n	41246 <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41254:	4b05      	ldr	r3, [pc, #20]	; (4126c <z_log_dropped+0x28>)
   41256:	e8d3 2fef 	ldaex	r2, [r3]
   4125a:	3a01      	subs	r2, #1
   4125c:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41260:	2900      	cmp	r1, #0
   41262:	d1f8      	bne.n	41256 <z_log_dropped+0x12>
}
   41264:	4770      	bx	lr
   41266:	bf00      	nop
   41268:	2001a7ec 	.word	0x2001a7ec
   4126c:	2001a7e8 	.word	0x2001a7e8

00041270 <z_log_dropped_read_and_clear>:
}
   41270:	2000      	movs	r0, #0
   41272:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   41274:	4b03      	ldr	r3, [pc, #12]	; (41284 <z_log_dropped_read_and_clear+0x14>)
   41276:	e8d3 0fef 	ldaex	r0, [r3]
   4127a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4127e:	2900      	cmp	r1, #0
   41280:	d1f9      	bne.n	41276 <z_log_dropped_read_and_clear+0x6>
   41282:	4770      	bx	lr
   41284:	2001a7ec 	.word	0x2001a7ec

00041288 <dropped_notify>:
{
   41288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
   4128a:	f7ff fff1 	bl	41270 <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
   4128e:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
   41290:	4607      	mov	r7, r0
   41292:	4c09      	ldr	r4, [pc, #36]	; (412b8 <dropped_notify+0x30>)
   41294:	4d09      	ldr	r5, [pc, #36]	; (412bc <dropped_notify+0x34>)
   41296:	1b2d      	subs	r5, r5, r4
   41298:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   4129a:	42ae      	cmp	r6, r5
   4129c:	db00      	blt.n	412a0 <dropped_notify+0x18>
}
   4129e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   412a0:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   412a2:	795b      	ldrb	r3, [r3, #5]
   412a4:	b12b      	cbz	r3, 412b2 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
   412a6:	6823      	ldr	r3, [r4, #0]
   412a8:	691b      	ldr	r3, [r3, #16]
   412aa:	b113      	cbz	r3, 412b2 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
   412ac:	4639      	mov	r1, r7
   412ae:	4620      	mov	r0, r4
   412b0:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   412b2:	3601      	adds	r6, #1
   412b4:	3410      	adds	r4, #16
   412b6:	e7f0      	b.n	4129a <dropped_notify+0x12>
   412b8:	00048d60 	.word	0x00048d60
   412bc:	00048d80 	.word	0x00048d80

000412c0 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   412c0:	4b14      	ldr	r3, [pc, #80]	; (41314 <z_log_strdup+0x54>)
{
   412c2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
   412c4:	4298      	cmp	r0, r3
{
   412c6:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   412c8:	d302      	bcc.n	412d0 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   412ca:	4b13      	ldr	r3, [pc, #76]	; (41318 <z_log_strdup+0x58>)
   412cc:	4298      	cmp	r0, r3
   412ce:	d31c      	bcc.n	4130a <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   412d0:	2200      	movs	r2, #0
   412d2:	2300      	movs	r3, #0
   412d4:	4811      	ldr	r0, [pc, #68]	; (4131c <z_log_strdup+0x5c>)
   412d6:	a901      	add	r1, sp, #4
   412d8:	f004 ffe0 	bl	4629c <k_mem_slab_alloc>
	if (err != 0) {
   412dc:	4605      	mov	r5, r0
   412de:	b9b8      	cbnz	r0, 41310 <z_log_strdup+0x50>
   412e0:	2201      	movs	r2, #1
   412e2:	9b01      	ldr	r3, [sp, #4]
   412e4:	e8d3 1fef 	ldaex	r1, [r3]
   412e8:	e8c3 2fe0 	stlex	r0, r2, [r3]
   412ec:	2800      	cmp	r0, #0
   412ee:	d1f9      	bne.n	412e4 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   412f0:	9801      	ldr	r0, [sp, #4]
   412f2:	4621      	mov	r1, r4
   412f4:	221f      	movs	r2, #31
   412f6:	3004      	adds	r0, #4
   412f8:	f006 fe53 	bl	47fa2 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   412fc:	237e      	movs	r3, #126	; 0x7e
   412fe:	9c01      	ldr	r4, [sp, #4]
   41300:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   41304:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   41308:	3404      	adds	r4, #4
}
   4130a:	4620      	mov	r0, r4
   4130c:	b003      	add	sp, #12
   4130e:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   41310:	4c03      	ldr	r4, [pc, #12]	; (41320 <z_log_strdup+0x60>)
   41312:	e7fa      	b.n	4130a <z_log_strdup+0x4a>
   41314:	00048a38 	.word	0x00048a38
   41318:	000497dc 	.word	0x000497dc
   4131c:	2001a7fc 	.word	0x2001a7fc
   41320:	00048ff2 	.word	0x00048ff2

00041324 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
   41324:	b148      	cbz	r0, 4133a <log_is_strdup+0x16>
   41326:	4b05      	ldr	r3, [pc, #20]	; (4133c <log_is_strdup+0x18>)
   41328:	4298      	cmp	r0, r3
   4132a:	d305      	bcc.n	41338 <log_is_strdup+0x14>
   4132c:	33a0      	adds	r3, #160	; 0xa0
   4132e:	4298      	cmp	r0, r3
   41330:	bf2c      	ite	cs
   41332:	2000      	movcs	r0, #0
   41334:	2001      	movcc	r0, #1
   41336:	4770      	bx	lr
   41338:	2000      	movs	r0, #0
}
   4133a:	4770      	bx	lr
   4133c:	20023ae0 	.word	0x20023ae0

00041340 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
   41340:	4b41      	ldr	r3, [pc, #260]	; (41448 <z_impl_log_process+0x108>)
{
   41342:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   41346:	781b      	ldrb	r3, [r3, #0]
{
   41348:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   4134a:	b903      	cbnz	r3, 4134e <z_impl_log_process+0xe>
   4134c:	b1a0      	cbz	r0, 41378 <z_impl_log_process+0x38>
	msg = get_msg();
   4134e:	f7ff ff57 	bl	41200 <get_msg>
	if (msg.msg) {
   41352:	4605      	mov	r5, r0
   41354:	b118      	cbz	r0, 4135e <z_impl_log_process+0x1e>
		if (!bypass) {
   41356:	b19c      	cbz	r4, 41380 <z_impl_log_process+0x40>
			log_msg_put(msg.msg);
   41358:	4628      	mov	r0, r5
   4135a:	f006 fc1f 	bl	47b9c <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
   4135e:	b92c      	cbnz	r4, 4136c <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
   41360:	4b3a      	ldr	r3, [pc, #232]	; (4144c <z_impl_log_process+0x10c>)
	if (!bypass && z_log_dropped_pending()) {
   41362:	681b      	ldr	r3, [r3, #0]
   41364:	2b00      	cmp	r3, #0
   41366:	dd01      	ble.n	4136c <z_impl_log_process+0x2c>
		dropped_notify();
   41368:	f7ff ff8e 	bl	41288 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   4136c:	4838      	ldr	r0, [pc, #224]	; (41450 <z_impl_log_process+0x110>)
   4136e:	f006 fb07 	bl	47980 <log_list_head_peek>
   41372:	1e04      	subs	r4, r0, #0
   41374:	bf18      	it	ne
   41376:	2401      	movne	r4, #1
}
   41378:	4620      	mov	r0, r4
   4137a:	b003      	add	sp, #12
   4137c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41380:	4b34      	ldr	r3, [pc, #208]	; (41454 <z_impl_log_process+0x114>)
   41382:	e8d3 2fef 	ldaex	r2, [r3]
   41386:	3a01      	subs	r2, #1
   41388:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4138c:	2900      	cmp	r1, #0
   4138e:	d1f8      	bne.n	41382 <z_impl_log_process+0x42>
		    !panic_mode) {
   41390:	4b31      	ldr	r3, [pc, #196]	; (41458 <z_impl_log_process+0x118>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
   41392:	781b      	ldrb	r3, [r3, #0]
   41394:	b9bb      	cbnz	r3, 413c6 <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41396:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   41398:	07db      	lsls	r3, r3, #31
   4139a:	d414      	bmi.n	413c6 <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
   4139c:	f006 fc0d 	bl	47bba <log_msg_str_get>
   413a0:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
   413a2:	4628      	mov	r0, r5
   413a4:	f006 fbd8 	bl	47b58 <log_msg_nargs_get>
   413a8:	4601      	mov	r1, r0
   413aa:	4640      	mov	r0, r8
   413ac:	f006 fafd 	bl	479aa <z_log_get_s_mask>
   413b0:	4606      	mov	r6, r0
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
   413b2:	4b2a      	ldr	r3, [pc, #168]	; (4145c <z_impl_log_process+0x11c>)
   413b4:	4a2a      	ldr	r2, [pc, #168]	; (41460 <z_impl_log_process+0x120>)
		if (!is_rodata(str) && !log_is_strdup(str) &&
   413b6:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 41474 <z_impl_log_process+0x134>
   413ba:	1a9b      	subs	r3, r3, r2
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   413bc:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 41478 <z_impl_log_process+0x138>
   413c0:	ea4f 09d3 	mov.w	r9, r3, lsr #3
	while (mask) {
   413c4:	b936      	cbnz	r6, 413d4 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
   413c6:	4e27      	ldr	r6, [pc, #156]	; (41464 <z_impl_log_process+0x124>)
   413c8:	4f27      	ldr	r7, [pc, #156]	; (41468 <z_impl_log_process+0x128>)
   413ca:	f04f 0800 	mov.w	r8, #0
   413ce:	1bbf      	subs	r7, r7, r6
   413d0:	113f      	asrs	r7, r7, #4
   413d2:	e036      	b.n	41442 <z_impl_log_process+0x102>
		idx = 31 - __builtin_clz(mask);
   413d4:	fab6 f786 	clz	r7, r6
   413d8:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   413dc:	4639      	mov	r1, r7
   413de:	4628      	mov	r0, r5
   413e0:	f006 fbbd 	bl	47b5e <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   413e4:	4b21      	ldr	r3, [pc, #132]	; (4146c <z_impl_log_process+0x12c>)
		str = (const char *)log_msg_arg_get(msg, idx);
   413e6:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   413e8:	4298      	cmp	r0, r3
   413ea:	d302      	bcc.n	413f2 <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   413ec:	4b20      	ldr	r3, [pc, #128]	; (41470 <z_impl_log_process+0x130>)
   413ee:	4298      	cmp	r0, r3
   413f0:	d316      	bcc.n	41420 <z_impl_log_process+0xe0>
   413f2:	4610      	mov	r0, r2
   413f4:	f7ff ff96 	bl	41324 <log_is_strdup>
   413f8:	b990      	cbnz	r0, 41420 <z_impl_log_process+0xe0>
   413fa:	4552      	cmp	r2, sl
   413fc:	d010      	beq.n	41420 <z_impl_log_process+0xe0>
	return msg->hdr.ids.source_id;
   413fe:	8969      	ldrh	r1, [r5, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   41400:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41404:	f000 f8f4 	bl	415f0 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   41408:	ea4f 1389 	mov.w	r3, r9, lsl #6
   4140c:	f043 0301 	orr.w	r3, r3, #1
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   41410:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   41412:	f8ad 3000 	strh.w	r3, [sp]
   41416:	4639      	mov	r1, r7
   41418:	4643      	mov	r3, r8
   4141a:	4658      	mov	r0, fp
   4141c:	f006 fb1f 	bl	47a5e <log_3>
		mask &= ~BIT(idx);
   41420:	2301      	movs	r3, #1
   41422:	fa03 f707 	lsl.w	r7, r3, r7
   41426:	ea26 0607 	bic.w	r6, r6, r7
   4142a:	e7cb      	b.n	413c4 <z_impl_log_process+0x84>
	return backend->cb->active;
   4142c:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
   4142e:	795b      	ldrb	r3, [r3, #5]
   41430:	b123      	cbz	r3, 4143c <z_impl_log_process+0xfc>
	backend->api->put(backend, msg);
   41432:	6833      	ldr	r3, [r6, #0]
   41434:	4629      	mov	r1, r5
   41436:	4630      	mov	r0, r6
   41438:	685b      	ldr	r3, [r3, #4]
   4143a:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   4143c:	f108 0801 	add.w	r8, r8, #1
   41440:	3610      	adds	r6, #16
   41442:	45b8      	cmp	r8, r7
   41444:	dbf2      	blt.n	4142c <z_impl_log_process+0xec>
   41446:	e787      	b.n	41358 <z_impl_log_process+0x18>
   41448:	2001ad42 	.word	0x2001ad42
   4144c:	2001a7ec 	.word	0x2001a7ec
   41450:	2001a7f4 	.word	0x2001a7f4
   41454:	2001a7e8 	.word	0x2001a7e8
   41458:	2001ad43 	.word	0x2001ad43
   4145c:	00048d20 	.word	0x00048d20
   41460:	00048d10 	.word	0x00048d10
   41464:	00048d60 	.word	0x00048d60
   41468:	00048d80 	.word	0x00048d80
   4146c:	00048a38 	.word	0x00048a38
   41470:	000497dc 	.word	0x000497dc
   41474:	00048ff2 	.word	0x00048ff2
   41478:	0004900c 	.word	0x0004900c

0004147c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   4147c:	4b26      	ldr	r3, [pc, #152]	; (41518 <msg_finalize+0x9c>)
{
   4147e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
   41480:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   41482:	8141      	strh	r1, [r0, #10]
{
   41484:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
   41486:	4798      	blx	r3
   41488:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4148a:	f04f 0320 	mov.w	r3, #32
   4148e:	f3ef 8511 	mrs	r5, BASEPRI
   41492:	f383 8812 	msr	BASEPRI_MAX, r3
   41496:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   4149a:	4820      	ldr	r0, [pc, #128]	; (4151c <msg_finalize+0xa0>)
   4149c:	4621      	mov	r1, r4
   4149e:	f006 fa65 	bl	4796c <log_list_add_tail>
	__asm__ volatile(
   414a2:	f385 8811 	msr	BASEPRI, r5
   414a6:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   414aa:	4b1d      	ldr	r3, [pc, #116]	; (41520 <msg_finalize+0xa4>)
   414ac:	e8d3 2fef 	ldaex	r2, [r3]
   414b0:	1c51      	adds	r1, r2, #1
   414b2:	e8c3 1fe0 	stlex	r0, r1, [r3]
   414b6:	2800      	cmp	r0, #0
   414b8:	d1f8      	bne.n	414ac <msg_finalize+0x30>
	if (panic_mode) {
   414ba:	4b1a      	ldr	r3, [pc, #104]	; (41524 <msg_finalize+0xa8>)
   414bc:	781b      	ldrb	r3, [r3, #0]
   414be:	b183      	cbz	r3, 414e2 <msg_finalize+0x66>
	__asm__ volatile(
   414c0:	f04f 0320 	mov.w	r3, #32
   414c4:	f3ef 8411 	mrs	r4, BASEPRI
   414c8:	f383 8812 	msr	BASEPRI_MAX, r3
   414cc:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   414d0:	2000      	movs	r0, #0
   414d2:	f7ff ff35 	bl	41340 <z_impl_log_process>
	__asm__ volatile(
   414d6:	f384 8811 	msr	BASEPRI, r4
   414da:	f3bf 8f6f 	isb	sy
}
   414de:	b003      	add	sp, #12
   414e0:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && cnt == 0) {
   414e2:	4b11      	ldr	r3, [pc, #68]	; (41528 <msg_finalize+0xac>)
   414e4:	681b      	ldr	r3, [r3, #0]
   414e6:	2b00      	cmp	r3, #0
   414e8:	d0f9      	beq.n	414de <msg_finalize+0x62>
   414ea:	b952      	cbnz	r2, 41502 <msg_finalize+0x86>
	z_impl_k_timer_start(timer, duration, period);
   414ec:	2200      	movs	r2, #0
   414ee:	2300      	movs	r3, #0
   414f0:	480e      	ldr	r0, [pc, #56]	; (4152c <msg_finalize+0xb0>)
   414f2:	e9cd 2300 	strd	r2, r3, [sp]
   414f6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   414fa:	2300      	movs	r3, #0
   414fc:	f005 fdc8 	bl	47090 <z_impl_k_timer_start>
   41500:	e7ed      	b.n	414de <msg_finalize+0x62>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   41502:	2a0a      	cmp	r2, #10
   41504:	d1eb      	bne.n	414de <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
   41506:	4809      	ldr	r0, [pc, #36]	; (4152c <msg_finalize+0xb0>)
   41508:	f007 fa70 	bl	489ec <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   4150c:	4808      	ldr	r0, [pc, #32]	; (41530 <msg_finalize+0xb4>)
}
   4150e:	b003      	add	sp, #12
   41510:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   41514:	f005 b870 	b.w	465f8 <z_impl_k_sem_give>
   41518:	2001a504 	.word	0x2001a504
   4151c:	2001a7f4 	.word	0x2001a7f4
   41520:	2001a7e8 	.word	0x2001a7e8
   41524:	2001ad43 	.word	0x2001ad43
   41528:	2001a818 	.word	0x2001a818
   4152c:	2001a5f0 	.word	0x2001a5f0
   41530:	2001a5e0 	.word	0x2001a5e0

00041534 <log_process_thread_func>:
{
   41534:	b510      	push	{r4, lr}
	log_init();
   41536:	f7ff fe3b 	bl	411b0 <log_init>
	return z_impl_z_current_get();
   4153a:	f005 fb97 	bl	46c6c <z_impl_z_current_get>
	proc_tid = process_tid;
   4153e:	4b0c      	ldr	r3, [pc, #48]	; (41570 <log_process_thread_func+0x3c>)
   41540:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   41542:	b130      	cbz	r0, 41552 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   41544:	4b0b      	ldr	r3, [pc, #44]	; (41574 <log_process_thread_func+0x40>)
	    process_tid &&
   41546:	681b      	ldr	r3, [r3, #0]
   41548:	2b09      	cmp	r3, #9
   4154a:	dd02      	ble.n	41552 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   4154c:	480a      	ldr	r0, [pc, #40]	; (41578 <log_process_thread_func+0x44>)
   4154e:	f005 f853 	bl	465f8 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   41552:	4c09      	ldr	r4, [pc, #36]	; (41578 <log_process_thread_func+0x44>)
   41554:	2000      	movs	r0, #0
   41556:	f7ff fef3 	bl	41340 <z_impl_log_process>
		if (log_process(false) == false) {
   4155a:	2800      	cmp	r0, #0
   4155c:	d1fa      	bne.n	41554 <log_process_thread_func+0x20>
   4155e:	f04f 32ff 	mov.w	r2, #4294967295
   41562:	f04f 33ff 	mov.w	r3, #4294967295
   41566:	4620      	mov	r0, r4
   41568:	f005 f866 	bl	46638 <z_impl_k_sem_take>
   4156c:	e7f2      	b.n	41554 <log_process_thread_func+0x20>
   4156e:	bf00      	nop
   41570:	2001a818 	.word	0x2001a818
   41574:	2001a7e8 	.word	0x2001a7e8
   41578:	2001a5e0 	.word	0x2001a5e0

0004157c <z_impl_log_panic>:
{
   4157c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   4157e:	4f0e      	ldr	r7, [pc, #56]	; (415b8 <z_impl_log_panic+0x3c>)
   41580:	783d      	ldrb	r5, [r7, #0]
   41582:	b975      	cbnz	r5, 415a2 <z_impl_log_panic+0x26>
	log_init();
   41584:	f7ff fe14 	bl	411b0 <log_init>
	return __log_backends_end - __log_backends_start;
   41588:	4c0c      	ldr	r4, [pc, #48]	; (415bc <z_impl_log_panic+0x40>)
   4158a:	4e0d      	ldr	r6, [pc, #52]	; (415c0 <z_impl_log_panic+0x44>)
   4158c:	1b36      	subs	r6, r6, r4
   4158e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   41590:	42b5      	cmp	r5, r6
   41592:	db07      	blt.n	415a4 <z_impl_log_panic+0x28>
   41594:	2000      	movs	r0, #0
   41596:	f7ff fed3 	bl	41340 <z_impl_log_process>
		while (log_process(false) == true) {
   4159a:	2800      	cmp	r0, #0
   4159c:	d1fa      	bne.n	41594 <z_impl_log_panic+0x18>
	panic_mode = true;
   4159e:	2301      	movs	r3, #1
   415a0:	703b      	strb	r3, [r7, #0]
}
   415a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   415a4:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   415a6:	795b      	ldrb	r3, [r3, #5]
   415a8:	b11b      	cbz	r3, 415b2 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   415aa:	6823      	ldr	r3, [r4, #0]
   415ac:	4620      	mov	r0, r4
   415ae:	695b      	ldr	r3, [r3, #20]
   415b0:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   415b2:	3501      	adds	r5, #1
   415b4:	3410      	adds	r4, #16
   415b6:	e7eb      	b.n	41590 <z_impl_log_panic+0x14>
   415b8:	2001ad43 	.word	0x2001ad43
   415bc:	00048d60 	.word	0x00048d60
   415c0:	00048d80 	.word	0x00048d80

000415c4 <z_log_free>:
{
   415c4:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   415c6:	3804      	subs	r0, #4
   415c8:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   415ca:	e8d0 3fef 	ldaex	r3, [r0]
   415ce:	1e5a      	subs	r2, r3, #1
   415d0:	e8c0 2fe1 	stlex	r1, r2, [r0]
   415d4:	2900      	cmp	r1, #0
   415d6:	d1f8      	bne.n	415ca <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
   415d8:	2b01      	cmp	r3, #1
   415da:	d103      	bne.n	415e4 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   415dc:	4803      	ldr	r0, [pc, #12]	; (415ec <z_log_free+0x28>)
   415de:	a901      	add	r1, sp, #4
   415e0:	f007 f845 	bl	4866e <k_mem_slab_free>
}
   415e4:	b003      	add	sp, #12
   415e6:	f85d fb04 	ldr.w	pc, [sp], #4
   415ea:	bf00      	nop
   415ec:	2001a7fc 	.word	0x2001a7fc

000415f0 <log_source_name_get>:
   415f0:	4a04      	ldr	r2, [pc, #16]	; (41604 <log_source_name_get+0x14>)
   415f2:	4b05      	ldr	r3, [pc, #20]	; (41608 <log_source_name_get+0x18>)
   415f4:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   415f6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   415fa:	bf34      	ite	cc
   415fc:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   41600:	2000      	movcs	r0, #0
}
   41602:	4770      	bx	lr
   41604:	00048d10 	.word	0x00048d10
   41608:	00048d60 	.word	0x00048d60

0004160c <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   4160c:	4b05      	ldr	r3, [pc, #20]	; (41624 <log_backend_enable+0x18>)

	log_backend_id_set(backend, id);
   4160e:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
   41610:	1ac3      	subs	r3, r0, r3
   41612:	111b      	asrs	r3, r3, #4
   41614:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   41616:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
   41618:	2201      	movs	r2, #1
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);
   4161a:	6843      	ldr	r3, [r0, #4]
	backend->cb->ctx = ctx;
   4161c:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
   4161e:	715a      	strb	r2, [r3, #5]

	z_log_notify_backend_enabled();
   41620:	f7ff be02 	b.w	41228 <z_log_notify_backend_enabled>
   41624:	00048d60 	.word	0x00048d60

00041628 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   41628:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   4162c:	2220      	movs	r2, #32
   4162e:	4902      	ldr	r1, [pc, #8]	; (41638 <log_msg_pool_init+0x10>)
   41630:	4802      	ldr	r0, [pc, #8]	; (4163c <log_msg_pool_init+0x14>)
   41632:	f007 b801 	b.w	48638 <k_mem_slab_init>
   41636:	bf00      	nop
   41638:	20023b80 	.word	0x20023b80
   4163c:	2001a81c 	.word	0x2001a81c

00041640 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
   41640:	2300      	movs	r3, #0
{
   41642:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   41644:	4d09      	ldr	r5, [pc, #36]	; (4166c <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   41646:	9301      	str	r3, [sp, #4]
   41648:	2001      	movs	r0, #1
   4164a:	f7ff fe79 	bl	41340 <z_impl_log_process>
   4164e:	4604      	mov	r4, r0
			z_log_dropped();
   41650:	f7ff fdf8 	bl	41244 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   41654:	2200      	movs	r2, #0
   41656:	2300      	movs	r3, #0
   41658:	4628      	mov	r0, r5
   4165a:	a901      	add	r1, sp, #4
   4165c:	f004 fe1e 	bl	4629c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   41660:	b108      	cbz	r0, 41666 <log_msg_no_space_handle+0x26>
   41662:	2c00      	cmp	r4, #0
   41664:	d1f0      	bne.n	41648 <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
   41666:	9801      	ldr	r0, [sp, #4]
   41668:	b003      	add	sp, #12
   4166a:	bd30      	pop	{r4, r5, pc}
   4166c:	2001a81c 	.word	0x2001a81c

00041670 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
   41670:	2300      	movs	r3, #0
{
   41672:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41674:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
   41676:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41678:	4806      	ldr	r0, [pc, #24]	; (41694 <log_msg_chunk_alloc+0x24>)
   4167a:	2300      	movs	r3, #0
   4167c:	a901      	add	r1, sp, #4
   4167e:	f004 fe0d 	bl	4629c <k_mem_slab_alloc>
	if (err != 0) {
   41682:	b110      	cbz	r0, 4168a <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
   41684:	f7ff ffdc 	bl	41640 <log_msg_no_space_handle>
   41688:	9001      	str	r0, [sp, #4]
}
   4168a:	9801      	ldr	r0, [sp, #4]
   4168c:	b003      	add	sp, #12
   4168e:	f85d fb04 	ldr.w	pc, [sp], #4
   41692:	bf00      	nop
   41694:	2001a81c 	.word	0x2001a81c

00041698 <msg_free>:
{
   41698:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4169a:	7a03      	ldrb	r3, [r0, #8]
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
   4169c:	7a45      	ldrb	r5, [r0, #9]
{
   4169e:	b085      	sub	sp, #20
   416a0:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   416a2:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
   416a4:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   416a8:	d41c      	bmi.n	416e4 <msg_free+0x4c>
   416aa:	b1dd      	cbz	r5, 416e4 <msg_free+0x4c>
		uint32_t smask = 0U;
   416ac:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
   416ae:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
   416b0:	4631      	mov	r1, r6
   416b2:	9801      	ldr	r0, [sp, #4]
   416b4:	f006 fa53 	bl	47b5e <log_msg_arg_get>
   416b8:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
   416ba:	f7ff fe33 	bl	41324 <log_is_strdup>
   416be:	b170      	cbz	r0, 416de <msg_free+0x46>
				if (smask == 0U) {
   416c0:	b934      	cbnz	r4, 416d0 <msg_free+0x38>
					smask = z_log_get_s_mask(
   416c2:	9b01      	ldr	r3, [sp, #4]
   416c4:	4629      	mov	r1, r5
   416c6:	6918      	ldr	r0, [r3, #16]
   416c8:	f006 f96f 	bl	479aa <z_log_get_s_mask>
					if (smask == 0U) {
   416cc:	4604      	mov	r4, r0
   416ce:	b148      	cbz	r0, 416e4 <msg_free+0x4c>
				if (smask & BIT(i)) {
   416d0:	fa24 f306 	lsr.w	r3, r4, r6
   416d4:	07d9      	lsls	r1, r3, #31
   416d6:	d502      	bpl.n	416de <msg_free+0x46>
					z_log_free(buf);
   416d8:	4638      	mov	r0, r7
   416da:	f7ff ff73 	bl	415c4 <z_log_free>
		for (i = 0U; i < nargs; i++) {
   416de:	3601      	adds	r6, #1
   416e0:	42ae      	cmp	r6, r5
   416e2:	d3e5      	bcc.n	416b0 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
   416e4:	9b01      	ldr	r3, [sp, #4]
   416e6:	7a1a      	ldrb	r2, [r3, #8]
   416e8:	0792      	lsls	r2, r2, #30
   416ea:	d504      	bpl.n	416f6 <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
   416ec:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   416ee:	4c08      	ldr	r4, [pc, #32]	; (41710 <msg_free+0x78>)
   416f0:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   416f2:	9b03      	ldr	r3, [sp, #12]
   416f4:	b92b      	cbnz	r3, 41702 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   416f6:	4806      	ldr	r0, [pc, #24]	; (41710 <msg_free+0x78>)
   416f8:	a901      	add	r1, sp, #4
   416fa:	f006 ffb8 	bl	4866e <k_mem_slab_free>
}
   416fe:	b005      	add	sp, #20
   41700:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
   41702:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   41704:	4620      	mov	r0, r4
   41706:	a903      	add	r1, sp, #12
   41708:	f006 ffb1 	bl	4866e <k_mem_slab_free>
		cont = next;
   4170c:	9503      	str	r5, [sp, #12]
   4170e:	e7f0      	b.n	416f2 <msg_free+0x5a>
   41710:	2001a81c 	.word	0x2001a81c

00041714 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
   41714:	b40e      	push	{r1, r2, r3}
   41716:	b503      	push	{r0, r1, lr}
   41718:	ab03      	add	r3, sp, #12
   4171a:	f853 2b04 	ldr.w	r2, [r3], #4
   4171e:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
   41720:	4804      	ldr	r0, [pc, #16]	; (41734 <print_formatted+0x20>)
	va_start(args, fmt);
   41722:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
   41724:	f7ff f90a 	bl	4093c <cbvprintf>
	va_end(args);

	return length;
}
   41728:	b002      	add	sp, #8
   4172a:	f85d eb04 	ldr.w	lr, [sp], #4
   4172e:	b003      	add	sp, #12
   41730:	4770      	bx	lr
   41732:	bf00      	nop
   41734:	00047ebb 	.word	0x00047ebb

00041738 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
   41738:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4173c:	461f      	mov	r7, r3
   4173e:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   41740:	f001 0301 	and.w	r3, r1, #1
{
   41744:	9205      	str	r2, [sp, #20]
   41746:	4606      	mov	r6, r0
   41748:	4688      	mov	r8, r1
   4174a:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
   4174e:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   41752:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   41756:	9304      	str	r3, [sp, #16]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   41758:	f001 0508 	and.w	r5, r1, #8
	const char *tag = z_log_get_tag();
   4175c:	f006 f99b 	bl	47a96 <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
   41760:	4602      	mov	r2, r0
   41762:	2800      	cmp	r0, #0
   41764:	d044      	beq.n	417f0 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
   41766:	4630      	mov	r0, r6
   41768:	4938      	ldr	r1, [pc, #224]	; (4184c <prefix_print+0x114>)
   4176a:	f7ff ffd3 	bl	41714 <print_formatted>
   4176e:	4604      	mov	r4, r0
	}

	if (stamp) {
   41770:	f1bb 0f00 	cmp.w	fp, #0
   41774:	d008      	beq.n	41788 <prefix_print+0x50>
	if (!format) {
   41776:	f018 0f44 	tst.w	r8, #68	; 0x44
   4177a:	d13b      	bne.n	417f4 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
   4177c:	463a      	mov	r2, r7
   4177e:	4630      	mov	r0, r6
   41780:	4933      	ldr	r1, [pc, #204]	; (41850 <prefix_print+0x118>)
   41782:	f7ff ffc7 	bl	41714 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
   41786:	4404      	add	r4, r0
	if (color) {
   41788:	9b04      	ldr	r3, [sp, #16]
   4178a:	b153      	cbz	r3, 417a2 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
   4178c:	4b31      	ldr	r3, [pc, #196]	; (41854 <prefix_print+0x11c>)
		print_formatted(output, "%s", log_color);
   4178e:	4630      	mov	r0, r6
		const char *log_color = start && (colors[level] != NULL) ?
   41790:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
   41794:	4b30      	ldr	r3, [pc, #192]	; (41858 <prefix_print+0x120>)
   41796:	4931      	ldr	r1, [pc, #196]	; (4185c <prefix_print+0x124>)
   41798:	2a00      	cmp	r2, #0
   4179a:	bf08      	it	eq
   4179c:	461a      	moveq	r2, r3
   4179e:	f7ff ffb9 	bl	41714 <print_formatted>
	if (level_on) {
   417a2:	b13d      	cbz	r5, 417b4 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
   417a4:	4b2e      	ldr	r3, [pc, #184]	; (41860 <prefix_print+0x128>)
   417a6:	4630      	mov	r0, r6
   417a8:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   417ac:	492d      	ldr	r1, [pc, #180]	; (41864 <prefix_print+0x12c>)
   417ae:	f7ff ffb1 	bl	41714 <print_formatted>
   417b2:	4605      	mov	r5, r0
	if (source_id >= 0) {
   417b4:	f1ba 0f00 	cmp.w	sl, #0
   417b8:	db16      	blt.n	417e8 <prefix_print+0xb0>
		total += print_formatted(output,
   417ba:	9b05      	ldr	r3, [sp, #20]
   417bc:	2b00      	cmp	r3, #0
   417be:	d043      	beq.n	41848 <prefix_print+0x110>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   417c0:	2301      	movs	r3, #1
   417c2:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
   417c6:	4b28      	ldr	r3, [pc, #160]	; (41868 <prefix_print+0x130>)
   417c8:	f019 0f10 	tst.w	r9, #16
   417cc:	4f27      	ldr	r7, [pc, #156]	; (4186c <prefix_print+0x134>)
   417ce:	bf18      	it	ne
   417d0:	461f      	movne	r7, r3
   417d2:	4651      	mov	r1, sl
   417d4:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
   417d8:	f7ff ff0a 	bl	415f0 <log_source_name_get>
   417dc:	4639      	mov	r1, r7
   417de:	4602      	mov	r2, r0
   417e0:	4630      	mov	r0, r6
   417e2:	f7ff ff97 	bl	41714 <print_formatted>
   417e6:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
   417e8:	1928      	adds	r0, r5, r4
   417ea:	b007      	add	sp, #28
   417ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
   417f0:	4604      	mov	r4, r0
   417f2:	e7bd      	b.n	41770 <prefix_print+0x38>
	} else if (freq != 0U) {
   417f4:	4b1e      	ldr	r3, [pc, #120]	; (41870 <prefix_print+0x138>)
   417f6:	6818      	ldr	r0, [r3, #0]
   417f8:	2800      	cmp	r0, #0
   417fa:	d0c4      	beq.n	41786 <prefix_print+0x4e>
		timestamp /= timestamp_div;
   417fc:	4b1d      	ldr	r3, [pc, #116]	; (41874 <prefix_print+0x13c>)
   417fe:	f44f 6c61 	mov.w	ip, #3600	; 0xe10
   41802:	6819      	ldr	r1, [r3, #0]
		mins = seconds / 60U;
   41804:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
		timestamp /= timestamp_div;
   41808:	fbb7 f7f1 	udiv	r7, r7, r1
		total_seconds = timestamp / freq;
   4180c:	fbb7 f1f0 	udiv	r1, r7, r0
		seconds -= hours * 3600U;
   41810:	fbb1 f2fc 	udiv	r2, r1, ip
		remainder = timestamp % freq;
   41814:	fb00 7711 	mls	r7, r0, r1, r7
   41818:	fb0c 1c12 	mls	ip, ip, r2, r1
		ms = (remainder * 1000U) / freq;
   4181c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   41820:	434f      	muls	r7, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   41822:	fbb7 f8f0 	udiv	r8, r7, r0
   41826:	fb00 7718 	mls	r7, r0, r8, r7
		mins = seconds / 60U;
   4182a:	fbbc f3fe 	udiv	r3, ip, lr
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   4182e:	434f      	muls	r7, r1
   41830:	fbb7 f0f0 	udiv	r0, r7, r0
			length = print_formatted(output,
   41834:	fb0e c113 	mls	r1, lr, r3, ip
   41838:	e9cd 8001 	strd	r8, r0, [sp, #4]
   4183c:	9100      	str	r1, [sp, #0]
   4183e:	4630      	mov	r0, r6
   41840:	490d      	ldr	r1, [pc, #52]	; (41878 <prefix_print+0x140>)
   41842:	f7ff ff67 	bl	41714 <print_formatted>
   41846:	e79e      	b.n	41786 <prefix_print+0x4e>
		total += print_formatted(output,
   41848:	4f08      	ldr	r7, [pc, #32]	; (4186c <prefix_print+0x134>)
   4184a:	e7c2      	b.n	417d2 <prefix_print+0x9a>
   4184c:	0004905e 	.word	0x0004905e
   41850:	00049062 	.word	0x00049062
   41854:	00048da8 	.word	0x00048da8
   41858:	00049050 	.word	0x00049050
   4185c:	00049087 	.word	0x00049087
   41860:	00048dbc 	.word	0x00048dbc
   41864:	0004908a 	.word	0x0004908a
   41868:	0004905a 	.word	0x0004905a
   4186c:	00049055 	.word	0x00049055
   41870:	2001a838 	.word	0x2001a838
   41874:	2001a83c 	.word	0x2001a83c
   41878:	0004906b 	.word	0x0004906b

0004187c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
   4187c:	b538      	push	{r3, r4, r5, lr}
   4187e:	460c      	mov	r4, r1
	if (color) {
   41880:	07e1      	lsls	r1, r4, #31
{
   41882:	4605      	mov	r5, r0
	if (color) {
   41884:	d503      	bpl.n	4188e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
   41886:	4a08      	ldr	r2, [pc, #32]	; (418a8 <postfix_print+0x2c>)
   41888:	4908      	ldr	r1, [pc, #32]	; (418ac <postfix_print+0x30>)
   4188a:	f7ff ff43 	bl	41714 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   4188e:	06e2      	lsls	r2, r4, #27
   41890:	d408      	bmi.n	418a4 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41892:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   41894:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
   41896:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   4189a:	bf4c      	ite	mi
   4189c:	4904      	ldrmi	r1, [pc, #16]	; (418b0 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   4189e:	4905      	ldrpl	r1, [pc, #20]	; (418b4 <postfix_print+0x38>)
   418a0:	f7ff bf38 	b.w	41714 <print_formatted>
}
   418a4:	bd38      	pop	{r3, r4, r5, pc}
   418a6:	bf00      	nop
   418a8:	00049050 	.word	0x00049050
   418ac:	00049087 	.word	0x00049087
   418b0:	00049091 	.word	0x00049091
   418b4:	00049090 	.word	0x00049090

000418b8 <hexdump_line_print>:
{
   418b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   418bc:	461d      	mov	r5, r3
   418be:	9b08      	ldr	r3, [sp, #32]
   418c0:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   418c2:	06da      	lsls	r2, r3, #27
{
   418c4:	4604      	mov	r4, r0
   418c6:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   418c8:	d405      	bmi.n	418d6 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   418ca:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   418cc:	bf4c      	ite	mi
   418ce:	492a      	ldrmi	r1, [pc, #168]	; (41978 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   418d0:	492a      	ldrpl	r1, [pc, #168]	; (4197c <hexdump_line_print+0xc4>)
   418d2:	f7ff ff1f 	bl	41714 <print_formatted>
{
   418d6:	f04f 0800 	mov.w	r8, #0
		print_formatted(output, " ");
   418da:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 41984 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   418de:	45a8      	cmp	r8, r5
   418e0:	db2a      	blt.n	41938 <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   418e2:	2500      	movs	r5, #0
			print_formatted(output, "   ");
   418e4:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 41988 <hexdump_line_print+0xd0>
			print_formatted(output, "%02x ", data[i]);
   418e8:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 4198c <hexdump_line_print+0xd4>
			print_formatted(output, " ");
   418ec:	f8df a094 	ldr.w	sl, [pc, #148]	; 41984 <hexdump_line_print+0xcc>
		if (i < length) {
   418f0:	42bd      	cmp	r5, r7
   418f2:	d22f      	bcs.n	41954 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
   418f4:	4649      	mov	r1, r9
   418f6:	4620      	mov	r0, r4
   418f8:	5d72      	ldrb	r2, [r6, r5]
   418fa:	f7ff ff0b 	bl	41714 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   418fe:	3501      	adds	r5, #1
   41900:	2d10      	cmp	r5, #16
   41902:	d120      	bne.n	41946 <hexdump_line_print+0x8e>
	print_formatted(output, "|");
   41904:	4620      	mov	r0, r4
   41906:	491e      	ldr	r1, [pc, #120]	; (41980 <hexdump_line_print+0xc8>)
   41908:	f7ff ff04 	bl	41714 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   4190c:	2500      	movs	r5, #0
			print_formatted(output, " ");
   4190e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 41984 <hexdump_line_print+0xcc>
			print_formatted(output, "%c",
   41912:	f8df 907c 	ldr.w	r9, [pc, #124]	; 41990 <hexdump_line_print+0xd8>
		if (i < length) {
   41916:	42af      	cmp	r7, r5
   41918:	d928      	bls.n	4196c <hexdump_line_print+0xb4>
			char c = (char)data[i];
   4191a:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
   4191c:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
   4191e:	f1a2 0320 	sub.w	r3, r2, #32
   41922:	2b5f      	cmp	r3, #95	; 0x5f
   41924:	bf28      	it	cs
   41926:	222e      	movcs	r2, #46	; 0x2e
   41928:	4620      	mov	r0, r4
   4192a:	f7ff fef3 	bl	41714 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   4192e:	3501      	adds	r5, #1
   41930:	2d10      	cmp	r5, #16
   41932:	d114      	bne.n	4195e <hexdump_line_print+0xa6>
}
   41934:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
   41938:	4649      	mov	r1, r9
   4193a:	4620      	mov	r0, r4
   4193c:	f7ff feea 	bl	41714 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   41940:	f108 0801 	add.w	r8, r8, #1
   41944:	e7cb      	b.n	418de <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
   41946:	076a      	lsls	r2, r5, #29
   41948:	d1d2      	bne.n	418f0 <hexdump_line_print+0x38>
			print_formatted(output, " ");
   4194a:	4651      	mov	r1, sl
   4194c:	4620      	mov	r0, r4
   4194e:	f7ff fee1 	bl	41714 <print_formatted>
   41952:	e7cd      	b.n	418f0 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
   41954:	4641      	mov	r1, r8
   41956:	4620      	mov	r0, r4
   41958:	f7ff fedc 	bl	41714 <print_formatted>
   4195c:	e7cf      	b.n	418fe <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
   4195e:	076b      	lsls	r3, r5, #29
   41960:	d1d9      	bne.n	41916 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41962:	4641      	mov	r1, r8
   41964:	4620      	mov	r0, r4
   41966:	f7ff fed5 	bl	41714 <print_formatted>
   4196a:	e7d4      	b.n	41916 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   4196c:	4641      	mov	r1, r8
   4196e:	4620      	mov	r0, r4
   41970:	f7ff fed0 	bl	41714 <print_formatted>
   41974:	e7db      	b.n	4192e <hexdump_line_print+0x76>
   41976:	bf00      	nop
   41978:	00049091 	.word	0x00049091
   4197c:	00049090 	.word	0x00049090
   41980:	0004909d 	.word	0x0004909d
   41984:	0004909b 	.word	0x0004909b
   41988:	00049099 	.word	0x00049099
   4198c:	00049093 	.word	0x00049093
   41990:	0004909f 	.word	0x0004909f

00041994 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
   41994:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   41998:	7a8b      	ldrb	r3, [r1, #10]
   4199a:	4617      	mov	r7, r2
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
   4199c:	f013 0807 	ands.w	r8, r3, #7
{
   419a0:	4605      	mov	r5, r0
   419a2:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   419a4:	7a0a      	ldrb	r2, [r1, #8]
   419a6:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
   419a8:	d021      	beq.n	419ee <log_output_msg_process+0x5a>
   419aa:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
   419ac:	8949      	ldrh	r1, [r1, #10]
   419ae:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   419b2:	f3c1 1189 	ubfx	r1, r1, #6, #10
   419b6:	e9cd 8300 	strd	r8, r3, [sp]
   419ba:	9102      	str	r1, [sp, #8]
   419bc:	68f3      	ldr	r3, [r6, #12]
   419be:	4639      	mov	r1, r7
   419c0:	f002 0201 	and.w	r2, r2, #1
   419c4:	f7ff feb8 	bl	41738 <prefix_print>
   419c8:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   419ca:	7a34      	ldrb	r4, [r6, #8]
   419cc:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   419ce:	f014 0401 	ands.w	r4, r4, #1
   419d2:	d00e      	beq.n	419f2 <log_output_msg_process+0x5e>
		std_print(msg, output);
   419d4:	4629      	mov	r1, r5
   419d6:	4630      	mov	r0, r6
   419d8:	f006 f905 	bl	47be6 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
   419dc:	f1b8 0f00 	cmp.w	r8, #0
   419e0:	d02b      	beq.n	41a3a <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
   419e2:	4642      	mov	r2, r8
   419e4:	4639      	mov	r1, r7
   419e6:	4628      	mov	r0, r5
   419e8:	f7ff ff48 	bl	4187c <postfix_print>
   419ec:	e025      	b.n	41a3a <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
   419ee:	46c1      	mov	r9, r8
   419f0:	e7eb      	b.n	419ca <log_output_msg_process+0x36>
	} else if (raw_string) {
   419f2:	f1b8 0f00 	cmp.w	r8, #0
   419f6:	d126      	bne.n	41a46 <log_output_msg_process+0xb2>
	size_t offset = 0;
   419f8:	4627      	mov	r7, r4
		length = output->size;
   419fa:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   419fc:	aa06      	add	r2, sp, #24
		length = output->size;
   419fe:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41a00:	4630      	mov	r0, r6
   41a02:	463b      	mov	r3, r7
   41a04:	68a9      	ldr	r1, [r5, #8]
   41a06:	f006 f8da 	bl	47bbe <log_msg_hexdump_data_get>
		output->control_block->offset = length;
   41a0a:	9a06      	ldr	r2, [sp, #24]
   41a0c:	686b      	ldr	r3, [r5, #4]
   41a0e:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   41a10:	b13a      	cbz	r2, 41a22 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
   41a12:	68ab      	ldr	r3, [r5, #8]
   41a14:	4413      	add	r3, r2
   41a16:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   41a1a:	f1a4 030a 	sub.w	r3, r4, #10
   41a1e:	425c      	negs	r4, r3
   41a20:	415c      	adcs	r4, r3
		log_output_flush(output);
   41a22:	4628      	mov	r0, r5
   41a24:	f006 fa3c 	bl	47ea0 <log_output_flush>
		offset += length;
   41a28:	9b06      	ldr	r3, [sp, #24]
   41a2a:	441f      	add	r7, r3
	} while (length > 0);
   41a2c:	2b00      	cmp	r3, #0
   41a2e:	d1e4      	bne.n	419fa <log_output_msg_process+0x66>
	if (eol) {
   41a30:	b11c      	cbz	r4, 41a3a <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
   41a32:	4628      	mov	r0, r5
   41a34:	4913      	ldr	r1, [pc, #76]	; (41a84 <log_output_msg_process+0xf0>)
   41a36:	f7ff fe6d 	bl	41714 <print_formatted>
	}

	log_output_flush(output);
   41a3a:	4628      	mov	r0, r5
   41a3c:	f006 fa30 	bl	47ea0 <log_output_flush>
}
   41a40:	b00a      	add	sp, #40	; 0x28
   41a42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(output, "%s", log_msg_str_get(msg));
   41a46:	4630      	mov	r0, r6
   41a48:	f006 f8b7 	bl	47bba <log_msg_str_get>
   41a4c:	490e      	ldr	r1, [pc, #56]	; (41a88 <log_output_msg_process+0xf4>)
   41a4e:	4602      	mov	r2, r0
   41a50:	4628      	mov	r0, r5
   41a52:	f7ff fe5f 	bl	41714 <print_formatted>
		length = sizeof(buf);
   41a56:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41a5a:	aa05      	add	r2, sp, #20
   41a5c:	4623      	mov	r3, r4
   41a5e:	4630      	mov	r0, r6
   41a60:	a906      	add	r1, sp, #24
		length = sizeof(buf);
   41a62:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41a66:	f006 f8aa 	bl	47bbe <log_msg_hexdump_data_get>
		if (length) {
   41a6a:	9a05      	ldr	r2, [sp, #20]
   41a6c:	2a00      	cmp	r2, #0
   41a6e:	d0b8      	beq.n	419e2 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
   41a70:	464b      	mov	r3, r9
   41a72:	4628      	mov	r0, r5
   41a74:	9700      	str	r7, [sp, #0]
   41a76:	a906      	add	r1, sp, #24
   41a78:	f7ff ff1e 	bl	418b8 <hexdump_line_print>
			offset += length;
   41a7c:	9b05      	ldr	r3, [sp, #20]
   41a7e:	441c      	add	r4, r3
		length = sizeof(buf);
   41a80:	e7eb      	b.n	41a5a <log_output_msg_process+0xc6>
   41a82:	bf00      	nop
   41a84:	000490a2 	.word	0x000490a2
   41a88:	00049087 	.word	0x00049087

00041a8c <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41a8c:	f242 730f 	movw	r3, #9999	; 0x270f
{
   41a90:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41a92:	428b      	cmp	r3, r1
   41a94:	bf28      	it	cs
   41a96:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
   41a98:	6805      	ldr	r5, [r0, #0]
{
   41a9a:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41a9c:	2105      	movs	r1, #5
   41a9e:	4668      	mov	r0, sp
   41aa0:	4a0d      	ldr	r2, [pc, #52]	; (41ad8 <log_output_dropped_process+0x4c>)
   41aa2:	f005 fc58 	bl	47356 <snprintk>
   41aa6:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
   41aa8:	6863      	ldr	r3, [r4, #4]
   41aaa:	4628      	mov	r0, r5
   41aac:	220b      	movs	r2, #11
   41aae:	685b      	ldr	r3, [r3, #4]
   41ab0:	490a      	ldr	r1, [pc, #40]	; (41adc <log_output_dropped_process+0x50>)
   41ab2:	f006 f88b 	bl	47bcc <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
   41ab6:	6863      	ldr	r3, [r4, #4]
   41ab8:	4632      	mov	r2, r6
   41aba:	4669      	mov	r1, sp
   41abc:	4628      	mov	r0, r5
   41abe:	685b      	ldr	r3, [r3, #4]
   41ac0:	f006 f884 	bl	47bcc <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
   41ac4:	6863      	ldr	r3, [r4, #4]
   41ac6:	221b      	movs	r2, #27
   41ac8:	4628      	mov	r0, r5
   41aca:	685b      	ldr	r3, [r3, #4]
   41acc:	4904      	ldr	r1, [pc, #16]	; (41ae0 <log_output_dropped_process+0x54>)
   41ace:	f006 f87d 	bl	47bcc <buffer_write>
		     output->control_block->ctx);
}
   41ad2:	b002      	add	sp, #8
   41ad4:	bd70      	pop	{r4, r5, r6, pc}
   41ad6:	bf00      	nop
   41ad8:	00049719 	.word	0x00049719
   41adc:	000490e0 	.word	0x000490e0
   41ae0:	000490c4 	.word	0x000490c4

00041ae4 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
   41ae4:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   41ae6:	2100      	movs	r1, #0
	timestamp_div = 1U;
   41ae8:	4a07      	ldr	r2, [pc, #28]	; (41b08 <log_output_timestamp_freq_set+0x24>)
{
   41aea:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   41aec:	4c07      	ldr	r4, [pc, #28]	; (41b0c <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   41aee:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   41af0:	42a0      	cmp	r0, r4
   41af2:	d804      	bhi.n	41afe <log_output_timestamp_freq_set+0x1a>
   41af4:	b101      	cbz	r1, 41af8 <log_output_timestamp_freq_set+0x14>
   41af6:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   41af8:	4b05      	ldr	r3, [pc, #20]	; (41b10 <log_output_timestamp_freq_set+0x2c>)
   41afa:	6018      	str	r0, [r3, #0]
}
   41afc:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
   41afe:	2101      	movs	r1, #1
		frequency /= 2U;
   41b00:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   41b02:	005b      	lsls	r3, r3, #1
   41b04:	e7f4      	b.n	41af0 <log_output_timestamp_freq_set+0xc>
   41b06:	bf00      	nop
   41b08:	2001a83c 	.word	0x2001a83c
   41b0c:	000f4240 	.word	0x000f4240
   41b10:	2001a838 	.word	0x2001a838

00041b14 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
   41b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   41b16:	460d      	mov	r5, r1
   41b18:	4604      	mov	r4, r0
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
   41b1a:	4f06      	ldr	r7, [pc, #24]	; (41b34 <char_out+0x20>)
   41b1c:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
   41b1e:	42b4      	cmp	r4, r6
   41b20:	d101      	bne.n	41b26 <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
   41b22:	4628      	mov	r0, r5
   41b24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
   41b26:	6838      	ldr	r0, [r7, #0]
   41b28:	f814 1b01 	ldrb.w	r1, [r4], #1
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   41b2c:	6883      	ldr	r3, [r0, #8]
   41b2e:	685b      	ldr	r3, [r3, #4]
   41b30:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
   41b32:	e7f4      	b.n	41b1e <char_out+0xa>
   41b34:	2001a854 	.word	0x2001a854

00041b38 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   41b38:	4b01      	ldr	r3, [pc, #4]	; (41b40 <log_backend_uart_init+0x8>)
   41b3a:	4a02      	ldr	r2, [pc, #8]	; (41b44 <log_backend_uart_init+0xc>)
   41b3c:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
   41b3e:	4770      	bx	lr
   41b40:	2001a854 	.word	0x2001a854
   41b44:	00048af0 	.word	0x00048af0

00041b48 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
   41b48:	2201      	movs	r2, #1
   41b4a:	4b02      	ldr	r3, [pc, #8]	; (41b54 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
   41b4c:	4802      	ldr	r0, [pc, #8]	; (41b58 <panic+0x10>)
   41b4e:	701a      	strb	r2, [r3, #0]
   41b50:	f006 b9a6 	b.w	47ea0 <log_output_flush>
   41b54:	2001ad44 	.word	0x2001ad44
   41b58:	00048dec 	.word	0x00048dec

00041b5c <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
   41b5c:	4801      	ldr	r0, [pc, #4]	; (41b64 <dropped+0x8>)
   41b5e:	f7ff bf95 	b.w	41a8c <log_output_dropped_process>
   41b62:	bf00      	nop
   41b64:	00048dec 	.word	0x00048dec

00041b68 <put>:
{
   41b68:	b510      	push	{r4, lr}
   41b6a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41b6c:	4608      	mov	r0, r1
   41b6e:	f005 ffea 	bl	47b46 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41b72:	4621      	mov	r1, r4
   41b74:	4804      	ldr	r0, [pc, #16]	; (41b88 <put+0x20>)
   41b76:	220f      	movs	r2, #15
   41b78:	f7ff ff0c 	bl	41994 <log_output_msg_process>
	log_msg_put(msg);
   41b7c:	4620      	mov	r0, r4
}
   41b7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41b82:	f006 b80b 	b.w	47b9c <log_msg_put>
   41b86:	bf00      	nop
   41b88:	00048dec 	.word	0x00048dec

00041b8c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   41b8c:	2201      	movs	r2, #1
   41b8e:	4b01      	ldr	r3, [pc, #4]	; (41b94 <log_backend_rtt_init+0x8>)
   41b90:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   41b92:	4770      	bx	lr
   41b94:	2001ad56 	.word	0x2001ad56

00041b98 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
   41b98:	2201      	movs	r2, #1
   41b9a:	4b02      	ldr	r3, [pc, #8]	; (41ba4 <panic+0xc>)
	log_output_flush(output);
   41b9c:	4802      	ldr	r0, [pc, #8]	; (41ba8 <panic+0x10>)
   41b9e:	701a      	strb	r2, [r3, #0]
   41ba0:	f006 b97e 	b.w	47ea0 <log_output_flush>
   41ba4:	2001ad57 	.word	0x2001ad57
   41ba8:	00048e18 	.word	0x00048e18

00041bac <dropped>:
	log_output_dropped_process(output, cnt);
   41bac:	4801      	ldr	r0, [pc, #4]	; (41bb4 <dropped+0x8>)
   41bae:	f7ff bf6d 	b.w	41a8c <log_output_dropped_process>
   41bb2:	bf00      	nop
   41bb4:	00048e18 	.word	0x00048e18

00041bb8 <put>:
{
   41bb8:	b510      	push	{r4, lr}
   41bba:	460c      	mov	r4, r1
	log_msg_get(msg);
   41bbc:	4608      	mov	r0, r1
   41bbe:	f005 ffc2 	bl	47b46 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41bc2:	4621      	mov	r1, r4
   41bc4:	4804      	ldr	r0, [pc, #16]	; (41bd8 <put+0x20>)
   41bc6:	220f      	movs	r2, #15
   41bc8:	f7ff fee4 	bl	41994 <log_output_msg_process>
	log_msg_put(msg);
   41bcc:	4620      	mov	r0, r4
}
   41bce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41bd2:	f005 bfe3 	b.w	47b9c <log_msg_put>
   41bd6:	bf00      	nop
   41bd8:	00048e18 	.word	0x00048e18

00041bdc <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41bdc:	4b05      	ldr	r3, [pc, #20]	; (41bf4 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
   41bde:	781b      	ldrb	r3, [r3, #0]
   41be0:	b11b      	cbz	r3, 41bea <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
   41be2:	f241 3088 	movw	r0, #5000	; 0x1388
   41be6:	f006 bec8 	b.w	4897a <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
   41bea:	2005      	movs	r0, #5
   41bec:	2100      	movs	r1, #0
   41bee:	f005 b829 	b.w	46c44 <z_impl_k_sleep>
   41bf2:	bf00      	nop
   41bf4:	2001ad57 	.word	0x2001ad57

00041bf8 <data_out_block_mode>:
{
   41bf8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41bfc:	f8df 9094 	ldr.w	r9, [pc, #148]	; 41c94 <data_out_block_mode+0x9c>
{
   41c00:	4680      	mov	r8, r0
   41c02:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
   41c04:	2404      	movs	r4, #4
   41c06:	46cb      	mov	fp, r9
	return z_impl_k_mutex_lock(mutex, timeout);
   41c08:	f8df a08c 	ldr.w	sl, [pc, #140]	; 41c98 <data_out_block_mode+0xa0>
		if (!is_sync_mode()) {
   41c0c:	f899 5000 	ldrb.w	r5, [r9]
   41c10:	b9cd      	cbnz	r5, 41c46 <data_out_block_mode+0x4e>
   41c12:	f04f 33ff 	mov.w	r3, #4294967295
   41c16:	f04f 32ff 	mov.w	r2, #4294967295
   41c1a:	4650      	mov	r0, sl
   41c1c:	f004 fc28 	bl	46470 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41c20:	463a      	mov	r2, r7
   41c22:	4641      	mov	r1, r8
   41c24:	4628      	mov	r0, r5
   41c26:	f002 fd51 	bl	446cc <SEGGER_RTT_WriteSkipNoLock>
   41c2a:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   41c2c:	4650      	mov	r0, sl
   41c2e:	f004 fc9d 	bl	4656c <z_impl_k_mutex_unlock>
		if (ret) {
   41c32:	4d17      	ldr	r5, [pc, #92]	; (41c90 <data_out_block_mode+0x98>)
   41c34:	b1fe      	cbz	r6, 41c76 <data_out_block_mode+0x7e>
	host_present = true;
   41c36:	2301      	movs	r3, #1
   41c38:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
   41c3a:	f89b 3000 	ldrb.w	r3, [fp]
   41c3e:	b96b      	cbnz	r3, 41c5c <data_out_block_mode+0x64>
}
   41c40:	4638      	mov	r0, r7
   41c42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41c46:	463a      	mov	r2, r7
   41c48:	4641      	mov	r1, r8
   41c4a:	2000      	movs	r0, #0
   41c4c:	f002 fd3e 	bl	446cc <SEGGER_RTT_WriteSkipNoLock>
   41c50:	4606      	mov	r6, r0
   41c52:	e7ee      	b.n	41c32 <data_out_block_mode+0x3a>
	if (retry_cnt == 0) {
   41c54:	b95c      	cbnz	r4, 41c6e <data_out_block_mode+0x76>
		host_present = false;
   41c56:	702c      	strb	r4, [r5, #0]
   41c58:	f04f 34ff 	mov.w	r4, #4294967295
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   41c5c:	2000      	movs	r0, #0
   41c5e:	f002 fd81 	bl	44764 <SEGGER_RTT_HasDataUp>
   41c62:	2800      	cmp	r0, #0
   41c64:	d0ec      	beq.n	41c40 <data_out_block_mode+0x48>
   41c66:	782b      	ldrb	r3, [r5, #0]
   41c68:	2b00      	cmp	r3, #0
   41c6a:	d1f3      	bne.n	41c54 <data_out_block_mode+0x5c>
   41c6c:	e7e8      	b.n	41c40 <data_out_block_mode+0x48>
			on_failed_write(retry_cnt--);
   41c6e:	3c01      	subs	r4, #1
   41c70:	f7ff ffb4 	bl	41bdc <on_failed_write.part.0>
   41c74:	e7f2      	b.n	41c5c <data_out_block_mode+0x64>
		} else if (host_present) {
   41c76:	782b      	ldrb	r3, [r5, #0]
   41c78:	b113      	cbz	r3, 41c80 <data_out_block_mode+0x88>
	if (retry_cnt == 0) {
   41c7a:	3c01      	subs	r4, #1
   41c7c:	d104      	bne.n	41c88 <data_out_block_mode+0x90>
		host_present = false;
   41c7e:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   41c80:	782b      	ldrb	r3, [r5, #0]
   41c82:	2b00      	cmp	r3, #0
   41c84:	d1c2      	bne.n	41c0c <data_out_block_mode+0x14>
   41c86:	e7db      	b.n	41c40 <data_out_block_mode+0x48>
   41c88:	f7ff ffa8 	bl	41bdc <on_failed_write.part.0>
   41c8c:	e7f8      	b.n	41c80 <data_out_block_mode+0x88>
   41c8e:	bf00      	nop
   41c90:	2001ad56 	.word	0x2001ad56
   41c94:	2001ad57 	.word	0x2001ad57
   41c98:	2001a5b8 	.word	0x2001a5b8

00041c9c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   41c9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   41ca0:	4605      	mov	r5, r0
	__asm__ volatile(
   41ca2:	f04f 0320 	mov.w	r3, #32
   41ca6:	f3ef 8611 	mrs	r6, BASEPRI
   41caa:	f383 8812 	msr	BASEPRI_MAX, r3
   41cae:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41cb2:	4b10      	ldr	r3, [pc, #64]	; (41cf4 <pm_state_notify+0x58>)
   41cb4:	681c      	ldr	r4, [r3, #0]
   41cb6:	2c00      	cmp	r4, #0
   41cb8:	bf38      	it	cc
   41cba:	2400      	movcc	r4, #0
   41cbc:	b19c      	cbz	r4, 41ce6 <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   41cbe:	f04f 090c 	mov.w	r9, #12
   41cc2:	4f0d      	ldr	r7, [pc, #52]	; (41cf8 <pm_state_notify+0x5c>)
   41cc4:	f8df 8034 	ldr.w	r8, [pc, #52]	; 41cfc <pm_state_notify+0x60>
			callback = notifier->state_exit;
   41cc8:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   41ccc:	2d00      	cmp	r5, #0
   41cce:	bf08      	it	eq
   41cd0:	4613      	moveq	r3, r2
		if (callback) {
   41cd2:	b12b      	cbz	r3, 41ce0 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   41cd4:	f898 2014 	ldrb.w	r2, [r8, #20]
   41cd8:	fb09 f202 	mul.w	r2, r9, r2
   41cdc:	5cb8      	ldrb	r0, [r7, r2]
   41cde:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   41ce0:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41ce2:	2c00      	cmp	r4, #0
   41ce4:	d1f0      	bne.n	41cc8 <pm_state_notify+0x2c>
	__asm__ volatile(
   41ce6:	f386 8811 	msr	BASEPRI, r6
   41cea:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   41cee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   41cf2:	bf00      	nop
   41cf4:	2001a86c 	.word	0x2001a86c
   41cf8:	2001a878 	.word	0x2001a878
   41cfc:	2001acfc 	.word	0x2001acfc

00041d00 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41d00:	2201      	movs	r2, #1
   41d02:	f000 031f 	and.w	r3, r0, #31
   41d06:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41d08:	4b08      	ldr	r3, [pc, #32]	; (41d2c <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   41d0a:	0940      	lsrs	r0, r0, #5
   41d0c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   41d10:	e8d0 3fef 	ldaex	r3, [r0]
   41d14:	ea43 0102 	orr.w	r1, r3, r2
   41d18:	e8c0 1fec 	stlex	ip, r1, [r0]
   41d1c:	f1bc 0f00 	cmp.w	ip, #0
   41d20:	d1f6      	bne.n	41d10 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   41d22:	421a      	tst	r2, r3
}
   41d24:	bf14      	ite	ne
   41d26:	2001      	movne	r0, #1
   41d28:	2000      	moveq	r0, #0
   41d2a:	4770      	bx	lr
   41d2c:	2001a884 	.word	0x2001a884

00041d30 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   41d30:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   41d32:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   41d34:	4b1a      	ldr	r3, [pc, #104]	; (41da0 <pm_system_resume+0x70>)
{
   41d36:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   41d38:	7d1d      	ldrb	r5, [r3, #20]
   41d3a:	f005 031f 	and.w	r3, r5, #31
   41d3e:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41d40:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41d42:	4b18      	ldr	r3, [pc, #96]	; (41da4 <pm_system_resume+0x74>)
   41d44:	0969      	lsrs	r1, r5, #5
   41d46:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   41d4a:	e8d3 1fef 	ldaex	r1, [r3]
   41d4e:	ea01 0400 	and.w	r4, r1, r0
   41d52:	e8c3 4fec 	stlex	ip, r4, [r3]
   41d56:	f1bc 0f00 	cmp.w	ip, #0
   41d5a:	d1f6      	bne.n	41d4a <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   41d5c:	4211      	tst	r1, r2
   41d5e:	d017      	beq.n	41d90 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   41d60:	220c      	movs	r2, #12
   41d62:	4c11      	ldr	r4, [pc, #68]	; (41da8 <pm_system_resume+0x78>)
   41d64:	ab01      	add	r3, sp, #4
   41d66:	fb02 4205 	mla	r2, r2, r5, r4
   41d6a:	ca07      	ldmia	r2, {r0, r1, r2}
   41d6c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   41d70:	4a0e      	ldr	r2, [pc, #56]	; (41dac <pm_system_resume+0x7c>)
   41d72:	b17a      	cbz	r2, 41d94 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   41d74:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41d78:	f005 fde9 	bl	4794e <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   41d7c:	2000      	movs	r0, #0
   41d7e:	f7ff ff8d 	bl	41c9c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   41d82:	230c      	movs	r3, #12
   41d84:	2200      	movs	r2, #0
   41d86:	436b      	muls	r3, r5
   41d88:	18e1      	adds	r1, r4, r3
   41d8a:	50e2      	str	r2, [r4, r3]
   41d8c:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   41d90:	b005      	add	sp, #20
   41d92:	bd30      	pop	{r4, r5, pc}
   41d94:	f382 8811 	msr	BASEPRI, r2
   41d98:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   41d9c:	e7ee      	b.n	41d7c <pm_system_resume+0x4c>
   41d9e:	bf00      	nop
   41da0:	2001acfc 	.word	0x2001acfc
   41da4:	2001a874 	.word	0x2001a874
   41da8:	2001a878 	.word	0x2001a878
   41dac:	0004794f 	.word	0x0004794f

00041db0 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   41db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   41db4:	4b39      	ldr	r3, [pc, #228]	; (41e9c <pm_system_suspend+0xec>)
{
   41db6:	4605      	mov	r5, r0
	uint8_t id = _current_cpu->id;
   41db8:	7d1c      	ldrb	r4, [r3, #20]
{
   41dba:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   41dbc:	4620      	mov	r0, r4
   41dbe:	f7ff ff9f 	bl	41d00 <atomic_test_and_set_bit.constprop.0>
   41dc2:	4e37      	ldr	r6, [pc, #220]	; (41ea0 <pm_system_suspend+0xf0>)
   41dc4:	b960      	cbnz	r0, 41de0 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   41dc6:	270c      	movs	r7, #12
   41dc8:	46e8      	mov	r8, sp
   41dca:	fb07 6704 	mla	r7, r7, r4, r6
   41dce:	462a      	mov	r2, r5
   41dd0:	4621      	mov	r1, r4
   41dd2:	4640      	mov	r0, r8
   41dd4:	f006 f888 	bl	47ee8 <pm_policy_next_state>
   41dd8:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
   41ddc:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   41de0:	230c      	movs	r3, #12
   41de2:	4363      	muls	r3, r4
   41de4:	5cf0      	ldrb	r0, [r6, r3]
   41de6:	18f2      	adds	r2, r6, r3
   41de8:	0967      	lsrs	r7, r4, #5
   41dea:	f004 081f 	and.w	r8, r4, #31
   41dee:	2800      	cmp	r0, #0
   41df0:	d03b      	beq.n	41e6a <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   41df2:	1c6b      	adds	r3, r5, #1
   41df4:	d014      	beq.n	41e20 <pm_system_suspend+0x70>
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
   41df6:	f240 30e7 	movw	r0, #999	; 0x3e7
   41dfa:	2100      	movs	r1, #0
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
		     k_us_to_ticks_ceil32(
   41dfc:	6893      	ldr	r3, [r2, #8]
   41dfe:	18c0      	adds	r0, r0, r3
   41e00:	f141 0100 	adc.w	r1, r1, #0
		if (result32 && (t < BIT64(32))) {
   41e04:	2901      	cmp	r1, #1
   41e06:	bf08      	it	eq
   41e08:	2800      	cmpeq	r0, #0
   41e0a:	d241      	bcs.n	41e90 <pm_system_suspend+0xe0>
			return ((uint32_t)t) / (from_hz / to_hz);
   41e0c:	f203 30e7 	addw	r0, r3, #999	; 0x3e7
   41e10:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   41e14:	fbb0 f0f3 	udiv	r0, r0, r3
		z_set_timeout_expiry(ticks -
   41e18:	2101      	movs	r1, #1
   41e1a:	1a28      	subs	r0, r5, r0
   41e1c:	f006 fd8d 	bl	4893a <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   41e20:	f004 fc80 	bl	46724 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   41e24:	2001      	movs	r0, #1
   41e26:	f7ff ff39 	bl	41c9c <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41e2a:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41e2c:	4b1d      	ldr	r3, [pc, #116]	; (41ea4 <pm_system_suspend+0xf4>)
   41e2e:	fa02 f208 	lsl.w	r2, r2, r8
   41e32:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   41e36:	e8d3 1fef 	ldaex	r1, [r3]
   41e3a:	4311      	orrs	r1, r2
   41e3c:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41e40:	2800      	cmp	r0, #0
   41e42:	d1f8      	bne.n	41e36 <pm_system_suspend+0x86>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   41e44:	230c      	movs	r3, #12
   41e46:	fb03 6404 	mla	r4, r3, r4, r6
   41e4a:	ab05      	add	r3, sp, #20
   41e4c:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   41e50:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   41e54:	4a14      	ldr	r2, [pc, #80]	; (41ea8 <pm_system_suspend+0xf8>)
   41e56:	b11a      	cbz	r2, 41e60 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
   41e58:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41e5c:	f005 fd64 	bl	47928 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   41e60:	f7ff ff66 	bl	41d30 <pm_system_resume>
	k_sched_unlock();
   41e64:	f004 fe38 	bl	46ad8 <k_sched_unlock>
	bool ret = true;
   41e68:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   41e6a:	2301      	movs	r3, #1
   41e6c:	fa03 f808 	lsl.w	r8, r3, r8
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41e70:	ea6f 0808 	mvn.w	r8, r8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41e74:	4b0d      	ldr	r3, [pc, #52]	; (41eac <pm_system_suspend+0xfc>)
   41e76:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   41e7a:	e8d7 3fef 	ldaex	r3, [r7]
   41e7e:	ea03 0308 	and.w	r3, r3, r8
   41e82:	e8c7 3fe2 	stlex	r2, r3, [r7]
   41e86:	2a00      	cmp	r2, #0
   41e88:	d1f7      	bne.n	41e7a <pm_system_suspend+0xca>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   41e8a:	b008      	add	sp, #32
   41e8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else {
			return t / ((uint64_t)from_hz / to_hz);
   41e90:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   41e94:	2300      	movs	r3, #0
   41e96:	f7fe f955 	bl	40144 <__aeabi_uldivmod>
   41e9a:	e7bd      	b.n	41e18 <pm_system_suspend+0x68>
   41e9c:	2001acfc 	.word	0x2001acfc
   41ea0:	2001a878 	.word	0x2001a878
   41ea4:	2001a874 	.word	0x2001a874
   41ea8:	00047929 	.word	0x00047929
   41eac:	2001a884 	.word	0x2001a884

00041eb0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   41eb0:	4901      	ldr	r1, [pc, #4]	; (41eb8 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   41eb2:	2210      	movs	r2, #16
	str	r2, [r1]
   41eb4:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   41eb6:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   41eb8:	e000ed10 	.word	0xe000ed10

00041ebc <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   41ebc:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   41ebe:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   41ec0:	f380 8811 	msr	BASEPRI, r0
	isb
   41ec4:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   41ec8:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   41ecc:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   41ece:	b662      	cpsie	i
	isb
   41ed0:	f3bf 8f6f 	isb	sy

	bx	lr
   41ed4:	4770      	bx	lr
   41ed6:	bf00      	nop

00041ed8 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   41ed8:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   41eda:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   41edc:	f381 8811 	msr	BASEPRI, r1

	wfe
   41ee0:	bf20      	wfe

	msr	BASEPRI, r0
   41ee2:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   41ee6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   41ee8:	4770      	bx	lr
   41eea:	bf00      	nop

00041eec <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   41eec:	b573      	push	{r0, r1, r4, r5, r6, lr}
   41eee:	4606      	mov	r6, r0

	if (esf != NULL) {
   41ef0:	460c      	mov	r4, r1
   41ef2:	b301      	cbz	r1, 41f36 <z_arm_fatal_error+0x4a>
   41ef4:	4b13      	ldr	r3, [pc, #76]	; (41f44 <z_arm_fatal_error+0x58>)
   41ef6:	4d14      	ldr	r5, [pc, #80]	; (41f48 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   41ef8:	4814      	ldr	r0, [pc, #80]	; (41f4c <z_arm_fatal_error+0x60>)
   41efa:	1aed      	subs	r5, r5, r3
   41efc:	08ed      	lsrs	r5, r5, #3
   41efe:	01ad      	lsls	r5, r5, #6
   41f00:	f045 0501 	orr.w	r5, r5, #1
   41f04:	f8ad 5000 	strh.w	r5, [sp]
   41f08:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   41f0c:	6809      	ldr	r1, [r1, #0]
   41f0e:	f005 fda6 	bl	47a5e <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   41f12:	f8ad 5000 	strh.w	r5, [sp]
   41f16:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   41f1a:	68e1      	ldr	r1, [r4, #12]
   41f1c:	480c      	ldr	r0, [pc, #48]	; (41f50 <z_arm_fatal_error+0x64>)
   41f1e:	f005 fd9e 	bl	47a5e <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   41f22:	462a      	mov	r2, r5
   41f24:	69e1      	ldr	r1, [r4, #28]
   41f26:	480b      	ldr	r0, [pc, #44]	; (41f54 <z_arm_fatal_error+0x68>)
   41f28:	f005 fd6c 	bl	47a04 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   41f2c:	462a      	mov	r2, r5
   41f2e:	69a1      	ldr	r1, [r4, #24]
   41f30:	4809      	ldr	r0, [pc, #36]	; (41f58 <z_arm_fatal_error+0x6c>)
   41f32:	f005 fd67 	bl	47a04 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   41f36:	4621      	mov	r1, r4
   41f38:	4630      	mov	r0, r6
}
   41f3a:	b002      	add	sp, #8
   41f3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
   41f40:	f004 b854 	b.w	45fec <z_fatal_error>
   41f44:	00048d10 	.word	0x00048d10
   41f48:	00048d40 	.word	0x00048d40
   41f4c:	00049119 	.word	0x00049119
   41f50:	00049148 	.word	0x00049148
   41f54:	00049177 	.word	0x00049177
   41f58:	00049186 	.word	0x00049186

00041f5c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   41f5c:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   41f5e:	2b00      	cmp	r3, #0
   41f60:	db08      	blt.n	41f74 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   41f62:	2201      	movs	r2, #1
   41f64:	f000 001f 	and.w	r0, r0, #31
   41f68:	fa02 f000 	lsl.w	r0, r2, r0
   41f6c:	4a02      	ldr	r2, [pc, #8]	; (41f78 <arch_irq_enable+0x1c>)
   41f6e:	095b      	lsrs	r3, r3, #5
   41f70:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   41f74:	4770      	bx	lr
   41f76:	bf00      	nop
   41f78:	e000e100 	.word	0xe000e100

00041f7c <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   41f7c:	4b05      	ldr	r3, [pc, #20]	; (41f94 <arch_irq_is_enabled+0x18>)
   41f7e:	0942      	lsrs	r2, r0, #5
   41f80:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   41f84:	2301      	movs	r3, #1
   41f86:	f000 001f 	and.w	r0, r0, #31
   41f8a:	fa03 f000 	lsl.w	r0, r3, r0
}
   41f8e:	4010      	ands	r0, r2
   41f90:	4770      	bx	lr
   41f92:	bf00      	nop
   41f94:	e000e100 	.word	0xe000e100

00041f98 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   41f98:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   41f9a:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   41f9c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fa0:	bfac      	ite	ge
   41fa2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fa6:	4b06      	ldrlt	r3, [pc, #24]	; (41fc0 <z_arm_irq_priority_set+0x28>)
   41fa8:	ea4f 1141 	mov.w	r1, r1, lsl #5
   41fac:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fae:	bfab      	itete	ge
   41fb0:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fb4:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fb8:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   41fbc:	5419      	strblt	r1, [r3, r0]
}
   41fbe:	4770      	bx	lr
   41fc0:	e000ed14 	.word	0xe000ed14

00041fc4 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   41fc4:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   41fc6:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   41fc8:	4b04      	ldr	r3, [pc, #16]	; (41fdc <_arch_isr_direct_pm+0x18>)
   41fca:	699a      	ldr	r2, [r3, #24]
   41fcc:	b11a      	cbz	r2, 41fd6 <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   41fce:	2200      	movs	r2, #0
   41fd0:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   41fd2:	f006 fb80 	bl	486d6 <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   41fd6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   41fd8:	bd08      	pop	{r3, pc}
   41fda:	bf00      	nop
   41fdc:	2001acfc 	.word	0x2001acfc

00041fe0 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   41fe0:	bf30      	wfi
    b z_SysNmiOnReset
   41fe2:	f7ff bffd 	b.w	41fe0 <z_SysNmiOnReset>
   41fe6:	bf00      	nop

00041fe8 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   41fe8:	4a0b      	ldr	r2, [pc, #44]	; (42018 <z_arm_prep_c+0x30>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   41fea:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   41fec:	4b0b      	ldr	r3, [pc, #44]	; (4201c <z_arm_prep_c+0x34>)
   41fee:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   41ff2:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   41ff4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   41ff8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   41ffc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   42000:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   42004:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   42008:	f004 f896 	bl	46138 <z_bss_zero>
	z_data_copy();
   4200c:	f004 fe86 	bl	46d1c <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   42010:	f000 fb06 	bl	42620 <z_arm_interrupt_init>
	z_cstart();
   42014:	f004 f89a 	bl	4614c <z_cstart>
   42018:	00040000 	.word	0x00040000
   4201c:	e000ed00 	.word	0xe000ed00

00042020 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   42020:	4a09      	ldr	r2, [pc, #36]	; (42048 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   42022:	490a      	ldr	r1, [pc, #40]	; (4204c <arch_swap+0x2c>)
	_current->arch.basepri = key;
   42024:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   42026:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   42028:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   4202a:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   4202c:	4908      	ldr	r1, [pc, #32]	; (42050 <arch_swap+0x30>)
   4202e:	684b      	ldr	r3, [r1, #4]
   42030:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   42034:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   42036:	2300      	movs	r3, #0
   42038:	f383 8811 	msr	BASEPRI, r3
   4203c:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   42040:	6893      	ldr	r3, [r2, #8]
}
   42042:	6f98      	ldr	r0, [r3, #120]	; 0x78
   42044:	4770      	bx	lr
   42046:	bf00      	nop
   42048:	2001acfc 	.word	0x2001acfc
   4204c:	00048f70 	.word	0x00048f70
   42050:	e000ed00 	.word	0xe000ed00

00042054 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   42054:	4915      	ldr	r1, [pc, #84]	; (420ac <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   42056:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   42058:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   4205c:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   42060:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   42062:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   42066:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   4206a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   4206c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   42070:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   42074:	4f0e      	ldr	r7, [pc, #56]	; (420b0 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   42076:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   4207a:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   4207c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   4207e:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   42080:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   42084:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   42086:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   42088:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   4208a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   4208e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   42092:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   42096:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   4209a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   4209e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   420a0:	f005 ff36 	bl	47f10 <configure_builtin_stack_guard>
    pop {r2, lr}
   420a4:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   420a8:	4770      	bx	lr
   420aa:	0000      	.short	0x0000
    ldr r1, =_kernel
   420ac:	2001acfc 	.word	0x2001acfc
    ldr v4, =_SCS_ICSR
   420b0:	e000ed04 	.word	0xe000ed04

000420b4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   420b4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   420b8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   420ba:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   420be:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   420c2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   420c4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   420c8:	2902      	cmp	r1, #2
    beq _oops
   420ca:	d0ff      	beq.n	420cc <_oops>

000420cc <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   420cc:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   420ce:	f005 ff10 	bl	47ef2 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   420d2:	bd01      	pop	{r0, pc}

000420d4 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   420d4:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   420d8:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   420da:	490c      	ldr	r1, [pc, #48]	; (4210c <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   420dc:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   420e0:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   420e2:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   420e6:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   420ea:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   420ec:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   420f0:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   420f4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   420f8:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   420fc:	2300      	movs	r3, #0
   420fe:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   42100:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   42104:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   42106:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   42108:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   4210a:	4770      	bx	lr
   4210c:	000474c7 	.word	0x000474c7

00042110 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   42110:	4b08      	ldr	r3, [pc, #32]	; (42134 <arch_switch_to_main_thread+0x24>)
   42112:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   42114:	6e43      	ldr	r3, [r0, #100]	; 0x64
   42116:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   4211a:	4610      	mov	r0, r2
   4211c:	f381 8809 	msr	PSP, r1
   42120:	2100      	movs	r1, #0
   42122:	b663      	cpsie	if
   42124:	f381 8811 	msr	BASEPRI, r1
   42128:	f3bf 8f6f 	isb	sy
   4212c:	2200      	movs	r2, #0
   4212e:	2300      	movs	r3, #0
   42130:	f005 f9c9 	bl	474c6 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   42134:	2001acfc 	.word	0x2001acfc

00042138 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   42138:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   4213a:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   4213c:	4a0b      	ldr	r2, [pc, #44]	; (4216c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   4213e:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   42140:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   42142:	bf1e      	ittt	ne
	movne	r1, #0
   42144:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   42146:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   42148:	f006 fac5 	blne	486d6 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   4214c:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   4214e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   42152:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   42156:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   4215a:	4905      	ldr	r1, [pc, #20]	; (42170 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   4215c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   4215e:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   42160:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   42162:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   42166:	4903      	ldr	r1, [pc, #12]	; (42174 <_isr_wrapper+0x3c>)
	bx r1
   42168:	4708      	bx	r1
   4216a:	0000      	.short	0x0000
	ldr r2, =_kernel
   4216c:	2001acfc 	.word	0x2001acfc
	ldr r1, =_sw_isr_table
   42170:	00048b08 	.word	0x00048b08
	ldr r1, =z_arm_int_exit
   42174:	00042179 	.word	0x00042179

00042178 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   42178:	4b04      	ldr	r3, [pc, #16]	; (4218c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   4217a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   4217c:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   4217e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   42180:	d003      	beq.n	4218a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   42182:	4903      	ldr	r1, [pc, #12]	; (42190 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   42184:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   42188:	600a      	str	r2, [r1, #0]

0004218a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   4218a:	4770      	bx	lr
	ldr r3, =_kernel
   4218c:	2001acfc 	.word	0x2001acfc
	ldr r1, =_SCS_ICSR
   42190:	e000ed04 	.word	0xe000ed04

00042194 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
   42194:	b570      	push	{r4, r5, r6, lr}
   42196:	4b28      	ldr	r3, [pc, #160]	; (42238 <usage_fault.isra.0+0xa4>)
   42198:	4c28      	ldr	r4, [pc, #160]	; (4223c <usage_fault.isra.0+0xa8>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4219a:	4d29      	ldr	r5, [pc, #164]	; (42240 <usage_fault.isra.0+0xac>)
   4219c:	1ae4      	subs	r4, r4, r3
   4219e:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
   421a0:	01a4      	lsls	r4, r4, #6
   421a2:	f044 0601 	orr.w	r6, r4, #1
   421a6:	4631      	mov	r1, r6
   421a8:	4826      	ldr	r0, [pc, #152]	; (42244 <usage_fault.isra.0+0xb0>)
   421aa:	f005 fc1e 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   421ae:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   421b0:	0193      	lsls	r3, r2, #6
   421b2:	d503      	bpl.n	421bc <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
   421b4:	4631      	mov	r1, r6
   421b6:	4824      	ldr	r0, [pc, #144]	; (42248 <usage_fault.isra.0+0xb4>)
   421b8:	f005 fc17 	bl	479ea <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   421bc:	6aab      	ldr	r3, [r5, #40]	; 0x28
   421be:	01dd      	lsls	r5, r3, #7
   421c0:	d504      	bpl.n	421cc <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
   421c2:	4822      	ldr	r0, [pc, #136]	; (4224c <usage_fault.isra.0+0xb8>)
   421c4:	f044 0101 	orr.w	r1, r4, #1
   421c8:	f005 fc0f 	bl	479ea <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   421cc:	4d1c      	ldr	r5, [pc, #112]	; (42240 <usage_fault.isra.0+0xac>)
   421ce:	6aae      	ldr	r6, [r5, #40]	; 0x28
   421d0:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   421d4:	d005      	beq.n	421e2 <usage_fault.isra.0+0x4e>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   421d6:	481e      	ldr	r0, [pc, #120]	; (42250 <usage_fault.isra.0+0xbc>)
   421d8:	f044 0101 	orr.w	r1, r4, #1
   421dc:	f005 fc05 	bl	479ea <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   421e0:	2602      	movs	r6, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   421e2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   421e4:	0318      	lsls	r0, r3, #12
   421e6:	d504      	bpl.n	421f2 <usage_fault.isra.0+0x5e>
		PR_FAULT_INFO("  No coprocessor instructions");
   421e8:	481a      	ldr	r0, [pc, #104]	; (42254 <usage_fault.isra.0+0xc0>)
   421ea:	f044 0101 	orr.w	r1, r4, #1
   421ee:	f005 fbfc 	bl	479ea <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   421f2:	4d13      	ldr	r5, [pc, #76]	; (42240 <usage_fault.isra.0+0xac>)
   421f4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   421f6:	0351      	lsls	r1, r2, #13
   421f8:	d504      	bpl.n	42204 <usage_fault.isra.0+0x70>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   421fa:	4817      	ldr	r0, [pc, #92]	; (42258 <usage_fault.isra.0+0xc4>)
   421fc:	f044 0101 	orr.w	r1, r4, #1
   42200:	f005 fbf3 	bl	479ea <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   42204:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42206:	039a      	lsls	r2, r3, #14
   42208:	d504      	bpl.n	42214 <usage_fault.isra.0+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   4220a:	4814      	ldr	r0, [pc, #80]	; (4225c <usage_fault.isra.0+0xc8>)
   4220c:	f044 0101 	orr.w	r1, r4, #1
   42210:	f005 fbeb 	bl	479ea <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   42214:	4d0a      	ldr	r5, [pc, #40]	; (42240 <usage_fault.isra.0+0xac>)
   42216:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42218:	03db      	lsls	r3, r3, #15
   4221a:	d504      	bpl.n	42226 <usage_fault.isra.0+0x92>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   4221c:	4810      	ldr	r0, [pc, #64]	; (42260 <usage_fault.isra.0+0xcc>)
   4221e:	f044 0101 	orr.w	r1, r4, #1
   42222:	f005 fbe2 	bl	479ea <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   42226:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
   42228:	4630      	mov	r0, r6
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   4222a:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   4222e:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   42232:	62ab      	str	r3, [r5, #40]	; 0x28
}
   42234:	bd70      	pop	{r4, r5, r6, pc}
   42236:	bf00      	nop
   42238:	00048d10 	.word	0x00048d10
   4223c:	00048d40 	.word	0x00048d40
   42240:	e000ed00 	.word	0xe000ed00
   42244:	000491b4 	.word	0x000491b4
   42248:	000491cc 	.word	0x000491cc
   4224c:	000491df 	.word	0x000491df
   42250:	000491f9 	.word	0x000491f9
   42254:	00049223 	.word	0x00049223
   42258:	00049241 	.word	0x00049241
   4225c:	00049266 	.word	0x00049266
   42260:	00049280 	.word	0x00049280

00042264 <mem_manage_fault.isra.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42264:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   42268:	4b28      	ldr	r3, [pc, #160]	; (4230c <mem_manage_fault.isra.0+0xa8>)
   4226a:	4c29      	ldr	r4, [pc, #164]	; (42310 <mem_manage_fault.isra.0+0xac>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   4226c:	4d29      	ldr	r5, [pc, #164]	; (42314 <mem_manage_fault.isra.0+0xb0>)
   4226e:	1ae4      	subs	r4, r4, r3
   42270:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
   42272:	01a4      	lsls	r4, r4, #6
   42274:	f044 0801 	orr.w	r8, r4, #1
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42278:	4607      	mov	r7, r0
   4227a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   4227c:	4826      	ldr	r0, [pc, #152]	; (42318 <mem_manage_fault.isra.0+0xb4>)
   4227e:	4641      	mov	r1, r8
   42280:	f005 fbb3 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42284:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42286:	06d0      	lsls	r0, r2, #27
   42288:	d503      	bpl.n	42292 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
   4228a:	4641      	mov	r1, r8
   4228c:	4823      	ldr	r0, [pc, #140]	; (4231c <mem_manage_fault.isra.0+0xb8>)
   4228e:	f005 fbac 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   42292:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42294:	0719      	lsls	r1, r3, #28
   42296:	d504      	bpl.n	422a2 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42298:	4821      	ldr	r0, [pc, #132]	; (42320 <mem_manage_fault.isra.0+0xbc>)
   4229a:	f044 0101 	orr.w	r1, r4, #1
   4229e:	f005 fba4 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   422a2:	4d1c      	ldr	r5, [pc, #112]	; (42314 <mem_manage_fault.isra.0+0xb0>)
   422a4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422a6:	079a      	lsls	r2, r3, #30
   422a8:	d512      	bpl.n	422d0 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
   422aa:	f044 0801 	orr.w	r8, r4, #1
   422ae:	4641      	mov	r1, r8
   422b0:	481c      	ldr	r0, [pc, #112]	; (42324 <mem_manage_fault.isra.0+0xc0>)
   422b2:	f005 fb9a 	bl	479ea <log_0>
		uint32_t temp = SCB->MMFAR;
   422b6:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   422b8:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422ba:	061b      	lsls	r3, r3, #24
   422bc:	d508      	bpl.n	422d0 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   422be:	4642      	mov	r2, r8
   422c0:	4819      	ldr	r0, [pc, #100]	; (42328 <mem_manage_fault.isra.0+0xc4>)
   422c2:	f005 fb9f 	bl	47a04 <log_1>
			if (from_hard_fault != 0) {
   422c6:	b11f      	cbz	r7, 422d0 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   422c8:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422ca:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   422ce:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   422d0:	4d10      	ldr	r5, [pc, #64]	; (42314 <mem_manage_fault.isra.0+0xb0>)
   422d2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   422d4:	07d0      	lsls	r0, r2, #31
   422d6:	d504      	bpl.n	422e2 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
   422d8:	4814      	ldr	r0, [pc, #80]	; (4232c <mem_manage_fault.isra.0+0xc8>)
   422da:	f044 0101 	orr.w	r1, r4, #1
   422de:	f005 fb84 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   422e2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422e4:	0699      	lsls	r1, r3, #26
   422e6:	d504      	bpl.n	422f2 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
   422e8:	4811      	ldr	r0, [pc, #68]	; (42330 <mem_manage_fault.isra.0+0xcc>)
   422ea:	f044 0101 	orr.w	r1, r4, #1
   422ee:	f005 fb7c 	bl	479ea <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   422f2:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   422f4:	4b07      	ldr	r3, [pc, #28]	; (42314 <mem_manage_fault.isra.0+0xb0>)
   422f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   422f8:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   422fa:	bf58      	it	pl
   422fc:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   422fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   42300:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   42304:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   42306:	7030      	strb	r0, [r6, #0]
}
   42308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4230c:	00048d10 	.word	0x00048d10
   42310:	00048d40 	.word	0x00048d40
   42314:	e000ed00 	.word	0xe000ed00
   42318:	000492ab 	.word	0x000492ab
   4231c:	000492c1 	.word	0x000492c1
   42320:	000492f4 	.word	0x000492f4
   42324:	00049307 	.word	0x00049307
   42328:	0004931f 	.word	0x0004931f
   4232c:	00049335 	.word	0x00049335
   42330:	00049354 	.word	0x00049354

00042334 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   42334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   42338:	4b2a      	ldr	r3, [pc, #168]	; (423e4 <bus_fault.isra.0+0xb0>)
   4233a:	4c2b      	ldr	r4, [pc, #172]	; (423e8 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   4233c:	4d2b      	ldr	r5, [pc, #172]	; (423ec <bus_fault.isra.0+0xb8>)
   4233e:	1ae4      	subs	r4, r4, r3
   42340:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
   42342:	01a4      	lsls	r4, r4, #6
   42344:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   42348:	4607      	mov	r7, r0
   4234a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   4234c:	4828      	ldr	r0, [pc, #160]	; (423f0 <bus_fault.isra.0+0xbc>)
   4234e:	4641      	mov	r1, r8
   42350:	f005 fb4b 	bl	479ea <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   42354:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42356:	04d1      	lsls	r1, r2, #19
   42358:	d503      	bpl.n	42362 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
   4235a:	4641      	mov	r1, r8
   4235c:	4825      	ldr	r0, [pc, #148]	; (423f4 <bus_fault.isra.0+0xc0>)
   4235e:	f005 fb44 	bl	479ea <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   42362:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42364:	051a      	lsls	r2, r3, #20
   42366:	d504      	bpl.n	42372 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42368:	4823      	ldr	r0, [pc, #140]	; (423f8 <bus_fault.isra.0+0xc4>)
   4236a:	f044 0101 	orr.w	r1, r4, #1
   4236e:	f005 fb3c 	bl	479ea <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   42372:	4d1e      	ldr	r5, [pc, #120]	; (423ec <bus_fault.isra.0+0xb8>)
   42374:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42376:	059b      	lsls	r3, r3, #22
   42378:	d512      	bpl.n	423a0 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
   4237a:	f044 0801 	orr.w	r8, r4, #1
   4237e:	4641      	mov	r1, r8
   42380:	481e      	ldr	r0, [pc, #120]	; (423fc <bus_fault.isra.0+0xc8>)
   42382:	f005 fb32 	bl	479ea <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   42386:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   42388:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4238a:	0418      	lsls	r0, r3, #16
   4238c:	d508      	bpl.n	423a0 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   4238e:	4642      	mov	r2, r8
   42390:	481b      	ldr	r0, [pc, #108]	; (42400 <bus_fault.isra.0+0xcc>)
   42392:	f005 fb37 	bl	47a04 <log_1>
			if (from_hard_fault != 0) {
   42396:	b11f      	cbz	r7, 423a0 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   42398:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4239a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   4239e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   423a0:	4d12      	ldr	r5, [pc, #72]	; (423ec <bus_fault.isra.0+0xb8>)
   423a2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   423a4:	0559      	lsls	r1, r3, #21
   423a6:	d504      	bpl.n	423b2 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
   423a8:	4816      	ldr	r0, [pc, #88]	; (42404 <bus_fault.isra.0+0xd0>)
   423aa:	f044 0101 	orr.w	r1, r4, #1
   423ae:	f005 fb1c 	bl	479ea <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   423b2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   423b4:	05da      	lsls	r2, r3, #23
   423b6:	d50d      	bpl.n	423d4 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
   423b8:	4813      	ldr	r0, [pc, #76]	; (42408 <bus_fault.isra.0+0xd4>)
   423ba:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   423be:	f005 fb14 	bl	479ea <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   423c2:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   423c4:	4a09      	ldr	r2, [pc, #36]	; (423ec <bus_fault.isra.0+0xb8>)
   423c6:	6a93      	ldr	r3, [r2, #40]	; 0x28
   423c8:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   423cc:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   423ce:	7030      	strb	r0, [r6, #0]
}
   423d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   423d4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   423d6:	049b      	lsls	r3, r3, #18
   423d8:	d5f3      	bpl.n	423c2 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   423da:	480c      	ldr	r0, [pc, #48]	; (4240c <bus_fault.isra.0+0xd8>)
   423dc:	f044 0101 	orr.w	r1, r4, #1
   423e0:	e7ed      	b.n	423be <bus_fault.isra.0+0x8a>
   423e2:	bf00      	nop
   423e4:	00048d10 	.word	0x00048d10
   423e8:	00048d40 	.word	0x00048d40
   423ec:	e000ed00 	.word	0xe000ed00
   423f0:	00049383 	.word	0x00049383
   423f4:	00049399 	.word	0x00049399
   423f8:	000492f4 	.word	0x000492f4
   423fc:	000493aa 	.word	0x000493aa
   42400:	000493c3 	.word	0x000493c3
   42404:	000493d8 	.word	0x000493d8
   42408:	000493f3 	.word	0x000493f3
   4240c:	00049354 	.word	0x00049354

00042410 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   42410:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   42414:	4b68      	ldr	r3, [pc, #416]	; (425b8 <z_arm_fault+0x1a8>)
{
   42416:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   42418:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   4241c:	4689      	mov	r9, r1
   4241e:	4614      	mov	r4, r2
   42420:	2700      	movs	r7, #0
   42422:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   42424:	f3c8 0608 	ubfx	r6, r8, #0, #9
   42428:	f387 8811 	msr	BASEPRI, r7
   4242c:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   42430:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   42434:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   42438:	d124      	bne.n	42484 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   4243a:	07d0      	lsls	r0, r2, #31
   4243c:	d422      	bmi.n	42484 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   4243e:	0651      	lsls	r1, r2, #25
   42440:	d403      	bmi.n	4244a <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   42442:	0722      	lsls	r2, r4, #28
   42444:	d40e      	bmi.n	42464 <z_arm_fault+0x54>
			*nested_exc = true;
   42446:	2701      	movs	r7, #1
   42448:	e00e      	b.n	42468 <z_arm_fault+0x58>
   4244a:	495c      	ldr	r1, [pc, #368]	; (425bc <z_arm_fault+0x1ac>)
   4244c:	4b5c      	ldr	r3, [pc, #368]	; (425c0 <z_arm_fault+0x1b0>)
		PR_FAULT_INFO("Exception occurred in Secure State");
   4244e:	485d      	ldr	r0, [pc, #372]	; (425c4 <z_arm_fault+0x1b4>)
   42450:	1a5b      	subs	r3, r3, r1
   42452:	08db      	lsrs	r3, r3, #3
   42454:	019b      	lsls	r3, r3, #6
   42456:	f043 0101 	orr.w	r1, r3, #1
   4245a:	f005 fac6 	bl	479ea <log_0>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   4245e:	f014 0704 	ands.w	r7, r4, #4
   42462:	d001      	beq.n	42468 <z_arm_fault+0x58>
			ptr_esf = (z_arch_esf_t *)psp;
   42464:	464d      	mov	r5, r9
	*nested_exc = false;
   42466:	2700      	movs	r7, #0
	*recoverable = false;
   42468:	2300      	movs	r3, #0
   4246a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   4246e:	1ef3      	subs	r3, r6, #3
   42470:	2b09      	cmp	r3, #9
   42472:	f200 8088 	bhi.w	42586 <z_arm_fault+0x176>
   42476:	e8df f003 	tbb	[pc, r3]
   4247a:	7507      	.short	0x7507
   4247c:	86867279 	.word	0x86867279
   42480:	7d868686 	.word	0x7d868686
		return NULL;
   42484:	463d      	mov	r5, r7
   42486:	e7ef      	b.n	42468 <z_arm_fault+0x58>
	*recoverable = false;
   42488:	f04f 0800 	mov.w	r8, #0
   4248c:	4a4b      	ldr	r2, [pc, #300]	; (425bc <z_arm_fault+0x1ac>)
   4248e:	4e4c      	ldr	r6, [pc, #304]	; (425c0 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** HARD FAULT *****");
   42490:	484d      	ldr	r0, [pc, #308]	; (425c8 <z_arm_fault+0x1b8>)
   42492:	1ab6      	subs	r6, r6, r2
   42494:	08f6      	lsrs	r6, r6, #3
   42496:	01b6      	lsls	r6, r6, #6
   42498:	f046 0601 	orr.w	r6, r6, #1
   4249c:	4631      	mov	r1, r6
   4249e:	f005 faa4 	bl	479ea <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   424a2:	4b45      	ldr	r3, [pc, #276]	; (425b8 <z_arm_fault+0x1a8>)
	*recoverable = false;
   424a4:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   424a8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   424aa:	f014 0402 	ands.w	r4, r4, #2
   424ae:	d005      	beq.n	424bc <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
   424b0:	4631      	mov	r1, r6
   424b2:	4846      	ldr	r0, [pc, #280]	; (425cc <z_arm_fault+0x1bc>)
	PR_FAULT_INFO(
   424b4:	f005 fa99 	bl	479ea <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   424b8:	2400      	movs	r4, #0
}
   424ba:	e006      	b.n	424ca <z_arm_fault+0xba>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   424bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   424be:	2a00      	cmp	r2, #0
   424c0:	da1d      	bge.n	424fe <z_arm_fault+0xee>
		PR_EXC("  Debug event");
   424c2:	4631      	mov	r1, r6
   424c4:	4842      	ldr	r0, [pc, #264]	; (425d0 <z_arm_fault+0x1c0>)
   424c6:	f005 fa90 	bl	479ea <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   424ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
   424ce:	b99b      	cbnz	r3, 424f8 <z_arm_fault+0xe8>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   424d0:	2220      	movs	r2, #32
   424d2:	4629      	mov	r1, r5
   424d4:	a802      	add	r0, sp, #8
   424d6:	f005 fd87 	bl	47fe8 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   424da:	9b09      	ldr	r3, [sp, #36]	; 0x24
   424dc:	2f00      	cmp	r7, #0
   424de:	d066      	beq.n	425ae <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   424e0:	f3c3 0208 	ubfx	r2, r3, #0, #9
   424e4:	b922      	cbnz	r2, 424f0 <z_arm_fault+0xe0>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   424e6:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   424ea:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   424ee:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   424f0:	4620      	mov	r0, r4
   424f2:	a902      	add	r1, sp, #8
   424f4:	f7ff fcfa 	bl	41eec <z_arm_fatal_error>
}
   424f8:	b00b      	add	sp, #44	; 0x2c
   424fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   424fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   42500:	005b      	lsls	r3, r3, #1
   42502:	d5e2      	bpl.n	424ca <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   42504:	4631      	mov	r1, r6
   42506:	4833      	ldr	r0, [pc, #204]	; (425d4 <z_arm_fault+0x1c4>)
   42508:	f005 fa6f 	bl	479ea <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
   4250c:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   4250e:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   42512:	f64d 7302 	movw	r3, #57090	; 0xdf02
   42516:	429a      	cmp	r2, r3
   42518:	d00c      	beq.n	42534 <z_arm_fault+0x124>
		} else if (SCB_MMFSR != 0) {
   4251a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   4251e:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   42522:	781b      	ldrb	r3, [r3, #0]
   42524:	b16b      	cbz	r3, 42542 <z_arm_fault+0x132>
			reason = mem_manage_fault(esf, 1, recoverable);
   42526:	2001      	movs	r0, #1
   42528:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   4252c:	f7ff fe9a 	bl	42264 <mem_manage_fault.isra.0>
   42530:	4604      	mov	r4, r0
		break;
   42532:	e7ca      	b.n	424ca <z_arm_fault+0xba>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   42534:	4632      	mov	r2, r6
   42536:	6829      	ldr	r1, [r5, #0]
   42538:	4827      	ldr	r0, [pc, #156]	; (425d8 <z_arm_fault+0x1c8>)
   4253a:	f005 fa63 	bl	47a04 <log_1>
			reason = esf->basic.r0;
   4253e:	682c      	ldr	r4, [r5, #0]
   42540:	e7c3      	b.n	424ca <z_arm_fault+0xba>
		} else if (SCB_BFSR != 0) {
   42542:	4b26      	ldr	r3, [pc, #152]	; (425dc <z_arm_fault+0x1cc>)
   42544:	781b      	ldrb	r3, [r3, #0]
   42546:	b12b      	cbz	r3, 42554 <z_arm_fault+0x144>
			reason = bus_fault(esf, 1, recoverable);
   42548:	2001      	movs	r0, #1
   4254a:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   4254e:	f7ff fef1 	bl	42334 <bus_fault.isra.0>
   42552:	e7ed      	b.n	42530 <z_arm_fault+0x120>
		} else if (SCB_UFSR != 0) {
   42554:	4b22      	ldr	r3, [pc, #136]	; (425e0 <z_arm_fault+0x1d0>)
   42556:	881b      	ldrh	r3, [r3, #0]
   42558:	b29b      	uxth	r3, r3
   4255a:	2b00      	cmp	r3, #0
   4255c:	d0b5      	beq.n	424ca <z_arm_fault+0xba>
		reason = usage_fault(esf);
   4255e:	f7ff fe19 	bl	42194 <usage_fault.isra.0>
   42562:	e7e5      	b.n	42530 <z_arm_fault+0x120>
		reason = mem_manage_fault(esf, 0, recoverable);
   42564:	2000      	movs	r0, #0
   42566:	f10d 0107 	add.w	r1, sp, #7
   4256a:	e7df      	b.n	4252c <z_arm_fault+0x11c>
		reason = bus_fault(esf, 0, recoverable);
   4256c:	2000      	movs	r0, #0
   4256e:	f10d 0107 	add.w	r1, sp, #7
   42572:	e7ec      	b.n	4254e <z_arm_fault+0x13e>
   42574:	4912      	ldr	r1, [pc, #72]	; (425c0 <z_arm_fault+0x1b0>)
   42576:	4b11      	ldr	r3, [pc, #68]	; (425bc <z_arm_fault+0x1ac>)
	PR_FAULT_INFO(
   42578:	481a      	ldr	r0, [pc, #104]	; (425e4 <z_arm_fault+0x1d4>)
   4257a:	1ac9      	subs	r1, r1, r3
   4257c:	08c9      	lsrs	r1, r1, #3
   4257e:	0189      	lsls	r1, r1, #6
   42580:	f041 0101 	orr.w	r1, r1, #1
   42584:	e796      	b.n	424b4 <z_arm_fault+0xa4>
   42586:	4a0d      	ldr	r2, [pc, #52]	; (425bc <z_arm_fault+0x1ac>)
   42588:	4b0d      	ldr	r3, [pc, #52]	; (425c0 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** %s %d) *****",
   4258a:	4817      	ldr	r0, [pc, #92]	; (425e8 <z_arm_fault+0x1d8>)
   4258c:	1a9b      	subs	r3, r3, r2
   4258e:	08db      	lsrs	r3, r3, #3
   42590:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   42594:	ea4f 1383 	mov.w	r3, r3, lsl #6
   42598:	4914      	ldr	r1, [pc, #80]	; (425ec <z_arm_fault+0x1dc>)
   4259a:	f043 0301 	orr.w	r3, r3, #1
   4259e:	bf18      	it	ne
   425a0:	4601      	movne	r1, r0
   425a2:	f1a6 0210 	sub.w	r2, r6, #16
   425a6:	4812      	ldr	r0, [pc, #72]	; (425f0 <z_arm_fault+0x1e0>)
   425a8:	f005 fa40 	bl	47a2c <log_2>
   425ac:	e784      	b.n	424b8 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   425ae:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   425b2:	f023 0301 	bic.w	r3, r3, #1
   425b6:	e79a      	b.n	424ee <z_arm_fault+0xde>
   425b8:	e000ed00 	.word	0xe000ed00
   425bc:	00048d10 	.word	0x00048d10
   425c0:	00048d40 	.word	0x00048d40
   425c4:	0004940b 	.word	0x0004940b
   425c8:	0004942e 	.word	0x0004942e
   425cc:	00049445 	.word	0x00049445
   425d0:	00049466 	.word	0x00049466
   425d4:	00049474 	.word	0x00049474
   425d8:	00049493 	.word	0x00049493
   425dc:	e000ed29 	.word	0xe000ed29
   425e0:	e000ed2a 	.word	0xe000ed2a
   425e4:	000494af 	.word	0x000494af
   425e8:	000494e8 	.word	0x000494e8
   425ec:	000494d3 	.word	0x000494d3
   425f0:	00049501 	.word	0x00049501

000425f4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   425f4:	4b04      	ldr	r3, [pc, #16]	; (42608 <z_arm_fault_init+0x14>)
   425f6:	695a      	ldr	r2, [r3, #20]
   425f8:	f042 0210 	orr.w	r2, r2, #16
   425fc:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   425fe:	695a      	ldr	r2, [r3, #20]
   42600:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   42604:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   42606:	4770      	bx	lr
   42608:	e000ed00 	.word	0xe000ed00

0004260c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   4260c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   42610:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   42614:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   42616:	4672      	mov	r2, lr
	bl z_arm_fault
   42618:	f7ff fefa 	bl	42410 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   4261c:	bd01      	pop	{r0, pc}
   4261e:	bf00      	nop

00042620 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   42620:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42622:	2120      	movs	r1, #32
   42624:	4803      	ldr	r0, [pc, #12]	; (42634 <z_arm_interrupt_init+0x14>)
   42626:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   42628:	3301      	adds	r3, #1
   4262a:	2b41      	cmp	r3, #65	; 0x41
   4262c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   42630:	d1f9      	bne.n	42626 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   42632:	4770      	bx	lr
   42634:	e000e100 	.word	0xe000e100

00042638 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   42638:	2000      	movs	r0, #0
    msr CONTROL, r0
   4263a:	f380 8814 	msr	CONTROL, r0
    isb
   4263e:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   42642:	2000      	movs	r0, #0
    msr MSPLIM, r0
   42644:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   42648:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   4264c:	f006 f9ee 	bl	48a2c <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   42650:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   42652:	490e      	ldr	r1, [pc, #56]	; (4268c <__start+0x54>)
    str r0, [r1]
   42654:	6008      	str	r0, [r1, #0]
    dsb
   42656:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   4265a:	480d      	ldr	r0, [pc, #52]	; (42690 <__start+0x58>)
    msr msp, r0
   4265c:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   42660:	f000 f82a 	bl	426b8 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   42664:	2020      	movs	r0, #32
    msr BASEPRI, r0
   42666:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   4266a:	480a      	ldr	r0, [pc, #40]	; (42694 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   4266c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   42670:	1840      	adds	r0, r0, r1
    msr PSP, r0
   42672:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   42676:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   4267a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   4267c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   4267e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   42682:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   42686:	f7ff fcaf 	bl	41fe8 <z_arm_prep_c>
   4268a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   4268c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42690:	200231a0 	.word	0x200231a0
    ldr r0, =z_interrupt_stacks
   42694:	200232e0 	.word	0x200232e0

00042698 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   42698:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   4269a:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   4269c:	4a05      	ldr	r2, [pc, #20]	; (426b4 <z_arm_clear_arm_mpu_config+0x1c>)
   4269e:	6811      	ldr	r1, [r2, #0]
	int num_regions =
   426a0:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
   426a4:	428b      	cmp	r3, r1
   426a6:	d100      	bne.n	426aa <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
   426a8:	4770      	bx	lr
  mpu->RNR = rnr;
   426aa:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   426ac:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
   426ae:	3301      	adds	r3, #1
   426b0:	e7f8      	b.n	426a4 <z_arm_clear_arm_mpu_config+0xc>
   426b2:	bf00      	nop
   426b4:	e000ed90 	.word	0xe000ed90

000426b8 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
   426b8:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   426ba:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   426bc:	2400      	movs	r4, #0
   426be:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   426c2:	f7ff ffe9 	bl	42698 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   426c6:	4a0e      	ldr	r2, [pc, #56]	; (42700 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
   426c8:	4623      	mov	r3, r4
   426ca:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
   426cc:	f04f 34ff 	mov.w	r4, #4294967295
   426d0:	f103 0020 	add.w	r0, r3, #32
   426d4:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   426d6:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   426d8:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   426dc:	d1f8      	bne.n	426d0 <z_arm_init_arch_hw_at_boot+0x18>
   426de:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   426e0:	f04f 30ff 	mov.w	r0, #4294967295
   426e4:	f103 0260 	add.w	r2, r3, #96	; 0x60
   426e8:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   426ea:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   426ec:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   426f0:	d1f8      	bne.n	426e4 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   426f2:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   426f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   426f8:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   426fc:	bd10      	pop	{r4, pc}
   426fe:	bf00      	nop
   42700:	e000e100 	.word	0xe000e100

00042704 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   42704:	4b06      	ldr	r3, [pc, #24]	; (42720 <z_impl_k_thread_abort+0x1c>)
   42706:	689b      	ldr	r3, [r3, #8]
   42708:	4283      	cmp	r3, r0
   4270a:	d107      	bne.n	4271c <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   4270c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   42710:	b123      	cbz	r3, 4271c <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   42712:	4a04      	ldr	r2, [pc, #16]	; (42724 <z_impl_k_thread_abort+0x20>)
   42714:	6853      	ldr	r3, [r2, #4]
   42716:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   4271a:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   4271c:	f004 baac 	b.w	46c78 <z_thread_abort>
   42720:	2001acfc 	.word	0x2001acfc
   42724:	e000ed00 	.word	0xe000ed00

00042728 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   42728:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   4272a:	4c09      	ldr	r4, [pc, #36]	; (42750 <z_arm_configure_static_mpu_regions+0x28>)
   4272c:	4a09      	ldr	r2, [pc, #36]	; (42754 <z_arm_configure_static_mpu_regions+0x2c>)
   4272e:	4623      	mov	r3, r4
   42730:	2101      	movs	r1, #1
   42732:	4809      	ldr	r0, [pc, #36]	; (42758 <z_arm_configure_static_mpu_regions+0x30>)
   42734:	f000 f912 	bl	4295c <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   42738:	2300      	movs	r3, #0
   4273a:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   4273c:	4b07      	ldr	r3, [pc, #28]	; (4275c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   4273e:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   42740:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   42742:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   42744:	9301      	str	r3, [sp, #4]
   42746:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   42748:	f000 f912 	bl	42970 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   4274c:	b004      	add	sp, #16
   4274e:	bd10      	pop	{r4, pc}
   42750:	20040000 	.word	0x20040000
   42754:	2001a500 	.word	0x2001a500
   42758:	00048e28 	.word	0x00048e28
   4275c:	2001a5f0 	.word	0x2001a5f0

00042760 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   42760:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42762:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   42764:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42766:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   4276a:	f004 031f 	and.w	r3, r4, #31
   4276e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42770:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42772:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42774:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   42778:	4904      	ldr	r1, [pc, #16]	; (4278c <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   4277a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   4277e:	f043 0301 	orr.w	r3, r3, #1
   42782:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   42784:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   42786:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   42788:	bd10      	pop	{r4, pc}
   4278a:	bf00      	nop
   4278c:	e000ed90 	.word	0xe000ed90

00042790 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   42790:	280f      	cmp	r0, #15
{
   42792:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
   42794:	d90d      	bls.n	427b2 <region_allocate_and_init+0x22>
   42796:	4b08      	ldr	r3, [pc, #32]	; (427b8 <region_allocate_and_init+0x28>)
   42798:	4a08      	ldr	r2, [pc, #32]	; (427bc <region_allocate_and_init+0x2c>)

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   4279a:	4601      	mov	r1, r0
   4279c:	1ad2      	subs	r2, r2, r3
   4279e:	08d2      	lsrs	r2, r2, #3
   427a0:	0192      	lsls	r2, r2, #6
   427a2:	4807      	ldr	r0, [pc, #28]	; (427c0 <region_allocate_and_init+0x30>)
   427a4:	f042 0201 	orr.w	r2, r2, #1
   427a8:	f005 f92c 	bl	47a04 <log_1>
		return -EINVAL;
   427ac:	f06f 0015 	mvn.w	r0, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   427b0:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   427b2:	f7ff ffd5 	bl	42760 <region_init>
	return index;
   427b6:	e7fb      	b.n	427b0 <region_allocate_and_init+0x20>
   427b8:	00048d10 	.word	0x00048d10
   427bc:	00048d30 	.word	0x00048d30
   427c0:	00049518 	.word	0x00049518

000427c4 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   427c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   427c8:	4689      	mov	r9, r1
   427ca:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   427cc:	4606      	mov	r6, r0
   427ce:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
   427d2:	4d54      	ldr	r5, [pc, #336]	; (42924 <mpu_configure_regions_and_partition.constprop.0+0x160>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   427d4:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   427d6:	45c8      	cmp	r8, r9
   427d8:	da33      	bge.n	42842 <mpu_configure_regions_and_partition.constprop.0+0x7e>
		if (regions[i].size == 0U) {
   427da:	f8d6 a004 	ldr.w	sl, [r6, #4]
   427de:	f1ba 0f00 	cmp.w	sl, #0
   427e2:	d04d      	beq.n	42880 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		&&
   427e4:	f1ba 0f1f 	cmp.w	sl, #31
   427e8:	d91e      	bls.n	42828 <mpu_configure_regions_and_partition.constprop.0+0x64>
		&&
   427ea:	f01a 0f1f 	tst.w	sl, #31
   427ee:	d11b      	bne.n	42828 <mpu_configure_regions_and_partition.constprop.0+0x64>
		((part->start &
   427f0:	f8d6 b000 	ldr.w	fp, [r6]
		&&
   427f4:	f01b 0f1f 	tst.w	fp, #31
   427f8:	d116      	bne.n	42828 <mpu_configure_regions_and_partition.constprop.0+0x64>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   427fa:	4658      	mov	r0, fp
   427fc:	f005 fb8e 	bl	47f1c <arm_cmse_mpu_region_get>
   42800:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42802:	eb0a 000b 	add.w	r0, sl, fp
   42806:	3801      	subs	r0, #1
   42808:	f005 fb88 	bl	47f1c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   4280c:	4287      	cmp	r7, r0
   4280e:	d01c      	beq.n	4284a <mpu_configure_regions_and_partition.constprop.0+0x86>
	return -EINVAL;
   42810:	f06f 0715 	mvn.w	r7, #21
   42814:	4a44      	ldr	r2, [pc, #272]	; (42928 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   42816:	4b45      	ldr	r3, [pc, #276]	; (4292c <mpu_configure_regions_and_partition.constprop.0+0x168>)
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   42818:	4639      	mov	r1, r7
   4281a:	1ad2      	subs	r2, r2, r3
   4281c:	08d2      	lsrs	r2, r2, #3
   4281e:	0192      	lsls	r2, r2, #6
   42820:	4843      	ldr	r0, [pc, #268]	; (42930 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
   42822:	f042 0201 	orr.w	r2, r2, #1
   42826:	e008      	b.n	4283a <mpu_configure_regions_and_partition.constprop.0+0x76>
			LOG_ERR("Partition %u: sanity check failed.", i);
   42828:	4641      	mov	r1, r8
   4282a:	4a3f      	ldr	r2, [pc, #252]	; (42928 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   4282c:	4b3f      	ldr	r3, [pc, #252]	; (4292c <mpu_configure_regions_and_partition.constprop.0+0x168>)
   4282e:	4841      	ldr	r0, [pc, #260]	; (42934 <mpu_configure_regions_and_partition.constprop.0+0x170>)
   42830:	1ad2      	subs	r2, r2, r3
   42832:	08d2      	lsrs	r2, r2, #3
   42834:	0192      	lsls	r2, r2, #6
   42836:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
   4283a:	f005 f8e3 	bl	47a04 <log_1>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   4283e:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   42842:	4620      	mov	r0, r4
   42844:	b005      	add	sp, #20
   42846:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   4284a:	f117 0f16 	cmn.w	r7, #22
   4284e:	d0e1      	beq.n	42814 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
   42850:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   42852:	42bb      	cmp	r3, r7
   42854:	dbde      	blt.n	42814 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
   42856:	60af      	str	r7, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   42858:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   4285a:	60af      	str	r7, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   4285c:	692b      	ldr	r3, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   4285e:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42862:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42866:	e9d6 3200 	ldrd	r3, r2, [r6]
   4286a:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   4286c:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   4286e:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
   42872:	d11a      	bne.n	428aa <mpu_configure_regions_and_partition.constprop.0+0xe6>
   42874:	45d3      	cmp	fp, sl
   42876:	d107      	bne.n	42888 <mpu_configure_regions_and_partition.constprop.0+0xc4>
			mpu_configure_region(u_reg_index, &regions[i]);
   42878:	4631      	mov	r1, r6
   4287a:	b2f8      	uxtb	r0, r7
   4287c:	f005 fb57 	bl	47f2e <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   42880:	f108 0801 	add.w	r8, r8, #1
   42884:	360c      	adds	r6, #12
   42886:	e7a6      	b.n	427d6 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   42888:	4631      	mov	r1, r6
	MPU->RNR = index;
   4288a:	60af      	str	r7, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   4288c:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   4288e:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42892:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   42896:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42898:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   4289a:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   4289c:	f005 fb47 	bl	47f2e <mpu_configure_region>
			if (reg_index == -EINVAL) {
   428a0:	f110 0f16 	cmn.w	r0, #22
   428a4:	d0cb      	beq.n	4283e <mpu_configure_regions_and_partition.constprop.0+0x7a>
			reg_index++;
   428a6:	1c44      	adds	r4, r0, #1
   428a8:	e7ea      	b.n	42880 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		} else if (reg_last == u_reg_last) {
   428aa:	3b01      	subs	r3, #1
   428ac:	45d3      	cmp	fp, sl
   428ae:	b2e0      	uxtb	r0, r4
   428b0:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   428b4:	60af      	str	r7, [r5, #8]
		} else if (reg_last == u_reg_last) {
   428b6:	d106      	bne.n	428c6 <mpu_configure_regions_and_partition.constprop.0+0x102>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   428b8:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   428ba:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   428bc:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   428c0:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   428c2:	612b      	str	r3, [r5, #16]
			reg_index =
   428c4:	e7ea      	b.n	4289c <mpu_configure_regions_and_partition.constprop.0+0xd8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   428c6:	6929      	ldr	r1, [r5, #16]
   428c8:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   428cc:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   428ce:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   428d0:	4631      	mov	r1, r6
   428d2:	f005 fb2c 	bl	47f2e <mpu_configure_region>
			if (reg_index == -EINVAL) {
   428d6:	f110 0f16 	cmn.w	r0, #22
   428da:	d0b0      	beq.n	4283e <mpu_configure_regions_and_partition.constprop.0+0x7a>
	MPU->RNR = index;
   428dc:	60af      	str	r7, [r5, #8]
	attr->rbar = MPU->RBAR &
   428de:	68ea      	ldr	r2, [r5, #12]
   428e0:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   428e4:	f10b 3bff 	add.w	fp, fp, #4294967295
	attr->rbar = MPU->RBAR &
   428e8:	f362 0304 	bfi	r3, r2, #0, #5
   428ec:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   428f0:	692b      	ldr	r3, [r5, #16]
   428f2:	f89d 2008 	ldrb.w	r2, [sp, #8]
   428f6:	085b      	lsrs	r3, r3, #1
   428f8:	f363 1247 	bfi	r2, r3, #5, #3
   428fc:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   42900:	e9d6 3200 	ldrd	r3, r2, [r6]
   42904:	4413      	add	r3, r2
   42906:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   42908:	f023 031f 	bic.w	r3, r3, #31
   4290c:	445b      	add	r3, fp
   4290e:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
   42912:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   42914:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   42918:	4669      	mov	r1, sp
   4291a:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   4291c:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   4291e:	f7ff ff37 	bl	42790 <region_allocate_and_init>
   42922:	e7bd      	b.n	428a0 <mpu_configure_regions_and_partition.constprop.0+0xdc>
   42924:	e000ed90 	.word	0xe000ed90
   42928:	00048d30 	.word	0x00048d30
   4292c:	00048d10 	.word	0x00048d10
   42930:	00049561 	.word	0x00049561
   42934:	0004953e 	.word	0x0004953e

00042938 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   42938:	2205      	movs	r2, #5
   4293a:	4b03      	ldr	r3, [pc, #12]	; (42948 <arm_core_mpu_enable+0x10>)
   4293c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   4293e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42942:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   42946:	4770      	bx	lr
   42948:	e000ed90 	.word	0xe000ed90

0004294c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   4294c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   42950:	2200      	movs	r2, #0
   42952:	4b01      	ldr	r3, [pc, #4]	; (42958 <arm_core_mpu_disable+0xc>)
   42954:	605a      	str	r2, [r3, #4]
}
   42956:	4770      	bx	lr
   42958:	e000ed90 	.word	0xe000ed90

0004295c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   4295c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   4295e:	4c03      	ldr	r4, [pc, #12]	; (4296c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   42960:	7822      	ldrb	r2, [r4, #0]
   42962:	f7ff ff2f 	bl	427c4 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   42966:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   42968:	bd10      	pop	{r4, pc}
   4296a:	bf00      	nop
   4296c:	2001ad58 	.word	0x2001ad58

00042970 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   42970:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42974:	4d26      	ldr	r5, [pc, #152]	; (42a10 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   42976:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42978:	4606      	mov	r6, r0
   4297a:	f04f 0800 	mov.w	r8, #0
   4297e:	46ab      	mov	fp, r5
	MPU->RNR = index;
   42980:	4f24      	ldr	r7, [pc, #144]	; (42a14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42982:	45d0      	cmp	r8, sl
   42984:	da1b      	bge.n	429be <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   42986:	f8d6 9004 	ldr.w	r9, [r6, #4]
   4298a:	f1b9 0f00 	cmp.w	r9, #0
   4298e:	d039      	beq.n	42a04 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   42990:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42992:	4608      	mov	r0, r1
   42994:	9101      	str	r1, [sp, #4]
   42996:	f005 fac1 	bl	47f1c <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   4299a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   4299c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   4299e:	eb09 0001 	add.w	r0, r9, r1
   429a2:	3801      	subs	r0, #1
   429a4:	f005 faba 	bl	47f1c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   429a8:	4284      	cmp	r4, r0
   429aa:	f04f 0214 	mov.w	r2, #20
   429ae:	4b1a      	ldr	r3, [pc, #104]	; (42a18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   429b0:	d008      	beq.n	429c4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   429b2:	f06f 0315 	mvn.w	r3, #21
   429b6:	fb02 f808 	mul.w	r8, r2, r8
   429ba:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   429be:	b003      	add	sp, #12
   429c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   429c4:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   429c8:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   429ca:	d0f8      	beq.n	429be <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   429cc:	7819      	ldrb	r1, [r3, #0]
   429ce:	42a1      	cmp	r1, r4
   429d0:	ddf5      	ble.n	429be <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   429d2:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   429d6:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   429d8:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   429da:	68fc      	ldr	r4, [r7, #12]
   429dc:	f100 0108 	add.w	r1, r0, #8
   429e0:	7b00      	ldrb	r0, [r0, #12]
   429e2:	f364 0004 	bfi	r0, r4, #0, #5
   429e6:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   429e8:	6938      	ldr	r0, [r7, #16]
   429ea:	790c      	ldrb	r4, [r1, #4]
   429ec:	0840      	lsrs	r0, r0, #1
   429ee:	f360 1447 	bfi	r4, r0, #5, #3
   429f2:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   429f4:	68f9      	ldr	r1, [r7, #12]
   429f6:	f021 011f 	bic.w	r1, r1, #31
   429fa:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   429fc:	6939      	ldr	r1, [r7, #16]
   429fe:	f021 011f 	bic.w	r1, r1, #31
   42a02:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42a04:	f108 0801 	add.w	r8, r8, #1
   42a08:	3514      	adds	r5, #20
   42a0a:	360c      	adds	r6, #12
   42a0c:	e7b9      	b.n	42982 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   42a0e:	bf00      	nop
   42a10:	2001a888 	.word	0x2001a888
   42a14:	e000ed90 	.word	0xe000ed90
   42a18:	2001ad58 	.word	0x2001ad58

00042a1c <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   42a1c:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   42a1e:	4c0e      	ldr	r4, [pc, #56]	; (42a58 <z_arm_mpu_init+0x3c>)
   42a20:	6825      	ldr	r5, [r4, #0]
   42a22:	2d10      	cmp	r5, #16
   42a24:	d814      	bhi.n	42a50 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   42a26:	f7ff ff91 	bl	4294c <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42a2a:	2000      	movs	r0, #0
	MPU->MAIR0 =
   42a2c:	4b0b      	ldr	r3, [pc, #44]	; (42a5c <z_arm_mpu_init+0x40>)
   42a2e:	4a0c      	ldr	r2, [pc, #48]	; (42a60 <z_arm_mpu_init+0x44>)
   42a30:	631a      	str	r2, [r3, #48]	; 0x30
   42a32:	4285      	cmp	r5, r0
   42a34:	d105      	bne.n	42a42 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   42a36:	4b0b      	ldr	r3, [pc, #44]	; (42a64 <z_arm_mpu_init+0x48>)
   42a38:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   42a3a:	f7ff ff7d 	bl	42938 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   42a3e:	2000      	movs	r0, #0
}
   42a40:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   42a42:	6861      	ldr	r1, [r4, #4]
   42a44:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   42a48:	f7ff fe8a 	bl	42760 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42a4c:	3001      	adds	r0, #1
   42a4e:	e7f0      	b.n	42a32 <z_arm_mpu_init+0x16>
		return -1;
   42a50:	f04f 30ff 	mov.w	r0, #4294967295
   42a54:	e7f4      	b.n	42a40 <z_arm_mpu_init+0x24>
   42a56:	bf00      	nop
   42a58:	00048e34 	.word	0x00048e34
   42a5c:	e000ed90 	.word	0xe000ed90
   42a60:	0044ffaa 	.word	0x0044ffaa
   42a64:	2001ad58 	.word	0x2001ad58

00042a68 <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   42a68:	b508      	push	{r3, lr}
   42a6a:	4908      	ldr	r1, [pc, #32]	; (42a8c <malloc+0x24>)
   42a6c:	4b08      	ldr	r3, [pc, #32]	; (42a90 <malloc+0x28>)
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
   42a6e:	4809      	ldr	r0, [pc, #36]	; (42a94 <malloc+0x2c>)
   42a70:	1ac9      	subs	r1, r1, r3
   42a72:	08c9      	lsrs	r1, r1, #3
   42a74:	0189      	lsls	r1, r1, #6
   42a76:	f041 0101 	orr.w	r1, r1, #1
   42a7a:	f004 ffb6 	bl	479ea <log_0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   42a7e:	f003 faaf 	bl	45fe0 <z_impl_z_errno>
	errno = ENOMEM;
   42a82:	230c      	movs	r3, #12
   42a84:	6003      	str	r3, [r0, #0]

	return NULL;
}
   42a86:	2000      	movs	r0, #0
   42a88:	bd08      	pop	{r3, pc}
   42a8a:	bf00      	nop
   42a8c:	00048d40 	.word	0x00048d40
   42a90:	00048d10 	.word	0x00048d10
   42a94:	00049584 	.word	0x00049584

00042a98 <_exit>:

#include <stdlib.h>
#include <zephyr.h>

void _exit(int status)
{
   42a98:	b508      	push	{r3, lr}
	printk("exit\n");
   42a9a:	4802      	ldr	r0, [pc, #8]	; (42aa4 <_exit+0xc>)
   42a9c:	f004 fc4e 	bl	4733c <printk>
	while (1) {
   42aa0:	e7fe      	b.n	42aa0 <_exit+0x8>
   42aa2:	bf00      	nop
   42aa4:	000495af 	.word	0x000495af

00042aa8 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   42aa8:	4b01      	ldr	r3, [pc, #4]	; (42ab0 <__stdout_hook_install+0x8>)
   42aaa:	6018      	str	r0, [r3, #0]
}
   42aac:	4770      	bx	lr
   42aae:	bf00      	nop
   42ab0:	2001a508 	.word	0x2001a508

00042ab4 <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
   42ab4:	3902      	subs	r1, #2
   42ab6:	2901      	cmp	r1, #1
   42ab8:	d802      	bhi.n	42ac0 <z_impl_zephyr_fputc+0xc>
   42aba:	4b03      	ldr	r3, [pc, #12]	; (42ac8 <z_impl_zephyr_fputc+0x14>)
   42abc:	681b      	ldr	r3, [r3, #0]
   42abe:	4718      	bx	r3
}
   42ac0:	f04f 30ff 	mov.w	r0, #4294967295
   42ac4:	4770      	bx	lr
   42ac6:	bf00      	nop
   42ac8:	2001a508 	.word	0x2001a508

00042acc <printf>:

	return r;
}

int printf(const char *ZRESTRICT format, ...)
{
   42acc:	b40f      	push	{r0, r1, r2, r3}
   42ace:	b507      	push	{r0, r1, r2, lr}
   42ad0:	ab04      	add	r3, sp, #16
   42ad2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   42ad6:	2102      	movs	r1, #2
   42ad8:	4804      	ldr	r0, [pc, #16]	; (42aec <printf+0x20>)
	va_start(vargs, format);
   42ada:	9301      	str	r3, [sp, #4]
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   42adc:	f7fd ff2e 	bl	4093c <cbvprintf>
	va_end(vargs);

	return r;
}
   42ae0:	b003      	add	sp, #12
   42ae2:	f85d eb04 	ldr.w	lr, [sp], #4
   42ae6:	b004      	add	sp, #16
   42ae8:	4770      	bx	lr
   42aea:	bf00      	nop
   42aec:	00048017 	.word	0x00048017

00042af0 <onoff_stop>:
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42af0:	b570      	push	{r4, r5, r6, lr}
   42af2:	4604      	mov	r4, r0
	err = set_off_state(&subdata->flags, ctx);
   42af4:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   42af6:	480d      	ldr	r0, [pc, #52]	; (42b2c <onoff_stop+0x3c>)
{
   42af8:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
   42afa:	1a23      	subs	r3, r4, r0
   42afc:	109a      	asrs	r2, r3, #2
   42afe:	4b0c      	ldr	r3, [pc, #48]	; (42b30 <onoff_stop+0x40>)
	err = set_off_state(&subdata->flags, ctx);
   42b00:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   42b02:	4353      	muls	r3, r2
   42b04:	b2db      	uxtb	r3, r3
	err = set_off_state(&subdata->flags, ctx);
   42b06:	435d      	muls	r5, r3
   42b08:	f105 0340 	add.w	r3, r5, #64	; 0x40
   42b0c:	4418      	add	r0, r3
   42b0e:	f005 fa8d 	bl	4802c <set_off_state>
	if (err < 0) {
   42b12:	1e01      	subs	r1, r0, #0
   42b14:	db04      	blt.n	42b20 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   42b16:	4b07      	ldr	r3, [pc, #28]	; (42b34 <onoff_stop+0x44>)
   42b18:	442b      	add	r3, r5
   42b1a:	685b      	ldr	r3, [r3, #4]
   42b1c:	4798      	blx	r3
	return 0;
   42b1e:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   42b20:	4620      	mov	r0, r4
   42b22:	4633      	mov	r3, r6
}
   42b24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   42b28:	4718      	bx	r3
   42b2a:	bf00      	nop
   42b2c:	2001a8ac 	.word	0x2001a8ac
   42b30:	b6db6db7 	.word	0xb6db6db7
   42b34:	00048e74 	.word	0x00048e74

00042b38 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42b38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   42b3c:	4c0f      	ldr	r4, [pc, #60]	; (42b7c <onoff_start+0x44>)
   42b3e:	4d10      	ldr	r5, [pc, #64]	; (42b80 <onoff_start+0x48>)
   42b40:	1b03      	subs	r3, r0, r4
   42b42:	109b      	asrs	r3, r3, #2
   42b44:	435d      	muls	r5, r3
   42b46:	b2eb      	uxtb	r3, r5
	err = set_starting_state(&subdata->flags, ctx);
   42b48:	250c      	movs	r5, #12
   42b4a:	435d      	muls	r5, r3
{
   42b4c:	4607      	mov	r7, r0
	err = set_starting_state(&subdata->flags, ctx);
   42b4e:	f105 0040 	add.w	r0, r5, #64	; 0x40
{
   42b52:	460e      	mov	r6, r1
	err = set_starting_state(&subdata->flags, ctx);
   42b54:	4420      	add	r0, r4
   42b56:	2140      	movs	r1, #64	; 0x40
   42b58:	f005 fa81 	bl	4805e <set_starting_state>
	if (err < 0) {
   42b5c:	1e01      	subs	r1, r0, #0
   42b5e:	db08      	blt.n	42b72 <onoff_start+0x3a>
	subdata->cb = cb;
   42b60:	4b08      	ldr	r3, [pc, #32]	; (42b84 <onoff_start+0x4c>)
   42b62:	442c      	add	r4, r5
	subdata->user_data = user_data;
   42b64:	e9c4 360e 	strd	r3, r6, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   42b68:	4b07      	ldr	r3, [pc, #28]	; (42b88 <onoff_start+0x50>)
   42b6a:	595b      	ldr	r3, [r3, r5]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   42b6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   42b70:	4718      	bx	r3
		notify(mgr, err);
   42b72:	4638      	mov	r0, r7
   42b74:	4633      	mov	r3, r6
}
   42b76:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   42b7a:	4718      	bx	r3
   42b7c:	2001a8ac 	.word	0x2001a8ac
   42b80:	b6db6db7 	.word	0xb6db6db7
   42b84:	000480c1 	.word	0x000480c1
   42b88:	00048e74 	.word	0x00048e74

00042b8c <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   42b8c:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42b8e:	2200      	movs	r2, #0
   42b90:	2101      	movs	r1, #1
{
   42b92:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42b94:	2005      	movs	r0, #5
   42b96:	f7ff f9ff 	bl	41f98 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   42b9a:	2005      	movs	r0, #5
   42b9c:	f7ff f9de 	bl	41f5c <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   42ba0:	480f      	ldr	r0, [pc, #60]	; (42be0 <clk_init+0x54>)
   42ba2:	f001 f8ef 	bl	43d84 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   42ba6:	4b0f      	ldr	r3, [pc, #60]	; (42be4 <clk_init+0x58>)
   42ba8:	4298      	cmp	r0, r3
   42baa:	d115      	bne.n	42bd8 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   42bac:	f005 fbc2 	bl	48334 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   42bb0:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   42bb2:	490d      	ldr	r1, [pc, #52]	; (42be8 <clk_init+0x5c>)
   42bb4:	4630      	mov	r0, r6
   42bb6:	f004 fc2a 	bl	4740e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   42bba:	2800      	cmp	r0, #0
   42bbc:	db0b      	blt.n	42bd6 <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42bbe:	2501      	movs	r5, #1
   42bc0:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   42bc2:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   42bc4:	4908      	ldr	r1, [pc, #32]	; (42be8 <clk_init+0x5c>)
   42bc6:	f104 001c 	add.w	r0, r4, #28
   42bca:	f004 fc20 	bl	4740e <onoff_manager_init>
		if (err < 0) {
   42bce:	2800      	cmp	r0, #0
   42bd0:	db01      	blt.n	42bd6 <clk_init+0x4a>
	}

	return 0;
   42bd2:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42bd4:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   42bd6:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   42bd8:	f06f 0004 	mvn.w	r0, #4
   42bdc:	e7fb      	b.n	42bd6 <clk_init+0x4a>
   42bde:	bf00      	nop
   42be0:	00042c21 	.word	0x00042c21
   42be4:	0bad0000 	.word	0x0bad0000
   42be8:	00048e8c 	.word	0x00048e8c

00042bec <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   42bec:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   42bee:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   42bf0:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   42bf2:	434b      	muls	r3, r1
   42bf4:	4808      	ldr	r0, [pc, #32]	; (42c18 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   42bf6:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   42bf8:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   42bfa:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   42bfc:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42c00:	4418      	add	r0, r3
	sub_data->cb = NULL;
   42c02:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42c04:	f005 fa49 	bl	4809a <set_on_state>
	if (callback) {
   42c08:	b12d      	cbz	r5, 42c16 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   42c0a:	4632      	mov	r2, r6
   42c0c:	462b      	mov	r3, r5
}
   42c0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   42c12:	4802      	ldr	r0, [pc, #8]	; (42c1c <clkstarted_handle.constprop.0+0x30>)
   42c14:	4718      	bx	r3
}
   42c16:	bd70      	pop	{r4, r5, r6, pc}
   42c18:	2001a8ac 	.word	0x2001a8ac
   42c1c:	00048aa8 	.word	0x00048aa8

00042c20 <clock_event_handler>:
	switch (event) {
   42c20:	b110      	cbz	r0, 42c28 <clock_event_handler+0x8>
   42c22:	2801      	cmp	r0, #1
   42c24:	d004      	beq.n	42c30 <clock_event_handler+0x10>
   42c26:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   42c28:	4b03      	ldr	r3, [pc, #12]	; (42c38 <clock_event_handler+0x18>)
   42c2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   42c2c:	075b      	lsls	r3, r3, #29
   42c2e:	d101      	bne.n	42c34 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   42c30:	f7ff bfdc 	b.w	42bec <clkstarted_handle.constprop.0>
}
   42c34:	4770      	bx	lr
   42c36:	bf00      	nop
   42c38:	2001a8ac 	.word	0x2001a8ac

00042c3c <generic_hfclk_start>:
{
   42c3c:	b508      	push	{r3, lr}
	__asm__ volatile(
   42c3e:	f04f 0320 	mov.w	r3, #32
   42c42:	f3ef 8111 	mrs	r1, BASEPRI
   42c46:	f383 8812 	msr	BASEPRI_MAX, r3
   42c4a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   42c4e:	4a11      	ldr	r2, [pc, #68]	; (42c94 <generic_hfclk_start+0x58>)
   42c50:	6813      	ldr	r3, [r2, #0]
   42c52:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   42c56:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   42c5a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   42c5c:	d00b      	beq.n	42c76 <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   42c5e:	4a0e      	ldr	r2, [pc, #56]	; (42c98 <generic_hfclk_start+0x5c>)
   42c60:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   42c64:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   42c68:	f013 0301 	ands.w	r3, r3, #1
   42c6c:	d003      	beq.n	42c76 <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   42c6e:	480b      	ldr	r0, [pc, #44]	; (42c9c <generic_hfclk_start+0x60>)
   42c70:	f005 fa13 	bl	4809a <set_on_state>
			already_started = true;
   42c74:	2301      	movs	r3, #1
	__asm__ volatile(
   42c76:	f381 8811 	msr	BASEPRI, r1
   42c7a:	f3bf 8f6f 	isb	sy
	if (already_started) {
   42c7e:	b123      	cbz	r3, 42c8a <generic_hfclk_start+0x4e>
}
   42c80:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   42c84:	2000      	movs	r0, #0
   42c86:	f7ff bfb1 	b.w	42bec <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   42c8a:	2001      	movs	r0, #1
}
   42c8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   42c90:	f001 b888 	b.w	43da4 <nrfx_clock_start>
   42c94:	2001a8fc 	.word	0x2001a8fc
   42c98:	40005000 	.word	0x40005000
   42c9c:	2001a8ec 	.word	0x2001a8ec

00042ca0 <generic_hfclk_stop>:
   42ca0:	4b07      	ldr	r3, [pc, #28]	; (42cc0 <generic_hfclk_stop+0x20>)
   42ca2:	e8d3 2fef 	ldaex	r2, [r3]
   42ca6:	f022 0102 	bic.w	r1, r2, #2
   42caa:	e8c3 1fe0 	stlex	r0, r1, [r3]
   42cae:	2800      	cmp	r0, #0
   42cb0:	d1f7      	bne.n	42ca2 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   42cb2:	07d3      	lsls	r3, r2, #31
   42cb4:	d402      	bmi.n	42cbc <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   42cb6:	2001      	movs	r0, #1
   42cb8:	f001 b8a6 	b.w	43e08 <nrfx_clock_stop>
}
   42cbc:	4770      	bx	lr
   42cbe:	bf00      	nop
   42cc0:	2001a8fc 	.word	0x2001a8fc

00042cc4 <api_blocking_start>:
{
   42cc4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42cc6:	2200      	movs	r2, #0
   42cc8:	2301      	movs	r3, #1
   42cca:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42cce:	466b      	mov	r3, sp
   42cd0:	4a08      	ldr	r2, [pc, #32]	; (42cf4 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42cd2:	f8cd d000 	str.w	sp, [sp]
   42cd6:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42cda:	f005 fa17 	bl	4810c <api_start>
	if (err < 0) {
   42cde:	2800      	cmp	r0, #0
   42ce0:	db05      	blt.n	42cee <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   42ce2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   42ce6:	2300      	movs	r3, #0
   42ce8:	4668      	mov	r0, sp
   42cea:	f003 fca5 	bl	46638 <z_impl_k_sem_take>
}
   42cee:	b005      	add	sp, #20
   42cf0:	f85d fb04 	ldr.w	pc, [sp], #4
   42cf4:	000480df 	.word	0x000480df

00042cf8 <z_nrf_clock_control_lf_on>:
{
   42cf8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   42cfc:	2201      	movs	r2, #1
   42cfe:	4607      	mov	r7, r0
   42d00:	4936      	ldr	r1, [pc, #216]	; (42ddc <z_nrf_clock_control_lf_on+0xe4>)
   42d02:	e8d1 3fef 	ldaex	r3, [r1]
   42d06:	e8c1 2fe0 	stlex	r0, r2, [r1]
   42d0a:	2800      	cmp	r0, #0
   42d0c:	d1f9      	bne.n	42d02 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   42d0e:	b933      	cbnz	r3, 42d1e <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   42d10:	4933      	ldr	r1, [pc, #204]	; (42de0 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   42d12:	4834      	ldr	r0, [pc, #208]	; (42de4 <z_nrf_clock_control_lf_on+0xec>)
   42d14:	604b      	str	r3, [r1, #4]
   42d16:	60cb      	str	r3, [r1, #12]
   42d18:	608a      	str	r2, [r1, #8]
   42d1a:	f004 fb8b 	bl	47434 <onoff_request>
	switch (start_mode) {
   42d1e:	1e7b      	subs	r3, r7, #1
   42d20:	2b01      	cmp	r3, #1
   42d22:	d82e      	bhi.n	42d82 <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   42d24:	2f01      	cmp	r7, #1
   42d26:	d106      	bne.n	42d36 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   42d28:	4b2f      	ldr	r3, [pc, #188]	; (42de8 <z_nrf_clock_control_lf_on+0xf0>)
   42d2a:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   42d2e:	f003 0303 	and.w	r3, r3, #3
   42d32:	2b02      	cmp	r3, #2
   42d34:	d025      	beq.n	42d82 <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   42d36:	f005 fcc3 	bl	486c0 <k_is_in_isr>
   42d3a:	4604      	mov	r4, r0
   42d3c:	b918      	cbnz	r0, 42d46 <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   42d3e:	4b2b      	ldr	r3, [pc, #172]	; (42dec <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   42d40:	781b      	ldrb	r3, [r3, #0]
   42d42:	2b00      	cmp	r3, #0
   42d44:	d144      	bne.n	42dd0 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   42d46:	f04f 0320 	mov.w	r3, #32
   42d4a:	f3ef 8611 	mrs	r6, BASEPRI
   42d4e:	f383 8812 	msr	BASEPRI_MAX, r3
   42d52:	f3bf 8f6f 	isb	sy
   42d56:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42d58:	4d23      	ldr	r5, [pc, #140]	; (42de8 <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42d5a:	f8df 809c 	ldr.w	r8, [pc, #156]	; 42df8 <z_nrf_clock_control_lf_on+0x100>
   42d5e:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42d60:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   42d64:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   42d68:	03d2      	lsls	r2, r2, #15
   42d6a:	d50c      	bpl.n	42d86 <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   42d6c:	f003 0303 	and.w	r3, r3, #3
   42d70:	2b02      	cmp	r3, #2
   42d72:	d001      	beq.n	42d78 <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   42d74:	2f01      	cmp	r7, #1
   42d76:	d106      	bne.n	42d86 <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   42d78:	b334      	cbz	r4, 42dc8 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   42d7a:	f386 8811 	msr	BASEPRI, r6
   42d7e:	f3bf 8f6f 	isb	sy
}
   42d82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   42d86:	b1d4      	cbz	r4, 42dbe <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   42d88:	4630      	mov	r0, r6
   42d8a:	f7ff f8a5 	bl	41ed8 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   42d8e:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   42d92:	b2db      	uxtb	r3, r3
   42d94:	2b01      	cmp	r3, #1
   42d96:	d1e3      	bne.n	42d60 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42d98:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   42d9c:	2a00      	cmp	r2, #0
   42d9e:	d0df      	beq.n	42d60 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   42da0:	2200      	movs	r2, #0
   42da2:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   42da6:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   42daa:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42dac:	2120      	movs	r1, #32
   42dae:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   42db2:	4a0f      	ldr	r2, [pc, #60]	; (42df0 <z_nrf_clock_control_lf_on+0xf8>)
   42db4:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42db8:	4a0e      	ldr	r2, [pc, #56]	; (42df4 <z_nrf_clock_control_lf_on+0xfc>)
   42dba:	6013      	str	r3, [r2, #0]
}
   42dbc:	e7d0      	b.n	42d60 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   42dbe:	2100      	movs	r1, #0
   42dc0:	2001      	movs	r0, #1
   42dc2:	f003 ff3f 	bl	46c44 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   42dc6:	e7e2      	b.n	42d8e <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   42dc8:	2302      	movs	r3, #2
   42dca:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   42dce:	e7d8      	b.n	42d82 <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   42dd0:	2202      	movs	r2, #2
   42dd2:	4b05      	ldr	r3, [pc, #20]	; (42de8 <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   42dd4:	4606      	mov	r6, r0
   42dd6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   42dda:	e7bd      	b.n	42d58 <z_nrf_clock_control_lf_on+0x60>
   42ddc:	2001a900 	.word	0x2001a900
   42de0:	2001a89c 	.word	0x2001a89c
   42de4:	2001a8c8 	.word	0x2001a8c8
   42de8:	40005000 	.word	0x40005000
   42dec:	20020a9a 	.word	0x20020a9a
   42df0:	e000e100 	.word	0xe000e100
   42df4:	40005008 	.word	0x40005008
   42df8:	40005104 	.word	0x40005104

00042dfc <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   42dfc:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   42dfe:	4808      	ldr	r0, [pc, #32]	; (42e20 <uart_console_init+0x24>)
   42e00:	4b08      	ldr	r3, [pc, #32]	; (42e24 <uart_console_init+0x28>)
   42e02:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   42e04:	f005 fb98 	bl	48538 <z_device_ready>
   42e08:	b138      	cbz	r0, 42e1a <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   42e0a:	4807      	ldr	r0, [pc, #28]	; (42e28 <uart_console_init+0x2c>)
   42e0c:	f7ff fe4c 	bl	42aa8 <__stdout_hook_install>
	__printk_hook_install(console_out);
   42e10:	4805      	ldr	r0, [pc, #20]	; (42e28 <uart_console_init+0x2c>)
   42e12:	f7fd fc85 	bl	40720 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   42e16:	2000      	movs	r0, #0
}
   42e18:	bd08      	pop	{r3, pc}
		return -ENODEV;
   42e1a:	f06f 0012 	mvn.w	r0, #18
   42e1e:	e7fb      	b.n	42e18 <uart_console_init+0x1c>
   42e20:	00048af0 	.word	0x00048af0
   42e24:	2001a904 	.word	0x2001a904
   42e28:	00042e2d 	.word	0x00042e2d

00042e2c <console_out>:
	if ('\n' == c) {
   42e2c:	280a      	cmp	r0, #10
{
   42e2e:	b538      	push	{r3, r4, r5, lr}
   42e30:	4604      	mov	r4, r0
   42e32:	4d07      	ldr	r5, [pc, #28]	; (42e50 <console_out+0x24>)
	if ('\n' == c) {
   42e34:	d104      	bne.n	42e40 <console_out+0x14>
   42e36:	6828      	ldr	r0, [r5, #0]
   42e38:	6883      	ldr	r3, [r0, #8]
   42e3a:	210d      	movs	r1, #13
   42e3c:	685b      	ldr	r3, [r3, #4]
   42e3e:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   42e40:	6828      	ldr	r0, [r5, #0]
   42e42:	6883      	ldr	r3, [r0, #8]
   42e44:	b2e1      	uxtb	r1, r4
   42e46:	685b      	ldr	r3, [r3, #4]
   42e48:	4798      	blx	r3
}
   42e4a:	4620      	mov	r0, r4
   42e4c:	bd38      	pop	{r3, r4, r5, pc}
   42e4e:	bf00      	nop
   42e50:	2001a904 	.word	0x2001a904

00042e54 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   42e54:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42e56:	6840      	ldr	r0, [r0, #4]
   42e58:	f001 051f 	and.w	r5, r1, #31
   42e5c:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   42e5e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42e62:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   42e66:	b085      	sub	sp, #20
   42e68:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   42e6c:	d104      	bne.n	42e78 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   42e6e:	4628      	mov	r0, r5
   42e70:	f001 fa88 	bl	44384 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   42e74:	2000      	movs	r0, #0
   42e76:	e02c      	b.n	42ed2 <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   42e78:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   42e7c:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   42e80:	d129      	bne.n	42ed6 <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   42e82:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42e86:	bf0c      	ite	eq
   42e88:	2304      	moveq	r3, #4
   42e8a:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   42e8c:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   42e90:	6883      	ldr	r3, [r0, #8]
   42e92:	fa23 f101 	lsr.w	r1, r3, r1
   42e96:	07c9      	lsls	r1, r1, #31
   42e98:	d429      	bmi.n	42eee <gpio_nrfx_pin_interrupt_configure+0x9a>
   42e9a:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   42e9e:	d126      	bne.n	42eee <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42ea0:	4a1b      	ldr	r2, [pc, #108]	; (42f10 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   42ea2:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42ea6:	3380      	adds	r3, #128	; 0x80
   42ea8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   42eac:	07db      	lsls	r3, r3, #31
   42eae:	d41e      	bmi.n	42eee <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   42eb0:	f10d 0407 	add.w	r4, sp, #7
   42eb4:	4621      	mov	r1, r4
   42eb6:	4628      	mov	r0, r5
   42eb8:	f001 f9d4 	bl	44264 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   42ebc:	4b15      	ldr	r3, [pc, #84]	; (42f14 <gpio_nrfx_pin_interrupt_configure+0xc0>)
   42ebe:	4298      	cmp	r0, r3
   42ec0:	d114      	bne.n	42eec <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   42ec2:	4620      	mov	r0, r4
   42ec4:	f001 fa18 	bl	442f8 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   42ec8:	4b13      	ldr	r3, [pc, #76]	; (42f18 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42eca:	4298      	cmp	r0, r3
   42ecc:	d00e      	beq.n	42eec <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   42ece:	f06f 000b 	mvn.w	r0, #11
}
   42ed2:	b005      	add	sp, #20
   42ed4:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   42ed6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   42eda:	d005      	beq.n	42ee8 <gpio_nrfx_pin_interrupt_configure+0x94>
   42edc:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42ee0:	bf0c      	ite	eq
   42ee2:	2302      	moveq	r3, #2
   42ee4:	2301      	movne	r3, #1
   42ee6:	e7d1      	b.n	42e8c <gpio_nrfx_pin_interrupt_configure+0x38>
   42ee8:	2303      	movs	r3, #3
   42eea:	e7cf      	b.n	42e8c <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   42eec:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42eee:	2300      	movs	r3, #0
   42ef0:	4628      	mov	r0, r5
   42ef2:	4619      	mov	r1, r3
   42ef4:	aa02      	add	r2, sp, #8
   42ef6:	f001 f875 	bl	43fe4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   42efa:	4b07      	ldr	r3, [pc, #28]	; (42f18 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42efc:	4298      	cmp	r0, r3
   42efe:	d104      	bne.n	42f0a <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   42f00:	2101      	movs	r1, #1
   42f02:	4628      	mov	r0, r5
   42f04:	f001 f9fe 	bl	44304 <nrfx_gpiote_trigger_enable>
   42f08:	e7b4      	b.n	42e74 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   42f0a:	f06f 0004 	mvn.w	r0, #4
   42f0e:	e7e0      	b.n	42ed2 <gpio_nrfx_pin_interrupt_configure+0x7e>
   42f10:	40842500 	.word	0x40842500
   42f14:	0bad0004 	.word	0x0bad0004
   42f18:	0bad0000 	.word	0x0bad0000

00042f1c <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   42f1c:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   42f1e:	f001 f9db 	bl	442d8 <nrfx_gpiote_is_init>
   42f22:	4604      	mov	r4, r0
   42f24:	b968      	cbnz	r0, 42f42 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   42f26:	f001 f9af 	bl	44288 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   42f2a:	4b08      	ldr	r3, [pc, #32]	; (42f4c <gpio_nrfx_init+0x30>)
   42f2c:	4298      	cmp	r0, r3
   42f2e:	d10a      	bne.n	42f46 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   42f30:	4621      	mov	r1, r4
   42f32:	4807      	ldr	r0, [pc, #28]	; (42f50 <gpio_nrfx_init+0x34>)
   42f34:	f001 f990 	bl	44258 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   42f38:	4622      	mov	r2, r4
   42f3a:	2105      	movs	r1, #5
   42f3c:	2031      	movs	r0, #49	; 0x31
   42f3e:	f7ff f82b 	bl	41f98 <z_arm_irq_priority_set>
		return 0;
   42f42:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   42f44:	bd10      	pop	{r4, pc}
		return -EIO;
   42f46:	f06f 0004 	mvn.w	r0, #4
   42f4a:	e7fb      	b.n	42f44 <gpio_nrfx_init+0x28>
   42f4c:	0bad0000 	.word	0x0bad0000
   42f50:	00042f55 	.word	0x00042f55

00042f54 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42f54:	0943      	lsrs	r3, r0, #5
{
   42f56:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42f58:	d117      	bne.n	42f8a <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42f5a:	4b0c      	ldr	r3, [pc, #48]	; (42f8c <nrfx_gpio_handler+0x38>)
   42f5c:	6859      	ldr	r1, [r3, #4]
   42f5e:	b1a1      	cbz	r1, 42f8a <nrfx_gpio_handler+0x36>
   42f60:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   42f62:	2501      	movs	r5, #1
   42f64:	2c00      	cmp	r4, #0
   42f66:	bf38      	it	cc
   42f68:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   42f6a:	4e09      	ldr	r6, [pc, #36]	; (42f90 <nrfx_gpio_handler+0x3c>)
   42f6c:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   42f6e:	688a      	ldr	r2, [r1, #8]
   42f70:	402a      	ands	r2, r5
   42f72:	d002      	beq.n	42f7a <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   42f74:	4630      	mov	r0, r6
   42f76:	684b      	ldr	r3, [r1, #4]
   42f78:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42f7a:	b134      	cbz	r4, 42f8a <nrfx_gpio_handler+0x36>
	return node->next;
   42f7c:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   42f7e:	4621      	mov	r1, r4
   42f80:	2b00      	cmp	r3, #0
   42f82:	bf38      	it	cc
   42f84:	2300      	movcc	r3, #0
   42f86:	461c      	mov	r4, r3
   42f88:	e7f1      	b.n	42f6e <nrfx_gpio_handler+0x1a>
}
   42f8a:	bd70      	pop	{r4, r5, r6, pc}
   42f8c:	2001a908 	.word	0x2001a908
   42f90:	00048ac0 	.word	0x00048ac0

00042f94 <gpio_nrfx_pin_configure>:
{
   42f94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   42f98:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   42f9a:	f001 051f 	and.w	r5, r1, #31
   42f9e:	7b3b      	ldrb	r3, [r7, #12]
{
   42fa0:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   42fa2:	4614      	mov	r4, r2
{
   42fa4:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   42fa6:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   42faa:	b9ca      	cbnz	r2, 42fe0 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   42fac:	a902      	add	r1, sp, #8
   42fae:	4628      	mov	r0, r5
   42fb0:	f001 f958 	bl	44264 <nrfx_gpiote_channel_get>
   42fb4:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   42fb6:	4628      	mov	r0, r5
   42fb8:	f001 fa06 	bl	443c8 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   42fbc:	4b47      	ldr	r3, [pc, #284]	; (430dc <gpio_nrfx_pin_configure+0x148>)
   42fbe:	4298      	cmp	r0, r3
   42fc0:	d004      	beq.n	42fcc <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   42fc2:	f06f 0004 	mvn.w	r0, #4
}
   42fc6:	b005      	add	sp, #20
   42fc8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   42fcc:	4284      	cmp	r4, r0
   42fce:	d105      	bne.n	42fdc <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   42fd0:	f89d 0008 	ldrb.w	r0, [sp, #8]
   42fd4:	f001 f98a 	bl	442ec <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   42fd8:	42a0      	cmp	r0, r4
   42fda:	d1f2      	bne.n	42fc2 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   42fdc:	2000      	movs	r0, #0
   42fde:	e7f2      	b.n	42fc6 <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   42fe0:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   42fe4:	f10d 0103 	add.w	r1, sp, #3
   42fe8:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   42fea:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   42fee:	f001 f939 	bl	44264 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42ff2:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   42ff4:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42ff6:	4649      	mov	r1, r9
   42ff8:	4628      	mov	r0, r5
   42ffa:	aa02      	add	r2, sp, #8
   42ffc:	f000 fff2 	bl	43fe4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   43000:	4b36      	ldr	r3, [pc, #216]	; (430dc <gpio_nrfx_pin_configure+0x148>)
   43002:	4298      	cmp	r0, r3
   43004:	d002      	beq.n	4300c <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43006:	f06f 0015 	mvn.w	r0, #21
   4300a:	e7dc      	b.n	42fc6 <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   4300c:	4580      	cmp	r8, r0
   4300e:	d103      	bne.n	43018 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   43010:	f89d 0003 	ldrb.w	r0, [sp, #3]
   43014:	f001 f96a 	bl	442ec <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   43018:	05a3      	lsls	r3, r4, #22
   4301a:	d54c      	bpl.n	430b6 <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   4301c:	4b30      	ldr	r3, [pc, #192]	; (430e0 <gpio_nrfx_pin_configure+0x14c>)
   4301e:	4a31      	ldr	r2, [pc, #196]	; (430e4 <gpio_nrfx_pin_configure+0x150>)
   43020:	4023      	ands	r3, r4
   43022:	4293      	cmp	r3, r2
   43024:	d039      	beq.n	4309a <gpio_nrfx_pin_configure+0x106>
   43026:	d80c      	bhi.n	43042 <gpio_nrfx_pin_configure+0xae>
   43028:	2b06      	cmp	r3, #6
   4302a:	d014      	beq.n	43056 <gpio_nrfx_pin_configure+0xc2>
   4302c:	d804      	bhi.n	43038 <gpio_nrfx_pin_configure+0xa4>
   4302e:	b193      	cbz	r3, 43056 <gpio_nrfx_pin_configure+0xc2>
   43030:	2b02      	cmp	r3, #2
   43032:	d1e8      	bne.n	43006 <gpio_nrfx_pin_configure+0x72>
   43034:	2304      	movs	r3, #4
   43036:	e00e      	b.n	43056 <gpio_nrfx_pin_configure+0xc2>
   43038:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   4303c:	d1e3      	bne.n	43006 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   4303e:	2301      	movs	r3, #1
   43040:	e009      	b.n	43056 <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43042:	4a29      	ldr	r2, [pc, #164]	; (430e8 <gpio_nrfx_pin_configure+0x154>)
   43044:	4293      	cmp	r3, r2
   43046:	d02a      	beq.n	4309e <gpio_nrfx_pin_configure+0x10a>
   43048:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   4304c:	d029      	beq.n	430a2 <gpio_nrfx_pin_configure+0x10e>
   4304e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   43052:	d1d8      	bne.n	43006 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   43054:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   43056:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   4305a:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   4305e:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   43062:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   43064:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   43068:	bf4c      	ite	mi
   4306a:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   4306c:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43070:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   43072:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43076:	d516      	bpl.n	430a6 <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   43078:	2101      	movs	r1, #1
   4307a:	687b      	ldr	r3, [r7, #4]
   4307c:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   43080:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   43082:	2200      	movs	r2, #0
   43084:	4628      	mov	r0, r5
   43086:	a901      	add	r1, sp, #4
   43088:	f001 f852 	bl	44130 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   4308c:	4b13      	ldr	r3, [pc, #76]	; (430dc <gpio_nrfx_pin_configure+0x148>)
   4308e:	4298      	cmp	r0, r3
   43090:	bf14      	ite	ne
   43092:	f06f 0015 	mvnne.w	r0, #21
   43096:	2000      	moveq	r0, #0
   43098:	e795      	b.n	42fc6 <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   4309a:	2307      	movs	r3, #7
   4309c:	e7db      	b.n	43056 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   4309e:	2305      	movs	r3, #5
   430a0:	e7d9      	b.n	43056 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   430a2:	2303      	movs	r3, #3
   430a4:	e7d7      	b.n	43056 <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   430a6:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   430a8:	bf41      	itttt	mi
   430aa:	2101      	movmi	r1, #1
   430ac:	687b      	ldrmi	r3, [r7, #4]
   430ae:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   430b2:	60de      	strmi	r6, [r3, #12]
}
   430b4:	e7e5      	b.n	43082 <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   430b6:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   430b8:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   430bc:	bf4c      	ite	mi
   430be:	2403      	movmi	r4, #3
   430c0:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   430c4:	461a      	mov	r2, r3
   430c6:	4628      	mov	r0, r5
   430c8:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   430ca:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   430ce:	f000 ff89 	bl	43fe4 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   430d2:	4b02      	ldr	r3, [pc, #8]	; (430dc <gpio_nrfx_pin_configure+0x148>)
   430d4:	4298      	cmp	r0, r3
   430d6:	d081      	beq.n	42fdc <gpio_nrfx_pin_configure+0x48>
   430d8:	e795      	b.n	43006 <gpio_nrfx_pin_configure+0x72>
   430da:	bf00      	nop
   430dc:	0bad0000 	.word	0x0bad0000
   430e0:	00f00006 	.word	0x00f00006
   430e4:	00100006 	.word	0x00100006
   430e8:	00400002 	.word	0x00400002

000430ec <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   430ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   430ee:	794b      	ldrb	r3, [r1, #5]
   430f0:	2b01      	cmp	r3, #1
   430f2:	d026      	beq.n	43142 <uarte_nrfx_configure+0x56>
   430f4:	2b03      	cmp	r3, #3
   430f6:	d121      	bne.n	4313c <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   430f8:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   430fa:	798b      	ldrb	r3, [r1, #6]
   430fc:	2b03      	cmp	r3, #3
   430fe:	d11d      	bne.n	4313c <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   43100:	79cc      	ldrb	r4, [r1, #7]
   43102:	b10c      	cbz	r4, 43108 <uarte_nrfx_configure+0x1c>
   43104:	2c01      	cmp	r4, #1
   43106:	d119      	bne.n	4313c <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   43108:	790a      	ldrb	r2, [r1, #4]
   4310a:	b112      	cbz	r2, 43112 <uarte_nrfx_configure+0x26>
   4310c:	2a02      	cmp	r2, #2
   4310e:	d115      	bne.n	4313c <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   43110:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   43112:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   43114:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   43116:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   4311a:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   4311c:	d065      	beq.n	431ea <uarte_nrfx_configure+0xfe>
   4311e:	d82d      	bhi.n	4317c <uarte_nrfx_configure+0x90>
   43120:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   43124:	d064      	beq.n	431f0 <uarte_nrfx_configure+0x104>
   43126:	d816      	bhi.n	43156 <uarte_nrfx_configure+0x6a>
   43128:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   4312c:	d062      	beq.n	431f4 <uarte_nrfx_configure+0x108>
   4312e:	d80a      	bhi.n	43146 <uarte_nrfx_configure+0x5a>
   43130:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   43134:	d061      	beq.n	431fa <uarte_nrfx_configure+0x10e>
   43136:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   4313a:	d061      	beq.n	43200 <uarte_nrfx_configure+0x114>
   4313c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   43140:	e052      	b.n	431e8 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   43142:	2600      	movs	r6, #0
   43144:	e7d9      	b.n	430fa <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   43146:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   4314a:	d05c      	beq.n	43206 <uarte_nrfx_configure+0x11a>
   4314c:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   43150:	d1f4      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   43152:	4b37      	ldr	r3, [pc, #220]	; (43230 <uarte_nrfx_configure+0x144>)
   43154:	e03c      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43156:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   4315a:	d057      	beq.n	4320c <uarte_nrfx_configure+0x120>
   4315c:	d807      	bhi.n	4316e <uarte_nrfx_configure+0x82>
   4315e:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   43162:	d055      	beq.n	43210 <uarte_nrfx_configure+0x124>
   43164:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   43168:	d1e8      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   4316a:	4b32      	ldr	r3, [pc, #200]	; (43234 <uarte_nrfx_configure+0x148>)
   4316c:	e030      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4316e:	f647 2712 	movw	r7, #31250	; 0x7a12
   43172:	42bb      	cmp	r3, r7
   43174:	d1e2      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   43176:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   4317a:	e029      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4317c:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   43180:	d048      	beq.n	43214 <uarte_nrfx_configure+0x128>
   43182:	d813      	bhi.n	431ac <uarte_nrfx_configure+0xc0>
   43184:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   43188:	d047      	beq.n	4321a <uarte_nrfx_configure+0x12e>
   4318a:	d809      	bhi.n	431a0 <uarte_nrfx_configure+0xb4>
   4318c:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   43190:	42bb      	cmp	r3, r7
   43192:	d044      	beq.n	4321e <uarte_nrfx_configure+0x132>
   43194:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   43198:	d1d0      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   4319a:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   4319e:	e017      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431a0:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   431a4:	d1ca      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   431a6:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   431aa:	e011      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431ac:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   431b0:	d038      	beq.n	43224 <uarte_nrfx_configure+0x138>
   431b2:	d808      	bhi.n	431c6 <uarte_nrfx_configure+0xda>
   431b4:	4f20      	ldr	r7, [pc, #128]	; (43238 <uarte_nrfx_configure+0x14c>)
   431b6:	42bb      	cmp	r3, r7
   431b8:	d037      	beq.n	4322a <uarte_nrfx_configure+0x13e>
   431ba:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   431be:	d1bd      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   431c0:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   431c4:	e004      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431c6:	4f1d      	ldr	r7, [pc, #116]	; (4323c <uarte_nrfx_configure+0x150>)
   431c8:	42bb      	cmp	r3, r7
   431ca:	d1b7      	bne.n	4313c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   431cc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   431d0:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   431d4:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   431d6:	4334      	orrs	r4, r6
   431d8:	4322      	orrs	r2, r4
   431da:	3304      	adds	r3, #4
   431dc:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   431de:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   431e2:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   431e6:	2000      	movs	r0, #0
}
   431e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   431ea:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   431ee:	e7ef      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   431f0:	4b13      	ldr	r3, [pc, #76]	; (43240 <uarte_nrfx_configure+0x154>)
   431f2:	e7ed      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   431f4:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   431f8:	e7ea      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   431fa:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   431fe:	e7e7      	b.n	431d0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43200:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   43204:	e7e4      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   43206:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   4320a:	e7e1      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   4320c:	4b0d      	ldr	r3, [pc, #52]	; (43244 <uarte_nrfx_configure+0x158>)
   4320e:	e7df      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   43210:	4b0d      	ldr	r3, [pc, #52]	; (43248 <uarte_nrfx_configure+0x15c>)
   43212:	e7dd      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   43214:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   43218:	e7da      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   4321a:	4b0c      	ldr	r3, [pc, #48]	; (4324c <uarte_nrfx_configure+0x160>)
   4321c:	e7d8      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   4321e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   43222:	e7d5      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   43224:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   43228:	e7d2      	b.n	431d0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   4322a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   4322e:	e7cf      	b.n	431d0 <uarte_nrfx_configure+0xe4>
   43230:	0013b000 	.word	0x0013b000
   43234:	004ea000 	.word	0x004ea000
   43238:	0003d090 	.word	0x0003d090
   4323c:	000f4240 	.word	0x000f4240
   43240:	00275000 	.word	0x00275000
   43244:	0075c000 	.word	0x0075c000
   43248:	003af000 	.word	0x003af000
   4324c:	013a9000 	.word	0x013a9000

00043250 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   43250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   43252:	4605      	mov	r5, r0
   43254:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   43256:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   43258:	f005 fa32 	bl	486c0 <k_is_in_isr>
   4325c:	b910      	cbnz	r0, 43264 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   4325e:	4b2c      	ldr	r3, [pc, #176]	; (43310 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   43260:	781b      	ldrb	r3, [r3, #0]
   43262:	b983      	cbnz	r3, 43286 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43264:	f04f 0320 	mov.w	r3, #32
   43268:	f3ef 8411 	mrs	r4, BASEPRI
   4326c:	f383 8812 	msr	BASEPRI_MAX, r3
   43270:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   43274:	4628      	mov	r0, r5
   43276:	f004 fff7 	bl	48268 <is_tx_ready>
   4327a:	bb28      	cbnz	r0, 432c8 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   4327c:	f384 8811 	msr	BASEPRI, r4
   43280:	f3bf 8f6f 	isb	sy
}
   43284:	e7ee      	b.n	43264 <uarte_nrfx_poll_out+0x14>
{
   43286:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   43288:	4628      	mov	r0, r5
   4328a:	f004 ffed 	bl	48268 <is_tx_ready>
   4328e:	b970      	cbnz	r0, 432ae <uarte_nrfx_poll_out+0x5e>
   43290:	2001      	movs	r0, #1
   43292:	f005 f84d 	bl	48330 <nrfx_busy_wait>
   43296:	3c01      	subs	r4, #1
   43298:	d1f6      	bne.n	43288 <uarte_nrfx_poll_out+0x38>
   4329a:	2100      	movs	r1, #0
   4329c:	2001      	movs	r0, #1
   4329e:	f003 fcd1 	bl	46c44 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   432a2:	e7f0      	b.n	43286 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   432a4:	f384 8811 	msr	BASEPRI, r4
   432a8:	f3bf 8f6f 	isb	sy
}
   432ac:	e7f5      	b.n	4329a <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   432ae:	f04f 0320 	mov.w	r3, #32
   432b2:	f3ef 8411 	mrs	r4, BASEPRI
   432b6:	f383 8812 	msr	BASEPRI_MAX, r3
   432ba:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   432be:	4628      	mov	r0, r5
   432c0:	f004 ffd2 	bl	48268 <is_tx_ready>
   432c4:	2800      	cmp	r0, #0
   432c6:	d0ed      	beq.n	432a4 <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   432c8:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   432ca:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   432ce:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   432d0:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   432d2:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   432d6:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   432da:	2200      	movs	r2, #0
   432dc:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   432e0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   432e4:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   432e8:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   432ec:	684a      	ldr	r2, [r1, #4]
   432ee:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   432f0:	bf41      	itttt	mi
   432f2:	2208      	movmi	r2, #8
   432f4:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   432f8:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   432fc:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43300:	2201      	movs	r2, #1
   43302:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   43304:	f384 8811 	msr	BASEPRI, r4
   43308:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   4330c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   4330e:	bf00      	nop
   43310:	20020a9a 	.word	0x20020a9a

00043314 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   43314:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   43318:	4606      	mov	r6, r0
   4331a:	2101      	movs	r1, #1
   4331c:	2200      	movs	r2, #0
   4331e:	2008      	movs	r0, #8
   43320:	f7fe fe3a 	bl	41f98 <z_arm_irq_priority_set>
   43324:	2008      	movs	r0, #8
   43326:	f7fe fe19 	bl	41f5c <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   4332a:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   4332c:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   4332e:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   43330:	683c      	ldr	r4, [r7, #0]
   43332:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   43336:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   43338:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4333a:	68d8      	ldr	r0, [r3, #12]
   4333c:	1c41      	adds	r1, r0, #1
   4333e:	d00b      	beq.n	43358 <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43340:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   43342:	f8df c154 	ldr.w	ip, [pc, #340]	; 43498 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   43346:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   4334a:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   4334c:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43350:	2103      	movs	r1, #3
   43352:	3280      	adds	r2, #128	; 0x80
   43354:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43358:	6919      	ldr	r1, [r3, #16]
   4335a:	1c4a      	adds	r2, r1, #1
   4335c:	d00d      	beq.n	4337a <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   4335e:	7f1a      	ldrb	r2, [r3, #28]
   43360:	f8df c134 	ldr.w	ip, [pc, #308]	; 43498 <uarte_0_init+0x184>
   43364:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43366:	bf14      	ite	ne
   43368:	f04f 0e0c 	movne.w	lr, #12
   4336c:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   43370:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   43374:	3280      	adds	r2, #128	; 0x80
   43376:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4337a:	f8d3 c014 	ldr.w	ip, [r3, #20]
   4337e:	f1bc 3fff 	cmp.w	ip, #4294967295
   43382:	d00e      	beq.n	433a2 <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43384:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   43388:	f8df 810c 	ldr.w	r8, [pc, #268]	; 43498 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   4338c:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43390:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   43394:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43398:	f04f 0e03 	mov.w	lr, #3
   4339c:	3280      	adds	r2, #128	; 0x80
   4339e:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   433a2:	f8d3 e018 	ldr.w	lr, [r3, #24]
   433a6:	f1be 3fff 	cmp.w	lr, #4294967295
   433aa:	d00d      	beq.n	433c8 <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   433ac:	7f5a      	ldrb	r2, [r3, #29]
   433ae:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 43498 <uarte_0_init+0x184>
   433b2:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   433b4:	bf14      	ite	ne
   433b6:	f04f 090c 	movne.w	r9, #12
   433ba:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   433be:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   433c2:	3280      	adds	r2, #128	; 0x80
   433c4:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   433c8:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   433ca:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   433ce:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   433d2:	6931      	ldr	r1, [r6, #16]
   433d4:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   433d6:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   433da:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   433dc:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   433e0:	f7ff fe84 	bl	430ec <uarte_nrfx_configure>
	if (err) {
   433e4:	4606      	mov	r6, r0
   433e6:	b9a8      	cbnz	r0, 43414 <uarte_0_init+0x100>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   433e8:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   433ea:	0799      	lsls	r1, r3, #30
   433ec:	d522      	bpl.n	43434 <uarte_0_init+0x120>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   433ee:	f105 0012 	add.w	r0, r5, #18
   433f2:	f000 fd7d 	bl	43ef0 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   433f6:	4b23      	ldr	r3, [pc, #140]	; (43484 <uarte_0_init+0x170>)
   433f8:	4298      	cmp	r0, r3
   433fa:	d00e      	beq.n	4341a <uarte_0_init+0x106>
   433fc:	4b22      	ldr	r3, [pc, #136]	; (43488 <uarte_0_init+0x174>)
   433fe:	4923      	ldr	r1, [pc, #140]	; (4348c <uarte_0_init+0x178>)
		LOG_ERR("Failed to allocate PPI Channel");
   43400:	4823      	ldr	r0, [pc, #140]	; (43490 <uarte_0_init+0x17c>)
   43402:	1ac9      	subs	r1, r1, r3
   43404:	08c9      	lsrs	r1, r1, #3
   43406:	0189      	lsls	r1, r1, #6
   43408:	f041 0101 	orr.w	r1, r1, #1
   4340c:	f004 faed 	bl	479ea <log_0>
		return -EIO;
   43410:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   43414:	4630      	mov	r0, r6
   43416:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   4341a:	7cab      	ldrb	r3, [r5, #18]
   4341c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   43420:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   43424:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   43428:	2301      	movs	r3, #1
   4342a:	7caa      	ldrb	r2, [r5, #18]
   4342c:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   4342e:	4a19      	ldr	r2, [pc, #100]	; (43494 <uarte_0_init+0x180>)
   43430:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43434:	2308      	movs	r3, #8
   43436:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   4343a:	7a3b      	ldrb	r3, [r7, #8]
   4343c:	b95b      	cbnz	r3, 43456 <uarte_0_init+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4343e:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   43442:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   43446:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   4344a:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   4344e:	2301      	movs	r3, #1
   43450:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43454:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   43456:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   43458:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   4345a:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   4345c:	bf5c      	itt	pl
   4345e:	f44f 7280 	movpl.w	r2, #256	; 0x100
   43462:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   43466:	06db      	lsls	r3, r3, #27
   43468:	bf44      	itt	mi
   4346a:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   4346e:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   43472:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43474:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   43478:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4347c:	2301      	movs	r3, #1
   4347e:	60a3      	str	r3, [r4, #8]
   43480:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   43482:	e7c7      	b.n	43414 <uarte_0_init+0x100>
   43484:	0bad0000 	.word	0x0bad0000
   43488:	00048d10 	.word	0x00048d10
   4348c:	00048d58 	.word	0x00048d58
   43490:	000495eb 	.word	0x000495eb
   43494:	40017000 	.word	0x40017000
   43498:	40842500 	.word	0x40842500

0004349c <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   4349c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4349e:	4e20      	ldr	r6, [pc, #128]	; (43520 <sys_clock_timeout_handler+0x84>)
	return absolute_time & COUNTER_MAX;
   434a0:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   434a4:	e9d6 ce00 	ldrd	ip, lr, [r6]
   434a8:	ebb2 020c 	subs.w	r2, r2, ip

	last_count += dticks * CYC_PER_TICK;
   434ac:	f022 011f 	bic.w	r1, r2, #31
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   434b0:	eb63 030e 	sbc.w	r3, r3, lr
{
   434b4:	4604      	mov	r4, r0
	last_count += dticks * CYC_PER_TICK;
   434b6:	eb11 010c 	adds.w	r1, r1, ip
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   434ba:	ea4f 1052 	mov.w	r0, r2, lsr #5
	last_count += dticks * CYC_PER_TICK;
   434be:	eb43 070e 	adc.w	r7, r3, lr
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   434c2:	ea40 60c3 	orr.w	r0, r0, r3, lsl #27
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   434c6:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   434ca:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
	last_count += dticks * CYC_PER_TICK;
   434ce:	e9c6 1700 	strd	r1, r7, [r6]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   434d2:	f04f 0600 	mov.w	r6, #0
	if (in_anchor_range(cc_value)) {
   434d6:	d20a      	bcs.n	434ee <sys_clock_timeout_handler+0x52>
		return true;
   434d8:	2601      	movs	r6, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   434da:	4b12      	ldr	r3, [pc, #72]	; (43524 <sys_clock_timeout_handler+0x88>)
   434dc:	6819      	ldr	r1, [r3, #0]
   434de:	060a      	lsls	r2, r1, #24
   434e0:	0a0b      	lsrs	r3, r1, #8
   434e2:	1952      	adds	r2, r2, r5
   434e4:	4910      	ldr	r1, [pc, #64]	; (43528 <sys_clock_timeout_handler+0x8c>)
   434e6:	f143 0300 	adc.w	r3, r3, #0
   434ea:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   434ee:	f003 fd07 	bl	46f00 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   434f2:	00a3      	lsls	r3, r4, #2
   434f4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   434f8:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   434fc:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   43500:	42aa      	cmp	r2, r5
   43502:	d10b      	bne.n	4351c <sys_clock_timeout_handler+0x80>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   43504:	b91e      	cbnz	r6, 4350e <sys_clock_timeout_handler+0x72>
    p_reg->CC[ch] = cc_val;
   43506:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   4350a:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4350e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   43512:	4b06      	ldr	r3, [pc, #24]	; (4352c <sys_clock_timeout_handler+0x90>)
   43514:	fa00 f404 	lsl.w	r4, r0, r4
   43518:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   4351c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   4351e:	bf00      	nop
   43520:	2001a6c0 	.word	0x2001a6c0
   43524:	2001a91c 	.word	0x2001a91c
   43528:	2001a6a8 	.word	0x2001a6a8
   4352c:	40015000 	.word	0x40015000

00043530 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43530:	2301      	movs	r3, #1
   43532:	4083      	lsls	r3, r0
{
   43534:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43536:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43538:	4a0c      	ldr	r2, [pc, #48]	; (4356c <compare_int_lock+0x3c>)
   4353a:	e8d2 1fef 	ldaex	r1, [r2]
   4353e:	ea01 0c04 	and.w	ip, r1, r4
   43542:	e8c2 cfee 	stlex	lr, ip, [r2]
   43546:	f1be 0f00 	cmp.w	lr, #0
   4354a:	d1f6      	bne.n	4353a <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4354c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   43550:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   43554:	4a06      	ldr	r2, [pc, #24]	; (43570 <compare_int_lock+0x40>)
   43556:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   4355a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   4355e:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   43562:	420b      	tst	r3, r1
}
   43564:	bf14      	ite	ne
   43566:	2001      	movne	r0, #1
   43568:	2000      	moveq	r0, #0
   4356a:	bd10      	pop	{r4, pc}
   4356c:	2001a918 	.word	0x2001a918
   43570:	40015000 	.word	0x40015000

00043574 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   43574:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43576:	4a0e      	ldr	r2, [pc, #56]	; (435b0 <compare_int_unlock.part.0+0x3c>)
   43578:	4083      	lsls	r3, r0
   4357a:	e8d2 1fef 	ldaex	r1, [r2]
   4357e:	4319      	orrs	r1, r3
   43580:	e8c2 1fec 	stlex	ip, r1, [r2]
   43584:	f1bc 0f00 	cmp.w	ip, #0
   43588:	d1f7      	bne.n	4357a <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4358a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   4358e:	4a09      	ldr	r2, [pc, #36]	; (435b4 <compare_int_unlock.part.0+0x40>)
   43590:	4083      	lsls	r3, r0
   43592:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   43596:	4b08      	ldr	r3, [pc, #32]	; (435b8 <compare_int_unlock.part.0+0x44>)
   43598:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   4359c:	fa23 f000 	lsr.w	r0, r3, r0
   435a0:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   435a2:	bf42      	ittt	mi
   435a4:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   435a8:	4b04      	ldrmi	r3, [pc, #16]	; (435bc <compare_int_unlock.part.0+0x48>)
   435aa:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   435ae:	4770      	bx	lr
   435b0:	2001a918 	.word	0x2001a918
   435b4:	40015000 	.word	0x40015000
   435b8:	2001a914 	.word	0x2001a914
   435bc:	e000e100 	.word	0xe000e100

000435c0 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   435c0:	4b0d      	ldr	r3, [pc, #52]	; (435f8 <z_nrf_rtc_timer_read+0x38>)
   435c2:	681b      	ldr	r3, [r3, #0]
   435c4:	0a19      	lsrs	r1, r3, #8
   435c6:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   435c8:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   435cc:	4b0b      	ldr	r3, [pc, #44]	; (435fc <z_nrf_rtc_timer_read+0x3c>)
   435ce:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   435d2:	18c0      	adds	r0, r0, r3
   435d4:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   435d8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   435dc:	d20a      	bcs.n	435f4 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   435de:	4b08      	ldr	r3, [pc, #32]	; (43600 <z_nrf_rtc_timer_read+0x40>)
   435e0:	e9d3 2300 	ldrd	r2, r3, [r3]
   435e4:	4299      	cmp	r1, r3
   435e6:	bf08      	it	eq
   435e8:	4290      	cmpeq	r0, r2
   435ea:	d203      	bcs.n	435f4 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   435ec:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   435f0:	f141 0100 	adc.w	r1, r1, #0
}
   435f4:	4770      	bx	lr
   435f6:	bf00      	nop
   435f8:	2001a91c 	.word	0x2001a91c
   435fc:	40015000 	.word	0x40015000
   43600:	2001a6a8 	.word	0x2001a6a8

00043604 <compare_set>:
{
   43604:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43608:	4616      	mov	r6, r2
   4360a:	461f      	mov	r7, r3
   4360c:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   4360e:	f7ff ff8f 	bl	43530 <compare_int_lock>
   43612:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   43614:	f7ff ffd4 	bl	435c0 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   43618:	42b9      	cmp	r1, r7
   4361a:	bf08      	it	eq
   4361c:	42b0      	cmpeq	r0, r6
   4361e:	d27b      	bcs.n	43718 <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   43620:	2300      	movs	r3, #0
   43622:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   43626:	ebb6 0800 	subs.w	r8, r6, r0
   4362a:	eb67 0901 	sbc.w	r9, r7, r1
   4362e:	454b      	cmp	r3, r9
   43630:	bf08      	it	eq
   43632:	4542      	cmpeq	r2, r8
   43634:	d37d      	bcc.n	43732 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   43636:	4b40      	ldr	r3, [pc, #256]	; (43738 <compare_set+0x134>)
   43638:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   4363c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   43640:	429f      	cmp	r7, r3
   43642:	bf08      	it	eq
   43644:	4296      	cmpeq	r6, r2
   43646:	d051      	beq.n	436ec <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43648:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   4364c:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   43650:	4614      	mov	r4, r2
   43652:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   43656:	f105 0850 	add.w	r8, r5, #80	; 0x50
   4365a:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   4365e:	ea4f 0888 	mov.w	r8, r8, lsl #2
   43662:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43666:	fa1f f888 	uxth.w	r8, r8
   4366a:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   4366e:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   43672:	4b32      	ldr	r3, [pc, #200]	; (4373c <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43674:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43678:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   4367c:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   43680:	eba0 000a 	sub.w	r0, r0, sl
   43684:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43688:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   4368c:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   4368e:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   43692:	d105      	bne.n	436a0 <compare_set+0x9c>
   43694:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   43696:	2013      	movs	r0, #19
   43698:	f005 f96f 	bl	4897a <z_impl_k_busy_wait>
   4369c:	4b27      	ldr	r3, [pc, #156]	; (4373c <compare_set+0x138>)
   4369e:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   436a0:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   436a4:	eba4 000c 	sub.w	r0, r4, ip
   436a8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   436ac:	2100      	movs	r1, #0
			cc_val = now + 2;
   436ae:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   436b2:	bf88      	it	hi
   436b4:	4664      	movhi	r4, ip
   436b6:	f8c8 1000 	str.w	r1, [r8]
   436ba:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   436be:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   436c2:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   436c6:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   436ca:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   436ce:	4582      	cmp	sl, r0
   436d0:	d006      	beq.n	436e0 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   436d2:	1a20      	subs	r0, r4, r0
   436d4:	3802      	subs	r0, #2
   436d6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   436da:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   436de:	d819      	bhi.n	43714 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   436e0:	1aa4      	subs	r4, r4, r2
   436e2:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   436e6:	1932      	adds	r2, r6, r4
   436e8:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   436ec:	4c12      	ldr	r4, [pc, #72]	; (43738 <compare_set+0x134>)
   436ee:	0129      	lsls	r1, r5, #4
   436f0:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   436f4:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   436f8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   436fa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   436fc:	5062      	str	r2, [r4, r1]
	return ret;
   436fe:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   43700:	6043      	str	r3, [r0, #4]
	if (key) {
   43702:	9b00      	ldr	r3, [sp, #0]
   43704:	b113      	cbz	r3, 4370c <compare_set+0x108>
   43706:	4628      	mov	r0, r5
   43708:	f7ff ff34 	bl	43574 <compare_int_unlock.part.0>
}
   4370c:	4620      	mov	r0, r4
   4370e:	b003      	add	sp, #12
   43710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43714:	4620      	mov	r0, r4
   43716:	e7b1      	b.n	4367c <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   43718:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4371a:	4a09      	ldr	r2, [pc, #36]	; (43740 <compare_set+0x13c>)
   4371c:	40ab      	lsls	r3, r5
   4371e:	e8d2 1fef 	ldaex	r1, [r2]
   43722:	4319      	orrs	r1, r3
   43724:	e8c2 1fe0 	stlex	r0, r1, [r2]
   43728:	2800      	cmp	r0, #0
   4372a:	d1f8      	bne.n	4371e <compare_set+0x11a>
   4372c:	4632      	mov	r2, r6
   4372e:	463b      	mov	r3, r7
   43730:	e7dc      	b.n	436ec <compare_set+0xe8>
			return -EINVAL;
   43732:	f06f 0415 	mvn.w	r4, #21
   43736:	e7e4      	b.n	43702 <compare_set+0xfe>
   43738:	2001a6b0 	.word	0x2001a6b0
   4373c:	40015000 	.word	0x40015000
   43740:	2001a914 	.word	0x2001a914

00043744 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   43744:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   43746:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   43748:	f04f 30ff 	mov.w	r0, #4294967295
   4374c:	f04f 31ff 	mov.w	r1, #4294967295
   43750:	4d16      	ldr	r5, [pc, #88]	; (437ac <sys_clock_driver_init+0x68>)
   43752:	4b17      	ldr	r3, [pc, #92]	; (437b0 <sys_clock_driver_init+0x6c>)
   43754:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   43758:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   4375c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   43760:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43762:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   43766:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   4376a:	4b12      	ldr	r3, [pc, #72]	; (437b4 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   4376c:	2101      	movs	r1, #1
   4376e:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   43772:	2015      	movs	r0, #21
   43774:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   43778:	4622      	mov	r2, r4
   4377a:	f7fe fc0d 	bl	41f98 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   4377e:	2015      	movs	r0, #21
   43780:	f7fe fbec 	bl	41f5c <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   43784:	2301      	movs	r3, #1
   43786:	4a0c      	ldr	r2, [pc, #48]	; (437b8 <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43788:	4620      	mov	r0, r4
   4378a:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   4378c:	4a0b      	ldr	r2, [pc, #44]	; (437bc <sys_clock_driver_init+0x78>)
   4378e:	602b      	str	r3, [r5, #0]
   43790:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43792:	4b0b      	ldr	r3, [pc, #44]	; (437c0 <sys_clock_driver_init+0x7c>)
   43794:	4a0b      	ldr	r2, [pc, #44]	; (437c4 <sys_clock_driver_init+0x80>)
   43796:	9300      	str	r3, [sp, #0]
   43798:	9401      	str	r4, [sp, #4]
   4379a:	2300      	movs	r3, #0
   4379c:	f7ff ff32 	bl	43604 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   437a0:	4630      	mov	r0, r6
   437a2:	f7ff faa9 	bl	42cf8 <z_nrf_clock_control_lf_on>

	return 0;
}
   437a6:	4620      	mov	r0, r4
   437a8:	b002      	add	sp, #8
   437aa:	bd70      	pop	{r4, r5, r6, pc}
   437ac:	40015000 	.word	0x40015000
   437b0:	2001a6b0 	.word	0x2001a6b0
   437b4:	e000e100 	.word	0xe000e100
   437b8:	40015008 	.word	0x40015008
   437bc:	2001a918 	.word	0x2001a918
   437c0:	0004349d 	.word	0x0004349d
   437c4:	007fffff 	.word	0x007fffff

000437c8 <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   437c8:	4b33      	ldr	r3, [pc, #204]	; (43898 <rtc_nrf_isr+0xd0>)
{
   437ca:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   437ce:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   437d2:	079a      	lsls	r2, r3, #30
   437d4:	d509      	bpl.n	437ea <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   437d6:	4b31      	ldr	r3, [pc, #196]	; (4389c <rtc_nrf_isr+0xd4>)
   437d8:	681a      	ldr	r2, [r3, #0]
   437da:	b132      	cbz	r2, 437ea <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   437dc:	2200      	movs	r2, #0
   437de:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   437e0:	4a2f      	ldr	r2, [pc, #188]	; (438a0 <rtc_nrf_isr+0xd8>)
   437e2:	681b      	ldr	r3, [r3, #0]
   437e4:	6813      	ldr	r3, [r2, #0]
   437e6:	3301      	adds	r3, #1
   437e8:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   437ea:	f04f 0320 	mov.w	r3, #32
   437ee:	f3ef 8211 	mrs	r2, BASEPRI
   437f2:	f383 8812 	msr	BASEPRI_MAX, r3
   437f6:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   437fa:	4b27      	ldr	r3, [pc, #156]	; (43898 <rtc_nrf_isr+0xd0>)
   437fc:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   43800:	03db      	lsls	r3, r3, #15
   43802:	d50e      	bpl.n	43822 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43804:	4b27      	ldr	r3, [pc, #156]	; (438a4 <rtc_nrf_isr+0xdc>)
   43806:	e8d3 1fef 	ldaex	r1, [r3]
   4380a:	f021 0001 	bic.w	r0, r1, #1
   4380e:	e8c3 0fe4 	stlex	r4, r0, [r3]
   43812:	2c00      	cmp	r4, #0
   43814:	d1f7      	bne.n	43806 <rtc_nrf_isr+0x3e>
   43816:	4b24      	ldr	r3, [pc, #144]	; (438a8 <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43818:	2900      	cmp	r1, #0
   4381a:	d136      	bne.n	4388a <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4381c:	6819      	ldr	r1, [r3, #0]
		if (result) {
   4381e:	2900      	cmp	r1, #0
   43820:	d133      	bne.n	4388a <rtc_nrf_isr+0xc2>
{
   43822:	2300      	movs	r3, #0
	__asm__ volatile(
   43824:	f382 8811 	msr	BASEPRI, r2
   43828:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   4382c:	b353      	cbz	r3, 43884 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   4382e:	f7ff fec7 	bl	435c0 <z_nrf_rtc_timer_read>
   43832:	4604      	mov	r4, r0
	__asm__ volatile(
   43834:	f04f 0320 	mov.w	r3, #32
   43838:	f3ef 8011 	mrs	r0, BASEPRI
   4383c:	f383 8812 	msr	BASEPRI_MAX, r3
   43840:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   43844:	4b19      	ldr	r3, [pc, #100]	; (438ac <rtc_nrf_isr+0xe4>)
   43846:	2200      	movs	r2, #0
   43848:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   4384c:	4549      	cmp	r1, r9
   4384e:	bf08      	it	eq
   43850:	4544      	cmpeq	r4, r8
   43852:	d31f      	bcc.n	43894 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   43854:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43858:	f04f 34ff 	mov.w	r4, #4294967295
   4385c:	f04f 35ff 	mov.w	r5, #4294967295
			cc_data[chan].callback = NULL;
   43860:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   43862:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43866:	e9c3 4502 	strd	r4, r5, [r3, #8]
   4386a:	4b0b      	ldr	r3, [pc, #44]	; (43898 <rtc_nrf_isr+0xd0>)
   4386c:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   43870:	f380 8811 	msr	BASEPRI, r0
   43874:	f3bf 8f6f 	isb	sy
		if (handler) {
   43878:	b121      	cbz	r1, 43884 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   4387a:	4642      	mov	r2, r8
   4387c:	464b      	mov	r3, r9
   4387e:	2000      	movs	r0, #0
   43880:	9600      	str	r6, [sp, #0]
   43882:	4788      	blx	r1
}
   43884:	b002      	add	sp, #8
   43886:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   4388a:	2100      	movs	r1, #0
   4388c:	6019      	str	r1, [r3, #0]
   4388e:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43890:	2301      	movs	r3, #1
}
   43892:	e7c7      	b.n	43824 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   43894:	4611      	mov	r1, r2
   43896:	e7eb      	b.n	43870 <rtc_nrf_isr+0xa8>
   43898:	40015000 	.word	0x40015000
   4389c:	40015104 	.word	0x40015104
   438a0:	2001a91c 	.word	0x2001a91c
   438a4:	2001a914 	.word	0x2001a914
   438a8:	40015140 	.word	0x40015140
   438ac:	2001a6b0 	.word	0x2001a6b0

000438b0 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   438b0:	4b15      	ldr	r3, [pc, #84]	; (43908 <sys_clock_set_timeout+0x58>)
{
   438b2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   438b4:	f1b0 3fff 	cmp.w	r0, #4294967295
   438b8:	bf08      	it	eq
   438ba:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   438bc:	1e46      	subs	r6, r0, #1
   438be:	2e00      	cmp	r6, #0
   438c0:	dd20      	ble.n	43904 <sys_clock_set_timeout+0x54>
   438c2:	429e      	cmp	r6, r3
   438c4:	bfa8      	it	ge
   438c6:	461e      	movge	r6, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   438c8:	f7ff fe7a 	bl	435c0 <z_nrf_rtc_timer_read>
   438cc:	4b0f      	ldr	r3, [pc, #60]	; (4390c <sys_clock_set_timeout+0x5c>)
   438ce:	e9d3 4500 	ldrd	r4, r5, [r3]
   438d2:	1b00      	subs	r0, r0, r4
		ticks = 0;
   438d4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   438d8:	bf28      	it	cs
   438da:	2600      	movcs	r6, #0
	cyc += (CYC_PER_TICK - 1);
   438dc:	3020      	adds	r0, #32
   438de:	eb00 1246 	add.w	r2, r0, r6, lsl #5
	uint64_t target_time = cyc + last_count;
   438e2:	480b      	ldr	r0, [pc, #44]	; (43910 <sys_clock_set_timeout+0x60>)
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
   438e4:	f022 021f 	bic.w	r2, r2, #31
	uint64_t target_time = cyc + last_count;
   438e8:	4282      	cmp	r2, r0
   438ea:	bf28      	it	cs
   438ec:	4602      	movcs	r2, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   438ee:	2000      	movs	r0, #0
   438f0:	4b08      	ldr	r3, [pc, #32]	; (43914 <sys_clock_set_timeout+0x64>)
   438f2:	18a2      	adds	r2, r4, r2
   438f4:	9300      	str	r3, [sp, #0]
   438f6:	9001      	str	r0, [sp, #4]
   438f8:	f145 0300 	adc.w	r3, r5, #0
   438fc:	f7ff fe82 	bl	43604 <compare_set>
}
   43900:	b002      	add	sp, #8
   43902:	bd70      	pop	{r4, r5, r6, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43904:	2600      	movs	r6, #0
   43906:	e7df      	b.n	438c8 <sys_clock_set_timeout+0x18>
   43908:	0003ffff 	.word	0x0003ffff
   4390c:	2001a6c0 	.word	0x2001a6c0
   43910:	007fffe0 	.word	0x007fffe0
   43914:	0004349d 	.word	0x0004349d

00043918 <sys_clock_elapsed>:
{
   43918:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   4391a:	f7ff fe51 	bl	435c0 <z_nrf_rtc_timer_read>
   4391e:	4a05      	ldr	r2, [pc, #20]	; (43934 <sys_clock_elapsed+0x1c>)
   43920:	e9d2 3200 	ldrd	r3, r2, [r2]
   43924:	1ac0      	subs	r0, r0, r3
   43926:	eb61 0102 	sbc.w	r1, r1, r2
   4392a:	0940      	lsrs	r0, r0, #5
}
   4392c:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
   43930:	bd08      	pop	{r3, pc}
   43932:	bf00      	nop
   43934:	2001a6c0 	.word	0x2001a6c0

00043938 <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   43938:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   4393a:	4d19      	ldr	r5, [pc, #100]	; (439a0 <_nrf_modem_lib_init+0x68>)
   4393c:	4c19      	ldr	r4, [pc, #100]	; (439a4 <_nrf_modem_lib_init+0x6c>)
   4393e:	782b      	ldrb	r3, [r5, #0]
   43940:	b933      	cbnz	r3, 43950 <_nrf_modem_lib_init+0x18>
	list->tail = NULL;
   43942:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   43946:	4818      	ldr	r0, [pc, #96]	; (439a8 <_nrf_modem_lib_init+0x70>)
   43948:	f004 fecc 	bl	486e4 <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   4394c:	2301      	movs	r3, #1
   4394e:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   43950:	2200      	movs	r2, #0
   43952:	202a      	movs	r0, #42	; 0x2a
   43954:	4611      	mov	r1, r2
   43956:	f7fe fb1f 	bl	41f98 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   4395a:	2100      	movs	r1, #0
   4395c:	4813      	ldr	r0, [pc, #76]	; (439ac <_nrf_modem_lib_init+0x74>)
   4395e:	f002 f965 	bl	45c2c <nrf_modem_init>
   43962:	4b13      	ldr	r3, [pc, #76]	; (439b0 <_nrf_modem_lib_init+0x78>)
   43964:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   43966:	f04f 32ff 	mov.w	r2, #4294967295
   4396a:	f04f 33ff 	mov.w	r3, #4294967295
   4396e:	480e      	ldr	r0, [pc, #56]	; (439a8 <_nrf_modem_lib_init+0x70>)
   43970:	f002 fd7e 	bl	46470 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   43974:	6820      	ldr	r0, [r4, #0]
   43976:	b170      	cbz	r0, 43996 <_nrf_modem_lib_init+0x5e>
	return node->next;
   43978:	6804      	ldr	r4, [r0, #0]
   4397a:	2c00      	cmp	r4, #0
   4397c:	bf38      	it	cc
   4397e:	2400      	movcc	r4, #0
	z_impl_k_sem_give(sem);
   43980:	3004      	adds	r0, #4
   43982:	f002 fe39 	bl	465f8 <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   43986:	b134      	cbz	r4, 43996 <_nrf_modem_lib_init+0x5e>
   43988:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   4398a:	4620      	mov	r0, r4
   4398c:	2b00      	cmp	r3, #0
   4398e:	bf38      	it	cc
   43990:	2300      	movcc	r3, #0
   43992:	461c      	mov	r4, r3
   43994:	e7f4      	b.n	43980 <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   43996:	4804      	ldr	r0, [pc, #16]	; (439a8 <_nrf_modem_lib_init+0x70>)
   43998:	f002 fde8 	bl	4656c <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   4399c:	2000      	movs	r0, #0
   4399e:	bd38      	pop	{r3, r4, r5, pc}
   439a0:	2001ad59 	.word	0x2001ad59
   439a4:	2001a924 	.word	0x2001a924
   439a8:	2001a92c 	.word	0x2001a92c
   439ac:	00048f08 	.word	0x00048f08
   439b0:	2001a920 	.word	0x2001a920

000439b4 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   439b4:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   439b6:	4c0d      	ldr	r4, [pc, #52]	; (439ec <thread_monitor_entry_get+0x38>)
{
   439b8:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   439ba:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   439bc:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   439be:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   439c0:	4b0b      	ldr	r3, [pc, #44]	; (439f0 <thread_monitor_entry_get+0x3c>)
   439c2:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   439c4:	6801      	ldr	r1, [r0, #0]
   439c6:	4291      	cmp	r1, r2
   439c8:	d00e      	beq.n	439e8 <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   439ca:	b151      	cbz	r1, 439e2 <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   439cc:	6841      	ldr	r1, [r0, #4]
   439ce:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   439d0:	42b1      	cmp	r1, r6
   439d2:	bfc4      	itt	gt
   439d4:	4604      	movgt	r4, r0
   439d6:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   439d8:	3d01      	subs	r5, #1
   439da:	f100 0008 	add.w	r0, r0, #8
   439de:	d1f1      	bne.n	439c4 <thread_monitor_entry_get+0x10>
   439e0:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   439e2:	3b01      	subs	r3, #1
	new_entry->id = id;
   439e4:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   439e6:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   439e8:	bd70      	pop	{r4, r5, r6, pc}
   439ea:	bf00      	nop
   439ec:	2001a998 	.word	0x2001a998
   439f0:	2001a974 	.word	0x2001a974

000439f4 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   439f4:	4668      	mov	r0, sp
   439f6:	f020 0107 	bic.w	r1, r0, #7
   439fa:	468d      	mov	sp, r1
   439fc:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   439fe:	4b0f      	ldr	r3, [pc, #60]	; (43a3c <rpc_proxy_irq_handler+0x48>)
   43a00:	e8d3 2fef 	ldaex	r2, [r3]
   43a04:	3201      	adds	r2, #1
   43a06:	e8c3 2fe1 	stlex	r1, r2, [r3]
   43a0a:	2900      	cmp	r1, #0
   43a0c:	d1f8      	bne.n	43a00 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   43a0e:	f001 f951 	bl	44cb4 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   43a12:	4b0b      	ldr	r3, [pc, #44]	; (43a40 <rpc_proxy_irq_handler+0x4c>)
   43a14:	681c      	ldr	r4, [r3, #0]
   43a16:	2c00      	cmp	r4, #0
   43a18:	bf38      	it	cc
   43a1a:	2400      	movcc	r4, #0
   43a1c:	b12c      	cbz	r4, 43a2a <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   43a1e:	1d20      	adds	r0, r4, #4
   43a20:	f002 fdea 	bl	465f8 <z_impl_k_sem_give>
   43a24:	6824      	ldr	r4, [r4, #0]
   43a26:	2c00      	cmp	r4, #0
   43a28:	d1f8      	bne.n	43a1c <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   43a2a:	f7fe facb 	bl	41fc4 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   43a2e:	f7fe fba3 	bl	42178 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43a32:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   43a36:	4685      	mov	sp, r0
   43a38:	4770      	bx	lr
   43a3a:	bf00      	nop
   43a3c:	2001a974 	.word	0x2001a974
   43a40:	2001a990 	.word	0x2001a990

00043a44 <nrf_modem_os_timedwait>:
{
   43a44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43a48:	4688      	mov	r8, r1
   43a4a:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   43a4c:	f004 ff93 	bl	48976 <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   43a50:	f8d8 3000 	ldr.w	r3, [r8]
   43a54:	4604      	mov	r4, r0
   43a56:	2b00      	cmp	r3, #0
   43a58:	460d      	mov	r5, r1
   43a5a:	d103      	bne.n	43a64 <nrf_modem_os_timedwait+0x20>
	z_impl_k_yield();
   43a5c:	f003 f864 	bl	46b28 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   43a60:	2074      	movs	r0, #116	; 0x74
   43a62:	e077      	b.n	43b54 <nrf_modem_os_timedwait+0x110>
		*timeout = SYS_FOREVER_MS;
   43a64:	bfbc      	itt	lt
   43a66:	f04f 33ff 	movlt.w	r3, #4294967295
   43a6a:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   43a6e:	2201      	movs	r2, #1
   43a70:	2100      	movs	r1, #0
   43a72:	a802      	add	r0, sp, #8
   43a74:	f004 fe3d 	bl	486f2 <z_impl_k_sem_init>
   43a78:	f10d 0904 	add.w	r9, sp, #4
	__asm__ volatile(
   43a7c:	f04f 0320 	mov.w	r3, #32
   43a80:	f3ef 8b11 	mrs	fp, BASEPRI
   43a84:	f383 8812 	msr	BASEPRI_MAX, r3
   43a88:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   43a8c:	f003 f8ee 	bl	46c6c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43a90:	f7ff ff90 	bl	439b4 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   43a94:	4938      	ldr	r1, [pc, #224]	; (43b78 <nrf_modem_os_timedwait+0x134>)
   43a96:	6843      	ldr	r3, [r0, #4]
   43a98:	680a      	ldr	r2, [r1, #0]
   43a9a:	468a      	mov	sl, r1
   43a9c:	4293      	cmp	r3, r2
   43a9e:	f04f 0300 	mov.w	r3, #0
   43aa2:	d108      	bne.n	43ab6 <nrf_modem_os_timedwait+0x72>
	parent->next = child;
   43aa4:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   43aa6:	4b35      	ldr	r3, [pc, #212]	; (43b7c <nrf_modem_os_timedwait+0x138>)
   43aa8:	685a      	ldr	r2, [r3, #4]
   43aaa:	2a00      	cmp	r2, #0
   43aac:	d155      	bne.n	43b5a <nrf_modem_os_timedwait+0x116>
	list->head = node;
   43aae:	e9c3 9900 	strd	r9, r9, [r3]
		allow_to_sleep = true;
   43ab2:	2301      	movs	r3, #1
}
   43ab4:	e000      	b.n	43ab8 <nrf_modem_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   43ab6:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   43ab8:	f38b 8811 	msr	BASEPRI, fp
   43abc:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   43ac0:	2b00      	cmp	r3, #0
   43ac2:	d046      	beq.n	43b52 <nrf_modem_os_timedwait+0x10e>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   43ac4:	f8d8 2000 	ldr.w	r2, [r8]
   43ac8:	1c53      	adds	r3, r2, #1
   43aca:	bf19      	ittee	ne
   43acc:	ea22 72e2 	bicne.w	r2, r2, r2, asr #31
   43ad0:	17d3      	asrne	r3, r2, #31
   43ad2:	f04f 32ff 	moveq.w	r2, #4294967295
   43ad6:	f04f 33ff 	moveq.w	r3, #4294967295
	return z_impl_k_sem_take(sem, timeout);
   43ada:	a802      	add	r0, sp, #8
   43adc:	f002 fdac 	bl	46638 <z_impl_k_sem_take>
	__asm__ volatile(
   43ae0:	f04f 0320 	mov.w	r3, #32
   43ae4:	f3ef 8b11 	mrs	fp, BASEPRI
   43ae8:	f383 8812 	msr	BASEPRI_MAX, r3
   43aec:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43af0:	2000      	movs	r0, #0
   43af2:	4b22      	ldr	r3, [pc, #136]	; (43b7c <nrf_modem_os_timedwait+0x138>)
   43af4:	681a      	ldr	r2, [r3, #0]
   43af6:	b152      	cbz	r2, 43b0e <nrf_modem_os_timedwait+0xca>
   43af8:	454a      	cmp	r2, r9
   43afa:	d139      	bne.n	43b70 <nrf_modem_os_timedwait+0x12c>
Z_GENLIST_REMOVE(slist, snode)
   43afc:	9901      	ldr	r1, [sp, #4]
   43afe:	bb88      	cbnz	r0, 43b64 <nrf_modem_os_timedwait+0x120>
   43b00:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   43b02:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   43b04:	4290      	cmp	r0, r2
   43b06:	d100      	bne.n	43b0a <nrf_modem_os_timedwait+0xc6>
	list->tail = node;
   43b08:	6059      	str	r1, [r3, #4]
	parent->next = child;
   43b0a:	2300      	movs	r3, #0
   43b0c:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   43b0e:	f003 f8ad 	bl	46c6c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43b12:	f7ff ff4f 	bl	439b4 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   43b16:	f8da 3000 	ldr.w	r3, [sl]
   43b1a:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   43b1c:	f38b 8811 	msr	BASEPRI, fp
   43b20:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   43b24:	f8d8 9000 	ldr.w	r9, [r8]
   43b28:	f1b9 3fff 	cmp.w	r9, #4294967295
   43b2c:	d011      	beq.n	43b52 <nrf_modem_os_timedwait+0x10e>
	return z_impl_k_uptime_ticks();
   43b2e:	f004 ff22 	bl	48976 <z_impl_k_uptime_ticks>
	remaining = *timeout - k_uptime_delta(&start);
   43b32:	eb14 0409 	adds.w	r4, r4, r9
   43b36:	eb45 75e9 	adc.w	r5, r5, r9, asr #31
   43b3a:	1a26      	subs	r6, r4, r0
   43b3c:	eb65 0701 	sbc.w	r7, r5, r1
	*timeout = remaining > 0 ? remaining : 0;
   43b40:	2e00      	cmp	r6, #0
   43b42:	f177 0300 	sbcs.w	r3, r7, #0
   43b46:	bfb8      	it	lt
   43b48:	2600      	movlt	r6, #0
   43b4a:	f8c8 6000 	str.w	r6, [r8]
	if (*timeout == 0) {
   43b4e:	2e00      	cmp	r6, #0
   43b50:	d086      	beq.n	43a60 <nrf_modem_os_timedwait+0x1c>
	return 0;
   43b52:	2000      	movs	r0, #0
}
   43b54:	b007      	add	sp, #28
   43b56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43b5a:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   43b5e:	f8c3 9004 	str.w	r9, [r3, #4]
   43b62:	e7a6      	b.n	43ab2 <nrf_modem_os_timedwait+0x6e>
	parent->next = child;
   43b64:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   43b66:	6859      	ldr	r1, [r3, #4]
   43b68:	4291      	cmp	r1, r2
	list->tail = node;
   43b6a:	bf08      	it	eq
   43b6c:	6058      	streq	r0, [r3, #4]
}
   43b6e:	e7cc      	b.n	43b0a <nrf_modem_os_timedwait+0xc6>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43b70:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43b72:	6812      	ldr	r2, [r2, #0]
   43b74:	e7bf      	b.n	43af6 <nrf_modem_os_timedwait+0xb2>
   43b76:	bf00      	nop
   43b78:	2001a974 	.word	0x2001a974
   43b7c:	2001a990 	.word	0x2001a990

00043b80 <nrf_modem_os_sem_init>:
{
   43b80:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   43b82:	6804      	ldr	r4, [r0, #0]
   43b84:	4b09      	ldr	r3, [pc, #36]	; (43bac <nrf_modem_os_sem_init+0x2c>)
   43b86:	b12c      	cbz	r4, 43b94 <nrf_modem_os_sem_init+0x14>
   43b88:	429c      	cmp	r4, r3
   43b8a:	d303      	bcc.n	43b94 <nrf_modem_os_sem_init+0x14>
   43b8c:	f103 0530 	add.w	r5, r3, #48	; 0x30
   43b90:	42ac      	cmp	r4, r5
   43b92:	d306      	bcc.n	43ba2 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   43b94:	4d06      	ldr	r5, [pc, #24]	; (43bb0 <nrf_modem_os_sem_init+0x30>)
   43b96:	782c      	ldrb	r4, [r5, #0]
   43b98:	1c66      	adds	r6, r4, #1
   43b9a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   43b9e:	702e      	strb	r6, [r5, #0]
   43ba0:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   43ba2:	6800      	ldr	r0, [r0, #0]
}
   43ba4:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   43ba6:	f004 bda4 	b.w	486f2 <z_impl_k_sem_init>
   43baa:	bf00      	nop
   43bac:	2001a944 	.word	0x2001a944
   43bb0:	2001ad5a 	.word	0x2001ad5a

00043bb4 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43bb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43bb8:	4b01      	ldr	r3, [pc, #4]	; (43bc0 <nrf_modem_os_application_irq_set+0xc>)
   43bba:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43bbe:	4770      	bx	lr
   43bc0:	e000e100 	.word	0xe000e100

00043bc4 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43bc4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43bc8:	4b01      	ldr	r3, [pc, #4]	; (43bd0 <nrf_modem_os_application_irq_clear+0xc>)
   43bca:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43bce:	4770      	bx	lr
   43bd0:	e000e100 	.word	0xe000e100

00043bd4 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43bd4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43bd8:	4b01      	ldr	r3, [pc, #4]	; (43be0 <nrf_modem_os_trace_irq_set+0xc>)
   43bda:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43bde:	4770      	bx	lr
   43be0:	e000e100 	.word	0xe000e100

00043be4 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43be4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43be8:	4b01      	ldr	r3, [pc, #4]	; (43bf0 <nrf_modem_os_trace_irq_clear+0xc>)
   43bea:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43bee:	4770      	bx	lr
   43bf0:	e000e100 	.word	0xe000e100

00043bf4 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   43bf4:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   43bf6:	2200      	movs	r2, #0
   43bf8:	2300      	movs	r3, #0
   43bfa:	4801      	ldr	r0, [pc, #4]	; (43c00 <nrf_modem_os_alloc+0xc>)
   43bfc:	f004 bcf5 	b.w	485ea <k_heap_alloc>
   43c00:	2001a5a4 	.word	0x2001a5a4

00043c04 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   43c04:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   43c06:	4801      	ldr	r0, [pc, #4]	; (43c0c <nrf_modem_os_free+0x8>)
   43c08:	f004 bcf9 	b.w	485fe <k_heap_free>
   43c0c:	2001a5a4 	.word	0x2001a5a4

00043c10 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   43c10:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   43c12:	2200      	movs	r2, #0
   43c14:	2300      	movs	r3, #0
   43c16:	4801      	ldr	r0, [pc, #4]	; (43c1c <nrf_modem_os_shm_tx_alloc+0xc>)
   43c18:	f004 bce7 	b.w	485ea <k_heap_alloc>
   43c1c:	2001a97c 	.word	0x2001a97c

00043c20 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   43c20:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   43c22:	4801      	ldr	r0, [pc, #4]	; (43c28 <nrf_modem_os_shm_tx_free+0x8>)
   43c24:	f004 bceb 	b.w	485fe <k_heap_free>
   43c28:	2001a97c 	.word	0x2001a97c

00043c2c <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   43c2c:	b510      	push	{r4, lr}
	list->head = NULL;
   43c2e:	2400      	movs	r4, #0
   43c30:	4b0e      	ldr	r3, [pc, #56]	; (43c6c <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   43c32:	e9c3 4400 	strd	r4, r4, [r3]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43c36:	4b0e      	ldr	r3, [pc, #56]	; (43c70 <nrf_modem_os_init+0x44>)
   43c38:	e8d3 2fef 	ldaex	r2, [r3]
   43c3c:	e8c3 4fe1 	stlex	r1, r4, [r3]
   43c40:	2900      	cmp	r1, #0
   43c42:	d1f9      	bne.n	43c38 <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   43c44:	f004 fb62 	bl	4830c <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   43c48:	4621      	mov	r1, r4
   43c4a:	2204      	movs	r2, #4
   43c4c:	4809      	ldr	r0, [pc, #36]	; (43c74 <nrf_modem_os_init+0x48>)
   43c4e:	f004 f9d6 	bl	47ffe <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   43c52:	4621      	mov	r1, r4
   43c54:	2204      	movs	r2, #4
   43c56:	4808      	ldr	r0, [pc, #32]	; (43c78 <nrf_modem_os_init+0x4c>)
   43c58:	f004 f9d1 	bl	47ffe <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   43c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   43c60:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   43c64:	4905      	ldr	r1, [pc, #20]	; (43c7c <nrf_modem_os_init+0x50>)
   43c66:	4806      	ldr	r0, [pc, #24]	; (43c80 <nrf_modem_os_init+0x54>)
   43c68:	f004 bc70 	b.w	4854c <k_heap_init>
   43c6c:	2001a990 	.word	0x2001a990
   43c70:	2001a974 	.word	0x2001a974
   43c74:	2001a940 	.word	0x2001a940
   43c78:	2001a978 	.word	0x2001a978
   43c7c:	200164e8 	.word	0x200164e8
   43c80:	2001a97c 	.word	0x2001a97c

00043c84 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   43c84:	b508      	push	{r3, lr}
	z_impl_log_panic();
   43c86:	f7fd fc79 	bl	4157c <z_impl_log_panic>
   43c8a:	4b06      	ldr	r3, [pc, #24]	; (43ca4 <k_sys_fatal_error_handler+0x20>)
   43c8c:	4906      	ldr	r1, [pc, #24]	; (43ca8 <k_sys_fatal_error_handler+0x24>)
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   43c8e:	4807      	ldr	r0, [pc, #28]	; (43cac <k_sys_fatal_error_handler+0x28>)
   43c90:	1ac9      	subs	r1, r1, r3
   43c92:	08c9      	lsrs	r1, r1, #3
   43c94:	0189      	lsls	r1, r1, #6
   43c96:	f041 0101 	orr.w	r1, r1, #1
   43c9a:	f003 fea6 	bl	479ea <log_0>
		sys_arch_reboot(0);
   43c9e:	2000      	movs	r0, #0
   43ca0:	f004 fb43 	bl	4832a <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   43ca4:	00048d10 	.word	0x00048d10
   43ca8:	00048d18 	.word	0x00048d18
   43cac:	0004963d 	.word	0x0004963d

00043cb0 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   43cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   43cb2:	4604      	mov	r4, r0
   43cb4:	b0a3      	sub	sp, #140	; 0x8c
   43cb6:	460d      	mov	r5, r1
   43cb8:	4616      	mov	r6, r2
   43cba:	461f      	mov	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   43cbc:	f04f 32ff 	mov.w	r2, #4294967295
   43cc0:	f04f 33ff 	mov.w	r3, #4294967295
   43cc4:	480b      	ldr	r0, [pc, #44]	; (43cf4 <tfm_ns_interface_dispatch+0x44>)
   43cc6:	f002 fbd3 	bl	46470 <z_impl_k_mutex_lock>
	int32_t result;

	/* TF-M request protected by NS lock */
	if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   43cca:	b988      	cbnz	r0, 43cf0 <tfm_ns_interface_dispatch+0x40>
#endif

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   43ccc:	4668      	mov	r0, sp
   43cce:	f004 f923 	bl	47f18 <z_arm_save_fp_context>
#endif

	result = fn(arg0, arg1, arg2, arg3);
   43cd2:	463a      	mov	r2, r7
   43cd4:	4631      	mov	r1, r6
   43cd6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   43cd8:	4628      	mov	r0, r5
   43cda:	47a0      	blx	r4
   43cdc:	4604      	mov	r4, r0

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	z_arm_restore_fp_context(&context_buffer);
   43cde:	4668      	mov	r0, sp
   43ce0:	f004 f91b 	bl	47f1a <z_arm_restore_fp_context>
	return z_impl_k_mutex_unlock(mutex);
   43ce4:	4803      	ldr	r0, [pc, #12]	; (43cf4 <tfm_ns_interface_dispatch+0x44>)
   43ce6:	f002 fc41 	bl	4656c <z_impl_k_mutex_unlock>
#endif

	k_mutex_unlock(&tfm_mutex);

	return result;
}
   43cea:	4620      	mov	r0, r4
   43cec:	b023      	add	sp, #140	; 0x8c
   43cee:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (int32_t)TFM_ERROR_GENERIC;
   43cf0:	241f      	movs	r4, #31
   43cf2:	e7fa      	b.n	43cea <tfm_ns_interface_dispatch+0x3a>
   43cf4:	2001a5cc 	.word	0x2001a5cc

00043cf8 <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   43cf8:	4b01      	ldr	r3, [pc, #4]	; (43d00 <SystemInit+0x8>)
   43cfa:	4a02      	ldr	r2, [pc, #8]	; (43d04 <SystemInit+0xc>)
   43cfc:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   43cfe:	4770      	bx	lr
   43d00:	2001a520 	.word	0x2001a520
   43d04:	03d09000 	.word	0x03d09000

00043d08 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   43d08:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   43d0a:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   43d0c:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   43d0e:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   43d12:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   43d14:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   43d18:	d010      	beq.n	43d3c <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   43d1a:	fa05 f204 	lsl.w	r2, r5, r4
   43d1e:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   43d22:	e8d0 6fef 	ldaex	r6, [r0]
   43d26:	429e      	cmp	r6, r3
   43d28:	d104      	bne.n	43d34 <nrfx_flag32_alloc+0x2c>
   43d2a:	e8c0 2fec 	stlex	ip, r2, [r0]
   43d2e:	f1bc 0f00 	cmp.w	ip, #0
   43d32:	d1f6      	bne.n	43d22 <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43d34:	d1ea      	bne.n	43d0c <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   43d36:	4802      	ldr	r0, [pc, #8]	; (43d40 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   43d38:	700c      	strb	r4, [r1, #0]
}
   43d3a:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   43d3c:	4801      	ldr	r0, [pc, #4]	; (43d44 <nrfx_flag32_alloc+0x3c>)
   43d3e:	e7fc      	b.n	43d3a <nrfx_flag32_alloc+0x32>
   43d40:	0bad0000 	.word	0x0bad0000
   43d44:	0bad0002 	.word	0x0bad0002

00043d48 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   43d48:	6803      	ldr	r3, [r0, #0]
{
   43d4a:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   43d4c:	40cb      	lsrs	r3, r1
   43d4e:	07db      	lsls	r3, r3, #31
   43d50:	d411      	bmi.n	43d76 <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   43d52:	2301      	movs	r3, #1
   43d54:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   43d58:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   43d5a:	ea41 0203 	orr.w	r2, r1, r3
   43d5e:	e8d0 4fef 	ldaex	r4, [r0]
   43d62:	429c      	cmp	r4, r3
   43d64:	d104      	bne.n	43d70 <nrfx_flag32_free+0x28>
   43d66:	e8c0 2fec 	stlex	ip, r2, [r0]
   43d6a:	f1bc 0f00 	cmp.w	ip, #0
   43d6e:	d1f6      	bne.n	43d5e <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43d70:	d1f2      	bne.n	43d58 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   43d72:	4802      	ldr	r0, [pc, #8]	; (43d7c <nrfx_flag32_free+0x34>)
}
   43d74:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   43d76:	4802      	ldr	r0, [pc, #8]	; (43d80 <nrfx_flag32_free+0x38>)
   43d78:	e7fc      	b.n	43d74 <nrfx_flag32_free+0x2c>
   43d7a:	bf00      	nop
   43d7c:	0bad0000 	.word	0x0bad0000
   43d80:	0bad0004 	.word	0x0bad0004

00043d84 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   43d84:	4b04      	ldr	r3, [pc, #16]	; (43d98 <nrfx_clock_init+0x14>)
   43d86:	791a      	ldrb	r2, [r3, #4]
   43d88:	b922      	cbnz	r2, 43d94 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   43d8a:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   43d8c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   43d8e:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   43d90:	4802      	ldr	r0, [pc, #8]	; (43d9c <nrfx_clock_init+0x18>)
   43d92:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   43d94:	4802      	ldr	r0, [pc, #8]	; (43da0 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   43d96:	4770      	bx	lr
   43d98:	2001a9e8 	.word	0x2001a9e8
   43d9c:	0bad0000 	.word	0x0bad0000
   43da0:	0bad000c 	.word	0x0bad000c

00043da4 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43da4:	b110      	cbz	r0, 43dac <nrfx_clock_start+0x8>
   43da6:	2801      	cmp	r0, #1
   43da8:	d01e      	beq.n	43de8 <nrfx_clock_start+0x44>
   43daa:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43dac:	4b13      	ldr	r3, [pc, #76]	; (43dfc <nrfx_clock_start+0x58>)
   43dae:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43db2:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   43db6:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   43dba:	4619      	mov	r1, r3
   43dbc:	d010      	beq.n	43de0 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   43dbe:	f002 0203 	and.w	r2, r2, #3
   43dc2:	2a02      	cmp	r2, #2
   43dc4:	d10c      	bne.n	43de0 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43dc6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43dca:	2200      	movs	r2, #0
   43dcc:	4b0c      	ldr	r3, [pc, #48]	; (43e00 <nrfx_clock_start+0x5c>)
   43dce:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   43dd0:	2202      	movs	r2, #2
   43dd2:	681b      	ldr	r3, [r3, #0]
   43dd4:	4b09      	ldr	r3, [pc, #36]	; (43dfc <nrfx_clock_start+0x58>)
   43dd6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43dda:	2201      	movs	r2, #1
   43ddc:	609a      	str	r2, [r3, #8]
}
   43dde:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   43de0:	2301      	movs	r3, #1
   43de2:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   43de6:	e7f0      	b.n	43dca <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43de8:	2200      	movs	r2, #0
   43dea:	4b06      	ldr	r3, [pc, #24]	; (43e04 <nrfx_clock_start+0x60>)
   43dec:	601a      	str	r2, [r3, #0]
   43dee:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   43df0:	4b02      	ldr	r3, [pc, #8]	; (43dfc <nrfx_clock_start+0x58>)
   43df2:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43df6:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   43df8:	4770      	bx	lr
   43dfa:	bf00      	nop
   43dfc:	40005000 	.word	0x40005000
   43e00:	40005104 	.word	0x40005104
   43e04:	40005100 	.word	0x40005100

00043e08 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   43e08:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43e0a:	b110      	cbz	r0, 43e12 <nrfx_clock_stop+0xa>
   43e0c:	2801      	cmp	r0, #1
   43e0e:	d016      	beq.n	43e3e <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   43e10:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   43e12:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e14:	2101      	movs	r1, #1
   43e16:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   43e1a:	4c16      	ldr	r4, [pc, #88]	; (43e74 <nrfx_clock_stop+0x6c>)
   43e1c:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e20:	4a15      	ldr	r2, [pc, #84]	; (43e78 <nrfx_clock_stop+0x70>)
   43e22:	6010      	str	r0, [r2, #0]
   43e24:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e26:	4a15      	ldr	r2, [pc, #84]	; (43e7c <nrfx_clock_stop+0x74>)
   43e28:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43e2a:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   43e2e:	03db      	lsls	r3, r3, #15
   43e30:	d5ee      	bpl.n	43e10 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   43e32:	2001      	movs	r0, #1
   43e34:	f004 fa7c 	bl	48330 <nrfx_busy_wait>
   43e38:	3d01      	subs	r5, #1
   43e3a:	d1f6      	bne.n	43e2a <nrfx_clock_stop+0x22>
   43e3c:	e7e8      	b.n	43e10 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e3e:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e40:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e44:	4b0e      	ldr	r3, [pc, #56]	; (43e80 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   43e46:	4c0b      	ldr	r4, [pc, #44]	; (43e74 <nrfx_clock_stop+0x6c>)
   43e48:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e4c:	601a      	str	r2, [r3, #0]
   43e4e:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e50:	4b0c      	ldr	r3, [pc, #48]	; (43e84 <nrfx_clock_stop+0x7c>)
   43e52:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43e54:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43e58:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43e5c:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43e60:	03d2      	lsls	r2, r2, #15
   43e62:	d5d5      	bpl.n	43e10 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   43e64:	2b00      	cmp	r3, #0
   43e66:	d0d3      	beq.n	43e10 <nrfx_clock_stop+0x8>
   43e68:	2001      	movs	r0, #1
   43e6a:	f004 fa61 	bl	48330 <nrfx_busy_wait>
   43e6e:	3d01      	subs	r5, #1
   43e70:	d1f0      	bne.n	43e54 <nrfx_clock_stop+0x4c>
   43e72:	e7cd      	b.n	43e10 <nrfx_clock_stop+0x8>
   43e74:	40005000 	.word	0x40005000
   43e78:	40005104 	.word	0x40005104
   43e7c:	4000500c 	.word	0x4000500c
   43e80:	40005100 	.word	0x40005100
   43e84:	40005004 	.word	0x40005004

00043e88 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43e88:	4b15      	ldr	r3, [pc, #84]	; (43ee0 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   43e8a:	b510      	push	{r4, lr}
   43e8c:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   43e8e:	b14a      	cbz	r2, 43ea4 <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e90:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   43e92:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e94:	6018      	str	r0, [r3, #0]
   43e96:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   43e98:	4b12      	ldr	r3, [pc, #72]	; (43ee4 <nrfx_power_clock_irq_handler+0x5c>)
   43e9a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   43e9e:	4b12      	ldr	r3, [pc, #72]	; (43ee8 <nrfx_power_clock_irq_handler+0x60>)
   43ea0:	681b      	ldr	r3, [r3, #0]
   43ea2:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43ea4:	4b11      	ldr	r3, [pc, #68]	; (43eec <nrfx_power_clock_irq_handler+0x64>)
   43ea6:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   43ea8:	b182      	cbz	r2, 43ecc <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43eaa:	2200      	movs	r2, #0
   43eac:	601a      	str	r2, [r3, #0]
   43eae:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43eb0:	4b0c      	ldr	r3, [pc, #48]	; (43ee4 <nrfx_power_clock_irq_handler+0x5c>)
   43eb2:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43eb6:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   43eba:	f002 0203 	and.w	r2, r2, #3
   43ebe:	2a01      	cmp	r2, #1
   43ec0:	f04f 0102 	mov.w	r1, #2
   43ec4:	d103      	bne.n	43ece <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43ec6:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43eca:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   43ecc:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   43ece:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43ed2:	4b05      	ldr	r3, [pc, #20]	; (43ee8 <nrfx_power_clock_irq_handler+0x60>)
   43ed4:	2001      	movs	r0, #1
}
   43ed6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43eda:	681b      	ldr	r3, [r3, #0]
   43edc:	4718      	bx	r3
   43ede:	bf00      	nop
   43ee0:	40005100 	.word	0x40005100
   43ee4:	40005000 	.word	0x40005000
   43ee8:	2001a9e8 	.word	0x2001a9e8
   43eec:	40005104 	.word	0x40005104

00043ef0 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   43ef0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   43ef2:	4801      	ldr	r0, [pc, #4]	; (43ef8 <nrfx_dppi_channel_alloc+0x8>)
   43ef4:	f7ff bf08 	b.w	43d08 <nrfx_flag32_alloc>
   43ef8:	2001a524 	.word	0x2001a524

00043efc <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   43efc:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43efe:	4c0d      	ldr	r4, [pc, #52]	; (43f34 <call_handler+0x38>)
   43f00:	f100 0308 	add.w	r3, r0, #8
   43f04:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   43f08:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f0a:	05da      	lsls	r2, r3, #23
{
   43f0c:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f0e:	d507      	bpl.n	43f20 <call_handler+0x24>
   43f10:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   43f14:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   43f18:	6852      	ldr	r2, [r2, #4]
   43f1a:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   43f1e:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   43f20:	68a3      	ldr	r3, [r4, #8]
   43f22:	b12b      	cbz	r3, 43f30 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43f24:	4631      	mov	r1, r6
   43f26:	4628      	mov	r0, r5
   43f28:	68e2      	ldr	r2, [r4, #12]
    }
}
   43f2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43f2e:	4718      	bx	r3
}
   43f30:	bd70      	pop	{r4, r5, r6, pc}
   43f32:	bf00      	nop
   43f34:	2001a528 	.word	0x2001a528

00043f38 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f38:	4b12      	ldr	r3, [pc, #72]	; (43f84 <release_handler+0x4c>)
   43f3a:	3008      	adds	r0, #8
   43f3c:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   43f40:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f42:	05d1      	lsls	r1, r2, #23
   43f44:	d51b      	bpl.n	43f7e <release_handler+0x46>
   43f46:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   43f4a:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   43f4e:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43f52:	2000      	movs	r0, #0
   43f54:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   43f58:	f834 2b02 	ldrh.w	r2, [r4], #2
   43f5c:	f412 7f80 	tst.w	r2, #256	; 0x100
   43f60:	d003      	beq.n	43f6a <release_handler+0x32>
   43f62:	f3c2 2243 	ubfx	r2, r2, #9, #4
   43f66:	4291      	cmp	r1, r2
   43f68:	d009      	beq.n	43f7e <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43f6a:	3001      	adds	r0, #1
   43f6c:	2820      	cmp	r0, #32
   43f6e:	d1f3      	bne.n	43f58 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   43f70:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43f72:	4805      	ldr	r0, [pc, #20]	; (43f88 <release_handler+0x50>)
}
   43f74:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   43f76:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43f7a:	f7ff bee5 	b.w	43d48 <nrfx_flag32_free>
}
   43f7e:	bc10      	pop	{r4}
   43f80:	4770      	bx	lr
   43f82:	bf00      	nop
   43f84:	2001a528 	.word	0x2001a528
   43f88:	2001a57c 	.word	0x2001a57c

00043f8c <pin_handler_trigger_uninit>:
{
   43f8c:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   43f8e:	4c0c      	ldr	r4, [pc, #48]	; (43fc0 <pin_handler_trigger_uninit+0x34>)
   43f90:	f100 0508 	add.w	r5, r0, #8
   43f94:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   43f98:	069a      	lsls	r2, r3, #26
   43f9a:	d50a      	bpl.n	43fb2 <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   43f9c:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   43f9e:	0b5b      	lsrs	r3, r3, #13
   43fa0:	009b      	lsls	r3, r3, #2
   43fa2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   43fa6:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   43faa:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   43fae:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   43fb2:	f7ff ffc1 	bl	43f38 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   43fb6:	2300      	movs	r3, #0
   43fb8:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   43fbc:	bd38      	pop	{r3, r4, r5, pc}
   43fbe:	bf00      	nop
   43fc0:	2001a528 	.word	0x2001a528

00043fc4 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   43fc4:	f000 021f 	and.w	r2, r0, #31
   43fc8:	4805      	ldr	r0, [pc, #20]	; (43fe0 <nrf_gpio_cfg_sense_set+0x1c>)
   43fca:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   43fce:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   43fd2:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   43fd6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   43fda:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   43fde:	4770      	bx	lr
   43fe0:	40842500 	.word	0x40842500

00043fe4 <nrfx_gpiote_input_configure>:
{
   43fe4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   43fe6:	4604      	mov	r4, r0
    if (p_input_config)
   43fe8:	b1f9      	cbz	r1, 4402a <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   43fea:	4f4c      	ldr	r7, [pc, #304]	; (4411c <nrfx_gpiote_input_configure+0x138>)
   43fec:	f100 0c08 	add.w	ip, r0, #8
   43ff0:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   43ff4:	f000 0522 	and.w	r5, r0, #34	; 0x22
   43ff8:	2d22      	cmp	r5, #34	; 0x22
   43ffa:	d102      	bne.n	44002 <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   43ffc:	4848      	ldr	r0, [pc, #288]	; (44120 <nrfx_gpiote_input_configure+0x13c>)
}
   43ffe:	b003      	add	sp, #12
   44000:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44002:	4d48      	ldr	r5, [pc, #288]	; (44124 <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   44004:	f004 061f 	and.w	r6, r4, #31
   44008:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4400c:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   44010:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   44012:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   44016:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4401a:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   4401e:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   44022:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   44026:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   4402a:	b192      	cbz	r2, 44052 <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4402c:	483b      	ldr	r0, [pc, #236]	; (4411c <nrfx_gpiote_input_configure+0x138>)
   4402e:	f104 0608 	add.w	r6, r4, #8
   44032:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   44036:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   44038:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   4403a:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   4403c:	d50c      	bpl.n	44058 <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   4403e:	2a00      	cmp	r2, #0
   44040:	d1dc      	bne.n	43ffc <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   44042:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   44046:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   4404a:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   4404e:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   44052:	bbd3      	cbnz	r3, 440ca <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   44054:	4834      	ldr	r0, [pc, #208]	; (44128 <nrfx_gpiote_input_configure+0x144>)
   44056:	e7d2      	b.n	43ffe <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   44058:	f021 0120 	bic.w	r1, r1, #32
   4405c:	04c9      	lsls	r1, r1, #19
   4405e:	0cc9      	lsrs	r1, r1, #19
   44060:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   44064:	2a00      	cmp	r2, #0
   44066:	d0ec      	beq.n	44042 <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   44068:	2d03      	cmp	r5, #3
   4406a:	d8c7      	bhi.n	43ffc <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   4406c:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   44070:	4662      	mov	r2, ip
   44072:	0092      	lsls	r2, r2, #2
   44074:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   44078:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   4407c:	b925      	cbnz	r5, 44088 <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   4407e:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   44082:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   44086:	e7dc      	b.n	44042 <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44088:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4408c:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44090:	f027 0703 	bic.w	r7, r7, #3
   44094:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   44098:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4409c:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   440a0:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   440a4:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   440a8:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440ac:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   440b0:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   440b4:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   440b8:	ea47 070e 	orr.w	r7, r7, lr
   440bc:	f041 0120 	orr.w	r1, r1, #32
   440c0:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   440c4:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   440c8:	e7bb      	b.n	44042 <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   440ca:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   440cc:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   440d0:	f7ff ff32 	bl	43f38 <release_handler>
    if (!handler)
   440d4:	2e00      	cmp	r6, #0
   440d6:	d0bd      	beq.n	44054 <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   440d8:	4d10      	ldr	r5, [pc, #64]	; (4411c <nrfx_gpiote_input_configure+0x138>)
   440da:	682b      	ldr	r3, [r5, #0]
   440dc:	429e      	cmp	r6, r3
   440de:	d104      	bne.n	440ea <nrfx_gpiote_input_configure+0x106>
   440e0:	686b      	ldr	r3, [r5, #4]
   440e2:	429f      	cmp	r7, r3
   440e4:	d101      	bne.n	440ea <nrfx_gpiote_input_configure+0x106>
   440e6:	2200      	movs	r2, #0
   440e8:	e009      	b.n	440fe <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   440ea:	4810      	ldr	r0, [pc, #64]	; (4412c <nrfx_gpiote_input_configure+0x148>)
   440ec:	f10d 0107 	add.w	r1, sp, #7
   440f0:	f7ff fe0a 	bl	43d08 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   440f4:	4b0c      	ldr	r3, [pc, #48]	; (44128 <nrfx_gpiote_input_configure+0x144>)
   440f6:	4298      	cmp	r0, r3
   440f8:	d181      	bne.n	43ffe <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   440fa:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   440fe:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44102:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   44104:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44106:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   4410a:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   4410e:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   44112:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   44116:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   4411a:	e79b      	b.n	44054 <nrfx_gpiote_input_configure+0x70>
   4411c:	2001a528 	.word	0x2001a528
   44120:	0bad0004 	.word	0x0bad0004
   44124:	40842500 	.word	0x40842500
   44128:	0bad0000 	.word	0x0bad0000
   4412c:	2001a57c 	.word	0x2001a57c

00044130 <nrfx_gpiote_output_configure>:
{
   44130:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   44134:	2900      	cmp	r1, #0
   44136:	d044      	beq.n	441c2 <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44138:	4e43      	ldr	r6, [pc, #268]	; (44248 <nrfx_gpiote_output_configure+0x118>)
   4413a:	f100 0c08 	add.w	ip, r0, #8
   4413e:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   44142:	07ab      	lsls	r3, r5, #30
   44144:	d404      	bmi.n	44150 <nrfx_gpiote_output_configure+0x20>
   44146:	06af      	lsls	r7, r5, #26
   44148:	d502      	bpl.n	44150 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4414a:	4840      	ldr	r0, [pc, #256]	; (4424c <nrfx_gpiote_output_configure+0x11c>)
}
   4414c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   44150:	f015 0f1c 	tst.w	r5, #28
   44154:	d002      	beq.n	4415c <nrfx_gpiote_output_configure+0x2c>
   44156:	784b      	ldrb	r3, [r1, #1]
   44158:	2b01      	cmp	r3, #1
   4415a:	d0f6      	beq.n	4414a <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4415c:	4b3c      	ldr	r3, [pc, #240]	; (44250 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4415e:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   44162:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   44166:	bf14      	ite	ne
   44168:	2402      	movne	r4, #2
   4416a:	2400      	moveq	r4, #0
   4416c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44170:	1c8b      	adds	r3, r1, #2
   44172:	bf14      	ite	ne
   44174:	f04f 090c 	movne.w	r9, #12
   44178:	f04f 0900 	moveq.w	r9, #0
   4417c:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44180:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44184:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   44188:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   4418c:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   44190:	f1be 0f00 	cmp.w	lr, #0
   44194:	d003      	beq.n	4419e <nrfx_gpiote_output_configure+0x6e>
   44196:	f891 e001 	ldrb.w	lr, [r1, #1]
   4419a:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4419e:	b10b      	cbz	r3, 441a4 <nrfx_gpiote_output_configure+0x74>
   441a0:	788c      	ldrb	r4, [r1, #2]
   441a2:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   441a4:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   441a6:	f045 0503 	orr.w	r5, r5, #3
   441aa:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   441ae:	ea43 0308 	orr.w	r3, r3, r8
   441b2:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   441b6:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   441ba:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   441be:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   441c2:	b90a      	cbnz	r2, 441c8 <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   441c4:	4823      	ldr	r0, [pc, #140]	; (44254 <nrfx_gpiote_output_configure+0x124>)
   441c6:	e7c1      	b.n	4414c <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   441c8:	4d1f      	ldr	r5, [pc, #124]	; (44248 <nrfx_gpiote_output_configure+0x118>)
   441ca:	f100 0608 	add.w	r6, r0, #8
   441ce:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   441d2:	07a3      	lsls	r3, r4, #30
   441d4:	d5b9      	bpl.n	4414a <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   441d6:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   441d8:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   441da:	f024 0420 	bic.w	r4, r4, #32
   441de:	00b9      	lsls	r1, r7, #2
   441e0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   441e4:	04e4      	lsls	r4, r4, #19
   441e6:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   441ea:	0ce4      	lsrs	r4, r4, #19
   441ec:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   441f0:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   441f4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   441f8:	f892 c001 	ldrb.w	ip, [r2, #1]
   441fc:	f1bc 0f00 	cmp.w	ip, #0
   44200:	d0e0      	beq.n	441c4 <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   44202:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   44206:	7892      	ldrb	r2, [r2, #2]
   44208:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   4420c:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   44210:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44214:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   44218:	0203      	lsls	r3, r0, #8
   4421a:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   4421e:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44222:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   44226:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   4422a:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4422c:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   4422e:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44232:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44236:	4313      	orrs	r3, r2
   44238:	f044 0420 	orr.w	r4, r4, #32
   4423c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44240:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   44244:	e7be      	b.n	441c4 <nrfx_gpiote_output_configure+0x94>
   44246:	bf00      	nop
   44248:	2001a528 	.word	0x2001a528
   4424c:	0bad0004 	.word	0x0bad0004
   44250:	40842500 	.word	0x40842500
   44254:	0bad0000 	.word	0x0bad0000

00044258 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   44258:	4b01      	ldr	r3, [pc, #4]	; (44260 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   4425a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   4425e:	4770      	bx	lr
   44260:	2001a528 	.word	0x2001a528

00044264 <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44264:	4b05      	ldr	r3, [pc, #20]	; (4427c <nrfx_gpiote_channel_get+0x18>)
   44266:	3008      	adds	r0, #8
   44268:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   4426c:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   4426e:	bf43      	ittte	mi
   44270:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   44272:	4803      	ldrmi	r0, [pc, #12]	; (44280 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44274:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   44276:	4803      	ldrpl	r0, [pc, #12]	; (44284 <nrfx_gpiote_channel_get+0x20>)
}
   44278:	4770      	bx	lr
   4427a:	bf00      	nop
   4427c:	2001a528 	.word	0x2001a528
   44280:	0bad0000 	.word	0x0bad0000
   44284:	0bad0004 	.word	0x0bad0004

00044288 <nrfx_gpiote_init>:
{
   44288:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4428a:	4c0e      	ldr	r4, [pc, #56]	; (442c4 <nrfx_gpiote_init+0x3c>)
   4428c:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   44290:	b9b5      	cbnz	r5, 442c0 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   44292:	2240      	movs	r2, #64	; 0x40
   44294:	4629      	mov	r1, r5
   44296:	f104 0010 	add.w	r0, r4, #16
   4429a:	f003 feb0 	bl	47ffe <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   4429e:	2031      	movs	r0, #49	; 0x31
   442a0:	f7fd fe5c 	bl	41f5c <arch_irq_enable>
    p_reg->INTENSET = mask;
   442a4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   442a8:	4b07      	ldr	r3, [pc, #28]	; (442c8 <nrfx_gpiote_init+0x40>)
    return err_code;
   442aa:	4808      	ldr	r0, [pc, #32]	; (442cc <nrfx_gpiote_init+0x44>)
   442ac:	601d      	str	r5, [r3, #0]
   442ae:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   442b0:	4b07      	ldr	r3, [pc, #28]	; (442d0 <nrfx_gpiote_init+0x48>)
   442b2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   442b6:	2301      	movs	r3, #1
   442b8:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   442bc:	6563      	str	r3, [r4, #84]	; 0x54
}
   442be:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   442c0:	4804      	ldr	r0, [pc, #16]	; (442d4 <nrfx_gpiote_init+0x4c>)
   442c2:	e7fc      	b.n	442be <nrfx_gpiote_init+0x36>
   442c4:	2001a528 	.word	0x2001a528
   442c8:	4003117c 	.word	0x4003117c
   442cc:	0bad0000 	.word	0x0bad0000
   442d0:	40031000 	.word	0x40031000
   442d4:	0bad0005 	.word	0x0bad0005

000442d8 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   442d8:	4b03      	ldr	r3, [pc, #12]	; (442e8 <nrfx_gpiote_is_init+0x10>)
   442da:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   442de:	3800      	subs	r0, #0
   442e0:	bf18      	it	ne
   442e2:	2001      	movne	r0, #1
   442e4:	4770      	bx	lr
   442e6:	bf00      	nop
   442e8:	2001a528 	.word	0x2001a528

000442ec <nrfx_gpiote_channel_free>:
{
   442ec:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   442ee:	4801      	ldr	r0, [pc, #4]	; (442f4 <nrfx_gpiote_channel_free+0x8>)
   442f0:	f7ff bd2a 	b.w	43d48 <nrfx_flag32_free>
   442f4:	2001a578 	.word	0x2001a578

000442f8 <nrfx_gpiote_channel_alloc>:
{
   442f8:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   442fa:	4801      	ldr	r0, [pc, #4]	; (44300 <nrfx_gpiote_channel_alloc+0x8>)
   442fc:	f7ff bd04 	b.w	43d08 <nrfx_flag32_alloc>
   44300:	2001a578 	.word	0x2001a578

00044304 <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44304:	4b1b      	ldr	r3, [pc, #108]	; (44374 <nrfx_gpiote_trigger_enable+0x70>)
   44306:	f100 0208 	add.w	r2, r0, #8
   4430a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   4430e:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   44310:	069a      	lsls	r2, r3, #26
   44312:	d51a      	bpl.n	4434a <nrfx_gpiote_trigger_enable+0x46>
   44314:	f013 0402 	ands.w	r4, r3, #2
   44318:	d117      	bne.n	4434a <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   4431a:	4817      	ldr	r0, [pc, #92]	; (44378 <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   4431c:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   4431e:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44320:	5084      	str	r4, [r0, r2]
   44322:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   44324:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   44328:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   4432c:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   44330:	f040 0001 	orr.w	r0, r0, #1
   44334:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   44338:	b129      	cbz	r1, 44346 <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   4433a:	2201      	movs	r2, #1
   4433c:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   44340:	4a0e      	ldr	r2, [pc, #56]	; (4437c <nrfx_gpiote_trigger_enable+0x78>)
   44342:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44346:	bc10      	pop	{r4}
   44348:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4434a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   4434e:	2b04      	cmp	r3, #4
   44350:	d00c      	beq.n	4436c <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   44352:	2b05      	cmp	r3, #5
   44354:	d00c      	beq.n	44370 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   44356:	4b0a      	ldr	r3, [pc, #40]	; (44380 <nrfx_gpiote_trigger_enable+0x7c>)
   44358:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   4435a:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   4435e:	40d9      	lsrs	r1, r3
   44360:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44364:	3102      	adds	r1, #2
}
   44366:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   44368:	f7ff be2c 	b.w	43fc4 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   4436c:	2103      	movs	r1, #3
   4436e:	e7fa      	b.n	44366 <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   44370:	2102      	movs	r1, #2
   44372:	e7f8      	b.n	44366 <nrfx_gpiote_trigger_enable+0x62>
   44374:	2001a528 	.word	0x2001a528
   44378:	40031100 	.word	0x40031100
   4437c:	40031000 	.word	0x40031000
   44380:	40842500 	.word	0x40842500

00044384 <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44384:	4b0e      	ldr	r3, [pc, #56]	; (443c0 <nrfx_gpiote_trigger_disable+0x3c>)
   44386:	f100 0208 	add.w	r2, r0, #8
   4438a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   4438e:	0699      	lsls	r1, r3, #26
   44390:	d513      	bpl.n	443ba <nrfx_gpiote_trigger_disable+0x36>
   44392:	079a      	lsls	r2, r3, #30
   44394:	d411      	bmi.n	443ba <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   44396:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44398:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   4439a:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   4439c:	4909      	ldr	r1, [pc, #36]	; (443c4 <nrfx_gpiote_trigger_disable+0x40>)
   4439e:	009b      	lsls	r3, r3, #2
   443a0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   443a4:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   443a8:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   443ac:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   443b0:	f022 0203 	bic.w	r2, r2, #3
   443b4:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   443b8:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   443ba:	2100      	movs	r1, #0
   443bc:	f7ff be02 	b.w	43fc4 <nrf_gpio_cfg_sense_set>
   443c0:	2001a528 	.word	0x2001a528
   443c4:	40031000 	.word	0x40031000

000443c8 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   443c8:	4b0c      	ldr	r3, [pc, #48]	; (443fc <nrfx_gpiote_pin_uninit+0x34>)
   443ca:	f100 0208 	add.w	r2, r0, #8
   443ce:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   443d2:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   443d4:	07db      	lsls	r3, r3, #31
{
   443d6:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   443d8:	d50d      	bpl.n	443f6 <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   443da:	f7ff ffd3 	bl	44384 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   443de:	4620      	mov	r0, r4
   443e0:	f7ff fdd4 	bl	43f8c <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   443e4:	2202      	movs	r2, #2
   443e6:	4b06      	ldr	r3, [pc, #24]	; (44400 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   443e8:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   443ec:	3480      	adds	r4, #128	; 0x80
   443ee:	4805      	ldr	r0, [pc, #20]	; (44404 <nrfx_gpiote_pin_uninit+0x3c>)
   443f0:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   443f4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   443f6:	4804      	ldr	r0, [pc, #16]	; (44408 <nrfx_gpiote_pin_uninit+0x40>)
   443f8:	e7fc      	b.n	443f4 <nrfx_gpiote_pin_uninit+0x2c>
   443fa:	bf00      	nop
   443fc:	2001a528 	.word	0x2001a528
   44400:	40842500 	.word	0x40842500
   44404:	0bad0000 	.word	0x0bad0000
   44408:	0bad0004 	.word	0x0bad0004

0004440c <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   4440c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   44410:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   44412:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44414:	4634      	mov	r4, r6
{
   44416:	4b4b      	ldr	r3, [pc, #300]	; (44544 <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   44418:	484b      	ldr	r0, [pc, #300]	; (44548 <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   4441a:	494c      	ldr	r1, [pc, #304]	; (4454c <nrfx_gpiote_irq_handler+0x140>)
{
   4441c:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4441e:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   44420:	b135      	cbz	r5, 44430 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   44422:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   44426:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44428:	bf1e      	ittt	ne
   4442a:	601c      	strne	r4, [r3, #0]
   4442c:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   4442e:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   44430:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44432:	428b      	cmp	r3, r1
        mask <<= 1;
   44434:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44438:	d1f1      	bne.n	4441e <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4443a:	4f45      	ldr	r7, [pc, #276]	; (44550 <nrfx_gpiote_irq_handler+0x144>)
   4443c:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   4443e:	b183      	cbz	r3, 44462 <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   44440:	4d44      	ldr	r5, [pc, #272]	; (44554 <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   44442:	f10d 080c 	add.w	r8, sp, #12
   44446:	6a2b      	ldr	r3, [r5, #32]
   44448:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4444a:	622b      	str	r3, [r5, #32]
   4444c:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   44450:	9803      	ldr	r0, [sp, #12]
   44452:	b940      	cbnz	r0, 44466 <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44454:	6038      	str	r0, [r7, #0]
   44456:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   44458:	6a2b      	ldr	r3, [r5, #32]
   4445a:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4445c:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   4445e:	2b00      	cmp	r3, #0
   44460:	d1f4      	bne.n	4444c <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   44462:	2401      	movs	r4, #1
   44464:	e069      	b.n	4453a <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   44466:	fa90 faa0 	rbit	sl, r0
   4446a:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4446e:	4a3a      	ldr	r2, [pc, #232]	; (44558 <nrfx_gpiote_irq_handler+0x14c>)
   44470:	f10a 0308 	add.w	r3, sl, #8
   44474:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   44478:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   4447c:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   44480:	fa09 f403 	lsl.w	r4, r9, r3
   44484:	f818 300c 	ldrb.w	r3, [r8, ip]
   44488:	f3c1 0282 	ubfx	r2, r1, #2, #3
   4448c:	ea23 0304 	bic.w	r3, r3, r4
   44490:	f808 300c 	strb.w	r3, [r8, ip]
   44494:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44498:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   4449c:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4449e:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   444a0:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   444a4:	d518      	bpl.n	444d8 <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   444a6:	4611      	mov	r1, r2
   444a8:	4650      	mov	r0, sl
   444aa:	9301      	str	r3, [sp, #4]
   444ac:	f7ff fd26 	bl	43efc <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   444b0:	9b01      	ldr	r3, [sp, #4]
   444b2:	b2e4      	uxtb	r4, r4
   444b4:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   444b8:	f3c3 4301 	ubfx	r3, r3, #16, #2
   444bc:	429c      	cmp	r4, r3
   444be:	d107      	bne.n	444d0 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   444c0:	2100      	movs	r1, #0
   444c2:	4650      	mov	r0, sl
   444c4:	f7ff fd7e 	bl	43fc4 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   444c8:	4621      	mov	r1, r4
   444ca:	4650      	mov	r0, sl
   444cc:	f7ff fd7a 	bl	43fc4 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   444d0:	fa09 f00a 	lsl.w	r0, r9, sl
   444d4:	6228      	str	r0, [r5, #32]
}
   444d6:	e7bb      	b.n	44450 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   444d8:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   444da:	bf0c      	ite	eq
   444dc:	2103      	moveq	r1, #3
   444de:	2102      	movne	r1, #2
   444e0:	4650      	mov	r0, sl
   444e2:	9201      	str	r2, [sp, #4]
   444e4:	f7ff fd6e 	bl	43fc4 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   444e8:	9a01      	ldr	r2, [sp, #4]
   444ea:	2a03      	cmp	r2, #3
   444ec:	d004      	beq.n	444f8 <nrfx_gpiote_irq_handler+0xec>
   444ee:	2c02      	cmp	r4, #2
   444f0:	d107      	bne.n	44502 <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   444f2:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   444f6:	d1eb      	bne.n	444d0 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   444f8:	4659      	mov	r1, fp
   444fa:	4650      	mov	r0, sl
   444fc:	f7ff fcfe 	bl	43efc <call_handler>
   44500:	e7e6      	b.n	444d0 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   44502:	2c03      	cmp	r4, #3
   44504:	d1e4      	bne.n	444d0 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   44506:	f1bb 0f02 	cmp.w	fp, #2
   4450a:	e7f4      	b.n	444f6 <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   4450c:	fa96 f3a6 	rbit	r3, r6
   44510:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   44514:	fa04 f203 	lsl.w	r2, r4, r3
   44518:	009b      	lsls	r3, r3, #2
   4451a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   4451e:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   44522:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   44526:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   4452a:	f3c0 2004 	ubfx	r0, r0, #8, #5
   4452e:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   44532:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   44536:	f7ff fce1 	bl	43efc <call_handler>
    while (mask)
   4453a:	2e00      	cmp	r6, #0
   4453c:	d1e6      	bne.n	4450c <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   4453e:	b005      	add	sp, #20
   44540:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44544:	40031100 	.word	0x40031100
   44548:	40031000 	.word	0x40031000
   4454c:	40031120 	.word	0x40031120
   44550:	4003117c 	.word	0x4003117c
   44554:	40842500 	.word	0x40842500
   44558:	2001a528 	.word	0x2001a528

0004455c <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   4455c:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4455e:	4c08      	ldr	r4, [pc, #32]	; (44580 <nrfx_ipc_init+0x24>)
{
   44560:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44562:	7923      	ldrb	r3, [r4, #4]
{
   44564:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44566:	b943      	cbnz	r3, 4457a <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   44568:	202a      	movs	r0, #42	; 0x2a
   4456a:	f7fd fcf7 	bl	41f5c <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   4456e:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   44570:	4804      	ldr	r0, [pc, #16]	; (44584 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44572:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   44574:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   44576:	60a5      	str	r5, [r4, #8]
}
   44578:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   4457a:	4803      	ldr	r0, [pc, #12]	; (44588 <nrfx_ipc_init+0x2c>)
   4457c:	e7fc      	b.n	44578 <nrfx_ipc_init+0x1c>
   4457e:	bf00      	nop
   44580:	2001a9f0 	.word	0x2001a9f0
   44584:	0bad0000 	.word	0x0bad0000
   44588:	0bad000c 	.word	0x0bad000c

0004458c <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4458c:	2300      	movs	r3, #0
{
   4458e:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   44590:	4a0d      	ldr	r2, [pc, #52]	; (445c8 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   44592:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   44596:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4459a:	3301      	adds	r3, #1
   4459c:	2b08      	cmp	r3, #8
   4459e:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   445a2:	d1f6      	bne.n	44592 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   445a4:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   445a6:	4a08      	ldr	r2, [pc, #32]	; (445c8 <nrfx_ipc_config_load+0x3c>)
   445a8:	f100 0120 	add.w	r1, r0, #32
   445ac:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   445b0:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   445b4:	3301      	adds	r3, #1
   445b6:	2b08      	cmp	r3, #8
   445b8:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   445bc:	d1f6      	bne.n	445ac <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   445be:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   445c0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   445c4:	bd30      	pop	{r4, r5, pc}
   445c6:	bf00      	nop
   445c8:	4002a000 	.word	0x4002a000

000445cc <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   445cc:	2300      	movs	r3, #0
   445ce:	4a14      	ldr	r2, [pc, #80]	; (44620 <nrfx_ipc_uninit+0x54>)
   445d0:	4914      	ldr	r1, [pc, #80]	; (44624 <nrfx_ipc_uninit+0x58>)
   445d2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   445d6:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   445da:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   445de:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   445e2:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   445e6:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   445ea:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   445ee:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   445f2:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   445f6:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   445fa:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   445fe:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   44602:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   44606:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   4460a:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   4460e:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   44612:	f04f 32ff 	mov.w	r2, #4294967295
   44616:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   4461a:	4a03      	ldr	r2, [pc, #12]	; (44628 <nrfx_ipc_uninit+0x5c>)
   4461c:	7113      	strb	r3, [r2, #4]
}
   4461e:	4770      	bx	lr
   44620:	4002a004 	.word	0x4002a004
   44624:	4002a000 	.word	0x4002a000
   44628:	2001a9f0 	.word	0x2001a9f0

0004462c <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   4462c:	4b0c      	ldr	r3, [pc, #48]	; (44660 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   4462e:	b430      	push	{r4, r5}
   44630:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   44634:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   44636:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44638:	2500      	movs	r5, #0
    while (bitmask)
   4463a:	b923      	cbnz	r3, 44646 <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   4463c:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   4463e:	4b09      	ldr	r3, [pc, #36]	; (44664 <nrfx_ipc_irq_handler+0x38>)
   44640:	681a      	ldr	r2, [r3, #0]
   44642:	6899      	ldr	r1, [r3, #8]
   44644:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   44646:	fa93 f2a3 	rbit	r2, r3
   4464a:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   4464e:	fa04 f102 	lsl.w	r1, r4, r2
   44652:	ea23 0301 	bic.w	r3, r3, r1
   44656:	4904      	ldr	r1, [pc, #16]	; (44668 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   44658:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4465a:	508d      	str	r5, [r1, r2]
}
   4465c:	e7ed      	b.n	4463a <nrfx_ipc_irq_handler+0xe>
   4465e:	bf00      	nop
   44660:	4002a000 	.word	0x4002a000
   44664:	2001a9f0 	.word	0x2001a9f0
   44668:	4002a100 	.word	0x4002a100

0004466c <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   4466c:	2303      	movs	r3, #3
static void _DoInit(void) {
   4466e:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44670:	4c10      	ldr	r4, [pc, #64]	; (446b4 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   44672:	4a11      	ldr	r2, [pc, #68]	; (446b8 <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44674:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   44676:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   44678:	4b10      	ldr	r3, [pc, #64]	; (446bc <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   4467a:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   4467c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   4467e:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
   44682:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   44684:	2300      	movs	r3, #0
   44686:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   44688:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4468a:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   4468c:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   4468e:	4a0c      	ldr	r2, [pc, #48]	; (446c0 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   44690:	490c      	ldr	r1, [pc, #48]	; (446c4 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
   44692:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44694:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
   44696:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44698:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   4469a:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   4469c:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4469e:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   446a0:	f003 fc75 	bl	47f8e <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   446a4:	4620      	mov	r0, r4
   446a6:	4908      	ldr	r1, [pc, #32]	; (446c8 <_DoInit+0x5c>)
   446a8:	f003 fc71 	bl	47f8e <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   446ac:	2320      	movs	r3, #32
   446ae:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   446b0:	bd10      	pop	{r4, pc}
   446b2:	bf00      	nop
   446b4:	2001a9fc 	.word	0x2001a9fc
   446b8:	0004965a 	.word	0x0004965a
   446bc:	2001ad6b 	.word	0x2001ad6b
   446c0:	2001ad5b 	.word	0x2001ad5b
   446c4:	00049663 	.word	0x00049663
   446c8:	00049667 	.word	0x00049667

000446cc <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   446cc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   446d0:	f04f 0b18 	mov.w	fp, #24
   446d4:	4f22      	ldr	r7, [pc, #136]	; (44760 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   446d6:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   446d8:	fb0b 7200 	mla	r2, fp, r0, r7
   446dc:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   446de:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   446e0:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   446e2:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   446e4:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   446e6:	d834      	bhi.n	44752 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   446e8:	f8d2 a020 	ldr.w	sl, [r2, #32]
   446ec:	ebaa 0905 	sub.w	r9, sl, r5
   446f0:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
   446f4:	4294      	cmp	r4, r2
   446f6:	d811      	bhi.n	4471c <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   446f8:	f04f 0918 	mov.w	r9, #24
   446fc:	fb06 9309 	mla	r3, r6, r9, r9
   44700:	443b      	add	r3, r7
   44702:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   44704:	4622      	mov	r2, r4
   44706:	4641      	mov	r1, r8
   44708:	4428      	add	r0, r5
   4470a:	f003 fc6d 	bl	47fe8 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   4470e:	fb09 7606 	mla	r6, r9, r6, r7
   44712:	442c      	add	r4, r5
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
   44714:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   44716:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   44718:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   4471c:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   4471e:	429c      	cmp	r4, r3
   44720:	d81b      	bhi.n	4475a <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   44722:	fb00 bb0b 	mla	fp, r0, fp, fp
   44726:	44bb      	add	fp, r7
   44728:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   4472c:	464a      	mov	r2, r9
   4472e:	4428      	add	r0, r5
   44730:	442c      	add	r4, r5
   44732:	f003 fc59 	bl	47fe8 <memcpy>
      if (NumBytes) {
   44736:	ebb4 040a 	subs.w	r4, r4, sl
   4473a:	d006      	beq.n	4474a <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   4473c:	4622      	mov	r2, r4
   4473e:	f8db 0004 	ldr.w	r0, [fp, #4]
   44742:	eb08 0109 	add.w	r1, r8, r9
   44746:	f003 fc4f 	bl	47fe8 <memcpy>
      pRing->WrOff = NumBytes;
   4474a:	2018      	movs	r0, #24
   4474c:	fb00 7606 	mla	r6, r0, r6, r7
   44750:	e7e0      	b.n	44714 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   44752:	3b01      	subs	r3, #1
   44754:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   44756:	42a3      	cmp	r3, r4
   44758:	d2ce      	bcs.n	446f8 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   4475a:	2000      	movs	r0, #0
   4475c:	e7dc      	b.n	44718 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   4475e:	bf00      	nop
   44760:	2001a9fc 	.word	0x2001a9fc

00044764 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   44764:	2218      	movs	r2, #24
   44766:	4b03      	ldr	r3, [pc, #12]	; (44774 <SEGGER_RTT_HasDataUp+0x10>)
   44768:	fb02 3300 	mla	r3, r2, r0, r3
   4476c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   4476e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   44770:	1a80      	subs	r0, r0, r2
   44772:	4770      	bx	lr
   44774:	2001a9fc 	.word	0x2001a9fc

00044778 <rpc_handle_data_message>:
   44778:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4477c:	4680      	mov	r8, r0
   4477e:	4604      	mov	r4, r0
   44780:	2700      	movs	r7, #0
   44782:	f858 6b08 	ldr.w	r6, [r8], #8
   44786:	4d0c      	ldr	r5, [pc, #48]	; (447b8 <rpc_handle_data_message+0x40>)
   44788:	b2f6      	uxtb	r6, r6
   4478a:	782b      	ldrb	r3, [r5, #0]
   4478c:	42b3      	cmp	r3, r6
   4478e:	d00a      	beq.n	447a6 <rpc_handle_data_message+0x2e>
   44790:	3701      	adds	r7, #1
   44792:	2f04      	cmp	r7, #4
   44794:	f105 050c 	add.w	r5, r5, #12
   44798:	d1f7      	bne.n	4478a <rpc_handle_data_message+0x12>
   4479a:	68a0      	ldr	r0, [r4, #8]
   4479c:	b150      	cbz	r0, 447b4 <rpc_handle_data_message+0x3c>
   4479e:	f003 fe1d 	bl	483dc <rpc_transport_peer_data_free>
   447a2:	2000      	movs	r0, #0
   447a4:	e006      	b.n	447b4 <rpc_handle_data_message+0x3c>
   447a6:	6821      	ldr	r1, [r4, #0]
   447a8:	4640      	mov	r0, r8
   447aa:	686b      	ldr	r3, [r5, #4]
   447ac:	0c09      	lsrs	r1, r1, #16
   447ae:	4798      	blx	r3
   447b0:	2802      	cmp	r0, #2
   447b2:	d0ed      	beq.n	44790 <rpc_handle_data_message+0x18>
   447b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   447b8:	00048f2c 	.word	0x00048f2c

000447bc <trace_write>:
   447bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   447c0:	4f53      	ldr	r7, [pc, #332]	; (44910 <trace_write+0x154>)
   447c2:	4605      	mov	r5, r0
   447c4:	2100      	movs	r1, #0
   447c6:	6838      	ldr	r0, [r7, #0]
   447c8:	f003 fd8e 	bl	482e8 <nrf_modem_os_sem_take>
   447cc:	4604      	mov	r4, r0
   447ce:	2800      	cmp	r0, #0
   447d0:	d14c      	bne.n	4486c <trace_write+0xb0>
   447d2:	782b      	ldrb	r3, [r5, #0]
   447d4:	f8d5 8008 	ldr.w	r8, [r5, #8]
   447d8:	2b62      	cmp	r3, #98	; 0x62
   447da:	d043      	beq.n	44864 <trace_write+0xa8>
   447dc:	2b63      	cmp	r3, #99	; 0x63
   447de:	d043      	beq.n	44868 <trace_write+0xac>
   447e0:	2b61      	cmp	r3, #97	; 0x61
   447e2:	d102      	bne.n	447ea <trace_write+0x2e>
   447e4:	4b4b      	ldr	r3, [pc, #300]	; (44914 <trace_write+0x158>)
   447e6:	881c      	ldrh	r4, [r3, #0]
   447e8:	b2a4      	uxth	r4, r4
   447ea:	6838      	ldr	r0, [r7, #0]
   447ec:	f003 fd7a 	bl	482e4 <nrf_modem_os_sem_give>
   447f0:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   447f4:	6929      	ldr	r1, [r5, #16]
   447f6:	eba8 080a 	sub.w	r8, r8, sl
   447fa:	eba1 030a 	sub.w	r3, r1, sl
   447fe:	b29b      	uxth	r3, r3
   44800:	fa14 f488 	uxtah	r4, r4, r8
   44804:	fbb4 f2f3 	udiv	r2, r4, r3
   44808:	fb03 4412 	mls	r4, r3, r2, r4
   4480c:	686a      	ldr	r2, [r5, #4]
   4480e:	eba2 020a 	sub.w	r2, r2, sl
   44812:	fa13 f282 	uxtah	r2, r3, r2
   44816:	1b12      	subs	r2, r2, r4
   44818:	fb92 f0f3 	sdiv	r0, r2, r3
   4481c:	fb03 2210 	mls	r2, r3, r0, r2
   44820:	fa1f f982 	uxth.w	r9, r2
   44824:	fa14 f282 	uxtah	r2, r4, r2
   44828:	4293      	cmp	r3, r2
   4482a:	44a2      	add	sl, r4
   4482c:	da22      	bge.n	44874 <trace_write+0xb8>
   4482e:	eba1 030a 	sub.w	r3, r1, sl
   44832:	b29b      	uxth	r3, r3
   44834:	eba9 0403 	sub.w	r4, r9, r3
   44838:	4699      	mov	r9, r3
   4483a:	b2a4      	uxth	r4, r4
   4483c:	f1b9 0f00 	cmp.w	r9, #0
   44840:	d064      	beq.n	4490c <trace_write+0x150>
   44842:	2005      	movs	r0, #5
   44844:	f7ff f9d6 	bl	43bf4 <nrf_modem_os_alloc>
   44848:	4680      	mov	r8, r0
   4484a:	2800      	cmp	r0, #0
   4484c:	d05e      	beq.n	4490c <trace_write+0x150>
   4484e:	b19c      	cbz	r4, 44878 <trace_write+0xbc>
   44850:	2005      	movs	r0, #5
   44852:	f7ff f9cf 	bl	43bf4 <nrf_modem_os_alloc>
   44856:	4606      	mov	r6, r0
   44858:	b970      	cbnz	r0, 44878 <trace_write+0xbc>
   4485a:	4640      	mov	r0, r8
   4485c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44860:	f7ff b9d0 	b.w	43c04 <nrf_modem_os_free>
   44864:	4b2c      	ldr	r3, [pc, #176]	; (44918 <trace_write+0x15c>)
   44866:	e7be      	b.n	447e6 <trace_write+0x2a>
   44868:	4b2c      	ldr	r3, [pc, #176]	; (4491c <trace_write+0x160>)
   4486a:	e7bc      	b.n	447e6 <trace_write+0x2a>
   4486c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44870:	f7ff b9b0 	b.w	43bd4 <nrf_modem_os_trace_irq_set>
   44874:	2400      	movs	r4, #0
   44876:	e7e1      	b.n	4483c <trace_write+0x80>
   44878:	2100      	movs	r1, #0
   4487a:	6838      	ldr	r0, [r7, #0]
   4487c:	f003 fd34 	bl	482e8 <nrf_modem_os_sem_take>
   44880:	b140      	cbz	r0, 44894 <trace_write+0xd8>
   44882:	f7ff f9a7 	bl	43bd4 <nrf_modem_os_trace_irq_set>
   44886:	4640      	mov	r0, r8
   44888:	f7ff f9bc 	bl	43c04 <nrf_modem_os_free>
   4488c:	2c00      	cmp	r4, #0
   4488e:	d03d      	beq.n	4490c <trace_write+0x150>
   44890:	4630      	mov	r0, r6
   44892:	e7e3      	b.n	4485c <trace_write+0xa0>
   44894:	782b      	ldrb	r3, [r5, #0]
   44896:	2b62      	cmp	r3, #98	; 0x62
   44898:	d034      	beq.n	44904 <trace_write+0x148>
   4489a:	2b63      	cmp	r3, #99	; 0x63
   4489c:	d034      	beq.n	44908 <trace_write+0x14c>
   4489e:	2b61      	cmp	r3, #97	; 0x61
   448a0:	d107      	bne.n	448b2 <trace_write+0xf6>
   448a2:	4a1c      	ldr	r2, [pc, #112]	; (44914 <trace_write+0x158>)
   448a4:	8813      	ldrh	r3, [r2, #0]
   448a6:	eb04 0109 	add.w	r1, r4, r9
   448aa:	fa11 f383 	uxtah	r3, r1, r3
   448ae:	b29b      	uxth	r3, r3
   448b0:	8013      	strh	r3, [r2, #0]
   448b2:	6838      	ldr	r0, [r7, #0]
   448b4:	f06f 0b10 	mvn.w	fp, #16
   448b8:	f06f 0741 	mvn.w	r7, #65	; 0x41
   448bc:	f003 fd12 	bl	482e4 <nrf_modem_os_sem_give>
   448c0:	f888 b000 	strb.w	fp, [r8]
   448c4:	f888 7001 	strb.w	r7, [r8, #1]
   448c8:	782b      	ldrb	r3, [r5, #0]
   448ca:	2105      	movs	r1, #5
   448cc:	4640      	mov	r0, r8
   448ce:	f888 3004 	strb.w	r3, [r8, #4]
   448d2:	f8a8 9002 	strh.w	r9, [r8, #2]
   448d6:	f003 fd24 	bl	48322 <nrf_modem_os_trace_put>
   448da:	4649      	mov	r1, r9
   448dc:	4650      	mov	r0, sl
   448de:	f003 fd20 	bl	48322 <nrf_modem_os_trace_put>
   448e2:	b19c      	cbz	r4, 4490c <trace_write+0x150>
   448e4:	f886 b000 	strb.w	fp, [r6]
   448e8:	7077      	strb	r7, [r6, #1]
   448ea:	782b      	ldrb	r3, [r5, #0]
   448ec:	2105      	movs	r1, #5
   448ee:	4630      	mov	r0, r6
   448f0:	7133      	strb	r3, [r6, #4]
   448f2:	8074      	strh	r4, [r6, #2]
   448f4:	f003 fd15 	bl	48322 <nrf_modem_os_trace_put>
   448f8:	4621      	mov	r1, r4
   448fa:	68e8      	ldr	r0, [r5, #12]
   448fc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44900:	f003 bd0f 	b.w	48322 <nrf_modem_os_trace_put>
   44904:	4a04      	ldr	r2, [pc, #16]	; (44918 <trace_write+0x15c>)
   44906:	e7cd      	b.n	448a4 <trace_write+0xe8>
   44908:	4a04      	ldr	r2, [pc, #16]	; (4491c <trace_write+0x160>)
   4490a:	e7cb      	b.n	448a4 <trace_write+0xe8>
   4490c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44910:	2001aab4 	.word	0x2001aab4
   44914:	2001ad38 	.word	0x2001ad38
   44918:	2001ad34 	.word	0x2001ad34
   4491c:	2001ad36 	.word	0x2001ad36

00044920 <ipc_trace_init>:
   44920:	2300      	movs	r3, #0
   44922:	4a08      	ldr	r2, [pc, #32]	; (44944 <ipc_trace_init+0x24>)
   44924:	b510      	push	{r4, lr}
   44926:	8013      	strh	r3, [r2, #0]
   44928:	4a07      	ldr	r2, [pc, #28]	; (44948 <ipc_trace_init+0x28>)
   4492a:	4604      	mov	r4, r0
   4492c:	8013      	strh	r3, [r2, #0]
   4492e:	4a07      	ldr	r2, [pc, #28]	; (4494c <ipc_trace_init+0x2c>)
   44930:	4807      	ldr	r0, [pc, #28]	; (44950 <ipc_trace_init+0x30>)
   44932:	8013      	strh	r3, [r2, #0]
   44934:	2201      	movs	r2, #1
   44936:	4611      	mov	r1, r2
   44938:	f7ff f922 	bl	43b80 <nrf_modem_os_sem_init>
   4493c:	4b05      	ldr	r3, [pc, #20]	; (44954 <ipc_trace_init+0x34>)
   4493e:	601c      	str	r4, [r3, #0]
   44940:	bd10      	pop	{r4, pc}
   44942:	bf00      	nop
   44944:	2001ad38 	.word	0x2001ad38
   44948:	2001ad34 	.word	0x2001ad34
   4494c:	2001ad36 	.word	0x2001ad36
   44950:	2001aab4 	.word	0x2001aab4
   44954:	2001aab0 	.word	0x2001aab0

00044958 <nrf_modem_trace_irq_handler>:
   44958:	b508      	push	{r3, lr}
   4495a:	4b10      	ldr	r3, [pc, #64]	; (4499c <nrf_modem_trace_irq_handler+0x44>)
   4495c:	781b      	ldrb	r3, [r3, #0]
   4495e:	b90b      	cbnz	r3, 44964 <nrf_modem_trace_irq_handler+0xc>
   44960:	f7ff f940 	bl	43be4 <nrf_modem_os_trace_irq_clear>
   44964:	4b0e      	ldr	r3, [pc, #56]	; (449a0 <nrf_modem_trace_irq_handler+0x48>)
   44966:	6818      	ldr	r0, [r3, #0]
   44968:	6842      	ldr	r2, [r0, #4]
   4496a:	6883      	ldr	r3, [r0, #8]
   4496c:	429a      	cmp	r2, r3
   4496e:	d001      	beq.n	44974 <nrf_modem_trace_irq_handler+0x1c>
   44970:	f7ff ff24 	bl	447bc <trace_write>
   44974:	4b0b      	ldr	r3, [pc, #44]	; (449a4 <nrf_modem_trace_irq_handler+0x4c>)
   44976:	6818      	ldr	r0, [r3, #0]
   44978:	6882      	ldr	r2, [r0, #8]
   4497a:	6843      	ldr	r3, [r0, #4]
   4497c:	429a      	cmp	r2, r3
   4497e:	d001      	beq.n	44984 <nrf_modem_trace_irq_handler+0x2c>
   44980:	f7ff ff1c 	bl	447bc <trace_write>
   44984:	4b08      	ldr	r3, [pc, #32]	; (449a8 <nrf_modem_trace_irq_handler+0x50>)
   44986:	6818      	ldr	r0, [r3, #0]
   44988:	6882      	ldr	r2, [r0, #8]
   4498a:	6843      	ldr	r3, [r0, #4]
   4498c:	429a      	cmp	r2, r3
   4498e:	d003      	beq.n	44998 <nrf_modem_trace_irq_handler+0x40>
   44990:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   44994:	f7ff bf12 	b.w	447bc <trace_write>
   44998:	bd08      	pop	{r3, pc}
   4499a:	bf00      	nop
   4499c:	2001e96b 	.word	0x2001e96b
   449a0:	2001aaac 	.word	0x2001aaac
   449a4:	2001aaa4 	.word	0x2001aaa4
   449a8:	2001aaa8 	.word	0x2001aaa8

000449ac <ipc_trace_handle>:
   449ac:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   449b0:	4b43      	ldr	r3, [pc, #268]	; (44ac0 <ipc_trace_handle+0x114>)
   449b2:	681b      	ldr	r3, [r3, #0]
   449b4:	6919      	ldr	r1, [r3, #16]
   449b6:	f8d3 a014 	ldr.w	sl, [r3, #20]
   449ba:	7c1a      	ldrb	r2, [r3, #16]
   449bc:	2200      	movs	r2, #0
   449be:	741a      	strb	r2, [r3, #16]
   449c0:	7c58      	ldrb	r0, [r3, #17]
   449c2:	745a      	strb	r2, [r3, #17]
   449c4:	7c98      	ldrb	r0, [r3, #18]
   449c6:	749a      	strb	r2, [r3, #18]
   449c8:	7cd8      	ldrb	r0, [r3, #19]
   449ca:	74da      	strb	r2, [r3, #19]
   449cc:	7d18      	ldrb	r0, [r3, #20]
   449ce:	751a      	strb	r2, [r3, #20]
   449d0:	7d58      	ldrb	r0, [r3, #21]
   449d2:	755a      	strb	r2, [r3, #21]
   449d4:	7d98      	ldrb	r0, [r3, #22]
   449d6:	759a      	strb	r2, [r3, #22]
   449d8:	7dd8      	ldrb	r0, [r3, #23]
   449da:	75da      	strb	r2, [r3, #23]
   449dc:	2900      	cmp	r1, #0
   449de:	d033      	beq.n	44a48 <ipc_trace_handle+0x9c>
   449e0:	3901      	subs	r1, #1
   449e2:	2903      	cmp	r1, #3
   449e4:	d830      	bhi.n	44a48 <ipc_trace_handle+0x9c>
   449e6:	e8df f001 	tbb	[pc, r1]
   449ea:	6502      	.short	0x6502
   449ec:	534c      	.short	0x534c
   449ee:	4a35      	ldr	r2, [pc, #212]	; (44ac4 <ipc_trace_handle+0x118>)
   449f0:	7811      	ldrb	r1, [r2, #0]
   449f2:	b109      	cbz	r1, 449f8 <ipc_trace_handle+0x4c>
   449f4:	2100      	movs	r1, #0
   449f6:	7011      	strb	r1, [r2, #0]
   449f8:	2200      	movs	r2, #0
   449fa:	4691      	mov	r9, r2
   449fc:	4617      	mov	r7, r2
   449fe:	4614      	mov	r4, r2
   44a00:	4d31      	ldr	r5, [pc, #196]	; (44ac8 <ipc_trace_handle+0x11c>)
   44a02:	4932      	ldr	r1, [pc, #200]	; (44acc <ipc_trace_handle+0x120>)
   44a04:	4832      	ldr	r0, [pc, #200]	; (44ad0 <ipc_trace_handle+0x124>)
   44a06:	f8d5 e000 	ldr.w	lr, [r5]
   44a0a:	f8d1 8000 	ldr.w	r8, [r1]
   44a0e:	6806      	ldr	r6, [r0, #0]
   44a10:	f8da b008 	ldr.w	fp, [sl, #8]
   44a14:	9501      	str	r5, [sp, #4]
   44a16:	45a3      	cmp	fp, r4
   44a18:	d119      	bne.n	44a4e <ipc_trace_handle+0xa2>
   44a1a:	b107      	cbz	r7, 44a1e <ipc_trace_handle+0x72>
   44a1c:	6006      	str	r6, [r0, #0]
   44a1e:	f1b9 0f00 	cmp.w	r9, #0
   44a22:	d001      	beq.n	44a28 <ipc_trace_handle+0x7c>
   44a24:	f8c1 8000 	str.w	r8, [r1]
   44a28:	b112      	cbz	r2, 44a30 <ipc_trace_handle+0x84>
   44a2a:	9a01      	ldr	r2, [sp, #4]
   44a2c:	f8c2 e000 	str.w	lr, [r2]
   44a30:	7a1a      	ldrb	r2, [r3, #8]
   44a32:	2101      	movs	r1, #1
   44a34:	2200      	movs	r2, #0
   44a36:	7219      	strb	r1, [r3, #8]
   44a38:	7a59      	ldrb	r1, [r3, #9]
   44a3a:	725a      	strb	r2, [r3, #9]
   44a3c:	7a99      	ldrb	r1, [r3, #10]
   44a3e:	729a      	strb	r2, [r3, #10]
   44a40:	7ada      	ldrb	r2, [r3, #11]
   44a42:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   44a46:	72da      	strb	r2, [r3, #11]
   44a48:	b003      	add	sp, #12
   44a4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44a4e:	1ca5      	adds	r5, r4, #2
   44a50:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   44a54:	686d      	ldr	r5, [r5, #4]
   44a56:	f895 c000 	ldrb.w	ip, [r5]
   44a5a:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   44a5e:	d009      	beq.n	44a74 <ipc_trace_handle+0xc8>
   44a60:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   44a64:	d00a      	beq.n	44a7c <ipc_trace_handle+0xd0>
   44a66:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   44a6a:	bf04      	itt	eq
   44a6c:	462e      	moveq	r6, r5
   44a6e:	2701      	moveq	r7, #1
   44a70:	3401      	adds	r4, #1
   44a72:	e7d0      	b.n	44a16 <ipc_trace_handle+0x6a>
   44a74:	46a8      	mov	r8, r5
   44a76:	f04f 0901 	mov.w	r9, #1
   44a7a:	e7f9      	b.n	44a70 <ipc_trace_handle+0xc4>
   44a7c:	46ae      	mov	lr, r5
   44a7e:	2201      	movs	r2, #1
   44a80:	e7f6      	b.n	44a70 <ipc_trace_handle+0xc4>
   44a82:	2101      	movs	r1, #1
   44a84:	4a0f      	ldr	r2, [pc, #60]	; (44ac4 <ipc_trace_handle+0x118>)
   44a86:	7011      	strb	r1, [r2, #0]
   44a88:	7a1a      	ldrb	r2, [r3, #8]
   44a8a:	2103      	movs	r1, #3
   44a8c:	2200      	movs	r2, #0
   44a8e:	e7d2      	b.n	44a36 <ipc_trace_handle+0x8a>
   44a90:	7a19      	ldrb	r1, [r3, #8]
   44a92:	2104      	movs	r1, #4
   44a94:	7219      	strb	r1, [r3, #8]
   44a96:	7a59      	ldrb	r1, [r3, #9]
   44a98:	725a      	strb	r2, [r3, #9]
   44a9a:	7a99      	ldrb	r1, [r3, #10]
   44a9c:	729a      	strb	r2, [r3, #10]
   44a9e:	7ad9      	ldrb	r1, [r3, #11]
   44aa0:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   44aa4:	72d9      	strb	r1, [r3, #11]
   44aa6:	4b07      	ldr	r3, [pc, #28]	; (44ac4 <ipc_trace_handle+0x118>)
   44aa8:	701a      	strb	r2, [r3, #0]
   44aaa:	b003      	add	sp, #12
   44aac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44ab0:	f7ff bf52 	b.w	44958 <nrf_modem_trace_irq_handler>
   44ab4:	b003      	add	sp, #12
   44ab6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44aba:	f7ff b88b 	b.w	43bd4 <nrf_modem_os_trace_irq_set>
   44abe:	bf00      	nop
   44ac0:	2001aab0 	.word	0x2001aab0
   44ac4:	2001e96b 	.word	0x2001e96b
   44ac8:	2001aaa8 	.word	0x2001aaa8
   44acc:	2001aaa4 	.word	0x2001aaa4
   44ad0:	2001aaac 	.word	0x2001aaac

00044ad4 <rpc_trace_coredump_in_progress>:
   44ad4:	4b01      	ldr	r3, [pc, #4]	; (44adc <rpc_trace_coredump_in_progress+0x8>)
   44ad6:	7818      	ldrb	r0, [r3, #0]
   44ad8:	4770      	bx	lr
   44ada:	bf00      	nop
   44adc:	2001e96b 	.word	0x2001e96b

00044ae0 <handle_modem_rpc_msg>:
   44ae0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44ae4:	4606      	mov	r6, r0
   44ae6:	460f      	mov	r7, r1
   44ae8:	2500      	movs	r5, #0
   44aea:	f8df 8074 	ldr.w	r8, [pc, #116]	; 44b60 <handle_modem_rpc_msg+0x80>
   44aee:	6833      	ldr	r3, [r6, #0]
   44af0:	42ab      	cmp	r3, r5
   44af2:	d801      	bhi.n	44af8 <handle_modem_rpc_msg+0x18>
   44af4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44af8:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   44afc:	68a3      	ldr	r3, [r4, #8]
   44afe:	b1fb      	cbz	r3, 44b40 <handle_modem_rpc_msg+0x60>
   44b00:	6863      	ldr	r3, [r4, #4]
   44b02:	b2db      	uxtb	r3, r3
   44b04:	2b01      	cmp	r3, #1
   44b06:	d11b      	bne.n	44b40 <handle_modem_rpc_msg+0x60>
   44b08:	6862      	ldr	r2, [r4, #4]
   44b0a:	f8b8 3000 	ldrh.w	r3, [r8]
   44b0e:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   44b12:	d115      	bne.n	44b40 <handle_modem_rpc_msg+0x60>
   44b14:	2f02      	cmp	r7, #2
   44b16:	68a0      	ldr	r0, [r4, #8]
   44b18:	d114      	bne.n	44b44 <handle_modem_rpc_msg+0x64>
   44b1a:	f7ff fe2d 	bl	44778 <rpc_handle_data_message>
   44b1e:	2802      	cmp	r0, #2
   44b20:	d00e      	beq.n	44b40 <handle_modem_rpc_msg+0x60>
   44b22:	2801      	cmp	r0, #1
   44b24:	d113      	bne.n	44b4e <handle_modem_rpc_msg+0x6e>
   44b26:	6863      	ldr	r3, [r4, #4]
   44b28:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44b2c:	f043 0302 	orr.w	r3, r3, #2
   44b30:	6063      	str	r3, [r4, #4]
   44b32:	f8b8 3000 	ldrh.w	r3, [r8]
   44b36:	3301      	adds	r3, #1
   44b38:	f8a8 3000 	strh.w	r3, [r8]
   44b3c:	f7ff f83a 	bl	43bb4 <nrf_modem_os_application_irq_set>
   44b40:	3501      	adds	r5, #1
   44b42:	e7d4      	b.n	44aee <handle_modem_rpc_msg+0xe>
   44b44:	6801      	ldr	r1, [r0, #0]
   44b46:	0c09      	lsrs	r1, r1, #16
   44b48:	f003 fc06 	bl	48358 <rpc_handle_ctrl_message>
   44b4c:	e7e7      	b.n	44b1e <handle_modem_rpc_msg+0x3e>
   44b4e:	2800      	cmp	r0, #0
   44b50:	d1ef      	bne.n	44b32 <handle_modem_rpc_msg+0x52>
   44b52:	6863      	ldr	r3, [r4, #4]
   44b54:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44b58:	f043 0303 	orr.w	r3, r3, #3
   44b5c:	e7e8      	b.n	44b30 <handle_modem_rpc_msg+0x50>
   44b5e:	bf00      	nop
   44b60:	2001ad3a 	.word	0x2001ad3a

00044b64 <rpc_transport_ipc_msg_alloc>:
   44b64:	b570      	push	{r4, r5, r6, lr}
   44b66:	4616      	mov	r6, r2
   44b68:	2400      	movs	r4, #0
   44b6a:	6803      	ldr	r3, [r0, #0]
   44b6c:	42a3      	cmp	r3, r4
   44b6e:	d101      	bne.n	44b74 <rpc_transport_ipc_msg_alloc+0x10>
   44b70:	2300      	movs	r3, #0
   44b72:	e01c      	b.n	44bae <rpc_transport_ipc_msg_alloc+0x4a>
   44b74:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   44b78:	6855      	ldr	r5, [r2, #4]
   44b7a:	b2ed      	uxtb	r5, r5
   44b7c:	2d03      	cmp	r5, #3
   44b7e:	d118      	bne.n	44bb2 <rpc_transport_ipc_msg_alloc+0x4e>
   44b80:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   44b84:	6093      	str	r3, [r2, #8]
   44b86:	6851      	ldr	r1, [r2, #4]
   44b88:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   44b8c:	6051      	str	r1, [r2, #4]
   44b8e:	490c      	ldr	r1, [pc, #48]	; (44bc0 <rpc_transport_ipc_msg_alloc+0x5c>)
   44b90:	8808      	ldrh	r0, [r1, #0]
   44b92:	1c44      	adds	r4, r0, #1
   44b94:	800c      	strh	r4, [r1, #0]
   44b96:	6851      	ldr	r1, [r2, #4]
   44b98:	b289      	uxth	r1, r1
   44b9a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   44b9e:	6051      	str	r1, [r2, #4]
   44ba0:	4618      	mov	r0, r3
   44ba2:	2240      	movs	r2, #64	; 0x40
   44ba4:	2100      	movs	r1, #0
   44ba6:	f003 fa2a 	bl	47ffe <memset>
   44baa:	4603      	mov	r3, r0
   44bac:	6046      	str	r6, [r0, #4]
   44bae:	4618      	mov	r0, r3
   44bb0:	bd70      	pop	{r4, r5, r6, pc}
   44bb2:	b915      	cbnz	r5, 44bba <rpc_transport_ipc_msg_alloc+0x56>
   44bb4:	6895      	ldr	r5, [r2, #8]
   44bb6:	2d00      	cmp	r5, #0
   44bb8:	d0e2      	beq.n	44b80 <rpc_transport_ipc_msg_alloc+0x1c>
   44bba:	3401      	adds	r4, #1
   44bbc:	e7d6      	b.n	44b6c <rpc_transport_ipc_msg_alloc+0x8>
   44bbe:	bf00      	nop
   44bc0:	2001ad3c 	.word	0x2001ad3c

00044bc4 <rpc_transport_ipc_data_msg_send>:
   44bc4:	b508      	push	{r3, lr}
   44bc6:	4b0b      	ldr	r3, [pc, #44]	; (44bf4 <rpc_transport_ipc_data_msg_send+0x30>)
   44bc8:	681b      	ldr	r3, [r3, #0]
   44bca:	1ac0      	subs	r0, r0, r3
   44bcc:	4b0a      	ldr	r3, [pc, #40]	; (44bf8 <rpc_transport_ipc_data_msg_send+0x34>)
   44bce:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44bd2:	681b      	ldr	r3, [r3, #0]
   44bd4:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44bd8:	6843      	ldr	r3, [r0, #4]
   44bda:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44bde:	f043 0301 	orr.w	r3, r3, #1
   44be2:	6043      	str	r3, [r0, #4]
   44be4:	2003      	movs	r0, #3
   44be6:	f003 fb79 	bl	482dc <nrf_modem_os_busywait>
   44bea:	2201      	movs	r2, #1
   44bec:	4b03      	ldr	r3, [pc, #12]	; (44bfc <rpc_transport_ipc_data_msg_send+0x38>)
   44bee:	601a      	str	r2, [r3, #0]
   44bf0:	bd08      	pop	{r3, pc}
   44bf2:	bf00      	nop
   44bf4:	2001aad0 	.word	0x2001aad0
   44bf8:	2001aad4 	.word	0x2001aad4
   44bfc:	4002a00c 	.word	0x4002a00c

00044c00 <rpc_transport_ipc_ctrl_msg_send>:
   44c00:	b508      	push	{r3, lr}
   44c02:	4b0b      	ldr	r3, [pc, #44]	; (44c30 <rpc_transport_ipc_ctrl_msg_send+0x30>)
   44c04:	681b      	ldr	r3, [r3, #0]
   44c06:	1ac0      	subs	r0, r0, r3
   44c08:	4b0a      	ldr	r3, [pc, #40]	; (44c34 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   44c0a:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44c0e:	681b      	ldr	r3, [r3, #0]
   44c10:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44c14:	6843      	ldr	r3, [r0, #4]
   44c16:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44c1a:	f043 0301 	orr.w	r3, r3, #1
   44c1e:	6043      	str	r3, [r0, #4]
   44c20:	2003      	movs	r0, #3
   44c22:	f003 fb5b 	bl	482dc <nrf_modem_os_busywait>
   44c26:	2201      	movs	r2, #1
   44c28:	4b03      	ldr	r3, [pc, #12]	; (44c38 <rpc_transport_ipc_ctrl_msg_send+0x38>)
   44c2a:	601a      	str	r2, [r3, #0]
   44c2c:	bd08      	pop	{r3, pc}
   44c2e:	bf00      	nop
   44c30:	2001aac8 	.word	0x2001aac8
   44c34:	2001aacc 	.word	0x2001aacc
   44c38:	4002a004 	.word	0x4002a004

00044c3c <rpc_transport_ipc_data_msg_alloc>:
   44c3c:	4b05      	ldr	r3, [pc, #20]	; (44c54 <rpc_transport_ipc_data_msg_alloc+0x18>)
   44c3e:	781b      	ldrb	r3, [r3, #0]
   44c40:	b933      	cbnz	r3, 44c50 <rpc_transport_ipc_data_msg_alloc+0x14>
   44c42:	4b05      	ldr	r3, [pc, #20]	; (44c58 <rpc_transport_ipc_data_msg_alloc+0x1c>)
   44c44:	2202      	movs	r2, #2
   44c46:	6819      	ldr	r1, [r3, #0]
   44c48:	4b04      	ldr	r3, [pc, #16]	; (44c5c <rpc_transport_ipc_data_msg_alloc+0x20>)
   44c4a:	6818      	ldr	r0, [r3, #0]
   44c4c:	f7ff bf8a 	b.w	44b64 <rpc_transport_ipc_msg_alloc>
   44c50:	2000      	movs	r0, #0
   44c52:	4770      	bx	lr
   44c54:	2001e96d 	.word	0x2001e96d
   44c58:	2001aad0 	.word	0x2001aad0
   44c5c:	2001aad4 	.word	0x2001aad4

00044c60 <rpc_transport_ipc_ctrl_msg_alloc>:
   44c60:	230a      	movs	r3, #10
   44c62:	b537      	push	{r0, r1, r2, r4, r5, lr}
   44c64:	4c0c      	ldr	r4, [pc, #48]	; (44c98 <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   44c66:	4d0d      	ldr	r5, [pc, #52]	; (44c9c <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   44c68:	9301      	str	r3, [sp, #4]
   44c6a:	2201      	movs	r2, #1
   44c6c:	6821      	ldr	r1, [r4, #0]
   44c6e:	6828      	ldr	r0, [r5, #0]
   44c70:	f7ff ff78 	bl	44b64 <rpc_transport_ipc_msg_alloc>
   44c74:	b968      	cbnz	r0, 44c92 <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   44c76:	f003 fb33 	bl	482e0 <nrf_modem_os_is_in_isr>
   44c7a:	b918      	cbnz	r0, 44c84 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   44c7c:	a901      	add	r1, sp, #4
   44c7e:	f7fe fee1 	bl	43a44 <nrf_modem_os_timedwait>
   44c82:	e7f2      	b.n	44c6a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44c84:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   44c88:	9b01      	ldr	r3, [sp, #4]
   44c8a:	4358      	muls	r0, r3
   44c8c:	f003 fb26 	bl	482dc <nrf_modem_os_busywait>
   44c90:	e7eb      	b.n	44c6a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44c92:	b003      	add	sp, #12
   44c94:	bd30      	pop	{r4, r5, pc}
   44c96:	bf00      	nop
   44c98:	2001aac8 	.word	0x2001aac8
   44c9c:	2001aacc 	.word	0x2001aacc

00044ca0 <rpc_transport_ipc_data_alloc>:
   44ca0:	4b03      	ldr	r3, [pc, #12]	; (44cb0 <rpc_transport_ipc_data_alloc+0x10>)
   44ca2:	781b      	ldrb	r3, [r3, #0]
   44ca4:	b90b      	cbnz	r3, 44caa <rpc_transport_ipc_data_alloc+0xa>
   44ca6:	f7fe bfb3 	b.w	43c10 <nrf_modem_os_shm_tx_alloc>
   44caa:	2000      	movs	r0, #0
   44cac:	4770      	bx	lr
   44cae:	bf00      	nop
   44cb0:	2001e96d 	.word	0x2001e96d

00044cb4 <nrf_modem_application_irq_handler>:
   44cb4:	b510      	push	{r4, lr}
   44cb6:	4c06      	ldr	r4, [pc, #24]	; (44cd0 <nrf_modem_application_irq_handler+0x1c>)
   44cb8:	f7fe ff84 	bl	43bc4 <nrf_modem_os_application_irq_clear>
   44cbc:	6820      	ldr	r0, [r4, #0]
   44cbe:	2101      	movs	r1, #1
   44cc0:	f7ff ff0e 	bl	44ae0 <handle_modem_rpc_msg>
   44cc4:	6860      	ldr	r0, [r4, #4]
   44cc6:	2102      	movs	r1, #2
   44cc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   44ccc:	f7ff bf08 	b.w	44ae0 <handle_modem_rpc_msg>
   44cd0:	2001aabc 	.word	0x2001aabc

00044cd4 <rpc_transport_ipc_msg_free>:
   44cd4:	2300      	movs	r3, #0
   44cd6:	4911      	ldr	r1, [pc, #68]	; (44d1c <rpc_transport_ipc_msg_free+0x48>)
   44cd8:	b530      	push	{r4, r5, lr}
   44cda:	680a      	ldr	r2, [r1, #0]
   44cdc:	6814      	ldr	r4, [r2, #0]
   44cde:	42a3      	cmp	r3, r4
   44ce0:	d10b      	bne.n	44cfa <rpc_transport_ipc_msg_free+0x26>
   44ce2:	2300      	movs	r3, #0
   44ce4:	684a      	ldr	r2, [r1, #4]
   44ce6:	6811      	ldr	r1, [r2, #0]
   44ce8:	428b      	cmp	r3, r1
   44cea:	d015      	beq.n	44d18 <rpc_transport_ipc_msg_free+0x44>
   44cec:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   44cf0:	68a4      	ldr	r4, [r4, #8]
   44cf2:	42a0      	cmp	r0, r4
   44cf4:	d008      	beq.n	44d08 <rpc_transport_ipc_msg_free+0x34>
   44cf6:	3301      	adds	r3, #1
   44cf8:	e7f6      	b.n	44ce8 <rpc_transport_ipc_msg_free+0x14>
   44cfa:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   44cfe:	68ad      	ldr	r5, [r5, #8]
   44d00:	42a8      	cmp	r0, r5
   44d02:	d001      	beq.n	44d08 <rpc_transport_ipc_msg_free+0x34>
   44d04:	3301      	adds	r3, #1
   44d06:	e7ea      	b.n	44cde <rpc_transport_ipc_msg_free+0xa>
   44d08:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   44d0c:	685a      	ldr	r2, [r3, #4]
   44d0e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   44d12:	f042 0203 	orr.w	r2, r2, #3
   44d16:	605a      	str	r2, [r3, #4]
   44d18:	bd30      	pop	{r4, r5, pc}
   44d1a:	bf00      	nop
   44d1c:	2001aabc 	.word	0x2001aabc

00044d20 <rpc_transport_ipc_init>:
   44d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44d24:	2200      	movs	r2, #0
   44d26:	b095      	sub	sp, #84	; 0x54
   44d28:	4605      	mov	r5, r0
   44d2a:	494d      	ldr	r1, [pc, #308]	; (44e60 <rpc_transport_ipc_init+0x140>)
   44d2c:	7900      	ldrb	r0, [r0, #4]
   44d2e:	f7ff fc15 	bl	4455c <nrfx_ipc_init>
   44d32:	2238      	movs	r2, #56	; 0x38
   44d34:	2100      	movs	r1, #0
   44d36:	a803      	add	r0, sp, #12
   44d38:	f003 f961 	bl	47ffe <memset>
   44d3c:	2302      	movs	r3, #2
   44d3e:	9304      	str	r3, [sp, #16]
   44d40:	2308      	movs	r3, #8
   44d42:	9306      	str	r3, [sp, #24]
   44d44:	2320      	movs	r3, #32
   44d46:	9308      	str	r3, [sp, #32]
   44d48:	2301      	movs	r3, #1
   44d4a:	930b      	str	r3, [sp, #44]	; 0x2c
   44d4c:	2304      	movs	r3, #4
   44d4e:	930d      	str	r3, [sp, #52]	; 0x34
   44d50:	2310      	movs	r3, #16
   44d52:	f04f 0c40 	mov.w	ip, #64	; 0x40
   44d56:	930f      	str	r3, [sp, #60]	; 0x3c
   44d58:	2380      	movs	r3, #128	; 0x80
   44d5a:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   44d5e:	23d5      	movs	r3, #213	; 0xd5
   44d60:	a803      	add	r0, sp, #12
   44d62:	9313      	str	r3, [sp, #76]	; 0x4c
   44d64:	f7ff fc12 	bl	4458c <nrfx_ipc_config_load>
   44d68:	682b      	ldr	r3, [r5, #0]
   44d6a:	2100      	movs	r1, #0
   44d6c:	685a      	ldr	r2, [r3, #4]
   44d6e:	6818      	ldr	r0, [r3, #0]
   44d70:	f003 f945 	bl	47ffe <memset>
   44d74:	682a      	ldr	r2, [r5, #0]
   44d76:	6814      	ldr	r4, [r2, #0]
   44d78:	69d3      	ldr	r3, [r2, #28]
   44d7a:	f104 0660 	add.w	r6, r4, #96	; 0x60
   44d7e:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   44d82:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   44d86:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   44d8a:	f104 0920 	add.w	r9, r4, #32
   44d8e:	2b00      	cmp	r3, #0
   44d90:	d060      	beq.n	44e54 <rpc_transport_ipc_init+0x134>
   44d92:	f104 0840 	add.w	r8, r4, #64	; 0x40
   44d96:	4933      	ldr	r1, [pc, #204]	; (44e64 <rpc_transport_ipc_init+0x144>)
   44d98:	f8c1 9000 	str.w	r9, [r1]
   44d9c:	b13b      	cbz	r3, 44dae <rpc_transport_ipc_init+0x8e>
   44d9e:	6992      	ldr	r2, [r2, #24]
   44da0:	4640      	mov	r0, r8
   44da2:	f8c8 2004 	str.w	r2, [r8, #4]
   44da6:	f8c8 3000 	str.w	r3, [r8]
   44daa:	f7ff fdb9 	bl	44920 <ipc_trace_init>
   44dae:	6828      	ldr	r0, [r5, #0]
   44db0:	2300      	movs	r3, #0
   44db2:	6902      	ldr	r2, [r0, #16]
   44db4:	2101      	movs	r1, #1
   44db6:	6062      	str	r2, [r4, #4]
   44db8:	6942      	ldr	r2, [r0, #20]
   44dba:	70a1      	strb	r1, [r4, #2]
   44dbc:	60a2      	str	r2, [r4, #8]
   44dbe:	4a2a      	ldr	r2, [pc, #168]	; (44e68 <rpc_transport_ipc_init+0x148>)
   44dc0:	7023      	strb	r3, [r4, #0]
   44dc2:	6017      	str	r7, [r2, #0]
   44dc4:	4a29      	ldr	r2, [pc, #164]	; (44e6c <rpc_transport_ipc_init+0x14c>)
   44dc6:	7063      	strb	r3, [r4, #1]
   44dc8:	6016      	str	r6, [r2, #0]
   44dca:	2208      	movs	r2, #8
   44dcc:	70e3      	strb	r3, [r4, #3]
   44dce:	60e6      	str	r6, [r4, #12]
   44dd0:	6127      	str	r7, [r4, #16]
   44dd2:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   44dd6:	f8c4 9014 	str.w	r9, [r4, #20]
   44dda:	f8c4 8018 	str.w	r8, [r4, #24]
   44dde:	707b      	strb	r3, [r7, #1]
   44de0:	70bb      	strb	r3, [r7, #2]
   44de2:	70fb      	strb	r3, [r7, #3]
   44de4:	2714      	movs	r7, #20
   44de6:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   44dea:	4a21      	ldr	r2, [pc, #132]	; (44e70 <rpc_transport_ipc_init+0x150>)
   44dec:	4d21      	ldr	r5, [pc, #132]	; (44e74 <rpc_transport_ipc_init+0x154>)
   44dee:	f8c2 b000 	str.w	fp, [r2]
   44df2:	4a21      	ldr	r2, [pc, #132]	; (44e78 <rpc_transport_ipc_init+0x158>)
   44df4:	7073      	strb	r3, [r6, #1]
   44df6:	f8c2 a000 	str.w	sl, [r2]
   44dfa:	4a20      	ldr	r2, [pc, #128]	; (44e7c <rpc_transport_ipc_init+0x15c>)
   44dfc:	70b3      	strb	r3, [r6, #2]
   44dfe:	70f3      	strb	r3, [r6, #3]
   44e00:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   44e04:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   44e08:	4c1d      	ldr	r4, [pc, #116]	; (44e80 <rpc_transport_ipc_init+0x160>)
   44e0a:	7029      	strb	r1, [r5, #0]
   44e0c:	491d      	ldr	r1, [pc, #116]	; (44e84 <rpc_transport_ipc_init+0x164>)
   44e0e:	6023      	str	r3, [r4, #0]
   44e10:	9302      	str	r3, [sp, #8]
   44e12:	600b      	str	r3, [r1, #0]
   44e14:	680b      	ldr	r3, [r1, #0]
   44e16:	4e1c      	ldr	r6, [pc, #112]	; (44e88 <rpc_transport_ipc_init+0x168>)
   44e18:	9302      	str	r3, [sp, #8]
   44e1a:	9b02      	ldr	r3, [sp, #8]
   44e1c:	2000      	movs	r0, #0
   44e1e:	a901      	add	r1, sp, #4
   44e20:	9701      	str	r7, [sp, #4]
   44e22:	f7fe fe0f 	bl	43a44 <nrf_modem_os_timedwait>
   44e26:	9b01      	ldr	r3, [sp, #4]
   44e28:	3b14      	subs	r3, #20
   44e2a:	441e      	add	r6, r3
   44e2c:	782b      	ldrb	r3, [r5, #0]
   44e2e:	2b01      	cmp	r3, #1
   44e30:	d104      	bne.n	44e3c <rpc_transport_ipc_init+0x11c>
   44e32:	2e00      	cmp	r6, #0
   44e34:	d1f2      	bne.n	44e1c <rpc_transport_ipc_init+0xfc>
   44e36:	f06f 0373 	mvn.w	r3, #115	; 0x73
   44e3a:	6023      	str	r3, [r4, #0]
   44e3c:	6824      	ldr	r4, [r4, #0]
   44e3e:	b95c      	cbnz	r4, 44e58 <rpc_transport_ipc_init+0x138>
   44e40:	4b12      	ldr	r3, [pc, #72]	; (44e8c <rpc_transport_ipc_init+0x16c>)
   44e42:	701c      	strb	r4, [r3, #0]
   44e44:	4b12      	ldr	r3, [pc, #72]	; (44e90 <rpc_transport_ipc_init+0x170>)
   44e46:	801c      	strh	r4, [r3, #0]
   44e48:	4b12      	ldr	r3, [pc, #72]	; (44e94 <rpc_transport_ipc_init+0x174>)
   44e4a:	801c      	strh	r4, [r3, #0]
   44e4c:	4620      	mov	r0, r4
   44e4e:	b015      	add	sp, #84	; 0x54
   44e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44e54:	4698      	mov	r8, r3
   44e56:	e79e      	b.n	44d96 <rpc_transport_ipc_init+0x76>
   44e58:	f7ff fbb8 	bl	445cc <nrfx_ipc_uninit>
   44e5c:	e7f6      	b.n	44e4c <rpc_transport_ipc_init+0x12c>
   44e5e:	bf00      	nop
   44e60:	00044e99 	.word	0x00044e99
   44e64:	2001aac4 	.word	0x2001aac4
   44e68:	2001aad4 	.word	0x2001aad4
   44e6c:	2001aacc 	.word	0x2001aacc
   44e70:	2001aad0 	.word	0x2001aad0
   44e74:	2001e96c 	.word	0x2001e96c
   44e78:	2001aac8 	.word	0x2001aac8
   44e7c:	4002a000 	.word	0x4002a000
   44e80:	2001aab8 	.word	0x2001aab8
   44e84:	40005610 	.word	0x40005610
   44e88:	000249f0 	.word	0x000249f0
   44e8c:	2001e96d 	.word	0x2001e96d
   44e90:	2001ad3c 	.word	0x2001ad3c
   44e94:	2001ad3a 	.word	0x2001ad3a

00044e98 <ipc_irq_handler>:
   44e98:	b570      	push	{r4, r5, r6, lr}
   44e9a:	4604      	mov	r4, r0
   44e9c:	0620      	lsls	r0, r4, #24
   44e9e:	d50c      	bpl.n	44eba <ipc_irq_handler+0x22>
   44ea0:	f7ff fd84 	bl	449ac <ipc_trace_handle>
   44ea4:	f7ff fe16 	bl	44ad4 <rpc_trace_coredump_in_progress>
   44ea8:	b138      	cbz	r0, 44eba <ipc_irq_handler+0x22>
   44eaa:	22e0      	movs	r2, #224	; 0xe0
   44eac:	4b3e      	ldr	r3, [pc, #248]	; (44fa8 <ipc_irq_handler+0x110>)
   44eae:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   44eb2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   44eb6:	605a      	str	r2, [r3, #4]
   44eb8:	bd70      	pop	{r4, r5, r6, pc}
   44eba:	07e1      	lsls	r1, r4, #31
   44ebc:	d548      	bpl.n	44f50 <ipc_irq_handler+0xb8>
   44ebe:	f248 0202 	movw	r2, #32770	; 0x8002
   44ec2:	4b3a      	ldr	r3, [pc, #232]	; (44fac <ipc_irq_handler+0x114>)
   44ec4:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   44ec8:	4293      	cmp	r3, r2
   44eca:	d035      	beq.n	44f38 <ipc_irq_handler+0xa0>
   44ecc:	d81b      	bhi.n	44f06 <ipc_irq_handler+0x6e>
   44ece:	f243 0232 	movw	r2, #12338	; 0x3032
   44ed2:	4293      	cmp	r3, r2
   44ed4:	d036      	beq.n	44f44 <ipc_irq_handler+0xac>
   44ed6:	d80b      	bhi.n	44ef0 <ipc_irq_handler+0x58>
   44ed8:	3b01      	subs	r3, #1
   44eda:	2b01      	cmp	r3, #1
   44edc:	d8ec      	bhi.n	44eb8 <ipc_irq_handler+0x20>
   44ede:	2203      	movs	r2, #3
   44ee0:	200e      	movs	r0, #14
   44ee2:	4b33      	ldr	r3, [pc, #204]	; (44fb0 <ipc_irq_handler+0x118>)
   44ee4:	701a      	strb	r2, [r3, #0]
   44ee6:	4b33      	ldr	r3, [pc, #204]	; (44fb4 <ipc_irq_handler+0x11c>)
   44ee8:	6018      	str	r0, [r3, #0]
   44eea:	f003 fb03 	bl	484f4 <rpc_transport_ipc_fault_handler>
   44eee:	e7e3      	b.n	44eb8 <ipc_irq_handler+0x20>
   44ef0:	f248 0201 	movw	r2, #32769	; 0x8001
   44ef4:	4293      	cmp	r3, r2
   44ef6:	d1df      	bne.n	44eb8 <ipc_irq_handler+0x20>
   44ef8:	2203      	movs	r2, #3
   44efa:	4b2d      	ldr	r3, [pc, #180]	; (44fb0 <ipc_irq_handler+0x118>)
   44efc:	701a      	strb	r2, [r3, #0]
   44efe:	2216      	movs	r2, #22
   44f00:	4b2c      	ldr	r3, [pc, #176]	; (44fb4 <ipc_irq_handler+0x11c>)
   44f02:	601a      	str	r2, [r3, #0]
   44f04:	e7d8      	b.n	44eb8 <ipc_irq_handler+0x20>
   44f06:	4a2c      	ldr	r2, [pc, #176]	; (44fb8 <ipc_irq_handler+0x120>)
   44f08:	4293      	cmp	r3, r2
   44f0a:	d80c      	bhi.n	44f26 <ipc_irq_handler+0x8e>
   44f0c:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   44f10:	d80c      	bhi.n	44f2c <ipc_irq_handler+0x94>
   44f12:	f248 0203 	movw	r2, #32771	; 0x8003
   44f16:	4293      	cmp	r3, r2
   44f18:	d1ce      	bne.n	44eb8 <ipc_irq_handler+0x20>
   44f1a:	2203      	movs	r2, #3
   44f1c:	4b24      	ldr	r3, [pc, #144]	; (44fb0 <ipc_irq_handler+0x118>)
   44f1e:	701a      	strb	r2, [r3, #0]
   44f20:	220c      	movs	r2, #12
   44f22:	4b24      	ldr	r3, [pc, #144]	; (44fb4 <ipc_irq_handler+0x11c>)
   44f24:	e7ed      	b.n	44f02 <ipc_irq_handler+0x6a>
   44f26:	4a25      	ldr	r2, [pc, #148]	; (44fbc <ipc_irq_handler+0x124>)
   44f28:	4293      	cmp	r3, r2
   44f2a:	d1c5      	bne.n	44eb8 <ipc_irq_handler+0x20>
   44f2c:	2103      	movs	r1, #3
   44f2e:	4a20      	ldr	r2, [pc, #128]	; (44fb0 <ipc_irq_handler+0x118>)
   44f30:	7011      	strb	r1, [r2, #0]
   44f32:	4a20      	ldr	r2, [pc, #128]	; (44fb4 <ipc_irq_handler+0x11c>)
   44f34:	6013      	str	r3, [r2, #0]
   44f36:	e7bf      	b.n	44eb8 <ipc_irq_handler+0x20>
   44f38:	2203      	movs	r2, #3
   44f3a:	4b1d      	ldr	r3, [pc, #116]	; (44fb0 <ipc_irq_handler+0x118>)
   44f3c:	701a      	strb	r2, [r3, #0]
   44f3e:	225f      	movs	r2, #95	; 0x5f
   44f40:	4b1c      	ldr	r3, [pc, #112]	; (44fb4 <ipc_irq_handler+0x11c>)
   44f42:	e7de      	b.n	44f02 <ipc_irq_handler+0x6a>
   44f44:	2203      	movs	r2, #3
   44f46:	4b1a      	ldr	r3, [pc, #104]	; (44fb0 <ipc_irq_handler+0x118>)
   44f48:	701a      	strb	r2, [r3, #0]
   44f4a:	2205      	movs	r2, #5
   44f4c:	4b19      	ldr	r3, [pc, #100]	; (44fb4 <ipc_irq_handler+0x11c>)
   44f4e:	e7d8      	b.n	44f02 <ipc_irq_handler+0x6a>
   44f50:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   44f54:	d003      	beq.n	44f5e <ipc_irq_handler+0xc6>
   44f56:	2202      	movs	r2, #2
   44f58:	4b15      	ldr	r3, [pc, #84]	; (44fb0 <ipc_irq_handler+0x118>)
   44f5a:	701a      	strb	r2, [r3, #0]
   44f5c:	e7ac      	b.n	44eb8 <ipc_irq_handler+0x20>
   44f5e:	0762      	lsls	r2, r4, #29
   44f60:	d505      	bpl.n	44f6e <ipc_irq_handler+0xd6>
   44f62:	4b13      	ldr	r3, [pc, #76]	; (44fb0 <ipc_irq_handler+0x118>)
   44f64:	781a      	ldrb	r2, [r3, #0]
   44f66:	461e      	mov	r6, r3
   44f68:	b93a      	cbnz	r2, 44f7a <ipc_irq_handler+0xe2>
   44f6a:	f7fe fe23 	bl	43bb4 <nrf_modem_os_application_irq_set>
   44f6e:	06e3      	lsls	r3, r4, #27
   44f70:	d5a2      	bpl.n	44eb8 <ipc_irq_handler+0x20>
   44f72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   44f76:	f7fe be1d 	b.w	43bb4 <nrf_modem_os_application_irq_set>
   44f7a:	2a01      	cmp	r2, #1
   44f7c:	d1f7      	bne.n	44f6e <ipc_irq_handler+0xd6>
   44f7e:	4a10      	ldr	r2, [pc, #64]	; (44fc0 <ipc_irq_handler+0x128>)
   44f80:	4810      	ldr	r0, [pc, #64]	; (44fc4 <ipc_irq_handler+0x12c>)
   44f82:	6812      	ldr	r2, [r2, #0]
   44f84:	6891      	ldr	r1, [r2, #8]
   44f86:	6041      	str	r1, [r0, #4]
   44f88:	6852      	ldr	r2, [r2, #4]
   44f8a:	6002      	str	r2, [r0, #0]
   44f8c:	b121      	cbz	r1, 44f98 <ipc_irq_handler+0x100>
   44f8e:	b11a      	cbz	r2, 44f98 <ipc_irq_handler+0x100>
   44f90:	6809      	ldr	r1, [r1, #0]
   44f92:	b109      	cbz	r1, 44f98 <ipc_irq_handler+0x100>
   44f94:	6812      	ldr	r2, [r2, #0]
   44f96:	b92a      	cbnz	r2, 44fa4 <ipc_irq_handler+0x10c>
   44f98:	2303      	movs	r3, #3
   44f9a:	2205      	movs	r2, #5
   44f9c:	7033      	strb	r3, [r6, #0]
   44f9e:	4b05      	ldr	r3, [pc, #20]	; (44fb4 <ipc_irq_handler+0x11c>)
   44fa0:	601a      	str	r2, [r3, #0]
   44fa2:	e7e4      	b.n	44f6e <ipc_irq_handler+0xd6>
   44fa4:	701d      	strb	r5, [r3, #0]
   44fa6:	e7e2      	b.n	44f6e <ipc_irq_handler+0xd6>
   44fa8:	e000e100 	.word	0xe000e100
   44fac:	4002a000 	.word	0x4002a000
   44fb0:	2001e96c 	.word	0x2001e96c
   44fb4:	2001aab8 	.word	0x2001aab8
   44fb8:	04400004 	.word	0x04400004
   44fbc:	05500001 	.word	0x05500001
   44fc0:	2001aac4 	.word	0x2001aac4
   44fc4:	2001aabc 	.word	0x2001aabc

00044fc8 <interface_init>:
   44fc8:	b508      	push	{r3, lr}
   44fca:	f44f 72b0 	mov.w	r2, #352	; 0x160
   44fce:	2100      	movs	r1, #0
   44fd0:	4802      	ldr	r0, [pc, #8]	; (44fdc <interface_init+0x14>)
   44fd2:	f003 f814 	bl	47ffe <memset>
   44fd6:	2000      	movs	r0, #0
   44fd8:	bd08      	pop	{r3, pc}
   44fda:	bf00      	nop
   44fdc:	2001aad8 	.word	0x2001aad8

00044fe0 <interface_socket_wait>:
   44fe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44fe4:	4615      	mov	r5, r2
   44fe6:	222c      	movs	r2, #44	; 0x2c
   44fe8:	4350      	muls	r0, r2
   44fea:	461e      	mov	r6, r3
   44fec:	4b0e      	ldr	r3, [pc, #56]	; (45028 <interface_socket_wait+0x48>)
   44fee:	460c      	mov	r4, r1
   44ff0:	181f      	adds	r7, r3, r0
   44ff2:	581b      	ldr	r3, [r3, r0]
   44ff4:	402b      	ands	r3, r5
   44ff6:	428b      	cmp	r3, r1
   44ff8:	d102      	bne.n	45000 <interface_socket_wait+0x20>
   44ffa:	2000      	movs	r0, #0
   44ffc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45000:	687b      	ldr	r3, [r7, #4]
   45002:	2b00      	cmp	r3, #0
   45004:	d1f9      	bne.n	44ffa <interface_socket_wait+0x1a>
   45006:	46b8      	mov	r8, r7
   45008:	f8d8 3000 	ldr.w	r3, [r8]
   4500c:	402b      	ands	r3, r5
   4500e:	42a3      	cmp	r3, r4
   45010:	d0f3      	beq.n	44ffa <interface_socket_wait+0x1a>
   45012:	f8d8 3004 	ldr.w	r3, [r8, #4]
   45016:	2b00      	cmp	r3, #0
   45018:	d1ef      	bne.n	44ffa <interface_socket_wait+0x1a>
   4501a:	4631      	mov	r1, r6
   4501c:	4638      	mov	r0, r7
   4501e:	f7fe fd11 	bl	43a44 <nrf_modem_os_timedwait>
   45022:	2800      	cmp	r0, #0
   45024:	d0f0      	beq.n	45008 <interface_socket_wait+0x28>
   45026:	e7e9      	b.n	44ffc <interface_socket_wait+0x1c>
   45028:	2001aad8 	.word	0x2001aad8

0004502c <interface_sockets_aux_state_set>:
   4502c:	4a0d      	ldr	r2, [pc, #52]	; (45064 <interface_sockets_aux_state_set+0x38>)
   4502e:	b570      	push	{r4, r5, r6, lr}
   45030:	2300      	movs	r3, #0
   45032:	4611      	mov	r1, r2
   45034:	252c      	movs	r5, #44	; 0x2c
   45036:	fb05 f403 	mul.w	r4, r5, r3
   4503a:	590c      	ldr	r4, [r1, r4]
   4503c:	b15c      	cbz	r4, 45056 <interface_sockets_aux_state_set+0x2a>
   4503e:	68d4      	ldr	r4, [r2, #12]
   45040:	f024 0608 	bic.w	r6, r4, #8
   45044:	2e02      	cmp	r6, #2
   45046:	d001      	beq.n	4504c <interface_sockets_aux_state_set+0x20>
   45048:	2c05      	cmp	r4, #5
   4504a:	d104      	bne.n	45056 <interface_sockets_aux_state_set+0x2a>
   4504c:	fb05 f603 	mul.w	r6, r5, r3
   45050:	598c      	ldr	r4, [r1, r6]
   45052:	4304      	orrs	r4, r0
   45054:	518c      	str	r4, [r1, r6]
   45056:	3301      	adds	r3, #1
   45058:	2b08      	cmp	r3, #8
   4505a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   4505e:	d1ea      	bne.n	45036 <interface_sockets_aux_state_set+0xa>
   45060:	bd70      	pop	{r4, r5, r6, pc}
   45062:	bf00      	nop
   45064:	2001aad8 	.word	0x2001aad8

00045068 <interface_sockets_aux_state_clear>:
   45068:	4a0d      	ldr	r2, [pc, #52]	; (450a0 <interface_sockets_aux_state_clear+0x38>)
   4506a:	b570      	push	{r4, r5, r6, lr}
   4506c:	2300      	movs	r3, #0
   4506e:	4611      	mov	r1, r2
   45070:	252c      	movs	r5, #44	; 0x2c
   45072:	43c0      	mvns	r0, r0
   45074:	fb05 f403 	mul.w	r4, r5, r3
   45078:	590c      	ldr	r4, [r1, r4]
   4507a:	b15c      	cbz	r4, 45094 <interface_sockets_aux_state_clear+0x2c>
   4507c:	68d4      	ldr	r4, [r2, #12]
   4507e:	f024 0608 	bic.w	r6, r4, #8
   45082:	2e02      	cmp	r6, #2
   45084:	d001      	beq.n	4508a <interface_sockets_aux_state_clear+0x22>
   45086:	2c05      	cmp	r4, #5
   45088:	d104      	bne.n	45094 <interface_sockets_aux_state_clear+0x2c>
   4508a:	fb05 f603 	mul.w	r6, r5, r3
   4508e:	598c      	ldr	r4, [r1, r6]
   45090:	4004      	ands	r4, r0
   45092:	518c      	str	r4, [r1, r6]
   45094:	3301      	adds	r3, #1
   45096:	2b08      	cmp	r3, #8
   45098:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   4509c:	d1ea      	bne.n	45074 <interface_sockets_aux_state_clear+0xc>
   4509e:	bd70      	pop	{r4, r5, r6, pc}
   450a0:	2001aad8 	.word	0x2001aad8

000450a4 <interface_from_internal_id_search>:
   450a4:	4b0a      	ldr	r3, [pc, #40]	; (450d0 <interface_from_internal_id_search+0x2c>)
   450a6:	4602      	mov	r2, r0
   450a8:	b530      	push	{r4, r5, lr}
   450aa:	2000      	movs	r0, #0
   450ac:	461c      	mov	r4, r3
   450ae:	212c      	movs	r1, #44	; 0x2c
   450b0:	fb01 f500 	mul.w	r5, r1, r0
   450b4:	5965      	ldr	r5, [r4, r5]
   450b6:	b115      	cbz	r5, 450be <interface_from_internal_id_search+0x1a>
   450b8:	699d      	ldr	r5, [r3, #24]
   450ba:	4295      	cmp	r5, r2
   450bc:	d006      	beq.n	450cc <interface_from_internal_id_search+0x28>
   450be:	3001      	adds	r0, #1
   450c0:	2808      	cmp	r0, #8
   450c2:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   450c6:	d1f3      	bne.n	450b0 <interface_from_internal_id_search+0xc>
   450c8:	f04f 30ff 	mov.w	r0, #4294967295
   450cc:	bd30      	pop	{r4, r5, pc}
   450ce:	bf00      	nop
   450d0:	2001aad8 	.word	0x2001aad8

000450d4 <interface_socket_from_handle_get>:
   450d4:	2807      	cmp	r0, #7
   450d6:	d808      	bhi.n	450ea <interface_socket_from_handle_get+0x16>
   450d8:	232c      	movs	r3, #44	; 0x2c
   450da:	4343      	muls	r3, r0
   450dc:	4a04      	ldr	r2, [pc, #16]	; (450f0 <interface_socket_from_handle_get+0x1c>)
   450de:	18d0      	adds	r0, r2, r3
   450e0:	58d3      	ldr	r3, [r2, r3]
   450e2:	2b00      	cmp	r3, #0
   450e4:	bf08      	it	eq
   450e6:	2000      	moveq	r0, #0
   450e8:	4770      	bx	lr
   450ea:	2000      	movs	r0, #0
   450ec:	4770      	bx	lr
   450ee:	bf00      	nop
   450f0:	2001aad8 	.word	0x2001aad8

000450f4 <rpc_error_to_nrf_errno>:
   450f4:	286a      	cmp	r0, #106	; 0x6a
   450f6:	bf9a      	itte	ls
   450f8:	4b01      	ldrls	r3, [pc, #4]	; (45100 <rpc_error_to_nrf_errno+0xc>)
   450fa:	5c18      	ldrbls	r0, [r3, r0]
   450fc:	205f      	movhi	r0, #95	; 0x5f
   450fe:	4770      	bx	lr
   45100:	00049673 	.word	0x00049673

00045104 <rpc_error_to_nrf_gai_errno>:
   45104:	2805      	cmp	r0, #5
   45106:	d013      	beq.n	45130 <rpc_error_to_nrf_gai_errno+0x2c>
   45108:	d807      	bhi.n	4511a <rpc_error_to_nrf_gai_errno+0x16>
   4510a:	b170      	cbz	r0, 4512a <rpc_error_to_nrf_gai_errno+0x26>
   4510c:	4b0b      	ldr	r3, [pc, #44]	; (4513c <rpc_error_to_nrf_gai_errno+0x38>)
   4510e:	5c1b      	ldrb	r3, [r3, r0]
   45110:	4a0b      	ldr	r2, [pc, #44]	; (45140 <rpc_error_to_nrf_gai_errno+0x3c>)
   45112:	f240 1015 	movw	r0, #277	; 0x115
   45116:	6013      	str	r3, [r2, #0]
   45118:	4770      	bx	lr
   4511a:	2806      	cmp	r0, #6
   4511c:	d00b      	beq.n	45136 <rpc_error_to_nrf_gai_errno+0x32>
   4511e:	280d      	cmp	r0, #13
   45120:	d009      	beq.n	45136 <rpc_error_to_nrf_gai_errno+0x32>
   45122:	286a      	cmp	r0, #106	; 0x6a
   45124:	d9f2      	bls.n	4510c <rpc_error_to_nrf_gai_errno+0x8>
   45126:	235f      	movs	r3, #95	; 0x5f
   45128:	e7f2      	b.n	45110 <rpc_error_to_nrf_gai_errno+0xc>
   4512a:	4b05      	ldr	r3, [pc, #20]	; (45140 <rpc_error_to_nrf_gai_errno+0x3c>)
   4512c:	6018      	str	r0, [r3, #0]
   4512e:	4770      	bx	lr
   45130:	f44f 708a 	mov.w	r0, #276	; 0x114
   45134:	4770      	bx	lr
   45136:	f240 1011 	movw	r0, #273	; 0x111
   4513a:	4770      	bx	lr
   4513c:	00049673 	.word	0x00049673
   45140:	2001ac40 	.word	0x2001ac40

00045144 <ip_interface_init>:
   45144:	b510      	push	{r4, lr}
   45146:	2400      	movs	r4, #0
   45148:	4b06      	ldr	r3, [pc, #24]	; (45164 <ip_interface_init+0x20>)
   4514a:	2220      	movs	r2, #32
   4514c:	601c      	str	r4, [r3, #0]
   4514e:	4b06      	ldr	r3, [pc, #24]	; (45168 <ip_interface_init+0x24>)
   45150:	4621      	mov	r1, r4
   45152:	4806      	ldr	r0, [pc, #24]	; (4516c <ip_interface_init+0x28>)
   45154:	601c      	str	r4, [r3, #0]
   45156:	f002 ff52 	bl	47ffe <memset>
   4515a:	2201      	movs	r2, #1
   4515c:	4b04      	ldr	r3, [pc, #16]	; (45170 <ip_interface_init+0x2c>)
   4515e:	4620      	mov	r0, r4
   45160:	701a      	strb	r2, [r3, #0]
   45162:	bd10      	pop	{r4, pc}
   45164:	2001ac4c 	.word	0x2001ac4c
   45168:	2001ac48 	.word	0x2001ac48
   4516c:	2001ac50 	.word	0x2001ac50
   45170:	2001e96f 	.word	0x2001e96f

00045174 <rpc_ip_event_handler>:
   45174:	f248 030f 	movw	r3, #32783	; 0x800f
   45178:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4517c:	4299      	cmp	r1, r3
   4517e:	4604      	mov	r4, r0
   45180:	460e      	mov	r6, r1
   45182:	b089      	sub	sp, #36	; 0x24
   45184:	f000 80a4 	beq.w	452d0 <rpc_ip_event_handler+0x15c>
   45188:	f249 0304 	movw	r3, #36868	; 0x9004
   4518c:	4299      	cmp	r1, r3
   4518e:	f000 80ab 	beq.w	452e8 <rpc_ip_event_handler+0x174>
   45192:	f248 030d 	movw	r3, #32781	; 0x800d
   45196:	4299      	cmp	r1, r3
   45198:	f040 80b8 	bne.w	4530c <rpc_ip_event_handler+0x198>
   4519c:	4bbc      	ldr	r3, [pc, #752]	; (45490 <rpc_ip_event_handler+0x31c>)
   4519e:	681a      	ldr	r2, [r3, #0]
   451a0:	9303      	str	r3, [sp, #12]
   451a2:	2a01      	cmp	r2, #1
   451a4:	d12d      	bne.n	45202 <rpc_ip_event_handler+0x8e>
   451a6:	6940      	ldr	r0, [r0, #20]
   451a8:	2800      	cmp	r0, #0
   451aa:	f040 808c 	bne.w	452c6 <rpc_ip_event_handler+0x152>
   451ae:	f8d4 a018 	ldr.w	sl, [r4, #24]
   451b2:	f8d4 8000 	ldr.w	r8, [r4]
   451b6:	ea4f 134a 	mov.w	r3, sl, lsl #5
   451ba:	4618      	mov	r0, r3
   451bc:	9301      	str	r3, [sp, #4]
   451be:	f7fe fd19 	bl	43bf4 <nrf_modem_os_alloc>
   451c2:	4607      	mov	r7, r0
   451c4:	b310      	cbz	r0, 4520c <rpc_ip_event_handler+0x98>
   451c6:	2024      	movs	r0, #36	; 0x24
   451c8:	fb00 f00a 	mul.w	r0, r0, sl
   451cc:	f7fe fd12 	bl	43bf4 <nrf_modem_os_alloc>
   451d0:	4605      	mov	r5, r0
   451d2:	b1e8      	cbz	r0, 45210 <rpc_ip_event_handler+0x9c>
   451d4:	2604      	movs	r6, #4
   451d6:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   451da:	f107 0920 	add.w	r9, r7, #32
   451de:	9302      	str	r3, [sp, #8]
   451e0:	9b02      	ldr	r3, [sp, #8]
   451e2:	42ab      	cmp	r3, r5
   451e4:	d118      	bne.n	45218 <rpc_ip_event_handler+0xa4>
   451e6:	f1ba 0f00 	cmp.w	sl, #0
   451ea:	d005      	beq.n	451f8 <rpc_ip_event_handler+0x84>
   451ec:	9b01      	ldr	r3, [sp, #4]
   451ee:	443b      	add	r3, r7
   451f0:	4699      	mov	r9, r3
   451f2:	2300      	movs	r3, #0
   451f4:	f849 3c04 	str.w	r3, [r9, #-4]
   451f8:	4ba6      	ldr	r3, [pc, #664]	; (45494 <rpc_ip_event_handler+0x320>)
   451fa:	601f      	str	r7, [r3, #0]
   451fc:	2302      	movs	r3, #2
   451fe:	9a03      	ldr	r2, [sp, #12]
   45200:	6013      	str	r3, [r2, #0]
   45202:	6820      	ldr	r0, [r4, #0]
   45204:	2800      	cmp	r0, #0
   45206:	f040 81c7 	bne.w	45598 <rpc_ip_event_handler+0x424>
   4520a:	e1c7      	b.n	4559c <rpc_ip_event_handler+0x428>
   4520c:	f7fe fcfa 	bl	43c04 <nrf_modem_os_free>
   45210:	220c      	movs	r2, #12
   45212:	4ba1      	ldr	r3, [pc, #644]	; (45498 <rpc_ip_event_handler+0x324>)
   45214:	601a      	str	r2, [r3, #0]
   45216:	e7ef      	b.n	451f8 <rpc_ip_event_handler+0x84>
   45218:	f858 2006 	ldr.w	r2, [r8, r6]
   4521c:	eb08 0106 	add.w	r1, r8, r6
   45220:	f849 2c20 	str.w	r2, [r9, #-32]
   45224:	eb08 0206 	add.w	r2, r8, r6
   45228:	6852      	ldr	r2, [r2, #4]
   4522a:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   4522e:	3a01      	subs	r2, #1
   45230:	2a04      	cmp	r2, #4
   45232:	bf8c      	ite	hi
   45234:	2200      	movhi	r2, #0
   45236:	4b99      	ldrls	r3, [pc, #612]	; (4549c <rpc_ip_event_handler+0x328>)
   45238:	f106 0614 	add.w	r6, r6, #20
   4523c:	bf98      	it	ls
   4523e:	569a      	ldrsbls	r2, [r3, r2]
   45240:	4b97      	ldr	r3, [pc, #604]	; (454a0 <rpc_ip_event_handler+0x32c>)
   45242:	f849 2c1c 	str.w	r2, [r9, #-28]
   45246:	681a      	ldr	r2, [r3, #0]
   45248:	4b96      	ldr	r3, [pc, #600]	; (454a4 <rpc_ip_event_handler+0x330>)
   4524a:	f849 2c18 	str.w	r2, [r9, #-24]
   4524e:	681a      	ldr	r2, [r3, #0]
   45250:	f849 2c14 	str.w	r2, [r9, #-20]
   45254:	8a0a      	ldrh	r2, [r1, #16]
   45256:	4994      	ldr	r1, [pc, #592]	; (454a8 <rpc_ip_event_handler+0x334>)
   45258:	2a04      	cmp	r2, #4
   4525a:	8808      	ldrh	r0, [r1, #0]
   4525c:	f849 2c10 	str.w	r2, [r9, #-16]
   45260:	f849 5c0c 	str.w	r5, [r9, #-12]
   45264:	eb08 0106 	add.w	r1, r8, r6
   45268:	d121      	bne.n	452ae <rpc_ip_event_handler+0x13a>
   4526a:	2202      	movs	r2, #2
   4526c:	606a      	str	r2, [r5, #4]
   4526e:	2210      	movs	r2, #16
   45270:	8128      	strh	r0, [r5, #8]
   45272:	702a      	strb	r2, [r5, #0]
   45274:	680a      	ldr	r2, [r1, #0]
   45276:	60ea      	str	r2, [r5, #12]
   45278:	f859 2c10 	ldr.w	r2, [r9, #-16]
   4527c:	f10b 0001 	add.w	r0, fp, #1
   45280:	4416      	add	r6, r2
   45282:	f7fe fcb7 	bl	43bf4 <nrf_modem_os_alloc>
   45286:	f849 0c08 	str.w	r0, [r9, #-8]
   4528a:	b148      	cbz	r0, 452a0 <rpc_ip_event_handler+0x12c>
   4528c:	465a      	mov	r2, fp
   4528e:	eb08 0106 	add.w	r1, r8, r6
   45292:	f002 fea9 	bl	47fe8 <memcpy>
   45296:	2100      	movs	r1, #0
   45298:	f859 2c08 	ldr.w	r2, [r9, #-8]
   4529c:	f802 100b 	strb.w	r1, [r2, fp]
   452a0:	f849 9c04 	str.w	r9, [r9, #-4]
   452a4:	445e      	add	r6, fp
   452a6:	f109 0920 	add.w	r9, r9, #32
   452aa:	3508      	adds	r5, #8
   452ac:	e798      	b.n	451e0 <rpc_ip_event_handler+0x6c>
   452ae:	230a      	movs	r3, #10
   452b0:	f04f 0c24 	mov.w	ip, #36	; 0x24
   452b4:	8128      	strh	r0, [r5, #8]
   452b6:	606b      	str	r3, [r5, #4]
   452b8:	f885 c000 	strb.w	ip, [r5]
   452bc:	f105 0010 	add.w	r0, r5, #16
   452c0:	f002 fe92 	bl	47fe8 <memcpy>
   452c4:	e7d8      	b.n	45278 <rpc_ip_event_handler+0x104>
   452c6:	f7ff ff1d 	bl	45104 <rpc_error_to_nrf_gai_errno>
   452ca:	4b73      	ldr	r3, [pc, #460]	; (45498 <rpc_ip_event_handler+0x324>)
   452cc:	6018      	str	r0, [r3, #0]
   452ce:	e795      	b.n	451fc <rpc_ip_event_handler+0x88>
   452d0:	6943      	ldr	r3, [r0, #20]
   452d2:	2b6a      	cmp	r3, #106	; 0x6a
   452d4:	bf8e      	itee	hi
   452d6:	235f      	movhi	r3, #95	; 0x5f
   452d8:	4a74      	ldrls	r2, [pc, #464]	; (454ac <rpc_ip_event_handler+0x338>)
   452da:	5cd3      	ldrbls	r3, [r2, r3]
   452dc:	4a74      	ldr	r2, [pc, #464]	; (454b0 <rpc_ip_event_handler+0x33c>)
   452de:	6013      	str	r3, [r2, #0]
   452e0:	4b74      	ldr	r3, [pc, #464]	; (454b4 <rpc_ip_event_handler+0x340>)
   452e2:	2201      	movs	r2, #1
   452e4:	701a      	strb	r2, [r3, #0]
   452e6:	e159      	b.n	4559c <rpc_ip_event_handler+0x428>
   452e8:	6903      	ldr	r3, [r0, #16]
   452ea:	2b03      	cmp	r3, #3
   452ec:	d807      	bhi.n	452fe <rpc_ip_event_handler+0x18a>
   452ee:	e8df f003 	tbb	[pc, r3]
   452f2:	0802      	.short	0x0802
   452f4:	0802      	.short	0x0802
   452f6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   452fa:	f7ff fe97 	bl	4502c <interface_sockets_aux_state_set>
   452fe:	4b6e      	ldr	r3, [pc, #440]	; (454b8 <rpc_ip_event_handler+0x344>)
   45300:	e7ef      	b.n	452e2 <rpc_ip_event_handler+0x16e>
   45302:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   45306:	f7ff feaf 	bl	45068 <interface_sockets_aux_state_clear>
   4530a:	e7f8      	b.n	452fe <rpc_ip_event_handler+0x18a>
   4530c:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   45310:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   45314:	68c0      	ldr	r0, [r0, #12]
   45316:	d13b      	bne.n	45390 <rpc_ip_event_handler+0x21c>
   45318:	f7ff fec4 	bl	450a4 <interface_from_internal_id_search>
   4531c:	4607      	mov	r7, r0
   4531e:	4638      	mov	r0, r7
   45320:	f7ff fed8 	bl	450d4 <interface_socket_from_handle_get>
   45324:	4605      	mov	r5, r0
   45326:	2800      	cmp	r0, #0
   45328:	f43f af6b 	beq.w	45202 <rpc_ip_event_handler+0x8e>
   4532c:	4601      	mov	r1, r0
   4532e:	4633      	mov	r3, r6
   45330:	4622      	mov	r2, r4
   45332:	4638      	mov	r0, r7
   45334:	f000 f9f4 	bl	45720 <tls_rpc_ip_event_handler>
   45338:	2800      	cmp	r0, #0
   4533a:	f000 812f 	beq.w	4559c <rpc_ip_event_handler+0x428>
   4533e:	f248 030c 	movw	r3, #32780	; 0x800c
   45342:	429e      	cmp	r6, r3
   45344:	d826      	bhi.n	45394 <rpc_ip_event_handler+0x220>
   45346:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   4534a:	f67f af5a 	bls.w	45202 <rpc_ip_event_handler+0x8e>
   4534e:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   45352:	3e01      	subs	r6, #1
   45354:	2e0b      	cmp	r6, #11
   45356:	f63f af54 	bhi.w	45202 <rpc_ip_event_handler+0x8e>
   4535a:	a301      	add	r3, pc, #4	; (adr r3, 45360 <rpc_ip_event_handler+0x1ec>)
   4535c:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   45360:	00045425 	.word	0x00045425
   45364:	000454d9 	.word	0x000454d9
   45368:	000455f5 	.word	0x000455f5
   4536c:	00045613 	.word	0x00045613
   45370:	000454bd 	.word	0x000454bd
   45374:	000455a5 	.word	0x000455a5
   45378:	000455a5 	.word	0x000455a5
   4537c:	0004551d 	.word	0x0004551d
   45380:	0004543f 	.word	0x0004543f
   45384:	00045203 	.word	0x00045203
   45388:	00045203 	.word	0x00045203
   4538c:	00045547 	.word	0x00045547
   45390:	0c07      	lsrs	r7, r0, #16
   45392:	e7c4      	b.n	4531e <rpc_ip_event_handler+0x1aa>
   45394:	f249 0302 	movw	r3, #36866	; 0x9002
   45398:	429e      	cmp	r6, r3
   4539a:	f000 80cc 	beq.w	45536 <rpc_ip_event_handler+0x3c2>
   4539e:	f249 0303 	movw	r3, #36867	; 0x9003
   453a2:	429e      	cmp	r6, r3
   453a4:	d05b      	beq.n	4545e <rpc_ip_event_handler+0x2ea>
   453a6:	f249 0301 	movw	r3, #36865	; 0x9001
   453aa:	429e      	cmp	r6, r3
   453ac:	f47f af29 	bne.w	45202 <rpc_ip_event_handler+0x8e>
   453b0:	682e      	ldr	r6, [r5, #0]
   453b2:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   453b6:	f000 80ee 	beq.w	45596 <rpc_ip_event_handler+0x422>
   453ba:	68a3      	ldr	r3, [r4, #8]
   453bc:	2b04      	cmp	r3, #4
   453be:	f240 80e7 	bls.w	45590 <rpc_ip_event_handler+0x41c>
   453c2:	8a63      	ldrh	r3, [r4, #18]
   453c4:	2b00      	cmp	r3, #0
   453c6:	f000 80e4 	beq.w	45592 <rpc_ip_event_handler+0x41e>
   453ca:	2b10      	cmp	r3, #16
   453cc:	f040 80cc 	bne.w	45568 <rpc_ip_event_handler+0x3f4>
   453d0:	2024      	movs	r0, #36	; 0x24
   453d2:	f7fe fc0f 	bl	43bf4 <nrf_modem_os_alloc>
   453d6:	b318      	cbz	r0, 45420 <rpc_ip_event_handler+0x2ac>
   453d8:	230a      	movs	r3, #10
   453da:	6043      	str	r3, [r0, #4]
   453dc:	2324      	movs	r3, #36	; 0x24
   453de:	7003      	strb	r3, [r0, #0]
   453e0:	7c62      	ldrb	r2, [r4, #17]
   453e2:	7c23      	ldrb	r3, [r4, #16]
   453e4:	f104 0124 	add.w	r1, r4, #36	; 0x24
   453e8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   453ec:	8103      	strh	r3, [r0, #8]
   453ee:	f100 0210 	add.w	r2, r0, #16
   453f2:	f104 0314 	add.w	r3, r4, #20
   453f6:	f853 6b04 	ldr.w	r6, [r3], #4
   453fa:	428b      	cmp	r3, r1
   453fc:	f842 6b04 	str.w	r6, [r2], #4
   45400:	d1f9      	bne.n	453f6 <rpc_ip_event_handler+0x282>
   45402:	2324      	movs	r3, #36	; 0x24
   45404:	6822      	ldr	r2, [r4, #0]
   45406:	9307      	str	r3, [sp, #28]
   45408:	9204      	str	r2, [sp, #16]
   4540a:	6862      	ldr	r2, [r4, #4]
   4540c:	a904      	add	r1, sp, #16
   4540e:	e9cd 2005 	strd	r2, r0, [sp, #20]
   45412:	69e8      	ldr	r0, [r5, #28]
   45414:	6803      	ldr	r3, [r0, #0]
   45416:	685b      	ldr	r3, [r3, #4]
   45418:	4798      	blx	r3
   4541a:	3001      	adds	r0, #1
   4541c:	f040 808f 	bne.w	4553e <rpc_ip_event_handler+0x3ca>
   45420:	2002      	movs	r0, #2
   45422:	e0bc      	b.n	4559e <rpc_ip_event_handler+0x42a>
   45424:	682b      	ldr	r3, [r5, #0]
   45426:	2b01      	cmp	r3, #1
   45428:	f040 80b8 	bne.w	4559c <rpc_ip_event_handler+0x428>
   4542c:	6960      	ldr	r0, [r4, #20]
   4542e:	2800      	cmp	r0, #0
   45430:	f040 80e9 	bne.w	45606 <rpc_ip_event_handler+0x492>
   45434:	2302      	movs	r3, #2
   45436:	602b      	str	r3, [r5, #0]
   45438:	69a3      	ldr	r3, [r4, #24]
   4543a:	61ab      	str	r3, [r5, #24]
   4543c:	e0af      	b.n	4559e <rpc_ip_event_handler+0x42a>
   4543e:	682b      	ldr	r3, [r5, #0]
   45440:	b29b      	uxth	r3, r3
   45442:	2b0d      	cmp	r3, #13
   45444:	f040 80aa 	bne.w	4559c <rpc_ip_event_handler+0x428>
   45448:	6960      	ldr	r0, [r4, #20]
   4544a:	2800      	cmp	r0, #0
   4544c:	f040 80db 	bne.w	45606 <rpc_ip_event_handler+0x492>
   45450:	682b      	ldr	r3, [r5, #0]
   45452:	0c1b      	lsrs	r3, r3, #16
   45454:	041b      	lsls	r3, r3, #16
   45456:	f043 030e 	orr.w	r3, r3, #14
   4545a:	602b      	str	r3, [r5, #0]
   4545c:	e09f      	b.n	4559e <rpc_ip_event_handler+0x42a>
   4545e:	682b      	ldr	r3, [r5, #0]
   45460:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   45464:	602b      	str	r3, [r5, #0]
   45466:	682b      	ldr	r3, [r5, #0]
   45468:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   4546c:	602b      	str	r3, [r5, #0]
   4546e:	6923      	ldr	r3, [r4, #16]
   45470:	2b6c      	cmp	r3, #108	; 0x6c
   45472:	d107      	bne.n	45484 <rpc_ip_event_handler+0x310>
   45474:	682b      	ldr	r3, [r5, #0]
   45476:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   4547a:	602b      	str	r3, [r5, #0]
   4547c:	2380      	movs	r3, #128	; 0x80
   4547e:	606b      	str	r3, [r5, #4]
   45480:	60ab      	str	r3, [r5, #8]
   45482:	e08b      	b.n	4559c <rpc_ip_event_handler+0x428>
   45484:	2b6a      	cmp	r3, #106	; 0x6a
   45486:	bf96      	itet	ls
   45488:	4a08      	ldrls	r2, [pc, #32]	; (454ac <rpc_ip_event_handler+0x338>)
   4548a:	235f      	movhi	r3, #95	; 0x5f
   4548c:	5cd3      	ldrbls	r3, [r2, r3]
   4548e:	e7f6      	b.n	4547e <rpc_ip_event_handler+0x30a>
   45490:	2001ac48 	.word	0x2001ac48
   45494:	2001ac4c 	.word	0x2001ac4c
   45498:	2001ac44 	.word	0x2001ac44
   4549c:	0004966e 	.word	0x0004966e
   454a0:	2001ac3c 	.word	0x2001ac3c
   454a4:	2001ac38 	.word	0x2001ac38
   454a8:	2001ad3e 	.word	0x2001ad3e
   454ac:	00049673 	.word	0x00049673
   454b0:	2001ac70 	.word	0x2001ac70
   454b4:	2001e970 	.word	0x2001e970
   454b8:	2001e96e 	.word	0x2001e96e
   454bc:	682b      	ldr	r3, [r5, #0]
   454be:	b29b      	uxth	r3, r3
   454c0:	2b03      	cmp	r3, #3
   454c2:	d16b      	bne.n	4559c <rpc_ip_event_handler+0x428>
   454c4:	6960      	ldr	r0, [r4, #20]
   454c6:	2800      	cmp	r0, #0
   454c8:	f040 809d 	bne.w	45606 <rpc_ip_event_handler+0x492>
   454cc:	682b      	ldr	r3, [r5, #0]
   454ce:	0c1b      	lsrs	r3, r3, #16
   454d0:	041b      	lsls	r3, r3, #16
   454d2:	f043 0304 	orr.w	r3, r3, #4
   454d6:	e7c0      	b.n	4545a <rpc_ip_event_handler+0x2e6>
   454d8:	682b      	ldr	r3, [r5, #0]
   454da:	0099      	lsls	r1, r3, #2
   454dc:	d55e      	bpl.n	4559c <rpc_ip_event_handler+0x428>
   454de:	682b      	ldr	r3, [r5, #0]
   454e0:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   454e4:	602b      	str	r3, [r5, #0]
   454e6:	6960      	ldr	r0, [r4, #20]
   454e8:	b968      	cbnz	r0, 45506 <rpc_ip_event_handler+0x392>
   454ea:	682b      	ldr	r3, [r5, #0]
   454ec:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   454f0:	602b      	str	r3, [r5, #0]
   454f2:	682b      	ldr	r3, [r5, #0]
   454f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   454f8:	602b      	str	r3, [r5, #0]
   454fa:	682b      	ldr	r3, [r5, #0]
   454fc:	0c1b      	lsrs	r3, r3, #16
   454fe:	041b      	lsls	r3, r3, #16
   45500:	f043 0305 	orr.w	r3, r3, #5
   45504:	e7a9      	b.n	4545a <rpc_ip_event_handler+0x2e6>
   45506:	286a      	cmp	r0, #106	; 0x6a
   45508:	bf8e      	itee	hi
   4550a:	235f      	movhi	r3, #95	; 0x5f
   4550c:	4b4c      	ldrls	r3, [pc, #304]	; (45640 <rpc_ip_event_handler+0x4cc>)
   4550e:	5c1b      	ldrbls	r3, [r3, r0]
   45510:	606b      	str	r3, [r5, #4]
   45512:	682b      	ldr	r3, [r5, #0]
   45514:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45518:	602b      	str	r3, [r5, #0]
   4551a:	e03f      	b.n	4559c <rpc_ip_event_handler+0x428>
   4551c:	682b      	ldr	r3, [r5, #0]
   4551e:	b29b      	uxth	r3, r3
   45520:	2b06      	cmp	r3, #6
   45522:	d13b      	bne.n	4559c <rpc_ip_event_handler+0x428>
   45524:	6960      	ldr	r0, [r4, #20]
   45526:	2800      	cmp	r0, #0
   45528:	d16d      	bne.n	45606 <rpc_ip_event_handler+0x492>
   4552a:	682b      	ldr	r3, [r5, #0]
   4552c:	0c1b      	lsrs	r3, r3, #16
   4552e:	041b      	lsls	r3, r3, #16
   45530:	f043 0307 	orr.w	r3, r3, #7
   45534:	e791      	b.n	4545a <rpc_ip_event_handler+0x2e6>
   45536:	682b      	ldr	r3, [r5, #0]
   45538:	b29b      	uxth	r3, r3
   4553a:	2b07      	cmp	r3, #7
   4553c:	d12e      	bne.n	4559c <rpc_ip_event_handler+0x428>
   4553e:	682b      	ldr	r3, [r5, #0]
   45540:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   45544:	e7e8      	b.n	45518 <rpc_ip_event_handler+0x3a4>
   45546:	682b      	ldr	r3, [r5, #0]
   45548:	b29b      	uxth	r3, r3
   4554a:	2b08      	cmp	r3, #8
   4554c:	d126      	bne.n	4559c <rpc_ip_event_handler+0x428>
   4554e:	6963      	ldr	r3, [r4, #20]
   45550:	2b00      	cmp	r3, #0
   45552:	d16d      	bne.n	45630 <rpc_ip_event_handler+0x4bc>
   45554:	4b3b      	ldr	r3, [pc, #236]	; (45644 <rpc_ip_event_handler+0x4d0>)
   45556:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4555a:	682b      	ldr	r3, [r5, #0]
   4555c:	0c1b      	lsrs	r3, r3, #16
   4555e:	041b      	lsls	r3, r3, #16
   45560:	f043 0309 	orr.w	r3, r3, #9
   45564:	602b      	str	r3, [r5, #0]
   45566:	e032      	b.n	455ce <rpc_ip_event_handler+0x45a>
   45568:	2b04      	cmp	r3, #4
   4556a:	d114      	bne.n	45596 <rpc_ip_event_handler+0x422>
   4556c:	2010      	movs	r0, #16
   4556e:	f7fe fb41 	bl	43bf4 <nrf_modem_os_alloc>
   45572:	2800      	cmp	r0, #0
   45574:	f43f af54 	beq.w	45420 <rpc_ip_event_handler+0x2ac>
   45578:	2302      	movs	r3, #2
   4557a:	6043      	str	r3, [r0, #4]
   4557c:	2310      	movs	r3, #16
   4557e:	7003      	strb	r3, [r0, #0]
   45580:	7c22      	ldrb	r2, [r4, #16]
   45582:	7c61      	ldrb	r1, [r4, #17]
   45584:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   45588:	8102      	strh	r2, [r0, #8]
   4558a:	6962      	ldr	r2, [r4, #20]
   4558c:	60c2      	str	r2, [r0, #12]
   4558e:	e739      	b.n	45404 <rpc_ip_event_handler+0x290>
   45590:	2300      	movs	r3, #0
   45592:	4618      	mov	r0, r3
   45594:	e736      	b.n	45404 <rpc_ip_event_handler+0x290>
   45596:	6820      	ldr	r0, [r4, #0]
   45598:	f002 ff4a 	bl	48430 <rpc_client_data_free>
   4559c:	2000      	movs	r0, #0
   4559e:	b009      	add	sp, #36	; 0x24
   455a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   455a4:	4b27      	ldr	r3, [pc, #156]	; (45644 <rpc_ip_event_handler+0x4d0>)
   455a6:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   455aa:	6963      	ldr	r3, [r4, #20]
   455ac:	b17b      	cbz	r3, 455ce <rpc_ip_event_handler+0x45a>
   455ae:	2b6b      	cmp	r3, #107	; 0x6b
   455b0:	d10f      	bne.n	455d2 <rpc_ip_event_handler+0x45e>
   455b2:	6928      	ldr	r0, [r5, #16]
   455b4:	220c      	movs	r2, #12
   455b6:	2801      	cmp	r0, #1
   455b8:	682b      	ldr	r3, [r5, #0]
   455ba:	d104      	bne.n	455c6 <rpc_ip_event_handler+0x452>
   455bc:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   455c0:	602b      	str	r3, [r5, #0]
   455c2:	606a      	str	r2, [r5, #4]
   455c4:	e7eb      	b.n	4559e <rpc_ip_event_handler+0x42a>
   455c6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   455ca:	602b      	str	r3, [r5, #0]
   455cc:	606a      	str	r2, [r5, #4]
   455ce:	2001      	movs	r0, #1
   455d0:	e7e5      	b.n	4559e <rpc_ip_event_handler+0x42a>
   455d2:	f023 0002 	bic.w	r0, r3, #2
   455d6:	2801      	cmp	r0, #1
   455d8:	d102      	bne.n	455e0 <rpc_ip_event_handler+0x46c>
   455da:	230c      	movs	r3, #12
   455dc:	606b      	str	r3, [r5, #4]
   455de:	e7de      	b.n	4559e <rpc_ip_event_handler+0x42a>
   455e0:	2b6a      	cmp	r3, #106	; 0x6a
   455e2:	bf8e      	itee	hi
   455e4:	235f      	movhi	r3, #95	; 0x5f
   455e6:	4a16      	ldrls	r2, [pc, #88]	; (45640 <rpc_ip_event_handler+0x4cc>)
   455e8:	5cd3      	ldrbls	r3, [r2, r3]
   455ea:	606b      	str	r3, [r5, #4]
   455ec:	682b      	ldr	r3, [r5, #0]
   455ee:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   455f2:	e7b7      	b.n	45564 <rpc_ip_event_handler+0x3f0>
   455f4:	682b      	ldr	r3, [r5, #0]
   455f6:	025a      	lsls	r2, r3, #9
   455f8:	d5d0      	bpl.n	4559c <rpc_ip_event_handler+0x428>
   455fa:	6960      	ldr	r0, [r4, #20]
   455fc:	b918      	cbnz	r0, 45606 <rpc_ip_event_handler+0x492>
   455fe:	682b      	ldr	r3, [r5, #0]
   45600:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   45604:	e729      	b.n	4545a <rpc_ip_event_handler+0x2e6>
   45606:	286a      	cmp	r0, #106	; 0x6a
   45608:	d817      	bhi.n	4563a <rpc_ip_event_handler+0x4c6>
   4560a:	4b0d      	ldr	r3, [pc, #52]	; (45640 <rpc_ip_event_handler+0x4cc>)
   4560c:	5c1b      	ldrb	r3, [r3, r0]
   4560e:	606b      	str	r3, [r5, #4]
   45610:	e7c4      	b.n	4559c <rpc_ip_event_handler+0x428>
   45612:	682b      	ldr	r3, [r5, #0]
   45614:	01db      	lsls	r3, r3, #7
   45616:	d5c1      	bpl.n	4559c <rpc_ip_event_handler+0x428>
   45618:	6963      	ldr	r3, [r4, #20]
   4561a:	b94b      	cbnz	r3, 45630 <rpc_ip_event_handler+0x4bc>
   4561c:	6820      	ldr	r0, [r4, #0]
   4561e:	b118      	cbz	r0, 45628 <rpc_ip_event_handler+0x4b4>
   45620:	2001      	movs	r0, #1
   45622:	4b08      	ldr	r3, [pc, #32]	; (45644 <rpc_ip_event_handler+0x4d0>)
   45624:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   45628:	682b      	ldr	r3, [r5, #0]
   4562a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   4562e:	e714      	b.n	4545a <rpc_ip_event_handler+0x2e6>
   45630:	2b6a      	cmp	r3, #106	; 0x6a
   45632:	d802      	bhi.n	4563a <rpc_ip_event_handler+0x4c6>
   45634:	4a02      	ldr	r2, [pc, #8]	; (45640 <rpc_ip_event_handler+0x4cc>)
   45636:	5cd3      	ldrb	r3, [r2, r3]
   45638:	e7e9      	b.n	4560e <rpc_ip_event_handler+0x49a>
   4563a:	235f      	movs	r3, #95	; 0x5f
   4563c:	e7e7      	b.n	4560e <rpc_ip_event_handler+0x49a>
   4563e:	bf00      	nop
   45640:	00049673 	.word	0x00049673
   45644:	2001ac50 	.word	0x2001ac50

00045648 <hostname_free>:
   45648:	b538      	push	{r3, r4, r5, lr}
   4564a:	4c07      	ldr	r4, [pc, #28]	; (45668 <hostname_free+0x20>)
   4564c:	4605      	mov	r5, r0
   4564e:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   45652:	b138      	cbz	r0, 45664 <hostname_free+0x1c>
   45654:	f7fe fad6 	bl	43c04 <nrf_modem_os_free>
   45658:	2300      	movs	r3, #0
   4565a:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   4565e:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   45662:	6063      	str	r3, [r4, #4]
   45664:	bd38      	pop	{r3, r4, r5, pc}
   45666:	bf00      	nop
   45668:	2001ac74 	.word	0x2001ac74

0004566c <secure_socket_attach_initiate>:
   4566c:	f04f 33ff 	mov.w	r3, #4294967295
   45670:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   45674:	f8df 8094 	ldr.w	r8, [pc, #148]	; 4570c <secure_socket_attach_initiate+0xa0>
   45678:	9301      	str	r3, [sp, #4]
   4567a:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   4567e:	460d      	mov	r5, r1
   45680:	4616      	mov	r6, r2
   45682:	f8d9 3004 	ldr.w	r3, [r9, #4]
   45686:	f247 0281 	movw	r2, #28801	; 0x7081
   4568a:	6989      	ldr	r1, [r1, #24]
   4568c:	4607      	mov	r7, r0
   4568e:	f002 fed1 	bl	48434 <ip_interface_request_create>
   45692:	4604      	mov	r4, r0
   45694:	b398      	cbz	r0, 456fe <secure_socket_attach_initiate+0x92>
   45696:	f8d9 2004 	ldr.w	r2, [r9, #4]
   4569a:	b122      	cbz	r2, 456a6 <secure_socket_attach_initiate+0x3a>
   4569c:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   456a0:	6800      	ldr	r0, [r0, #0]
   456a2:	f002 fca1 	bl	47fe8 <memcpy>
   456a6:	2324      	movs	r3, #36	; 0x24
   456a8:	4a17      	ldr	r2, [pc, #92]	; (45708 <secure_socket_attach_initiate+0x9c>)
   456aa:	fb03 2307 	mla	r3, r3, r7, r2
   456ae:	f104 0214 	add.w	r2, r4, #20
   456b2:	f103 0124 	add.w	r1, r3, #36	; 0x24
   456b6:	f853 0b04 	ldr.w	r0, [r3], #4
   456ba:	428b      	cmp	r3, r1
   456bc:	f842 0b04 	str.w	r0, [r2], #4
   456c0:	d1f9      	bne.n	456b6 <secure_socket_attach_initiate+0x4a>
   456c2:	68a3      	ldr	r3, [r4, #8]
   456c4:	4622      	mov	r2, r4
   456c6:	3324      	adds	r3, #36	; 0x24
   456c8:	60a3      	str	r3, [r4, #8]
   456ca:	682b      	ldr	r3, [r5, #0]
   456cc:	f247 0181 	movw	r1, #28801	; 0x7081
   456d0:	0c1b      	lsrs	r3, r3, #16
   456d2:	041b      	lsls	r3, r3, #16
   456d4:	f043 030a 	orr.w	r3, r3, #10
   456d8:	602b      	str	r3, [r5, #0]
   456da:	2004      	movs	r0, #4
   456dc:	f002 fea1 	bl	48422 <rpc_client_request_send>
   456e0:	682b      	ldr	r3, [r5, #0]
   456e2:	00db      	lsls	r3, r3, #3
   456e4:	d40d      	bmi.n	45702 <secure_socket_attach_initiate+0x96>
   456e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   456ea:	210b      	movs	r1, #11
   456ec:	4638      	mov	r0, r7
   456ee:	ab01      	add	r3, sp, #4
   456f0:	f002 feb3 	bl	4845a <ip_interface_wait>
   456f4:	b100      	cbz	r0, 456f8 <secure_socket_attach_initiate+0x8c>
   456f6:	602e      	str	r6, [r5, #0]
   456f8:	b003      	add	sp, #12
   456fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   456fe:	200c      	movs	r0, #12
   45700:	e7fa      	b.n	456f8 <secure_socket_attach_initiate+0x8c>
   45702:	2077      	movs	r0, #119	; 0x77
   45704:	e7f8      	b.n	456f8 <secure_socket_attach_initiate+0x8c>
   45706:	bf00      	nop
   45708:	2001e972 	.word	0x2001e972
   4570c:	2001ac74 	.word	0x2001ac74

00045710 <tls_interface_init>:
   45710:	2201      	movs	r2, #1
   45712:	4b02      	ldr	r3, [pc, #8]	; (4571c <tls_interface_init+0xc>)
   45714:	2000      	movs	r0, #0
   45716:	701a      	strb	r2, [r3, #0]
   45718:	4770      	bx	lr
   4571a:	bf00      	nop
   4571c:	2001e971 	.word	0x2001e971

00045720 <tls_rpc_ip_event_handler>:
   45720:	b570      	push	{r4, r5, r6, lr}
   45722:	460c      	mov	r4, r1
   45724:	f248 0181 	movw	r1, #32897	; 0x8081
   45728:	428b      	cmp	r3, r1
   4572a:	4606      	mov	r6, r0
   4572c:	d035      	beq.n	4579a <tls_rpc_ip_event_handler+0x7a>
   4572e:	f249 0182 	movw	r1, #36994	; 0x9082
   45732:	428b      	cmp	r3, r1
   45734:	d040      	beq.n	457b8 <tls_rpc_ip_event_handler+0x98>
   45736:	f248 0102 	movw	r1, #32770	; 0x8002
   4573a:	428b      	cmp	r3, r1
   4573c:	d161      	bne.n	45802 <tls_rpc_ip_event_handler+0xe2>
   4573e:	2c00      	cmp	r4, #0
   45740:	d05f      	beq.n	45802 <tls_rpc_ip_event_handler+0xe2>
   45742:	6963      	ldr	r3, [r4, #20]
   45744:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   45748:	d002      	beq.n	45750 <tls_rpc_ip_event_handler+0x30>
   4574a:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   4574e:	d158      	bne.n	45802 <tls_rpc_ip_event_handler+0xe2>
   45750:	6823      	ldr	r3, [r4, #0]
   45752:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45756:	6023      	str	r3, [r4, #0]
   45758:	6955      	ldr	r5, [r2, #20]
   4575a:	2d00      	cmp	r5, #0
   4575c:	d14d      	bne.n	457fa <tls_rpc_ip_event_handler+0xda>
   4575e:	6823      	ldr	r3, [r4, #0]
   45760:	0c1b      	lsrs	r3, r3, #16
   45762:	041b      	lsls	r3, r3, #16
   45764:	f043 0305 	orr.w	r3, r3, #5
   45768:	6023      	str	r3, [r4, #0]
   4576a:	6823      	ldr	r3, [r4, #0]
   4576c:	00db      	lsls	r3, r3, #3
   4576e:	d401      	bmi.n	45774 <tls_rpc_ip_event_handler+0x54>
   45770:	2000      	movs	r0, #0
   45772:	e020      	b.n	457b6 <tls_rpc_ip_event_handler+0x96>
   45774:	2324      	movs	r3, #36	; 0x24
   45776:	4373      	muls	r3, r6
   45778:	4a23      	ldr	r2, [pc, #140]	; (45808 <tls_rpc_ip_event_handler+0xe8>)
   4577a:	5cd3      	ldrb	r3, [r2, r3]
   4577c:	2b02      	cmp	r3, #2
   4577e:	d1f7      	bne.n	45770 <tls_rpc_ip_event_handler+0x50>
   45780:	4621      	mov	r1, r4
   45782:	4630      	mov	r0, r6
   45784:	f002 fe79 	bl	4847a <secure_client_socket>
   45788:	2800      	cmp	r0, #0
   4578a:	d0f1      	beq.n	45770 <tls_rpc_ip_event_handler+0x50>
   4578c:	2877      	cmp	r0, #119	; 0x77
   4578e:	d0ef      	beq.n	45770 <tls_rpc_ip_event_handler+0x50>
   45790:	6060      	str	r0, [r4, #4]
   45792:	6823      	ldr	r3, [r4, #0]
   45794:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45798:	e02d      	b.n	457f6 <tls_rpc_ip_event_handler+0xd6>
   4579a:	2c00      	cmp	r4, #0
   4579c:	d0e8      	beq.n	45770 <tls_rpc_ip_event_handler+0x50>
   4579e:	6823      	ldr	r3, [r4, #0]
   457a0:	b29b      	uxth	r3, r3
   457a2:	2b0a      	cmp	r3, #10
   457a4:	d1e4      	bne.n	45770 <tls_rpc_ip_event_handler+0x50>
   457a6:	6950      	ldr	r0, [r2, #20]
   457a8:	bb40      	cbnz	r0, 457fc <tls_rpc_ip_event_handler+0xdc>
   457aa:	6823      	ldr	r3, [r4, #0]
   457ac:	0c1b      	lsrs	r3, r3, #16
   457ae:	041b      	lsls	r3, r3, #16
   457b0:	f043 030b 	orr.w	r3, r3, #11
   457b4:	6023      	str	r3, [r4, #0]
   457b6:	bd70      	pop	{r4, r5, r6, pc}
   457b8:	2c00      	cmp	r4, #0
   457ba:	d0d9      	beq.n	45770 <tls_rpc_ip_event_handler+0x50>
   457bc:	6823      	ldr	r3, [r4, #0]
   457be:	b29b      	uxth	r3, r3
   457c0:	2b0b      	cmp	r3, #11
   457c2:	d1d5      	bne.n	45770 <tls_rpc_ip_event_handler+0x50>
   457c4:	6915      	ldr	r5, [r2, #16]
   457c6:	b9c5      	cbnz	r5, 457fa <tls_rpc_ip_event_handler+0xda>
   457c8:	6823      	ldr	r3, [r4, #0]
   457ca:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   457ce:	6023      	str	r3, [r4, #0]
   457d0:	f7ff ff3a 	bl	45648 <hostname_free>
   457d4:	6823      	ldr	r3, [r4, #0]
   457d6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   457da:	6023      	str	r3, [r4, #0]
   457dc:	6823      	ldr	r3, [r4, #0]
   457de:	0c1b      	lsrs	r3, r3, #16
   457e0:	041b      	lsls	r3, r3, #16
   457e2:	f043 030c 	orr.w	r3, r3, #12
   457e6:	6023      	str	r3, [r4, #0]
   457e8:	6823      	ldr	r3, [r4, #0]
   457ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   457ee:	6023      	str	r3, [r4, #0]
   457f0:	6823      	ldr	r3, [r4, #0]
   457f2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   457f6:	6023      	str	r3, [r4, #0]
   457f8:	e7ba      	b.n	45770 <tls_rpc_ip_event_handler+0x50>
   457fa:	4628      	mov	r0, r5
   457fc:	f7ff fc7a 	bl	450f4 <rpc_error_to_nrf_errno>
   45800:	e7c6      	b.n	45790 <tls_rpc_ip_event_handler+0x70>
   45802:	2001      	movs	r0, #1
   45804:	e7d7      	b.n	457b6 <tls_rpc_ip_event_handler+0x96>
   45806:	bf00      	nop
   45808:	2001e972 	.word	0x2001e972

0004580c <at_cmd_send>:
   4580c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4580e:	4615      	mov	r5, r2
   45810:	f06f 0258 	mvn.w	r2, #88	; 0x58
   45814:	2300      	movs	r3, #0
   45816:	7302      	strb	r2, [r0, #12]
   45818:	2204      	movs	r2, #4
   4581a:	4c0d      	ldr	r4, [pc, #52]	; (45850 <at_cmd_send+0x44>)
   4581c:	7343      	strb	r3, [r0, #13]
   4581e:	7383      	strb	r3, [r0, #14]
   45820:	73c3      	strb	r3, [r0, #15]
   45822:	7202      	strb	r2, [r0, #8]
   45824:	7243      	strb	r3, [r0, #9]
   45826:	7283      	strb	r3, [r0, #10]
   45828:	72c3      	strb	r3, [r0, #11]
   4582a:	4602      	mov	r2, r0
   4582c:	b289      	uxth	r1, r1
   4582e:	2003      	movs	r0, #3
   45830:	7023      	strb	r3, [r4, #0]
   45832:	f002 fdf6 	bl	48422 <rpc_client_request_send>
   45836:	f04f 33ff 	mov.w	r3, #4294967295
   4583a:	9301      	str	r3, [sp, #4]
   4583c:	7823      	ldrb	r3, [r4, #0]
   4583e:	42ab      	cmp	r3, r5
   45840:	d101      	bne.n	45846 <at_cmd_send+0x3a>
   45842:	b003      	add	sp, #12
   45844:	bd30      	pop	{r4, r5, pc}
   45846:	a901      	add	r1, sp, #4
   45848:	2000      	movs	r0, #0
   4584a:	f7fe f8fb 	bl	43a44 <nrf_modem_os_timedwait>
   4584e:	e7f5      	b.n	4583c <at_cmd_send+0x30>
   45850:	2001ea92 	.word	0x2001ea92

00045854 <nrf_modem_at_init>:
   45854:	2201      	movs	r2, #1
   45856:	b508      	push	{r3, lr}
   45858:	4611      	mov	r1, r2
   4585a:	4808      	ldr	r0, [pc, #32]	; (4587c <nrf_modem_at_init+0x28>)
   4585c:	f7fe f990 	bl	43b80 <nrf_modem_os_sem_init>
   45860:	2000      	movs	r0, #0
   45862:	f002 fdd8 	bl	48416 <rpc_client_request_alloc>
   45866:	b128      	cbz	r0, 45874 <nrf_modem_at_init+0x20>
   45868:	2201      	movs	r2, #1
   4586a:	2105      	movs	r1, #5
   4586c:	f7ff ffce 	bl	4580c <at_cmd_send>
   45870:	2000      	movs	r0, #0
   45872:	bd08      	pop	{r3, pc}
   45874:	f06f 000b 	mvn.w	r0, #11
   45878:	e7fb      	b.n	45872 <nrf_modem_at_init+0x1e>
   4587a:	bf00      	nop
   4587c:	2001acb4 	.word	0x2001acb4

00045880 <rpc_at_event_handler>:
   45880:	b570      	push	{r4, r5, r6, lr}
   45882:	68c3      	ldr	r3, [r0, #12]
   45884:	4605      	mov	r5, r0
   45886:	2ba7      	cmp	r3, #167	; 0xa7
   45888:	d003      	beq.n	45892 <rpc_at_event_handler+0x12>
   4588a:	6828      	ldr	r0, [r5, #0]
   4588c:	f002 fdd0 	bl	48430 <rpc_client_data_free>
   45890:	e008      	b.n	458a4 <rpc_at_event_handler+0x24>
   45892:	2903      	cmp	r1, #3
   45894:	d008      	beq.n	458a8 <rpc_at_event_handler+0x28>
   45896:	2904      	cmp	r1, #4
   45898:	d019      	beq.n	458ce <rpc_at_event_handler+0x4e>
   4589a:	2902      	cmp	r1, #2
   4589c:	d102      	bne.n	458a4 <rpc_at_event_handler+0x24>
   4589e:	2201      	movs	r2, #1
   458a0:	4b0e      	ldr	r3, [pc, #56]	; (458dc <rpc_at_event_handler+0x5c>)
   458a2:	701a      	strb	r2, [r3, #0]
   458a4:	2000      	movs	r0, #0
   458a6:	e00a      	b.n	458be <rpc_at_event_handler+0x3e>
   458a8:	4e0d      	ldr	r6, [pc, #52]	; (458e0 <rpc_at_event_handler+0x60>)
   458aa:	6833      	ldr	r3, [r6, #0]
   458ac:	b143      	cbz	r3, 458c0 <rpc_at_event_handler+0x40>
   458ae:	2400      	movs	r4, #0
   458b0:	6800      	ldr	r0, [r0, #0]
   458b2:	4798      	blx	r3
   458b4:	6828      	ldr	r0, [r5, #0]
   458b6:	6034      	str	r4, [r6, #0]
   458b8:	f002 fdba 	bl	48430 <rpc_client_data_free>
   458bc:	b2e0      	uxtb	r0, r4
   458be:	bd70      	pop	{r4, r5, r6, pc}
   458c0:	2202      	movs	r2, #2
   458c2:	4b08      	ldr	r3, [pc, #32]	; (458e4 <rpc_at_event_handler+0x64>)
   458c4:	2401      	movs	r4, #1
   458c6:	6018      	str	r0, [r3, #0]
   458c8:	4b04      	ldr	r3, [pc, #16]	; (458dc <rpc_at_event_handler+0x5c>)
   458ca:	701a      	strb	r2, [r3, #0]
   458cc:	e7f6      	b.n	458bc <rpc_at_event_handler+0x3c>
   458ce:	4b06      	ldr	r3, [pc, #24]	; (458e8 <rpc_at_event_handler+0x68>)
   458d0:	681b      	ldr	r3, [r3, #0]
   458d2:	2b00      	cmp	r3, #0
   458d4:	d0d9      	beq.n	4588a <rpc_at_event_handler+0xa>
   458d6:	6800      	ldr	r0, [r0, #0]
   458d8:	4798      	blx	r3
   458da:	e7d6      	b.n	4588a <rpc_at_event_handler+0xa>
   458dc:	2001ea92 	.word	0x2001ea92
   458e0:	2001acc0 	.word	0x2001acc0
   458e4:	2001acbc 	.word	0x2001acbc
   458e8:	2001acb8 	.word	0x2001acb8

000458ec <rpc_dfu_event_handler>:
   458ec:	b510      	push	{r4, lr}
   458ee:	4604      	mov	r4, r0
   458f0:	6800      	ldr	r0, [r0, #0]
   458f2:	b108      	cbz	r0, 458f8 <rpc_dfu_event_handler+0xc>
   458f4:	f002 fd9c 	bl	48430 <rpc_client_data_free>
   458f8:	4b05      	ldr	r3, [pc, #20]	; (45910 <rpc_dfu_event_handler+0x24>)
   458fa:	68e2      	ldr	r2, [r4, #12]
   458fc:	429a      	cmp	r2, r3
   458fe:	bf05      	ittet	eq
   45900:	2001      	moveq	r0, #1
   45902:	4b04      	ldreq	r3, [pc, #16]	; (45914 <rpc_dfu_event_handler+0x28>)
   45904:	2000      	movne	r0, #0
   45906:	7018      	strbeq	r0, [r3, #0]
   45908:	bf04      	itt	eq
   4590a:	4b03      	ldreq	r3, [pc, #12]	; (45918 <rpc_dfu_event_handler+0x2c>)
   4590c:	601c      	streq	r4, [r3, #0]
   4590e:	bd10      	pop	{r4, pc}
   45910:	15abe11a 	.word	0x15abe11a
   45914:	2001ea93 	.word	0x2001ea93
   45918:	2001acc4 	.word	0x2001acc4

0004591c <rpc_gnss_event_handler>:
   4591c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45920:	6804      	ldr	r4, [r0, #0]
   45922:	4607      	mov	r7, r0
   45924:	460d      	mov	r5, r1
   45926:	2c00      	cmp	r4, #0
   45928:	f000 8086 	beq.w	45a38 <rpc_gnss_event_handler+0x11c>
   4592c:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   45930:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   45934:	d142      	bne.n	459bc <rpc_gnss_event_handler+0xa0>
   45936:	4b5f      	ldr	r3, [pc, #380]	; (45ab4 <rpc_gnss_event_handler+0x198>)
   45938:	781a      	ldrb	r2, [r3, #0]
   4593a:	4698      	mov	r8, r3
   4593c:	2a01      	cmp	r2, #1
   4593e:	d131      	bne.n	459a4 <rpc_gnss_event_handler+0x88>
   45940:	4a5d      	ldr	r2, [pc, #372]	; (45ab8 <rpc_gnss_event_handler+0x19c>)
   45942:	6821      	ldr	r1, [r4, #0]
   45944:	8812      	ldrh	r2, [r2, #0]
   45946:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   4594a:	d12b      	bne.n	459a4 <rpc_gnss_event_handler+0x88>
   4594c:	6862      	ldr	r2, [r4, #4]
   4594e:	bb6a      	cbnz	r2, 459ac <rpc_gnss_event_handler+0x90>
   45950:	4b5a      	ldr	r3, [pc, #360]	; (45abc <rpc_gnss_event_handler+0x1a0>)
   45952:	681e      	ldr	r6, [r3, #0]
   45954:	b31e      	cbz	r6, 4599e <rpc_gnss_event_handler+0x82>
   45956:	f242 0309 	movw	r3, #8201	; 0x2009
   4595a:	429d      	cmp	r5, r3
   4595c:	d11f      	bne.n	4599e <rpc_gnss_event_handler+0x82>
   4595e:	4630      	mov	r0, r6
   45960:	8923      	ldrh	r3, [r4, #8]
   45962:	2280      	movs	r2, #128	; 0x80
   45964:	f840 3b04 	str.w	r3, [r0], #4
   45968:	f104 010a 	add.w	r1, r4, #10
   4596c:	f002 fb3c 	bl	47fe8 <memcpy>
   45970:	2280      	movs	r2, #128	; 0x80
   45972:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   45976:	f106 0084 	add.w	r0, r6, #132	; 0x84
   4597a:	f002 fb35 	bl	47fe8 <memcpy>
   4597e:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   45982:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   45986:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   4598a:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   4598e:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   45992:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   45996:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   4599a:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   4599e:	2300      	movs	r3, #0
   459a0:	f888 3000 	strb.w	r3, [r8]
   459a4:	6838      	ldr	r0, [r7, #0]
   459a6:	f002 fd43 	bl	48430 <rpc_client_data_free>
   459aa:	e045      	b.n	45a38 <rpc_gnss_event_handler+0x11c>
   459ac:	f647 71ff 	movw	r1, #32767	; 0x7fff
   459b0:	428a      	cmp	r2, r1
   459b2:	bf0c      	ite	eq
   459b4:	2203      	moveq	r2, #3
   459b6:	2202      	movne	r2, #2
   459b8:	701a      	strb	r2, [r3, #0]
   459ba:	e7f3      	b.n	459a4 <rpc_gnss_event_handler+0x88>
   459bc:	4e40      	ldr	r6, [pc, #256]	; (45ac0 <rpc_gnss_event_handler+0x1a4>)
   459be:	6833      	ldr	r3, [r6, #0]
   459c0:	2b00      	cmp	r3, #0
   459c2:	d0ef      	beq.n	459a4 <rpc_gnss_event_handler+0x88>
   459c4:	f244 0204 	movw	r2, #16388	; 0x4004
   459c8:	4291      	cmp	r1, r2
   459ca:	d80b      	bhi.n	459e4 <rpc_gnss_event_handler+0xc8>
   459cc:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   459d0:	d9e8      	bls.n	459a4 <rpc_gnss_event_handler+0x88>
   459d2:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   459d6:	3a02      	subs	r2, #2
   459d8:	2a02      	cmp	r2, #2
   459da:	d80b      	bhi.n	459f4 <rpc_gnss_event_handler+0xd8>
   459dc:	e8df f002 	tbb	[pc, r2]
   459e0:	4f45      	.short	0x4f45
   459e2:	59          	.byte	0x59
   459e3:	00          	.byte	0x00
   459e4:	f244 1301 	movw	r3, #16641	; 0x4101
   459e8:	4299      	cmp	r1, r3
   459ea:	d003      	beq.n	459f4 <rpc_gnss_event_handler+0xd8>
   459ec:	f244 2301 	movw	r3, #16897	; 0x4201
   459f0:	4299      	cmp	r1, r3
   459f2:	d1d7      	bne.n	459a4 <rpc_gnss_event_handler+0x88>
   459f4:	4f33      	ldr	r7, [pc, #204]	; (45ac4 <rpc_gnss_event_handler+0x1a8>)
   459f6:	6838      	ldr	r0, [r7, #0]
   459f8:	b108      	cbz	r0, 459fe <rpc_gnss_event_handler+0xe2>
   459fa:	f002 fd19 	bl	48430 <rpc_client_data_free>
   459fe:	f244 2301 	movw	r3, #16897	; 0x4201
   45a02:	429d      	cmp	r5, r3
   45a04:	4b30      	ldr	r3, [pc, #192]	; (45ac8 <rpc_gnss_event_handler+0x1ac>)
   45a06:	d11a      	bne.n	45a3e <rpc_gnss_event_handler+0x122>
   45a08:	2202      	movs	r2, #2
   45a0a:	603c      	str	r4, [r7, #0]
   45a0c:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   45a10:	701a      	strb	r2, [r3, #0]
   45a12:	07e3      	lsls	r3, r4, #31
   45a14:	d502      	bpl.n	45a1c <rpc_gnss_event_handler+0x100>
   45a16:	2002      	movs	r0, #2
   45a18:	6833      	ldr	r3, [r6, #0]
   45a1a:	4798      	blx	r3
   45a1c:	4d2b      	ldr	r5, [pc, #172]	; (45acc <rpc_gnss_event_handler+0x1b0>)
   45a1e:	f014 0418 	ands.w	r4, r4, #24
   45a22:	6833      	ldr	r3, [r6, #0]
   45a24:	782a      	ldrb	r2, [r5, #0]
   45a26:	d01a      	beq.n	45a5e <rpc_gnss_event_handler+0x142>
   45a28:	b91a      	cbnz	r2, 45a32 <rpc_gnss_event_handler+0x116>
   45a2a:	2005      	movs	r0, #5
   45a2c:	4798      	blx	r3
   45a2e:	2301      	movs	r3, #1
   45a30:	702b      	strb	r3, [r5, #0]
   45a32:	2001      	movs	r0, #1
   45a34:	6833      	ldr	r3, [r6, #0]
   45a36:	4798      	blx	r3
   45a38:	2000      	movs	r0, #0
   45a3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45a3e:	f244 1201 	movw	r2, #16641	; 0x4101
   45a42:	4295      	cmp	r5, r2
   45a44:	bf0b      	itete	eq
   45a46:	2201      	moveq	r2, #1
   45a48:	2200      	movne	r2, #0
   45a4a:	603c      	streq	r4, [r7, #0]
   45a4c:	603c      	strne	r4, [r7, #0]
   45a4e:	bf0b      	itete	eq
   45a50:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   45a54:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   45a58:	701a      	strbeq	r2, [r3, #0]
   45a5a:	701a      	strbne	r2, [r3, #0]
   45a5c:	e7d9      	b.n	45a12 <rpc_gnss_event_handler+0xf6>
   45a5e:	2a00      	cmp	r2, #0
   45a60:	d0e7      	beq.n	45a32 <rpc_gnss_event_handler+0x116>
   45a62:	2006      	movs	r0, #6
   45a64:	4798      	blx	r3
   45a66:	702c      	strb	r4, [r5, #0]
   45a68:	e7e3      	b.n	45a32 <rpc_gnss_event_handler+0x116>
   45a6a:	4c19      	ldr	r4, [pc, #100]	; (45ad0 <rpc_gnss_event_handler+0x1b4>)
   45a6c:	6820      	ldr	r0, [r4, #0]
   45a6e:	b108      	cbz	r0, 45a74 <rpc_gnss_event_handler+0x158>
   45a70:	f002 fcde 	bl	48430 <rpc_client_data_free>
   45a74:	683b      	ldr	r3, [r7, #0]
   45a76:	2003      	movs	r0, #3
   45a78:	6023      	str	r3, [r4, #0]
   45a7a:	6833      	ldr	r3, [r6, #0]
   45a7c:	e7db      	b.n	45a36 <rpc_gnss_event_handler+0x11a>
   45a7e:	4c15      	ldr	r4, [pc, #84]	; (45ad4 <rpc_gnss_event_handler+0x1b8>)
   45a80:	6820      	ldr	r0, [r4, #0]
   45a82:	b108      	cbz	r0, 45a88 <rpc_gnss_event_handler+0x16c>
   45a84:	f002 fcd4 	bl	48430 <rpc_client_data_free>
   45a88:	683b      	ldr	r3, [r7, #0]
   45a8a:	2004      	movs	r0, #4
   45a8c:	6023      	str	r3, [r4, #0]
   45a8e:	6833      	ldr	r3, [r6, #0]
   45a90:	e7d1      	b.n	45a36 <rpc_gnss_event_handler+0x11a>
   45a92:	7822      	ldrb	r2, [r4, #0]
   45a94:	2a03      	cmp	r2, #3
   45a96:	d885      	bhi.n	459a4 <rpc_gnss_event_handler+0x88>
   45a98:	e8df f002 	tbb	[pc, r2]
   45a9c:	09070502 	.word	0x09070502
   45aa0:	2007      	movs	r0, #7
   45aa2:	4798      	blx	r3
   45aa4:	e77e      	b.n	459a4 <rpc_gnss_event_handler+0x88>
   45aa6:	2008      	movs	r0, #8
   45aa8:	e7fb      	b.n	45aa2 <rpc_gnss_event_handler+0x186>
   45aaa:	2009      	movs	r0, #9
   45aac:	e7f9      	b.n	45aa2 <rpc_gnss_event_handler+0x186>
   45aae:	200a      	movs	r0, #10
   45ab0:	e7f7      	b.n	45aa2 <rpc_gnss_event_handler+0x186>
   45ab2:	bf00      	nop
   45ab4:	2001ea96 	.word	0x2001ea96
   45ab8:	2001ad40 	.word	0x2001ad40
   45abc:	2001acd8 	.word	0x2001acd8
   45ac0:	2001acc8 	.word	0x2001acc8
   45ac4:	2001accc 	.word	0x2001accc
   45ac8:	2001ea95 	.word	0x2001ea95
   45acc:	2001ea94 	.word	0x2001ea94
   45ad0:	2001acd4 	.word	0x2001acd4
   45ad4:	2001acd0 	.word	0x2001acd0

00045ad8 <full_dfu_ipc_irq_handler>:
   45ad8:	2301      	movs	r3, #1
   45ada:	4a03      	ldr	r2, [pc, #12]	; (45ae8 <full_dfu_ipc_irq_handler+0x10>)
   45adc:	6013      	str	r3, [r2, #0]
   45ade:	07c2      	lsls	r2, r0, #31
   45ae0:	bf44      	itt	mi
   45ae2:	4a02      	ldrmi	r2, [pc, #8]	; (45aec <full_dfu_ipc_irq_handler+0x14>)
   45ae4:	7013      	strbmi	r3, [r2, #0]
   45ae6:	4770      	bx	lr
   45ae8:	2001acdc 	.word	0x2001acdc
   45aec:	2001ea97 	.word	0x2001ea97

00045af0 <modem_ipc_wait_for_event>:
   45af0:	b538      	push	{r3, r4, r5, lr}
   45af2:	2300      	movs	r3, #0
   45af4:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   45af8:	4c0b      	ldr	r4, [pc, #44]	; (45b28 <modem_ipc_wait_for_event+0x38>)
   45afa:	6023      	str	r3, [r4, #0]
   45afc:	6823      	ldr	r3, [r4, #0]
   45afe:	b92b      	cbnz	r3, 45b0c <modem_ipc_wait_for_event+0x1c>
   45b00:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   45b04:	f002 fbea 	bl	482dc <nrf_modem_os_busywait>
   45b08:	3d01      	subs	r5, #1
   45b0a:	d1f7      	bne.n	45afc <modem_ipc_wait_for_event+0xc>
   45b0c:	6823      	ldr	r3, [r4, #0]
   45b0e:	b913      	cbnz	r3, 45b16 <modem_ipc_wait_for_event+0x26>
   45b10:	f06f 0073 	mvn.w	r0, #115	; 0x73
   45b14:	e006      	b.n	45b24 <modem_ipc_wait_for_event+0x34>
   45b16:	4b05      	ldr	r3, [pc, #20]	; (45b2c <modem_ipc_wait_for_event+0x3c>)
   45b18:	781b      	ldrb	r3, [r3, #0]
   45b1a:	2b01      	cmp	r3, #1
   45b1c:	bf14      	ite	ne
   45b1e:	2000      	movne	r0, #0
   45b20:	f06f 0004 	mvneq.w	r0, #4
   45b24:	bd38      	pop	{r3, r4, r5, pc}
   45b26:	bf00      	nop
   45b28:	2001acdc 	.word	0x2001acdc
   45b2c:	2001ea97 	.word	0x2001ea97

00045b30 <nrf_modem_full_dfu_setup>:
   45b30:	2200      	movs	r2, #0
   45b32:	2300      	movs	r3, #0
   45b34:	b5f0      	push	{r4, r5, r6, r7, lr}
   45b36:	4d2b      	ldr	r5, [pc, #172]	; (45be4 <nrf_modem_full_dfu_setup+0xb4>)
   45b38:	4e2b      	ldr	r6, [pc, #172]	; (45be8 <nrf_modem_full_dfu_setup+0xb8>)
   45b3a:	e9c5 2302 	strd	r2, r3, [r5, #8]
   45b3e:	e9c5 2304 	strd	r2, r3, [r5, #16]
   45b42:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   45b46:	4b29      	ldr	r3, [pc, #164]	; (45bec <nrf_modem_full_dfu_setup+0xbc>)
   45b48:	2400      	movs	r4, #0
   45b4a:	601a      	str	r2, [r3, #0]
   45b4c:	f100 031c 	add.w	r3, r0, #28
   45b50:	6033      	str	r3, [r6, #0]
   45b52:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   45b56:	6043      	str	r3, [r0, #4]
   45b58:	231c      	movs	r3, #28
   45b5a:	7203      	strb	r3, [r0, #8]
   45b5c:	2320      	movs	r3, #32
   45b5e:	2701      	movs	r7, #1
   45b60:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   45b64:	7243      	strb	r3, [r0, #9]
   45b66:	4b22      	ldr	r3, [pc, #136]	; (45bf0 <nrf_modem_full_dfu_setup+0xc0>)
   45b68:	7004      	strb	r4, [r0, #0]
   45b6a:	7044      	strb	r4, [r0, #1]
   45b6c:	70c2      	strb	r2, [r0, #3]
   45b6e:	7284      	strb	r4, [r0, #10]
   45b70:	72c4      	strb	r4, [r0, #11]
   45b72:	7087      	strb	r7, [r0, #2]
   45b74:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   45b78:	702c      	strb	r4, [r5, #0]
   45b7a:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   45b7e:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   45b82:	4b1c      	ldr	r3, [pc, #112]	; (45bf4 <nrf_modem_full_dfu_setup+0xc4>)
   45b84:	b093      	sub	sp, #76	; 0x4c
   45b86:	4622      	mov	r2, r4
   45b88:	4620      	mov	r0, r4
   45b8a:	491b      	ldr	r1, [pc, #108]	; (45bf8 <nrf_modem_full_dfu_setup+0xc8>)
   45b8c:	701c      	strb	r4, [r3, #0]
   45b8e:	f7fe fce5 	bl	4455c <nrfx_ipc_init>
   45b92:	4621      	mov	r1, r4
   45b94:	2240      	movs	r2, #64	; 0x40
   45b96:	a801      	add	r0, sp, #4
   45b98:	f002 fa31 	bl	47ffe <memset>
   45b9c:	2302      	movs	r3, #2
   45b9e:	9302      	str	r3, [sp, #8]
   45ba0:	2304      	movs	r3, #4
   45ba2:	930b      	str	r3, [sp, #44]	; 0x2c
   45ba4:	2305      	movs	r3, #5
   45ba6:	a801      	add	r0, sp, #4
   45ba8:	9311      	str	r3, [sp, #68]	; 0x44
   45baa:	9709      	str	r7, [sp, #36]	; 0x24
   45bac:	f7fe fcee 	bl	4458c <nrfx_ipc_config_load>
   45bb0:	4b12      	ldr	r3, [pc, #72]	; (45bfc <nrf_modem_full_dfu_setup+0xcc>)
   45bb2:	9400      	str	r4, [sp, #0]
   45bb4:	6836      	ldr	r6, [r6, #0]
   45bb6:	601c      	str	r4, [r3, #0]
   45bb8:	681b      	ldr	r3, [r3, #0]
   45bba:	9300      	str	r3, [sp, #0]
   45bbc:	9b00      	ldr	r3, [sp, #0]
   45bbe:	f7ff ff97 	bl	45af0 <modem_ipc_wait_for_event>
   45bc2:	4604      	mov	r4, r0
   45bc4:	b130      	cbz	r0, 45bd4 <nrf_modem_full_dfu_setup+0xa4>
   45bc6:	2303      	movs	r3, #3
   45bc8:	702b      	strb	r3, [r5, #0]
   45bca:	f7fe fcff 	bl	445cc <nrfx_ipc_uninit>
   45bce:	4620      	mov	r0, r4
   45bd0:	b013      	add	sp, #76	; 0x4c
   45bd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   45bd4:	6832      	ldr	r2, [r6, #0]
   45bd6:	4b0a      	ldr	r3, [pc, #40]	; (45c00 <nrf_modem_full_dfu_setup+0xd0>)
   45bd8:	429a      	cmp	r2, r3
   45bda:	d0f8      	beq.n	45bce <nrf_modem_full_dfu_setup+0x9e>
   45bdc:	f06f 0404 	mvn.w	r4, #4
   45be0:	e7f3      	b.n	45bca <nrf_modem_full_dfu_setup+0x9a>
   45be2:	bf00      	nop
   45be4:	2001a6c8 	.word	0x2001a6c8
   45be8:	2001ace0 	.word	0x2001ace0
   45bec:	2001ace4 	.word	0x2001ace4
   45bf0:	4002a000 	.word	0x4002a000
   45bf4:	2001ea97 	.word	0x2001ea97
   45bf8:	00045ad9 	.word	0x00045ad9
   45bfc:	40005610 	.word	0x40005610
   45c00:	a5000001 	.word	0xa5000001

00045c04 <modem_off>:
   45c04:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45c06:	2501      	movs	r5, #1
   45c08:	4c07      	ldr	r4, [pc, #28]	; (45c28 <modem_off+0x24>)
   45c0a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   45c0e:	6065      	str	r5, [r4, #4]
   45c10:	f002 fb64 	bl	482dc <nrf_modem_os_busywait>
   45c14:	2300      	movs	r3, #0
   45c16:	6063      	str	r3, [r4, #4]
   45c18:	9301      	str	r3, [sp, #4]
   45c1a:	6025      	str	r5, [r4, #0]
   45c1c:	6823      	ldr	r3, [r4, #0]
   45c1e:	9301      	str	r3, [sp, #4]
   45c20:	9b01      	ldr	r3, [sp, #4]
   45c22:	b003      	add	sp, #12
   45c24:	bd30      	pop	{r4, r5, pc}
   45c26:	bf00      	nop
   45c28:	40005610 	.word	0x40005610

00045c2c <nrf_modem_init>:
   45c2c:	b570      	push	{r4, r5, r6, lr}
   45c2e:	460d      	mov	r5, r1
   45c30:	b300      	cbz	r0, 45c74 <nrf_modem_init+0x48>
   45c32:	4e15      	ldr	r6, [pc, #84]	; (45c88 <nrf_modem_init+0x5c>)
   45c34:	7832      	ldrb	r2, [r6, #0]
   45c36:	bb02      	cbnz	r2, 45c7a <nrf_modem_init+0x4e>
   45c38:	2901      	cmp	r1, #1
   45c3a:	d113      	bne.n	45c64 <nrf_modem_init+0x38>
   45c3c:	68c1      	ldr	r1, [r0, #12]
   45c3e:	6842      	ldr	r2, [r0, #4]
   45c40:	440a      	add	r2, r1
   45c42:	6941      	ldr	r1, [r0, #20]
   45c44:	440a      	add	r2, r1
   45c46:	69c1      	ldr	r1, [r0, #28]
   45c48:	440a      	add	r2, r1
   45c4a:	f242 011b 	movw	r1, #8219	; 0x201b
   45c4e:	428a      	cmp	r2, r1
   45c50:	d916      	bls.n	45c80 <nrf_modem_init+0x54>
   45c52:	6800      	ldr	r0, [r0, #0]
   45c54:	f7ff ff6c 	bl	45b30 <nrf_modem_full_dfu_setup>
   45c58:	4604      	mov	r4, r0
   45c5a:	b130      	cbz	r0, 45c6a <nrf_modem_init+0x3e>
   45c5c:	f7ff ffd2 	bl	45c04 <modem_off>
   45c60:	4620      	mov	r0, r4
   45c62:	bd70      	pop	{r4, r5, r6, pc}
   45c64:	f002 fc48 	bl	484f8 <nrf_modem_platform_init>
   45c68:	e7f6      	b.n	45c58 <nrf_modem_init+0x2c>
   45c6a:	4b08      	ldr	r3, [pc, #32]	; (45c8c <nrf_modem_init+0x60>)
   45c6c:	701d      	strb	r5, [r3, #0]
   45c6e:	2301      	movs	r3, #1
   45c70:	7033      	strb	r3, [r6, #0]
   45c72:	e7f5      	b.n	45c60 <nrf_modem_init+0x34>
   45c74:	f06f 040d 	mvn.w	r4, #13
   45c78:	e7f2      	b.n	45c60 <nrf_modem_init+0x34>
   45c7a:	f04f 34ff 	mov.w	r4, #4294967295
   45c7e:	e7ef      	b.n	45c60 <nrf_modem_init+0x34>
   45c80:	f06f 040b 	mvn.w	r4, #11
   45c84:	e7ec      	b.n	45c60 <nrf_modem_init+0x34>
   45c86:	bf00      	nop
   45c88:	2001ea98 	.word	0x2001ea98
   45c8c:	2001ea99 	.word	0x2001ea99

00045c90 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
   45c90:	4b02      	ldr	r3, [pc, #8]	; (45c9c <mbedtls_platform_set_calloc_free+0xc>)
   45c92:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
   45c94:	4b02      	ldr	r3, [pc, #8]	; (45ca0 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
   45c96:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
   45c98:	6019      	str	r1, [r3, #0]
}
   45c9a:	4770      	bx	lr
   45c9c:	2001a584 	.word	0x2001a584
   45ca0:	2001a588 	.word	0x2001a588

00045ca4 <_heap_init>:
 *
 * Not static in order to allow extern use.
 */
void _heap_init(void)
{
	mbedtls_memory_buffer_alloc_init(mbedtls_heap, sizeof(mbedtls_heap));
   45ca4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   45ca8:	4801      	ldr	r0, [pc, #4]	; (45cb0 <_heap_init+0xc>)
   45caa:	f000 b947 	b.w	45f3c <mbedtls_memory_buffer_alloc_init>
   45cae:	bf00      	nop
   45cb0:	2001ea9a 	.word	0x2001ea9a

00045cb4 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
   45cb4:	6801      	ldr	r1, [r0, #0]
   45cb6:	4a0e      	ldr	r2, [pc, #56]	; (45cf0 <verify_header+0x3c>)
{
   45cb8:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
   45cba:	4291      	cmp	r1, r2
   45cbc:	d115      	bne.n	45cea <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
   45cbe:	69c1      	ldr	r1, [r0, #28]
   45cc0:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
   45cc4:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
   45cc8:	4291      	cmp	r1, r2
   45cca:	d10e      	bne.n	45cea <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
   45ccc:	6882      	ldr	r2, [r0, #8]
   45cce:	2a01      	cmp	r2, #1
   45cd0:	d80b      	bhi.n	45cea <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
   45cd2:	68c2      	ldr	r2, [r0, #12]
   45cd4:	b112      	cbz	r2, 45cdc <verify_header+0x28>
   45cd6:	6901      	ldr	r1, [r0, #16]
   45cd8:	428a      	cmp	r2, r1
   45cda:	d006      	beq.n	45cea <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
   45cdc:	6958      	ldr	r0, [r3, #20]
   45cde:	b128      	cbz	r0, 45cec <verify_header+0x38>
   45ce0:	699b      	ldr	r3, [r3, #24]
   45ce2:	1a1b      	subs	r3, r3, r0
   45ce4:	4258      	negs	r0, r3
   45ce6:	4158      	adcs	r0, r3
   45ce8:	4770      	bx	lr
        return( 1 );
   45cea:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
   45cec:	4770      	bx	lr
   45cee:	bf00      	nop
   45cf0:	ff00aa55 	.word	0xff00aa55

00045cf4 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
   45cf4:	4b0d      	ldr	r3, [pc, #52]	; (45d2c <verify_chain+0x38>)
{
   45cf6:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
   45cf8:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
   45cfa:	b1a6      	cbz	r6, 45d26 <verify_chain+0x32>
   45cfc:	4630      	mov	r0, r6
   45cfe:	f7ff ffd9 	bl	45cb4 <verify_header>
   45d02:	4604      	mov	r4, r0
   45d04:	b978      	cbnz	r0, 45d26 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
   45d06:	68f3      	ldr	r3, [r6, #12]
   45d08:	b96b      	cbnz	r3, 45d26 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
   45d0a:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
   45d0c:	b90d      	cbnz	r5, 45d12 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
   45d0e:	4620      	mov	r0, r4
   45d10:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
   45d12:	4628      	mov	r0, r5
   45d14:	f7ff ffce 	bl	45cb4 <verify_header>
   45d18:	b928      	cbnz	r0, 45d26 <verify_chain+0x32>
        if( cur->prev != prv )
   45d1a:	68eb      	ldr	r3, [r5, #12]
   45d1c:	42b3      	cmp	r3, r6
   45d1e:	d102      	bne.n	45d26 <verify_chain+0x32>
        cur = cur->next;
   45d20:	462e      	mov	r6, r5
   45d22:	692d      	ldr	r5, [r5, #16]
   45d24:	e7f2      	b.n	45d0c <verify_chain+0x18>
        return( 1 );
   45d26:	2401      	movs	r4, #1
   45d28:	e7f1      	b.n	45d0e <verify_chain+0x1a>
   45d2a:	bf00      	nop
   45d2c:	2001ace8 	.word	0x2001ace8

00045d30 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
   45d30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
   45d34:	4d3e      	ldr	r5, [pc, #248]	; (45e30 <buffer_alloc_calloc+0x100>)
   45d36:	682c      	ldr	r4, [r5, #0]
   45d38:	b1d4      	cbz	r4, 45d70 <buffer_alloc_calloc+0x40>
   45d3a:	68ac      	ldr	r4, [r5, #8]
   45d3c:	b1c4      	cbz	r4, 45d70 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
   45d3e:	2800      	cmp	r0, #0
   45d40:	d04b      	beq.n	45dda <buffer_alloc_calloc+0xaa>
   45d42:	2900      	cmp	r1, #0
   45d44:	d049      	beq.n	45dda <buffer_alloc_calloc+0xaa>
    original_len = len = n * size;
   45d46:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
   45d4a:	fbb6 f0f0 	udiv	r0, r6, r0
   45d4e:	4288      	cmp	r0, r1
   45d50:	d143      	bne.n	45dda <buffer_alloc_calloc+0xaa>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45d52:	1d30      	adds	r0, r6, #4
   45d54:	d841      	bhi.n	45dda <buffer_alloc_calloc+0xaa>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45d56:	07b1      	lsls	r1, r6, #30
   45d58:	d00d      	beq.n	45d76 <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45d5a:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45d5e:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
   45d60:	68ec      	ldr	r4, [r5, #12]
   45d62:	e003      	b.n	45d6c <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
   45d64:	6863      	ldr	r3, [r4, #4]
   45d66:	42bb      	cmp	r3, r7
   45d68:	d239      	bcs.n	45dde <buffer_alloc_calloc+0xae>
            break;

        cur = cur->next_free;
   45d6a:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
   45d6c:	2c00      	cmp	r4, #0
   45d6e:	d1f9      	bne.n	45d64 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
   45d70:	4620      	mov	r0, r4
   45d72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   45d76:	4637      	mov	r7, r6
   45d78:	e7f2      	b.n	45d60 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
   45d7a:	60e8      	str	r0, [r5, #12]
   45d7c:	e041      	b.n	45e02 <buffer_alloc_calloc+0xd2>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
   45d7e:	f107 0c20 	add.w	ip, r7, #32
   45d82:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
   45d86:	3920      	subs	r1, #32
   45d88:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
   45d8a:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
   45d8c:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 45e34 <buffer_alloc_calloc+0x104>
    new->prev = cur;
   45d90:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
   45d94:	6921      	ldr	r1, [r4, #16]
   45d96:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
   45d98:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
   45d9c:	f8df c098 	ldr.w	ip, [pc, #152]	; 45e38 <buffer_alloc_calloc+0x108>
   45da0:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
   45da4:	b101      	cbz	r1, 45da8 <buffer_alloc_calloc+0x78>
        new->next->prev = new;
   45da6:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
   45da8:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
   45dac:	b19a      	cbz	r2, 45dd6 <buffer_alloc_calloc+0xa6>
        new->prev_free->next_free = new;
   45dae:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
   45db0:	699a      	ldr	r2, [r3, #24]
   45db2:	b102      	cbz	r2, 45db6 <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
   45db4:	6153      	str	r3, [r2, #20]
    cur->next = new;
   45db6:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
   45db8:	2300      	movs	r3, #0
    cur->alloc = 1;
   45dba:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
   45dbe:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45dc2:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
   45dc4:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45dc8:	07db      	lsls	r3, r3, #31
   45dca:	d529      	bpl.n	45e20 <buffer_alloc_calloc+0xf0>
   45dcc:	f7ff ff92 	bl	45cf4 <verify_chain>
   45dd0:	b330      	cbz	r0, 45e20 <buffer_alloc_calloc+0xf0>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void _exit(int status);
static inline void exit(int status)
{
	_exit(status);
   45dd2:	4648      	mov	r0, r9
   45dd4:	e022      	b.n	45e1c <buffer_alloc_calloc+0xec>
        heap.first_free = new;
   45dd6:	60eb      	str	r3, [r5, #12]
   45dd8:	e7ea      	b.n	45db0 <buffer_alloc_calloc+0x80>
        return( NULL );
   45dda:	2400      	movs	r4, #0
   45ddc:	e7c8      	b.n	45d70 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
   45dde:	68a3      	ldr	r3, [r4, #8]
   45de0:	b113      	cbz	r3, 45de8 <buffer_alloc_calloc+0xb8>
   45de2:	2001      	movs	r0, #1
   45de4:	f7fc fe58 	bl	42a98 <_exit>
    if( cur->size - len < sizeof(memory_header) +
   45de8:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
   45dec:	6861      	ldr	r1, [r4, #4]
   45dee:	f104 0820 	add.w	r8, r4, #32
   45df2:	1bc9      	subs	r1, r1, r7
   45df4:	2923      	cmp	r1, #35	; 0x23
   45df6:	d8c2      	bhi.n	45d7e <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
   45df8:	2301      	movs	r3, #1
   45dfa:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
   45dfc:	2a00      	cmp	r2, #0
   45dfe:	d0bc      	beq.n	45d7a <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
   45e00:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
   45e02:	69a3      	ldr	r3, [r4, #24]
   45e04:	b103      	cbz	r3, 45e08 <buffer_alloc_calloc+0xd8>
            cur->next_free->prev_free = cur->prev_free;
   45e06:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
   45e08:	2300      	movs	r3, #0
        cur->next_free = NULL;
   45e0a:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45e0e:	692b      	ldr	r3, [r5, #16]
   45e10:	07da      	lsls	r2, r3, #31
   45e12:	d505      	bpl.n	45e20 <buffer_alloc_calloc+0xf0>
   45e14:	f7ff ff6e 	bl	45cf4 <verify_chain>
   45e18:	b110      	cbz	r0, 45e20 <buffer_alloc_calloc+0xf0>
   45e1a:	2001      	movs	r0, #1
   45e1c:	f7fc fe3c 	bl	42a98 <_exit>
    memset( ret, 0, original_len );
   45e20:	4632      	mov	r2, r6
   45e22:	2100      	movs	r1, #0
   45e24:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
   45e26:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
   45e28:	f002 f8e9 	bl	47ffe <memset>
    return( ret );
   45e2c:	e7a0      	b.n	45d70 <buffer_alloc_calloc+0x40>
   45e2e:	bf00      	nop
   45e30:	2001ace8 	.word	0x2001ace8
   45e34:	ff00aa55 	.word	0xff00aa55
   45e38:	ee119966 	.word	0xee119966

00045e3c <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
   45e3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
   45e3e:	4605      	mov	r5, r0
   45e40:	2800      	cmp	r0, #0
   45e42:	d078      	beq.n	45f36 <buffer_alloc_free+0xfa>
   45e44:	4e3c      	ldr	r6, [pc, #240]	; (45f38 <buffer_alloc_free+0xfc>)
   45e46:	6833      	ldr	r3, [r6, #0]
   45e48:	2b00      	cmp	r3, #0
   45e4a:	d074      	beq.n	45f36 <buffer_alloc_free+0xfa>
   45e4c:	68b2      	ldr	r2, [r6, #8]
   45e4e:	2a00      	cmp	r2, #0
   45e50:	d071      	beq.n	45f36 <buffer_alloc_free+0xfa>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
   45e52:	4283      	cmp	r3, r0
   45e54:	d803      	bhi.n	45e5e <buffer_alloc_free+0x22>
   45e56:	6872      	ldr	r2, [r6, #4]
   45e58:	4413      	add	r3, r2
   45e5a:	4298      	cmp	r0, r3
   45e5c:	d302      	bcc.n	45e64 <buffer_alloc_free+0x28>
   45e5e:	2001      	movs	r0, #1
   45e60:	f7fc fe1a 	bl	42a98 <_exit>
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
    }

    p -= sizeof(memory_header);
   45e64:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
   45e68:	4620      	mov	r0, r4
   45e6a:	f7ff ff23 	bl	45cb4 <verify_header>
   45e6e:	b110      	cbz	r0, 45e76 <buffer_alloc_free+0x3a>
   45e70:	2001      	movs	r0, #1
   45e72:	f7fc fe11 	bl	42a98 <_exit>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
   45e76:	f855 3c18 	ldr.w	r3, [r5, #-24]
   45e7a:	2b01      	cmp	r3, #1
   45e7c:	d002      	beq.n	45e84 <buffer_alloc_free+0x48>
   45e7e:	2001      	movs	r0, #1
   45e80:	f7fc fe0a 	bl	42a98 <_exit>
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
    }

    hdr->alloc = 0;
   45e84:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45e86:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
   45e8a:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45e8e:	b1af      	cbz	r7, 45ebc <buffer_alloc_free+0x80>
   45e90:	68ba      	ldr	r2, [r7, #8]
   45e92:	b992      	cbnz	r2, 45eba <buffer_alloc_free+0x7e>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
   45e94:	f855 3c1c 	ldr.w	r3, [r5, #-28]
   45e98:	f103 0220 	add.w	r2, r3, #32
   45e9c:	687b      	ldr	r3, [r7, #4]
   45e9e:	4413      	add	r3, r2
   45ea0:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
   45ea2:	f855 3c10 	ldr.w	r3, [r5, #-16]
   45ea6:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
   45ea8:	b103      	cbz	r3, 45eac <buffer_alloc_free+0x70>
            hdr->next->prev = hdr;
   45eaa:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45eac:	4620      	mov	r0, r4
   45eae:	2220      	movs	r2, #32
   45eb0:	2100      	movs	r1, #0
   45eb2:	f002 f8a4 	bl	47ffe <memset>
   45eb6:	4623      	mov	r3, r4
   45eb8:	463c      	mov	r4, r7
    memory_header *hdr, *old = NULL;
   45eba:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
   45ebc:	6920      	ldr	r0, [r4, #16]
   45ebe:	2800      	cmp	r0, #0
   45ec0:	d031      	beq.n	45f26 <buffer_alloc_free+0xea>
   45ec2:	6883      	ldr	r3, [r0, #8]
   45ec4:	2b00      	cmp	r3, #0
   45ec6:	d12e      	bne.n	45f26 <buffer_alloc_free+0xea>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
   45ec8:	6863      	ldr	r3, [r4, #4]
   45eca:	6842      	ldr	r2, [r0, #4]
   45ecc:	3320      	adds	r3, #32
   45ece:	4413      	add	r3, r2
   45ed0:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
   45ed2:	6903      	ldr	r3, [r0, #16]
   45ed4:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
   45ed8:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
   45eda:	b9d2      	cbnz	r2, 45f12 <buffer_alloc_free+0xd6>
   45edc:	b9f9      	cbnz	r1, 45f1e <buffer_alloc_free+0xe2>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
   45ede:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
   45ee0:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
   45ee2:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
   45ee4:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
   45ee6:	b1e2      	cbz	r2, 45f22 <buffer_alloc_free+0xe6>
            hdr->prev_free->next_free = hdr;
   45ee8:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
   45eea:	69a2      	ldr	r2, [r4, #24]
   45eec:	b102      	cbz	r2, 45ef0 <buffer_alloc_free+0xb4>
            hdr->next_free->prev_free = hdr;
   45eee:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
   45ef0:	b103      	cbz	r3, 45ef4 <buffer_alloc_free+0xb8>
            hdr->next->prev = hdr;
   45ef2:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45ef4:	2220      	movs	r2, #32
   45ef6:	2100      	movs	r1, #0
   45ef8:	f002 f881 	bl	47ffe <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
   45efc:	6933      	ldr	r3, [r6, #16]
   45efe:	079b      	lsls	r3, r3, #30
   45f00:	d519      	bpl.n	45f36 <buffer_alloc_free+0xfa>
   45f02:	f7ff fef7 	bl	45cf4 <verify_chain>
   45f06:	b1b0      	cbz	r0, 45f36 <buffer_alloc_free+0xfa>
        mbedtls_exit( 1 );
}
   45f08:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   45f0c:	2001      	movs	r0, #1
   45f0e:	f7fc bdc3 	b.w	42a98 <_exit>
                hdr->prev_free->next_free = hdr->next_free;
   45f12:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
   45f14:	69a1      	ldr	r1, [r4, #24]
   45f16:	2900      	cmp	r1, #0
   45f18:	d0e1      	beq.n	45ede <buffer_alloc_free+0xa2>
                hdr->next_free->prev_free = hdr->prev_free;
   45f1a:	614a      	str	r2, [r1, #20]
   45f1c:	e7df      	b.n	45ede <buffer_alloc_free+0xa2>
                heap.first_free = hdr->next_free;
   45f1e:	60f1      	str	r1, [r6, #12]
   45f20:	e7f8      	b.n	45f14 <buffer_alloc_free+0xd8>
            heap.first_free = hdr;
   45f22:	60f4      	str	r4, [r6, #12]
   45f24:	e7e1      	b.n	45eea <buffer_alloc_free+0xae>
    if( old == NULL )
   45f26:	2f00      	cmp	r7, #0
   45f28:	d1e8      	bne.n	45efc <buffer_alloc_free+0xc0>
        hdr->next_free = heap.first_free;
   45f2a:	68f3      	ldr	r3, [r6, #12]
   45f2c:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
   45f2e:	b103      	cbz	r3, 45f32 <buffer_alloc_free+0xf6>
            heap.first_free->prev_free = hdr;
   45f30:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
   45f32:	60f4      	str	r4, [r6, #12]
   45f34:	e7e2      	b.n	45efc <buffer_alloc_free+0xc0>
}
   45f36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   45f38:	2001ace8 	.word	0x2001ace8

00045f3c <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
   45f3c:	b538      	push	{r3, r4, r5, lr}
   45f3e:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45f40:	2214      	movs	r2, #20
   45f42:	2100      	movs	r1, #0
{
   45f44:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45f46:	4812      	ldr	r0, [pc, #72]	; (45f90 <mbedtls_memory_buffer_alloc_init+0x54>)
   45f48:	f002 f859 	bl	47ffe <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
   45f4c:	4911      	ldr	r1, [pc, #68]	; (45f94 <mbedtls_memory_buffer_alloc_init+0x58>)
   45f4e:	4812      	ldr	r0, [pc, #72]	; (45f98 <mbedtls_memory_buffer_alloc_init+0x5c>)
   45f50:	f7ff fe9e 	bl	45c90 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45f54:	2d23      	cmp	r5, #35	; 0x23
   45f56:	d91a      	bls.n	45f8e <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45f58:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45f5c:	bf1f      	itttt	ne
   45f5e:	3d04      	subne	r5, #4
   45f60:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45f62:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45f66:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
   45f68:	462a      	mov	r2, r5
   45f6a:	2100      	movs	r1, #0
   45f6c:	4620      	mov	r0, r4
   45f6e:	f002 f846 	bl	47ffe <memset>

    heap.buf = buf;
   45f72:	4b07      	ldr	r3, [pc, #28]	; (45f90 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
   45f74:	4a09      	ldr	r2, [pc, #36]	; (45f9c <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
   45f76:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
   45f7a:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
   45f7c:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
   45f7e:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
   45f82:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
   45f84:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
   45f88:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
   45f8a:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
   45f8c:	60dc      	str	r4, [r3, #12]
}
   45f8e:	bd38      	pop	{r3, r4, r5, pc}
   45f90:	2001ace8 	.word	0x2001ace8
   45f94:	00045e3d 	.word	0x00045e3d
   45f98:	00045d31 	.word	0x00045d31
   45f9c:	ff00aa55 	.word	0xff00aa55

00045fa0 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45fa0:	4b0e      	ldr	r3, [pc, #56]	; (45fdc <z_sys_init_run_level+0x3c>)
{
   45fa2:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45fa4:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   45fa8:	3001      	adds	r0, #1
   45faa:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   45fae:	42a6      	cmp	r6, r4
   45fb0:	d800      	bhi.n	45fb4 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   45fb2:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   45fb4:	e9d4 3500 	ldrd	r3, r5, [r4]
   45fb8:	4628      	mov	r0, r5
   45fba:	4798      	blx	r3
		if (dev != NULL) {
   45fbc:	b165      	cbz	r5, 45fd8 <z_sys_init_run_level+0x38>
			if (rc != 0) {
   45fbe:	68eb      	ldr	r3, [r5, #12]
   45fc0:	b130      	cbz	r0, 45fd0 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   45fc2:	2800      	cmp	r0, #0
   45fc4:	bfb8      	it	lt
   45fc6:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   45fc8:	28ff      	cmp	r0, #255	; 0xff
   45fca:	bfa8      	it	ge
   45fcc:	20ff      	movge	r0, #255	; 0xff
   45fce:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   45fd0:	785a      	ldrb	r2, [r3, #1]
   45fd2:	f042 0201 	orr.w	r2, r2, #1
   45fd6:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   45fd8:	3408      	adds	r4, #8
   45fda:	e7e8      	b.n	45fae <z_sys_init_run_level+0xe>
   45fdc:	00048f5c 	.word	0x00048f5c

00045fe0 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   45fe0:	4b01      	ldr	r3, [pc, #4]	; (45fe8 <z_impl_z_errno+0x8>)
   45fe2:	6898      	ldr	r0, [r3, #8]
}
   45fe4:	3060      	adds	r0, #96	; 0x60
   45fe6:	4770      	bx	lr
   45fe8:	2001acfc 	.word	0x2001acfc

00045fec <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   45fec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   45ff0:	4606      	mov	r6, r0
   45ff2:	460f      	mov	r7, r1
	__asm__ volatile(
   45ff4:	f04f 0320 	mov.w	r3, #32
   45ff8:	f3ef 8811 	mrs	r8, BASEPRI
   45ffc:	f383 8812 	msr	BASEPRI_MAX, r3
   46000:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   46004:	f000 fe32 	bl	46c6c <z_impl_z_current_get>
   46008:	4c21      	ldr	r4, [pc, #132]	; (46090 <z_fatal_error+0xa4>)
   4600a:	4b22      	ldr	r3, [pc, #136]	; (46094 <z_fatal_error+0xa8>)
   4600c:	2e04      	cmp	r6, #4
   4600e:	eba4 0403 	sub.w	r4, r4, r3
   46012:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   46016:	bf98      	it	ls
   46018:	4a1f      	ldrls	r2, [pc, #124]	; (46098 <z_fatal_error+0xac>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4601a:	ea4f 1484 	mov.w	r4, r4, lsl #6
   4601e:	f044 0301 	orr.w	r3, r4, #1
   46022:	4605      	mov	r5, r0
	switch (reason) {
   46024:	bf94      	ite	ls
   46026:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4602a:	4a1c      	ldrhi	r2, [pc, #112]	; (4609c <z_fatal_error+0xb0>)
   4602c:	f8ad 3000 	strh.w	r3, [sp]
   46030:	4631      	mov	r1, r6
   46032:	2300      	movs	r3, #0
   46034:	481a      	ldr	r0, [pc, #104]	; (460a0 <z_fatal_error+0xb4>)
   46036:	f001 fd12 	bl	47a5e <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   4603a:	b147      	cbz	r7, 4604e <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   4603c:	69fb      	ldr	r3, [r7, #28]
   4603e:	f3c3 0308 	ubfx	r3, r3, #0, #9
   46042:	b123      	cbz	r3, 4604e <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
   46044:	4817      	ldr	r0, [pc, #92]	; (460a4 <z_fatal_error+0xb8>)
   46046:	f044 0101 	orr.w	r1, r4, #1
   4604a:	f001 fcce 	bl	479ea <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   4604e:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   46052:	b12d      	cbz	r5, 46060 <z_fatal_error+0x74>
   46054:	4628      	mov	r0, r5
   46056:	f002 fb3c 	bl	486d2 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   4605a:	b108      	cbz	r0, 46060 <z_fatal_error+0x74>
   4605c:	7803      	ldrb	r3, [r0, #0]
   4605e:	b903      	cbnz	r3, 46062 <z_fatal_error+0x76>
		thread_name = "unknown";
   46060:	4811      	ldr	r0, [pc, #68]	; (460a8 <z_fatal_error+0xbc>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
   46062:	f7fb f92d 	bl	412c0 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
   46066:	4623      	mov	r3, r4
   46068:	4602      	mov	r2, r0
   4606a:	4629      	mov	r1, r5
   4606c:	480f      	ldr	r0, [pc, #60]	; (460ac <z_fatal_error+0xc0>)
   4606e:	f001 fcdd 	bl	47a2c <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   46072:	4639      	mov	r1, r7
   46074:	4630      	mov	r0, r6
   46076:	f7fd fe05 	bl	43c84 <k_sys_fatal_error_handler>
	__asm__ volatile(
   4607a:	f388 8811 	msr	BASEPRI, r8
   4607e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   46082:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   46084:	b002      	add	sp, #8
   46086:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   4608a:	f7fc bb3b 	b.w	42704 <z_impl_k_thread_abort>
   4608e:	bf00      	nop
   46090:	00048d40 	.word	0x00048d40
   46094:	00048d10 	.word	0x00048d10
   46098:	00048f74 	.word	0x00048f74
   4609c:	000496de 	.word	0x000496de
   460a0:	000496f4 	.word	0x000496f4
   460a4:	0004971c 	.word	0x0004971c
   460a8:	000496ec 	.word	0x000496ec
   460ac:	0004973d 	.word	0x0004973d

000460b0 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   460b0:	2300      	movs	r3, #0
   460b2:	2201      	movs	r2, #1
{
   460b4:	b510      	push	{r4, lr}
   460b6:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   460b8:	e9cd 2304 	strd	r2, r3, [sp, #16]
   460bc:	220f      	movs	r2, #15
   460be:	9301      	str	r3, [sp, #4]
   460c0:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   460c4:	2318      	movs	r3, #24
   460c6:	4a0b      	ldr	r2, [pc, #44]	; (460f4 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   460c8:	4c0b      	ldr	r4, [pc, #44]	; (460f8 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   460ca:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   460ce:	f44f 72a0 	mov.w	r2, #320	; 0x140
   460d2:	490a      	ldr	r1, [pc, #40]	; (460fc <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   460d4:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   460d8:	fb02 1100 	mla	r1, r2, r0, r1
   460dc:	9300      	str	r3, [sp, #0]
   460de:	4620      	mov	r0, r4
   460e0:	4b07      	ldr	r3, [pc, #28]	; (46100 <init_idle_thread+0x50>)
   460e2:	f000 f90b 	bl	462fc <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   460e6:	7b63      	ldrb	r3, [r4, #13]
   460e8:	f023 0304 	bic.w	r3, r3, #4
   460ec:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   460ee:	b006      	add	sp, #24
   460f0:	bd10      	pop	{r4, pc}
   460f2:	bf00      	nop
   460f4:	2001acfc 	.word	0x2001acfc
   460f8:	2001a6e0 	.word	0x2001a6e0
   460fc:	200231a0 	.word	0x200231a0
   46100:	00046445 	.word	0x00046445

00046104 <bg_thread_main>:
	z_sys_post_kernel = true;
   46104:	2201      	movs	r2, #1
{
   46106:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   46108:	4b09      	ldr	r3, [pc, #36]	; (46130 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   4610a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   4610c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   4610e:	f7ff ff47 	bl	45fa0 <z_sys_init_run_level>
	boot_banner();
   46112:	f001 f81d 	bl	47150 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   46116:	2003      	movs	r0, #3
   46118:	f7ff ff42 	bl	45fa0 <z_sys_init_run_level>
	z_init_static_threads();
   4611c:	f000 f94a 	bl	463b4 <z_init_static_threads>
	main();
   46120:	f7fa f98e 	bl	40440 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   46124:	4a03      	ldr	r2, [pc, #12]	; (46134 <bg_thread_main+0x30>)
   46126:	7b13      	ldrb	r3, [r2, #12]
   46128:	f023 0301 	bic.w	r3, r3, #1
   4612c:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   4612e:	bd08      	pop	{r3, pc}
   46130:	20020a9a 	.word	0x20020a9a
   46134:	2001a760 	.word	0x2001a760

00046138 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   46138:	4802      	ldr	r0, [pc, #8]	; (46144 <z_bss_zero+0xc>)
   4613a:	4a03      	ldr	r2, [pc, #12]	; (46148 <z_bss_zero+0x10>)
   4613c:	2100      	movs	r1, #0
   4613e:	1a12      	subs	r2, r2, r0
   46140:	f001 bf5d 	b.w	47ffe <memset>
   46144:	2001a5f0 	.word	0x2001a5f0
   46148:	20020a9c 	.word	0x20020a9c

0004614c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   4614c:	b580      	push	{r7, lr}
   4614e:	b0a6      	sub	sp, #152	; 0x98
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   46150:	f7fb f806 	bl	41160 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   46154:	4b2f      	ldr	r3, [pc, #188]	; (46214 <z_cstart+0xc8>)
	uint32_t msp =
   46156:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   4615a:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   4615e:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   46162:	2400      	movs	r4, #0
   46164:	23e0      	movs	r3, #224	; 0xe0
   46166:	4d2c      	ldr	r5, [pc, #176]	; (46218 <z_cstart+0xcc>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   46168:	4e2c      	ldr	r6, [pc, #176]	; (4621c <z_cstart+0xd0>)
   4616a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   4616e:	77ec      	strb	r4, [r5, #31]
   46170:	762c      	strb	r4, [r5, #24]
   46172:	766c      	strb	r4, [r5, #25]
   46174:	76ac      	strb	r4, [r5, #26]
   46176:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   4617a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4617c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 46230 <z_cstart+0xe4>
   46180:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   46184:	626b      	str	r3, [r5, #36]	; 0x24
   46186:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   4618a:	f7fc fa33 	bl	425f4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   4618e:	f7fb fe8f 	bl	41eb0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   46192:	f04f 33ff 	mov.w	r3, #4294967295
   46196:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   46198:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   4619a:	f7fc fc3f 	bl	42a1c <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   4619e:	f7fc fac3 	bl	42728 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   461a2:	f240 1301 	movw	r3, #257	; 0x101
   461a6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   461aa:	ab06      	add	r3, sp, #24
   461ac:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   461ae:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   461b2:	f002 f9c0 	bl	48536 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   461b6:	4620      	mov	r0, r4
   461b8:	f7ff fef2 	bl	45fa0 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   461bc:	2001      	movs	r0, #1
   461be:	f7ff feef 	bl	45fa0 <z_sys_init_run_level>
	z_sched_init();
   461c2:	f000 fca5 	bl	46b10 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   461c6:	4b16      	ldr	r3, [pc, #88]	; (46220 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   461c8:	4d16      	ldr	r5, [pc, #88]	; (46224 <z_cstart+0xd8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   461ca:	9305      	str	r3, [sp, #20]
   461cc:	2301      	movs	r3, #1
   461ce:	4916      	ldr	r1, [pc, #88]	; (46228 <z_cstart+0xdc>)
   461d0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   461d4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   461d8:	4628      	mov	r0, r5
   461da:	464b      	mov	r3, r9
   461dc:	e9cd 4401 	strd	r4, r4, [sp, #4]
   461e0:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   461e2:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   461e4:	f000 f88a 	bl	462fc <z_setup_new_thread>
   461e8:	4607      	mov	r7, r0
   461ea:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   461ec:	4628      	mov	r0, r5
   461ee:	f022 0204 	bic.w	r2, r2, #4
   461f2:	736a      	strb	r2, [r5, #13]
   461f4:	f002 fadf 	bl	487b6 <z_ready_thread>
		init_idle_thread(i);
   461f8:	4620      	mov	r0, r4
   461fa:	f7ff ff59 	bl	460b0 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   461fe:	4b0b      	ldr	r3, [pc, #44]	; (4622c <z_cstart+0xe0>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46200:	464a      	mov	r2, r9
   46202:	4639      	mov	r1, r7
   46204:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   46206:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   46208:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   4620a:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   4620e:	f7fb ff7f 	bl	42110 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   46212:	bf00      	nop
   46214:	200232e0 	.word	0x200232e0
   46218:	e000ed00 	.word	0xe000ed00
   4621c:	2001acfc 	.word	0x2001acfc
   46220:	0004979f 	.word	0x0004979f
   46224:	2001a760 	.word	0x2001a760
   46228:	200211a0 	.word	0x200211a0
   4622c:	2001a6e0 	.word	0x2001a6e0
   46230:	00046105 	.word	0x00046105

00046234 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   46234:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   46236:	4c06      	ldr	r4, [pc, #24]	; (46250 <statics_init+0x1c>)
   46238:	4d06      	ldr	r5, [pc, #24]	; (46254 <statics_init+0x20>)
   4623a:	42ac      	cmp	r4, r5
   4623c:	d301      	bcc.n	46242 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   4623e:	2000      	movs	r0, #0
   46240:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   46242:	4620      	mov	r0, r4
   46244:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   46248:	f002 f980 	bl	4854c <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   4624c:	3414      	adds	r4, #20
   4624e:	e7f4      	b.n	4623a <statics_init+0x6>
   46250:	2001a5a4 	.word	0x2001a5a4
   46254:	2001a5b8 	.word	0x2001a5b8

00046258 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   46258:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4625a:	4b0e      	ldr	r3, [pc, #56]	; (46294 <init_mem_slab_module+0x3c>)
   4625c:	4c0e      	ldr	r4, [pc, #56]	; (46298 <init_mem_slab_module+0x40>)
   4625e:	42a3      	cmp	r3, r4
   46260:	d301      	bcc.n	46266 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   46262:	2000      	movs	r0, #0
	return rc;
}
   46264:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   46266:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   4626a:	ea41 0200 	orr.w	r2, r1, r0
   4626e:	f012 0203 	ands.w	r2, r2, #3
   46272:	d10b      	bne.n	4628c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   46274:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   46276:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46278:	42aa      	cmp	r2, r5
   4627a:	d101      	bne.n	46280 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4627c:	331c      	adds	r3, #28
   4627e:	e7ee      	b.n	4625e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   46280:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46282:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   46284:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   46286:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   46288:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   4628a:	e7f5      	b.n	46278 <init_mem_slab_module+0x20>
		return -EINVAL;
   4628c:	f06f 0015 	mvn.w	r0, #21
	return rc;
   46290:	e7e8      	b.n	46264 <init_mem_slab_module+0xc>
   46292:	bf00      	nop
   46294:	2001a5a4 	.word	0x2001a5a4
   46298:	2001a5a4 	.word	0x2001a5a4

0004629c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   4629c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   4629e:	460c      	mov	r4, r1
   462a0:	4616      	mov	r6, r2
   462a2:	461f      	mov	r7, r3
	__asm__ volatile(
   462a4:	f04f 0320 	mov.w	r3, #32
   462a8:	f3ef 8111 	mrs	r1, BASEPRI
   462ac:	f383 8812 	msr	BASEPRI_MAX, r3
   462b0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   462b4:	6943      	ldr	r3, [r0, #20]
   462b6:	b15b      	cbz	r3, 462d0 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   462b8:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   462ba:	681b      	ldr	r3, [r3, #0]
   462bc:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   462be:	6983      	ldr	r3, [r0, #24]
   462c0:	3301      	adds	r3, #1
   462c2:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   462c4:	2000      	movs	r0, #0
	__asm__ volatile(
   462c6:	f381 8811 	msr	BASEPRI, r1
   462ca:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   462ce:	e011      	b.n	462f4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   462d0:	ea56 0207 	orrs.w	r2, r6, r7
   462d4:	d103      	bne.n	462de <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   462d6:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   462da:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   462dc:	e7f3      	b.n	462c6 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   462de:	4602      	mov	r2, r0
   462e0:	e9cd 6700 	strd	r6, r7, [sp]
   462e4:	3008      	adds	r0, #8
   462e6:	f000 fb65 	bl	469b4 <z_pend_curr>
		if (result == 0) {
   462ea:	b918      	cbnz	r0, 462f4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   462ec:	4b02      	ldr	r3, [pc, #8]	; (462f8 <k_mem_slab_alloc+0x5c>)
   462ee:	689b      	ldr	r3, [r3, #8]
   462f0:	695b      	ldr	r3, [r3, #20]
   462f2:	6023      	str	r3, [r4, #0]
}
   462f4:	b002      	add	sp, #8
   462f6:	bdd0      	pop	{r4, r6, r7, pc}
   462f8:	2001acfc 	.word	0x2001acfc

000462fc <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   462fc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   46300:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   46302:	f100 0558 	add.w	r5, r0, #88	; 0x58
   46306:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   46308:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   4630a:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   4630e:	2500      	movs	r5, #0
{
   46310:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   46312:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   46314:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   46316:	e9c0 5506 	strd	r5, r5, [r0, #24]
   4631a:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   4631c:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   4631e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46320:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   46324:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   46328:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   4632a:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   4632c:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   4632e:	9202      	str	r2, [sp, #8]
   46330:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   46332:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46336:	9201      	str	r2, [sp, #4]
   46338:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   4633a:	9200      	str	r2, [sp, #0]
   4633c:	4642      	mov	r2, r8
   4633e:	f7fb fec9 	bl	420d4 <arch_new_thread>
	if (!_current) {
   46342:	4b05      	ldr	r3, [pc, #20]	; (46358 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   46344:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   46346:	689b      	ldr	r3, [r3, #8]
   46348:	b103      	cbz	r3, 4634c <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   4634a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   4634c:	4640      	mov	r0, r8
   4634e:	6723      	str	r3, [r4, #112]	; 0x70
   46350:	b004      	add	sp, #16
   46352:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46356:	bf00      	nop
   46358:	2001acfc 	.word	0x2001acfc

0004635c <z_impl_k_thread_create>:
{
   4635c:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4635e:	2500      	movs	r5, #0
{
   46360:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46362:	9505      	str	r5, [sp, #20]
   46364:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   46366:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4636a:	9504      	str	r5, [sp, #16]
   4636c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   4636e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46370:	9503      	str	r5, [sp, #12]
   46372:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   46374:	9502      	str	r5, [sp, #8]
   46376:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   46378:	9501      	str	r5, [sp, #4]
   4637a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   4637c:	9500      	str	r5, [sp, #0]
   4637e:	f7ff ffbd 	bl	462fc <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   46382:	1c7b      	adds	r3, r7, #1
   46384:	bf08      	it	eq
   46386:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   4638a:	d005      	beq.n	46398 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   4638c:	ea56 0307 	orrs.w	r3, r6, r7
   46390:	d105      	bne.n	4639e <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   46392:	4620      	mov	r0, r4
   46394:	f000 fab2 	bl	468fc <z_sched_start>
}
   46398:	4620      	mov	r0, r4
   4639a:	b007      	add	sp, #28
   4639c:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   4639e:	4632      	mov	r2, r6
   463a0:	463b      	mov	r3, r7
   463a2:	4903      	ldr	r1, [pc, #12]	; (463b0 <z_impl_k_thread_create+0x54>)
   463a4:	f104 0018 	add.w	r0, r4, #24
   463a8:	f000 fd22 	bl	46df0 <z_add_timeout>
   463ac:	e7f4      	b.n	46398 <z_impl_k_thread_create+0x3c>
   463ae:	bf00      	nop
   463b0:	000487d7 	.word	0x000487d7

000463b4 <z_init_static_threads>:
{
   463b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   463b6:	4e20      	ldr	r6, [pc, #128]	; (46438 <z_init_static_threads+0x84>)
   463b8:	4d20      	ldr	r5, [pc, #128]	; (4643c <z_init_static_threads+0x88>)
   463ba:	4637      	mov	r7, r6
{
   463bc:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   463be:	42b5      	cmp	r5, r6
   463c0:	f105 0430 	add.w	r4, r5, #48	; 0x30
   463c4:	d30a      	bcc.n	463dc <z_init_static_threads+0x28>
	k_sched_lock();
   463c6:	f000 f9ad 	bl	46724 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   463ca:	4c1c      	ldr	r4, [pc, #112]	; (4643c <z_init_static_threads+0x88>)
   463cc:	4d1c      	ldr	r5, [pc, #112]	; (46440 <z_init_static_threads+0x8c>)
   463ce:	42bc      	cmp	r4, r7
   463d0:	d321      	bcc.n	46416 <z_init_static_threads+0x62>
}
   463d2:	b007      	add	sp, #28
   463d4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   463d8:	f000 bb7e 	b.w	46ad8 <k_sched_unlock>
		z_setup_new_thread(
   463dc:	f854 3c04 	ldr.w	r3, [r4, #-4]
   463e0:	9305      	str	r3, [sp, #20]
   463e2:	f854 3c10 	ldr.w	r3, [r4, #-16]
   463e6:	9304      	str	r3, [sp, #16]
   463e8:	f854 3c14 	ldr.w	r3, [r4, #-20]
   463ec:	9303      	str	r3, [sp, #12]
   463ee:	f854 3c18 	ldr.w	r3, [r4, #-24]
   463f2:	9302      	str	r3, [sp, #8]
   463f4:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   463f8:	9301      	str	r3, [sp, #4]
   463fa:	f854 3c20 	ldr.w	r3, [r4, #-32]
   463fe:	9300      	str	r3, [sp, #0]
   46400:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   46404:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   46408:	f7ff ff78 	bl	462fc <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   4640c:	f854 3c30 	ldr.w	r3, [r4, #-48]
   46410:	655d      	str	r5, [r3, #84]	; 0x54
   46412:	4625      	mov	r5, r4
   46414:	e7d3      	b.n	463be <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   46416:	6a62      	ldr	r2, [r4, #36]	; 0x24
   46418:	1c53      	adds	r3, r2, #1
   4641a:	d004      	beq.n	46426 <z_init_static_threads+0x72>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   4641c:	2a00      	cmp	r2, #0
			schedule_new_thread(thread_data->init_thread,
   4641e:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46420:	dc03      	bgt.n	4642a <z_init_static_threads+0x76>
	z_sched_start(thread);
   46422:	f000 fa6b 	bl	468fc <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   46426:	3430      	adds	r4, #48	; 0x30
   46428:	e7d1      	b.n	463ce <z_init_static_threads+0x1a>
   4642a:	4629      	mov	r1, r5
   4642c:	17d3      	asrs	r3, r2, #31
   4642e:	3018      	adds	r0, #24
   46430:	f000 fcde 	bl	46df0 <z_add_timeout>
   46434:	e7f7      	b.n	46426 <z_init_static_threads+0x72>
   46436:	bf00      	nop
   46438:	2001a5a4 	.word	0x2001a5a4
   4643c:	2001a5a4 	.word	0x2001a5a4
   46440:	000487d7 	.word	0x000487d7

00046444 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   46444:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   46446:	4c09      	ldr	r4, [pc, #36]	; (4646c <idle+0x28>)
	__asm__ volatile(
   46448:	f04f 0220 	mov.w	r2, #32
   4644c:	f3ef 8311 	mrs	r3, BASEPRI
   46450:	f382 8812 	msr	BASEPRI_MAX, r2
   46454:	f3bf 8f6f 	isb	sy
   46458:	f002 fa5f 	bl	4891a <z_get_next_timeout_expiry>
   4645c:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   4645e:	f7fb fca7 	bl	41db0 <pm_system_suspend>
   46462:	2800      	cmp	r0, #0
   46464:	d1f0      	bne.n	46448 <idle+0x4>
	arch_cpu_idle();
   46466:	f7fb fd29 	bl	41ebc <arch_cpu_idle>
}
   4646a:	e7ed      	b.n	46448 <idle+0x4>
   4646c:	2001acfc 	.word	0x2001acfc

00046470 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   46470:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46474:	4604      	mov	r4, r0
   46476:	4616      	mov	r6, r2
   46478:	461f      	mov	r7, r3
   4647a:	f04f 0320 	mov.w	r3, #32
   4647e:	f3ef 8811 	mrs	r8, BASEPRI
   46482:	f383 8812 	msr	BASEPRI_MAX, r3
   46486:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   4648a:	68c3      	ldr	r3, [r0, #12]
   4648c:	4a35      	ldr	r2, [pc, #212]	; (46564 <z_impl_k_mutex_lock+0xf4>)
   4648e:	b16b      	cbz	r3, 464ac <z_impl_k_mutex_lock+0x3c>
   46490:	6880      	ldr	r0, [r0, #8]
   46492:	6891      	ldr	r1, [r2, #8]
   46494:	4288      	cmp	r0, r1
   46496:	d019      	beq.n	464cc <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   46498:	ea56 0307 	orrs.w	r3, r6, r7
   4649c:	d118      	bne.n	464d0 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   4649e:	f388 8811 	msr	BASEPRI, r8
   464a2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   464a6:	f06f 000f 	mvn.w	r0, #15
   464aa:	e00c      	b.n	464c6 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   464ac:	6891      	ldr	r1, [r2, #8]
   464ae:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   464b2:	3301      	adds	r3, #1
   464b4:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   464b6:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   464b8:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   464ba:	60a3      	str	r3, [r4, #8]
   464bc:	f388 8811 	msr	BASEPRI, r8
   464c0:	f3bf 8f6f 	isb	sy
		return 0;
   464c4:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   464c6:	b002      	add	sp, #8
   464c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   464cc:	6921      	ldr	r1, [r4, #16]
   464ce:	e7f0      	b.n	464b2 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   464d0:	f991 100e 	ldrsb.w	r1, [r1, #14]
   464d4:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   464d8:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   464dc:	4299      	cmp	r1, r3
   464de:	bfa8      	it	ge
   464e0:	4619      	movge	r1, r3
   464e2:	4291      	cmp	r1, r2
   464e4:	bfb8      	it	lt
   464e6:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   464e8:	428b      	cmp	r3, r1
   464ea:	dd2f      	ble.n	4654c <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   464ec:	f000 fa76 	bl	469dc <z_set_prio>
   464f0:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   464f2:	4622      	mov	r2, r4
   464f4:	4641      	mov	r1, r8
   464f6:	e9cd 6700 	strd	r6, r7, [sp]
   464fa:	481b      	ldr	r0, [pc, #108]	; (46568 <z_impl_k_mutex_lock+0xf8>)
   464fc:	f000 fa5a 	bl	469b4 <z_pend_curr>
	if (got_mutex == 0) {
   46500:	2800      	cmp	r0, #0
   46502:	d0e0      	beq.n	464c6 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   46504:	f04f 0320 	mov.w	r3, #32
   46508:	f3ef 8611 	mrs	r6, BASEPRI
   4650c:	f383 8812 	msr	BASEPRI_MAX, r3
   46510:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   46514:	6823      	ldr	r3, [r4, #0]
   46516:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46518:	429c      	cmp	r4, r3
   4651a:	d00a      	beq.n	46532 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   4651c:	b14b      	cbz	r3, 46532 <z_impl_k_mutex_lock+0xc2>
   4651e:	f993 300e 	ldrsb.w	r3, [r3, #14]
   46522:	4299      	cmp	r1, r3
   46524:	bfa8      	it	ge
   46526:	4619      	movge	r1, r3
   46528:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   4652c:	4299      	cmp	r1, r3
   4652e:	bfb8      	it	lt
   46530:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46532:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   46534:	f990 300e 	ldrsb.w	r3, [r0, #14]
   46538:	4299      	cmp	r1, r3
   4653a:	d109      	bne.n	46550 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   4653c:	b16d      	cbz	r5, 4655a <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   4653e:	4631      	mov	r1, r6
   46540:	4809      	ldr	r0, [pc, #36]	; (46568 <z_impl_k_mutex_lock+0xf8>)
   46542:	f000 f8dd 	bl	46700 <z_reschedule>
	return -EAGAIN;
   46546:	f06f 000a 	mvn.w	r0, #10
   4654a:	e7bc      	b.n	464c6 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   4654c:	2500      	movs	r5, #0
   4654e:	e7d0      	b.n	464f2 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   46550:	f000 fa44 	bl	469dc <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46554:	2800      	cmp	r0, #0
   46556:	d1f2      	bne.n	4653e <z_impl_k_mutex_lock+0xce>
   46558:	e7f0      	b.n	4653c <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   4655a:	f386 8811 	msr	BASEPRI, r6
   4655e:	f3bf 8f6f 	isb	sy
   46562:	e7f0      	b.n	46546 <z_impl_k_mutex_lock+0xd6>
   46564:	2001acfc 	.word	0x2001acfc
   46568:	20020a9b 	.word	0x20020a9b

0004656c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   4656c:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   4656e:	6883      	ldr	r3, [r0, #8]
{
   46570:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   46572:	2b00      	cmp	r3, #0
   46574:	d036      	beq.n	465e4 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   46576:	4a1e      	ldr	r2, [pc, #120]	; (465f0 <z_impl_k_mutex_unlock+0x84>)
   46578:	6892      	ldr	r2, [r2, #8]
   4657a:	4293      	cmp	r3, r2
   4657c:	d135      	bne.n	465ea <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   4657e:	7bda      	ldrb	r2, [r3, #15]
   46580:	3a01      	subs	r2, #1
   46582:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   46584:	68c3      	ldr	r3, [r0, #12]
   46586:	2b01      	cmp	r3, #1
   46588:	d905      	bls.n	46596 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   4658a:	3b01      	subs	r3, #1
   4658c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   4658e:	f000 faa3 	bl	46ad8 <k_sched_unlock>

	return 0;
   46592:	2000      	movs	r0, #0
}
   46594:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   46596:	f04f 0320 	mov.w	r3, #32
   4659a:	f3ef 8511 	mrs	r5, BASEPRI
   4659e:	f383 8812 	msr	BASEPRI_MAX, r3
   465a2:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   465a6:	6901      	ldr	r1, [r0, #16]
   465a8:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   465aa:	f990 300e 	ldrsb.w	r3, [r0, #14]
   465ae:	4299      	cmp	r1, r3
   465b0:	d001      	beq.n	465b6 <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   465b2:	f000 fa13 	bl	469dc <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   465b6:	4620      	mov	r0, r4
   465b8:	f002 f971 	bl	4889e <z_unpend_first_thread>
	mutex->owner = new_owner;
   465bc:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   465be:	b158      	cbz	r0, 465d8 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   465c0:	f990 200e 	ldrsb.w	r2, [r0, #14]
   465c4:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   465c6:	2200      	movs	r2, #0
   465c8:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   465ca:	f002 f8f4 	bl	487b6 <z_ready_thread>
		z_reschedule(&lock, key);
   465ce:	4629      	mov	r1, r5
   465d0:	4808      	ldr	r0, [pc, #32]	; (465f4 <z_impl_k_mutex_unlock+0x88>)
   465d2:	f000 f895 	bl	46700 <z_reschedule>
   465d6:	e7da      	b.n	4658e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   465d8:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   465da:	f385 8811 	msr	BASEPRI, r5
   465de:	f3bf 8f6f 	isb	sy
   465e2:	e7d4      	b.n	4658e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   465e4:	f06f 0015 	mvn.w	r0, #21
   465e8:	e7d4      	b.n	46594 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   465ea:	f04f 30ff 	mov.w	r0, #4294967295
   465ee:	e7d1      	b.n	46594 <z_impl_k_mutex_unlock+0x28>
   465f0:	2001acfc 	.word	0x2001acfc
   465f4:	20020a9b 	.word	0x20020a9b

000465f8 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   465f8:	b538      	push	{r3, r4, r5, lr}
   465fa:	4604      	mov	r4, r0
	__asm__ volatile(
   465fc:	f04f 0320 	mov.w	r3, #32
   46600:	f3ef 8511 	mrs	r5, BASEPRI
   46604:	f383 8812 	msr	BASEPRI_MAX, r3
   46608:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   4660c:	f002 f947 	bl	4889e <z_unpend_first_thread>

	if (thread != NULL) {
   46610:	b148      	cbz	r0, 46626 <z_impl_k_sem_give+0x2e>
   46612:	2200      	movs	r2, #0
   46614:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   46616:	f002 f8ce 	bl	487b6 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   4661a:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   4661c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   46620:	4804      	ldr	r0, [pc, #16]	; (46634 <z_impl_k_sem_give+0x3c>)
   46622:	f000 b86d 	b.w	46700 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   46626:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   4662a:	429a      	cmp	r2, r3
   4662c:	bf18      	it	ne
   4662e:	3301      	addne	r3, #1
   46630:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   46632:	e7f2      	b.n	4661a <z_impl_k_sem_give+0x22>
   46634:	20020a9b 	.word	0x20020a9b

00046638 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   46638:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4663a:	4614      	mov	r4, r2
   4663c:	461d      	mov	r5, r3
   4663e:	f04f 0320 	mov.w	r3, #32
   46642:	f3ef 8111 	mrs	r1, BASEPRI
   46646:	f383 8812 	msr	BASEPRI_MAX, r3
   4664a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   4664e:	6883      	ldr	r3, [r0, #8]
   46650:	b143      	cbz	r3, 46664 <z_impl_k_sem_take+0x2c>
		sem->count--;
   46652:	3b01      	subs	r3, #1
   46654:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   46656:	f381 8811 	msr	BASEPRI, r1
   4665a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   4665e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   46660:	b003      	add	sp, #12
   46662:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46664:	ea54 0305 	orrs.w	r3, r4, r5
   46668:	d106      	bne.n	46678 <z_impl_k_sem_take+0x40>
   4666a:	f381 8811 	msr	BASEPRI, r1
   4666e:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   46672:	f06f 000f 	mvn.w	r0, #15
   46676:	e7f3      	b.n	46660 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   46678:	4602      	mov	r2, r0
   4667a:	e9cd 4500 	strd	r4, r5, [sp]
   4667e:	4802      	ldr	r0, [pc, #8]	; (46688 <z_impl_k_sem_take+0x50>)
   46680:	f000 f998 	bl	469b4 <z_pend_curr>
	return ret;
   46684:	e7ec      	b.n	46660 <z_impl_k_sem_take+0x28>
   46686:	bf00      	nop
   46688:	20020a9b 	.word	0x20020a9b

0004668c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   4668c:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   4668e:	4c08      	ldr	r4, [pc, #32]	; (466b0 <z_reset_time_slice+0x24>)
   46690:	6823      	ldr	r3, [r4, #0]
   46692:	b15b      	cbz	r3, 466ac <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46694:	f7fd f940 	bl	43918 <sys_clock_elapsed>
   46698:	4603      	mov	r3, r0
   4669a:	6820      	ldr	r0, [r4, #0]
   4669c:	4a05      	ldr	r2, [pc, #20]	; (466b4 <z_reset_time_slice+0x28>)
   4669e:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   466a0:	2100      	movs	r1, #0
	}
}
   466a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   466a6:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   466a8:	f002 b947 	b.w	4893a <z_set_timeout_expiry>
}
   466ac:	bd10      	pop	{r4, pc}
   466ae:	bf00      	nop
   466b0:	2001ad2c 	.word	0x2001ad2c
   466b4:	2001acfc 	.word	0x2001acfc

000466b8 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   466b8:	b510      	push	{r4, lr}
	__asm__ volatile(
   466ba:	f04f 0320 	mov.w	r3, #32
   466be:	f3ef 8411 	mrs	r4, BASEPRI
   466c2:	f383 8812 	msr	BASEPRI_MAX, r3
   466c6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   466ca:	2200      	movs	r2, #0
   466cc:	4b09      	ldr	r3, [pc, #36]	; (466f4 <k_sched_time_slice_set+0x3c>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   466ce:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
   466d0:	611a      	str	r2, [r3, #16]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   466d2:	4b09      	ldr	r3, [pc, #36]	; (466f8 <k_sched_time_slice_set+0x40>)
   466d4:	dc09      	bgt.n	466ea <k_sched_time_slice_set+0x32>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   466d6:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   466d8:	4b08      	ldr	r3, [pc, #32]	; (466fc <k_sched_time_slice_set+0x44>)
   466da:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
   466dc:	f7ff ffd6 	bl	4668c <z_reset_time_slice>
	__asm__ volatile(
   466e0:	f384 8811 	msr	BASEPRI, r4
   466e4:	f3bf 8f6f 	isb	sy
	}
}
   466e8:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
   466ea:	2802      	cmp	r0, #2
   466ec:	bfb8      	it	lt
   466ee:	2002      	movlt	r0, #2
   466f0:	e7f1      	b.n	466d6 <k_sched_time_slice_set+0x1e>
   466f2:	bf00      	nop
   466f4:	2001acfc 	.word	0x2001acfc
   466f8:	2001ad2c 	.word	0x2001ad2c
   466fc:	2001ad28 	.word	0x2001ad28

00046700 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   46700:	b949      	cbnz	r1, 46716 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   46702:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   46706:	b930      	cbnz	r0, 46716 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   46708:	4b05      	ldr	r3, [pc, #20]	; (46720 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   4670a:	69da      	ldr	r2, [r3, #28]
   4670c:	689b      	ldr	r3, [r3, #8]
   4670e:	429a      	cmp	r2, r3
   46710:	d001      	beq.n	46716 <z_reschedule+0x16>
	ret = arch_swap(key);
   46712:	f7fb bc85 	b.w	42020 <arch_swap>
   46716:	f381 8811 	msr	BASEPRI, r1
   4671a:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   4671e:	4770      	bx	lr
   46720:	2001acfc 	.word	0x2001acfc

00046724 <k_sched_lock>:
	__asm__ volatile(
   46724:	f04f 0320 	mov.w	r3, #32
   46728:	f3ef 8111 	mrs	r1, BASEPRI
   4672c:	f383 8812 	msr	BASEPRI_MAX, r3
   46730:	f3bf 8f6f 	isb	sy
   46734:	4b04      	ldr	r3, [pc, #16]	; (46748 <k_sched_lock+0x24>)
   46736:	689a      	ldr	r2, [r3, #8]
   46738:	7bd3      	ldrb	r3, [r2, #15]
   4673a:	3b01      	subs	r3, #1
   4673c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   4673e:	f381 8811 	msr	BASEPRI, r1
   46742:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   46746:	4770      	bx	lr
   46748:	2001acfc 	.word	0x2001acfc

0004674c <update_cache>:
{
   4674c:	b538      	push	{r3, r4, r5, lr}
   4674e:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   46750:	480c      	ldr	r0, [pc, #48]	; (46784 <update_cache+0x38>)
   46752:	f002 f826 	bl	487a2 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   46756:	4d0c      	ldr	r5, [pc, #48]	; (46788 <update_cache+0x3c>)
   46758:	4604      	mov	r4, r0
   4675a:	b900      	cbnz	r0, 4675e <update_cache+0x12>
   4675c:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   4675e:	68ab      	ldr	r3, [r5, #8]
   46760:	b94a      	cbnz	r2, 46776 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   46762:	7b5a      	ldrb	r2, [r3, #13]
   46764:	06d2      	lsls	r2, r2, #27
   46766:	d106      	bne.n	46776 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   46768:	69a2      	ldr	r2, [r4, #24]
   4676a:	b922      	cbnz	r2, 46776 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   4676c:	89da      	ldrh	r2, [r3, #14]
   4676e:	2a7f      	cmp	r2, #127	; 0x7f
   46770:	d901      	bls.n	46776 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   46772:	61eb      	str	r3, [r5, #28]
}
   46774:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   46776:	429c      	cmp	r4, r3
   46778:	d001      	beq.n	4677e <update_cache+0x32>
			z_reset_time_slice();
   4677a:	f7ff ff87 	bl	4668c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   4677e:	61ec      	str	r4, [r5, #28]
}
   46780:	e7f8      	b.n	46774 <update_cache+0x28>
   46782:	bf00      	nop
   46784:	2001ad1c 	.word	0x2001ad1c
   46788:	2001acfc 	.word	0x2001acfc

0004678c <move_thread_to_end_of_prio_q>:
{
   4678c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   4678e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46792:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46794:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46796:	7b43      	ldrb	r3, [r0, #13]
   46798:	da04      	bge.n	467a4 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   4679a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4679e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   467a0:	f001 ffb3 	bl	4870a <sys_dlist_remove>
	return list->head == list;
   467a4:	4a17      	ldr	r2, [pc, #92]	; (46804 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   467a6:	7b4b      	ldrb	r3, [r1, #13]
   467a8:	4610      	mov	r0, r2
   467aa:	f063 037f 	orn	r3, r3, #127	; 0x7f
   467ae:	734b      	strb	r3, [r1, #13]
   467b0:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   467b4:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   467b6:	4283      	cmp	r3, r0
   467b8:	bf08      	it	eq
   467ba:	2300      	moveq	r3, #0
   467bc:	2b00      	cmp	r3, #0
   467be:	bf38      	it	cc
   467c0:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   467c2:	b1cb      	cbz	r3, 467f8 <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   467c4:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   467c8:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   467cc:	42a6      	cmp	r6, r4
   467ce:	d00f      	beq.n	467f0 <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   467d0:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   467d2:	2c00      	cmp	r4, #0
   467d4:	dd0c      	ble.n	467f0 <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   467d6:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   467d8:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   467dc:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   467de:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   467e0:	6890      	ldr	r0, [r2, #8]
}
   467e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   467e6:	1a43      	subs	r3, r0, r1
   467e8:	4258      	negs	r0, r3
   467ea:	4158      	adcs	r0, r3
   467ec:	f7ff bfae 	b.w	4674c <update_cache>
	return (node == list->tail) ? NULL : node->next;
   467f0:	42ab      	cmp	r3, r5
   467f2:	d001      	beq.n	467f8 <move_thread_to_end_of_prio_q+0x6c>
   467f4:	681b      	ldr	r3, [r3, #0]
   467f6:	e7e4      	b.n	467c2 <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   467f8:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   467fc:	6029      	str	r1, [r5, #0]
	list->tail = node;
   467fe:	6251      	str	r1, [r2, #36]	; 0x24
}
   46800:	e7ee      	b.n	467e0 <move_thread_to_end_of_prio_q+0x54>
   46802:	bf00      	nop
   46804:	2001acfc 	.word	0x2001acfc

00046808 <z_time_slice>:
{
   46808:	4601      	mov	r1, r0
   4680a:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   4680c:	f04f 0320 	mov.w	r3, #32
   46810:	f3ef 8411 	mrs	r4, BASEPRI
   46814:	f383 8812 	msr	BASEPRI_MAX, r3
   46818:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   4681c:	4b16      	ldr	r3, [pc, #88]	; (46878 <z_time_slice+0x70>)
   4681e:	4a17      	ldr	r2, [pc, #92]	; (4687c <z_time_slice+0x74>)
   46820:	6898      	ldr	r0, [r3, #8]
   46822:	6815      	ldr	r5, [r2, #0]
   46824:	42a8      	cmp	r0, r5
   46826:	461d      	mov	r5, r3
   46828:	d106      	bne.n	46838 <z_time_slice+0x30>
			z_reset_time_slice();
   4682a:	f7ff ff2f 	bl	4668c <z_reset_time_slice>
	__asm__ volatile(
   4682e:	f384 8811 	msr	BASEPRI, r4
   46832:	f3bf 8f6f 	isb	sy
}
   46836:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   46838:	2600      	movs	r6, #0
   4683a:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   4683c:	4a10      	ldr	r2, [pc, #64]	; (46880 <z_time_slice+0x78>)
   4683e:	6812      	ldr	r2, [r2, #0]
   46840:	b1ba      	cbz	r2, 46872 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   46842:	89c2      	ldrh	r2, [r0, #14]
   46844:	2a7f      	cmp	r2, #127	; 0x7f
   46846:	d814      	bhi.n	46872 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   46848:	7b42      	ldrb	r2, [r0, #13]
   4684a:	06d2      	lsls	r2, r2, #27
   4684c:	d111      	bne.n	46872 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   4684e:	4a0d      	ldr	r2, [pc, #52]	; (46884 <z_time_slice+0x7c>)
   46850:	f990 600e 	ldrsb.w	r6, [r0, #14]
   46854:	6812      	ldr	r2, [r2, #0]
   46856:	4296      	cmp	r6, r2
   46858:	db0b      	blt.n	46872 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   4685a:	4a0b      	ldr	r2, [pc, #44]	; (46888 <z_time_slice+0x80>)
   4685c:	4290      	cmp	r0, r2
   4685e:	d008      	beq.n	46872 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   46860:	691a      	ldr	r2, [r3, #16]
   46862:	428a      	cmp	r2, r1
   46864:	dc02      	bgt.n	4686c <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   46866:	f7ff ff91 	bl	4678c <move_thread_to_end_of_prio_q>
   4686a:	e7de      	b.n	4682a <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   4686c:	1a52      	subs	r2, r2, r1
   4686e:	611a      	str	r2, [r3, #16]
   46870:	e7dd      	b.n	4682e <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   46872:	2300      	movs	r3, #0
   46874:	612b      	str	r3, [r5, #16]
   46876:	e7da      	b.n	4682e <z_time_slice+0x26>
   46878:	2001acfc 	.word	0x2001acfc
   4687c:	2001ad24 	.word	0x2001ad24
   46880:	2001ad2c 	.word	0x2001ad2c
   46884:	2001ad28 	.word	0x2001ad28
   46888:	2001a6e0 	.word	0x2001a6e0

0004688c <ready_thread>:
{
   4688c:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   4688e:	f990 300d 	ldrsb.w	r3, [r0, #13]
   46892:	7b42      	ldrb	r2, [r0, #13]
   46894:	2b00      	cmp	r3, #0
   46896:	db2d      	blt.n	468f4 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46898:	06d3      	lsls	r3, r2, #27
   4689a:	d12b      	bne.n	468f4 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   4689c:	6983      	ldr	r3, [r0, #24]
   4689e:	bb4b      	cbnz	r3, 468f4 <ready_thread+0x68>
	return list->head == list;
   468a0:	4915      	ldr	r1, [pc, #84]	; (468f8 <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   468a2:	f062 027f 	orn	r2, r2, #127	; 0x7f
   468a6:	7342      	strb	r2, [r0, #13]
   468a8:	460a      	mov	r2, r1
   468aa:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   468ae:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   468b0:	4294      	cmp	r4, r2
   468b2:	bf18      	it	ne
   468b4:	4623      	movne	r3, r4
   468b6:	2b00      	cmp	r3, #0
   468b8:	bf38      	it	cc
   468ba:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   468bc:	b1ab      	cbz	r3, 468ea <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   468be:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   468c2:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   468c6:	42a6      	cmp	r6, r4
   468c8:	d00b      	beq.n	468e2 <ready_thread+0x56>
		return b2 - b1;
   468ca:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   468cc:	2c00      	cmp	r4, #0
   468ce:	dd08      	ble.n	468e2 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   468d0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   468d2:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   468d6:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   468d8:	6058      	str	r0, [r3, #4]
		update_cache(0);
   468da:	2000      	movs	r0, #0
}
   468dc:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   468de:	f7ff bf35 	b.w	4674c <update_cache>
	return (node == list->tail) ? NULL : node->next;
   468e2:	42ab      	cmp	r3, r5
   468e4:	d001      	beq.n	468ea <ready_thread+0x5e>
   468e6:	681b      	ldr	r3, [r3, #0]
   468e8:	e7e8      	b.n	468bc <ready_thread+0x30>
	node->prev = tail;
   468ea:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   468ee:	6028      	str	r0, [r5, #0]
	list->tail = node;
   468f0:	6248      	str	r0, [r1, #36]	; 0x24
}
   468f2:	e7f2      	b.n	468da <ready_thread+0x4e>
}
   468f4:	bc70      	pop	{r4, r5, r6}
   468f6:	4770      	bx	lr
   468f8:	2001acfc 	.word	0x2001acfc

000468fc <z_sched_start>:
{
   468fc:	b510      	push	{r4, lr}
	__asm__ volatile(
   468fe:	f04f 0220 	mov.w	r2, #32
   46902:	f3ef 8411 	mrs	r4, BASEPRI
   46906:	f382 8812 	msr	BASEPRI_MAX, r2
   4690a:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   4690e:	7b42      	ldrb	r2, [r0, #13]
   46910:	0751      	lsls	r1, r2, #29
   46912:	d404      	bmi.n	4691e <z_sched_start+0x22>
	__asm__ volatile(
   46914:	f384 8811 	msr	BASEPRI, r4
   46918:	f3bf 8f6f 	isb	sy
}
   4691c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   4691e:	f022 0204 	bic.w	r2, r2, #4
   46922:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   46924:	f7ff ffb2 	bl	4688c <ready_thread>
	z_reschedule(&sched_spinlock, key);
   46928:	4621      	mov	r1, r4
}
   4692a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   4692e:	4801      	ldr	r0, [pc, #4]	; (46934 <z_sched_start+0x38>)
   46930:	f7ff bee6 	b.w	46700 <z_reschedule>
   46934:	20020a9b 	.word	0x20020a9b

00046938 <unready_thread>:
{
   46938:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   4693a:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   4693e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46940:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46942:	7b43      	ldrb	r3, [r0, #13]
   46944:	da04      	bge.n	46950 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46946:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4694a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   4694c:	f001 fedd 	bl	4870a <sys_dlist_remove>
	update_cache(thread == _current);
   46950:	4b04      	ldr	r3, [pc, #16]	; (46964 <unready_thread+0x2c>)
   46952:	6898      	ldr	r0, [r3, #8]
   46954:	1a43      	subs	r3, r0, r1
   46956:	4258      	negs	r0, r3
   46958:	4158      	adcs	r0, r3
}
   4695a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   4695e:	f7ff bef5 	b.w	4674c <update_cache>
   46962:	bf00      	nop
   46964:	2001acfc 	.word	0x2001acfc

00046968 <pend>:
{
   46968:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4696c:	4606      	mov	r6, r0
   4696e:	4614      	mov	r4, r2
   46970:	461d      	mov	r5, r3
	__asm__ volatile(
   46972:	f04f 0320 	mov.w	r3, #32
   46976:	f3ef 8711 	mrs	r7, BASEPRI
   4697a:	f383 8812 	msr	BASEPRI_MAX, r3
   4697e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   46982:	f001 ff4a 	bl	4881a <add_to_waitq_locked>
	__asm__ volatile(
   46986:	f387 8811 	msr	BASEPRI, r7
   4698a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   4698e:	1c6b      	adds	r3, r5, #1
   46990:	bf08      	it	eq
   46992:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   46996:	d008      	beq.n	469aa <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46998:	4622      	mov	r2, r4
   4699a:	462b      	mov	r3, r5
   4699c:	f106 0018 	add.w	r0, r6, #24
   469a0:	4903      	ldr	r1, [pc, #12]	; (469b0 <pend+0x48>)
}
   469a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   469a6:	f000 ba23 	b.w	46df0 <z_add_timeout>
   469aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   469ae:	bf00      	nop
   469b0:	000487d7 	.word	0x000487d7

000469b4 <z_pend_curr>:
{
   469b4:	b510      	push	{r4, lr}
   469b6:	460c      	mov	r4, r1
	pending_current = _current;
   469b8:	4b06      	ldr	r3, [pc, #24]	; (469d4 <z_pend_curr+0x20>)
{
   469ba:	4611      	mov	r1, r2
	pending_current = _current;
   469bc:	6898      	ldr	r0, [r3, #8]
   469be:	4b06      	ldr	r3, [pc, #24]	; (469d8 <z_pend_curr+0x24>)
   469c0:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   469c2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   469c6:	f7ff ffcf 	bl	46968 <pend>
   469ca:	4620      	mov	r0, r4
}
   469cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   469d0:	f7fb bb26 	b.w	42020 <arch_swap>
   469d4:	2001acfc 	.word	0x2001acfc
   469d8:	2001ad24 	.word	0x2001ad24

000469dc <z_set_prio>:
{
   469dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   469de:	4604      	mov	r4, r0
	__asm__ volatile(
   469e0:	f04f 0320 	mov.w	r3, #32
   469e4:	f3ef 8611 	mrs	r6, BASEPRI
   469e8:	f383 8812 	msr	BASEPRI_MAX, r3
   469ec:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   469f0:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   469f2:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   469f4:	06da      	lsls	r2, r3, #27
   469f6:	d138      	bne.n	46a6a <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   469f8:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   469fa:	2d00      	cmp	r5, #0
   469fc:	d135      	bne.n	46a6a <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   469fe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46a02:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46a04:	f001 fe81 	bl	4870a <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   46a08:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   46a0a:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   46a0c:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46a10:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   46a12:	4817      	ldr	r0, [pc, #92]	; (46a70 <z_set_prio+0x94>)
   46a14:	4603      	mov	r3, r0
   46a16:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46a1a:	429f      	cmp	r7, r3
   46a1c:	bf18      	it	ne
   46a1e:	463d      	movne	r5, r7
   46a20:	2d00      	cmp	r5, #0
   46a22:	461a      	mov	r2, r3
   46a24:	462b      	mov	r3, r5
   46a26:	bf38      	it	cc
   46a28:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46a2a:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46a2c:	b1c3      	cbz	r3, 46a60 <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   46a2e:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46a32:	42a9      	cmp	r1, r5
   46a34:	d010      	beq.n	46a58 <z_set_prio+0x7c>
		return b2 - b1;
   46a36:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   46a38:	2d00      	cmp	r5, #0
   46a3a:	dd0d      	ble.n	46a58 <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   46a3c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46a3e:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   46a42:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   46a44:	605c      	str	r4, [r3, #4]
			update_cache(1);
   46a46:	2001      	movs	r0, #1
   46a48:	f7ff fe80 	bl	4674c <update_cache>
   46a4c:	2001      	movs	r0, #1
	__asm__ volatile(
   46a4e:	f386 8811 	msr	BASEPRI, r6
   46a52:	f3bf 8f6f 	isb	sy
}
   46a56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   46a58:	42bb      	cmp	r3, r7
   46a5a:	d001      	beq.n	46a60 <z_set_prio+0x84>
   46a5c:	681b      	ldr	r3, [r3, #0]
   46a5e:	e7e5      	b.n	46a2c <z_set_prio+0x50>
	node->prev = tail;
   46a60:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   46a64:	603c      	str	r4, [r7, #0]
	list->tail = node;
   46a66:	6244      	str	r4, [r0, #36]	; 0x24
}
   46a68:	e7ed      	b.n	46a46 <z_set_prio+0x6a>
			thread->base.prio = prio;
   46a6a:	2000      	movs	r0, #0
   46a6c:	73a1      	strb	r1, [r4, #14]
   46a6e:	e7ee      	b.n	46a4e <z_set_prio+0x72>
   46a70:	2001acfc 	.word	0x2001acfc

00046a74 <z_impl_k_thread_suspend>:
{
   46a74:	b570      	push	{r4, r5, r6, lr}
   46a76:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   46a78:	3018      	adds	r0, #24
   46a7a:	f001 ff38 	bl	488ee <z_abort_timeout>
	__asm__ volatile(
   46a7e:	f04f 0320 	mov.w	r3, #32
   46a82:	f3ef 8611 	mrs	r6, BASEPRI
   46a86:	f383 8812 	msr	BASEPRI_MAX, r3
   46a8a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   46a8e:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46a92:	7b63      	ldrb	r3, [r4, #13]
   46a94:	2a00      	cmp	r2, #0
   46a96:	da05      	bge.n	46aa4 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46a98:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   46a9c:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46a9e:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46aa0:	f001 fe33 	bl	4870a <sys_dlist_remove>
		update_cache(thread == _current);
   46aa4:	4d0b      	ldr	r5, [pc, #44]	; (46ad4 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   46aa6:	7b63      	ldrb	r3, [r4, #13]
   46aa8:	68a8      	ldr	r0, [r5, #8]
   46aaa:	f043 0310 	orr.w	r3, r3, #16
   46aae:	7363      	strb	r3, [r4, #13]
   46ab0:	1b03      	subs	r3, r0, r4
   46ab2:	4258      	negs	r0, r3
   46ab4:	4158      	adcs	r0, r3
   46ab6:	f7ff fe49 	bl	4674c <update_cache>
	__asm__ volatile(
   46aba:	f386 8811 	msr	BASEPRI, r6
   46abe:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   46ac2:	68ab      	ldr	r3, [r5, #8]
   46ac4:	42a3      	cmp	r3, r4
   46ac6:	d103      	bne.n	46ad0 <z_impl_k_thread_suspend+0x5c>
}
   46ac8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   46acc:	f001 be5f 	b.w	4878e <z_reschedule_unlocked>
}
   46ad0:	bd70      	pop	{r4, r5, r6, pc}
   46ad2:	bf00      	nop
   46ad4:	2001acfc 	.word	0x2001acfc

00046ad8 <k_sched_unlock>:
{
   46ad8:	b510      	push	{r4, lr}
	__asm__ volatile(
   46ada:	f04f 0320 	mov.w	r3, #32
   46ade:	f3ef 8411 	mrs	r4, BASEPRI
   46ae2:	f383 8812 	msr	BASEPRI_MAX, r3
   46ae6:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   46aea:	4b08      	ldr	r3, [pc, #32]	; (46b0c <k_sched_unlock+0x34>)
		update_cache(0);
   46aec:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   46aee:	689a      	ldr	r2, [r3, #8]
   46af0:	7bd3      	ldrb	r3, [r2, #15]
   46af2:	3301      	adds	r3, #1
   46af4:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   46af6:	f7ff fe29 	bl	4674c <update_cache>
	__asm__ volatile(
   46afa:	f384 8811 	msr	BASEPRI, r4
   46afe:	f3bf 8f6f 	isb	sy
}
   46b02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   46b06:	f001 be42 	b.w	4878e <z_reschedule_unlocked>
   46b0a:	bf00      	nop
   46b0c:	2001acfc 	.word	0x2001acfc

00046b10 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   46b10:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   46b12:	4b04      	ldr	r3, [pc, #16]	; (46b24 <z_sched_init+0x14>)
   46b14:	4608      	mov	r0, r1
   46b16:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   46b1a:	e9c3 2208 	strd	r2, r2, [r3, #32]
   46b1e:	f7ff bdcb 	b.w	466b8 <k_sched_time_slice_set>
   46b22:	bf00      	nop
   46b24:	2001acfc 	.word	0x2001acfc

00046b28 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   46b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   46b2a:	f04f 0320 	mov.w	r3, #32
   46b2e:	f3ef 8411 	mrs	r4, BASEPRI
   46b32:	f383 8812 	msr	BASEPRI_MAX, r3
   46b36:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   46b3a:	491b      	ldr	r1, [pc, #108]	; (46ba8 <z_impl_k_yield+0x80>)
   46b3c:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46b3e:	7b43      	ldrb	r3, [r0, #13]
   46b40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46b44:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46b46:	f001 fde0 	bl	4870a <sys_dlist_remove>
	return list->head == list;
   46b4a:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   46b4c:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   46b4e:	7b53      	ldrb	r3, [r2, #13]
   46b50:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46b54:	7353      	strb	r3, [r2, #13]
   46b56:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46b5a:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46b5c:	4283      	cmp	r3, r0
   46b5e:	bf08      	it	eq
   46b60:	2300      	moveq	r3, #0
   46b62:	2b00      	cmp	r3, #0
   46b64:	bf38      	it	cc
   46b66:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46b68:	b1cb      	cbz	r3, 46b9e <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   46b6a:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   46b6e:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46b72:	42af      	cmp	r7, r5
   46b74:	d00f      	beq.n	46b96 <z_impl_k_yield+0x6e>
		return b2 - b1;
   46b76:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   46b78:	2d00      	cmp	r5, #0
   46b7a:	dd0c      	ble.n	46b96 <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   46b7c:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46b7e:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   46b82:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   46b84:	605a      	str	r2, [r3, #4]
	update_cache(1);
   46b86:	2001      	movs	r0, #1
   46b88:	f7ff fde0 	bl	4674c <update_cache>
   46b8c:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   46b8e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   46b92:	f7fb ba45 	b.w	42020 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   46b96:	42b3      	cmp	r3, r6
   46b98:	d001      	beq.n	46b9e <z_impl_k_yield+0x76>
   46b9a:	681b      	ldr	r3, [r3, #0]
   46b9c:	e7e4      	b.n	46b68 <z_impl_k_yield+0x40>
	node->prev = tail;
   46b9e:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   46ba2:	6032      	str	r2, [r6, #0]
	list->tail = node;
   46ba4:	624a      	str	r2, [r1, #36]	; 0x24
}
   46ba6:	e7ee      	b.n	46b86 <z_impl_k_yield+0x5e>
   46ba8:	2001acfc 	.word	0x2001acfc

00046bac <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   46bac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46bb0:	4604      	mov	r4, r0
   46bb2:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   46bb4:	ea54 0105 	orrs.w	r1, r4, r5
   46bb8:	d104      	bne.n	46bc4 <z_tick_sleep+0x18>
	z_impl_k_yield();
   46bba:	f7ff ffb5 	bl	46b28 <z_impl_k_yield>
		k_yield();
		return 0;
   46bbe:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   46bc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   46bc4:	f06f 0101 	mvn.w	r1, #1
   46bc8:	1a0a      	subs	r2, r1, r0
   46bca:	f04f 31ff 	mov.w	r1, #4294967295
   46bce:	eb61 0305 	sbc.w	r3, r1, r5
   46bd2:	2a01      	cmp	r2, #1
   46bd4:	f173 0300 	sbcs.w	r3, r3, #0
   46bd8:	da2a      	bge.n	46c30 <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   46bda:	f001 fec8 	bl	4896e <sys_clock_tick_get_32>
   46bde:	1906      	adds	r6, r0, r4
   46be0:	f04f 0320 	mov.w	r3, #32
   46be4:	f3ef 8811 	mrs	r8, BASEPRI
   46be8:	f383 8812 	msr	BASEPRI_MAX, r3
   46bec:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   46bf0:	4f11      	ldr	r7, [pc, #68]	; (46c38 <z_tick_sleep+0x8c>)
   46bf2:	4b12      	ldr	r3, [pc, #72]	; (46c3c <z_tick_sleep+0x90>)
   46bf4:	68b8      	ldr	r0, [r7, #8]
   46bf6:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   46bf8:	f7ff fe9e 	bl	46938 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   46bfc:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46bfe:	4910      	ldr	r1, [pc, #64]	; (46c40 <z_tick_sleep+0x94>)
   46c00:	4622      	mov	r2, r4
   46c02:	462b      	mov	r3, r5
   46c04:	3018      	adds	r0, #24
   46c06:	f000 f8f3 	bl	46df0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   46c0a:	68ba      	ldr	r2, [r7, #8]
   46c0c:	4640      	mov	r0, r8
   46c0e:	7b53      	ldrb	r3, [r2, #13]
   46c10:	f043 0310 	orr.w	r3, r3, #16
   46c14:	7353      	strb	r3, [r2, #13]
   46c16:	f7fb fa03 	bl	42020 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   46c1a:	f001 fea8 	bl	4896e <sys_clock_tick_get_32>
   46c1e:	1a30      	subs	r0, r6, r0
   46c20:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   46c24:	2801      	cmp	r0, #1
   46c26:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   46c2a:	bfb8      	it	lt
   46c2c:	2000      	movlt	r0, #0
   46c2e:	e7c7      	b.n	46bc0 <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   46c30:	f06f 0601 	mvn.w	r6, #1
   46c34:	1a36      	subs	r6, r6, r0
   46c36:	e7d3      	b.n	46be0 <z_tick_sleep+0x34>
   46c38:	2001acfc 	.word	0x2001acfc
   46c3c:	2001ad24 	.word	0x2001ad24
   46c40:	000487d7 	.word	0x000487d7

00046c44 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   46c44:	b508      	push	{r3, lr}
   46c46:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46c48:	3301      	adds	r3, #1
   46c4a:	bf08      	it	eq
   46c4c:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   46c50:	d003      	beq.n	46c5a <z_impl_k_sleep+0x16>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   46c52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ticks = z_tick_sleep(ticks);
   46c56:	f7ff bfa9 	b.w	46bac <z_tick_sleep>
		k_thread_suspend(_current);
   46c5a:	4b03      	ldr	r3, [pc, #12]	; (46c68 <z_impl_k_sleep+0x24>)
   46c5c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   46c5e:	f7ff ff09 	bl	46a74 <z_impl_k_thread_suspend>
}
   46c62:	f04f 30ff 	mov.w	r0, #4294967295
   46c66:	bd08      	pop	{r3, pc}
   46c68:	2001acfc 	.word	0x2001acfc

00046c6c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   46c6c:	4b01      	ldr	r3, [pc, #4]	; (46c74 <z_impl_z_current_get+0x8>)
   46c6e:	6898      	ldr	r0, [r3, #8]
   46c70:	4770      	bx	lr
   46c72:	bf00      	nop
   46c74:	2001acfc 	.word	0x2001acfc

00046c78 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   46c78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46c7c:	4604      	mov	r4, r0
   46c7e:	f04f 0320 	mov.w	r3, #32
   46c82:	f3ef 8611 	mrs	r6, BASEPRI
   46c86:	f383 8812 	msr	BASEPRI_MAX, r3
   46c8a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   46c8e:	7b43      	ldrb	r3, [r0, #13]
   46c90:	071a      	lsls	r2, r3, #28
   46c92:	d505      	bpl.n	46ca0 <z_thread_abort+0x28>
	__asm__ volatile(
   46c94:	f386 8811 	msr	BASEPRI, r6
   46c98:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   46c9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46ca0:	f023 0220 	bic.w	r2, r3, #32
   46ca4:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   46ca8:	09d2      	lsrs	r2, r2, #7
   46caa:	d120      	bne.n	46cee <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46cac:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   46cae:	68a3      	ldr	r3, [r4, #8]
   46cb0:	b113      	cbz	r3, 46cb8 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   46cb2:	4620      	mov	r0, r4
   46cb4:	f001 fd31 	bl	4871a <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   46cb8:	f104 0018 	add.w	r0, r4, #24
   46cbc:	f001 fe17 	bl	488ee <z_abort_timeout>
   46cc0:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   46cc4:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   46cc8:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46cca:	42bd      	cmp	r5, r7
   46ccc:	d000      	beq.n	46cd0 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   46cce:	b9b5      	cbnz	r5, 46cfe <z_thread_abort+0x86>
		update_cache(1);
   46cd0:	2001      	movs	r0, #1
   46cd2:	f7ff fd3b 	bl	4674c <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   46cd6:	4b10      	ldr	r3, [pc, #64]	; (46d18 <z_thread_abort+0xa0>)
   46cd8:	689b      	ldr	r3, [r3, #8]
   46cda:	42a3      	cmp	r3, r4
   46cdc:	d1da      	bne.n	46c94 <z_thread_abort+0x1c>
   46cde:	f3ef 8305 	mrs	r3, IPSR
   46ce2:	2b00      	cmp	r3, #0
   46ce4:	d1d6      	bne.n	46c94 <z_thread_abort+0x1c>
   46ce6:	4630      	mov	r0, r6
   46ce8:	f7fb f99a 	bl	42020 <arch_swap>
	return ret;
   46cec:	e7d2      	b.n	46c94 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46cee:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   46cf2:	f043 0308 	orr.w	r3, r3, #8
   46cf6:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46cf8:	f001 fd07 	bl	4870a <sys_dlist_remove>
}
   46cfc:	e7d7      	b.n	46cae <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   46cfe:	4628      	mov	r0, r5
   46d00:	f001 fd0b 	bl	4871a <unpend_thread_no_timeout>
   46d04:	f105 0018 	add.w	r0, r5, #24
   46d08:	f001 fdf1 	bl	488ee <z_abort_timeout>
		ready_thread(thread);
   46d0c:	4628      	mov	r0, r5
   46d0e:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   46d12:	f7ff fdbb 	bl	4688c <ready_thread>
   46d16:	e7d7      	b.n	46cc8 <z_thread_abort+0x50>
   46d18:	2001acfc 	.word	0x2001acfc

00046d1c <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   46d1c:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   46d1e:	4806      	ldr	r0, [pc, #24]	; (46d38 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   46d20:	4a06      	ldr	r2, [pc, #24]	; (46d3c <z_data_copy+0x20>)
   46d22:	4907      	ldr	r1, [pc, #28]	; (46d40 <z_data_copy+0x24>)
   46d24:	1a12      	subs	r2, r2, r0
   46d26:	f001 f95f 	bl	47fe8 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   46d2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   46d2e:	4a05      	ldr	r2, [pc, #20]	; (46d44 <z_data_copy+0x28>)
   46d30:	4905      	ldr	r1, [pc, #20]	; (46d48 <z_data_copy+0x2c>)
   46d32:	4806      	ldr	r0, [pc, #24]	; (46d4c <z_data_copy+0x30>)
   46d34:	f001 b958 	b.w	47fe8 <memcpy>
   46d38:	2001a500 	.word	0x2001a500
   46d3c:	2001a5f0 	.word	0x2001a5f0
   46d40:	000497f4 	.word	0x000497f4
   46d44:	00000000 	.word	0x00000000
   46d48:	000497dc 	.word	0x000497dc
   46d4c:	2001a500 	.word	0x2001a500

00046d50 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   46d50:	4b03      	ldr	r3, [pc, #12]	; (46d60 <elapsed+0x10>)
   46d52:	681b      	ldr	r3, [r3, #0]
   46d54:	b90b      	cbnz	r3, 46d5a <elapsed+0xa>
   46d56:	f7fc bddf 	b.w	43918 <sys_clock_elapsed>
}
   46d5a:	2000      	movs	r0, #0
   46d5c:	4770      	bx	lr
   46d5e:	bf00      	nop
   46d60:	2001ad30 	.word	0x2001ad30

00046d64 <remove_timeout>:
{
   46d64:	b530      	push	{r4, r5, lr}
   46d66:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46d68:	b168      	cbz	r0, 46d86 <remove_timeout+0x22>
   46d6a:	4a0a      	ldr	r2, [pc, #40]	; (46d94 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   46d6c:	6852      	ldr	r2, [r2, #4]
   46d6e:	4290      	cmp	r0, r2
   46d70:	d009      	beq.n	46d86 <remove_timeout+0x22>
	if (next(t) != NULL) {
   46d72:	b143      	cbz	r3, 46d86 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   46d74:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   46d78:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   46d7c:	1912      	adds	r2, r2, r4
   46d7e:	eb45 0101 	adc.w	r1, r5, r1
   46d82:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   46d86:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   46d88:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   46d8a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   46d8c:	2300      	movs	r3, #0
	node->prev = NULL;
   46d8e:	e9c0 3300 	strd	r3, r3, [r0]
}
   46d92:	bd30      	pop	{r4, r5, pc}
   46d94:	2001a58c 	.word	0x2001a58c

00046d98 <next_timeout>:

static int32_t next_timeout(void)
{
   46d98:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   46d9a:	4b13      	ldr	r3, [pc, #76]	; (46de8 <next_timeout+0x50>)
   46d9c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46d9e:	429c      	cmp	r4, r3
   46da0:	bf08      	it	eq
   46da2:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   46da4:	f7ff ffd4 	bl	46d50 <elapsed>
   46da8:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   46daa:	b1bc      	cbz	r4, 46ddc <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46dac:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   46db0:	1b40      	subs	r0, r0, r5
   46db2:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   46db6:	2801      	cmp	r0, #1
   46db8:	f171 0300 	sbcs.w	r3, r1, #0
   46dbc:	db11      	blt.n	46de2 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46dbe:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   46dc2:	2300      	movs	r3, #0
   46dc4:	4282      	cmp	r2, r0
   46dc6:	eb73 0401 	sbcs.w	r4, r3, r1
   46dca:	da00      	bge.n	46dce <next_timeout+0x36>
   46dcc:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   46dce:	4b07      	ldr	r3, [pc, #28]	; (46dec <next_timeout+0x54>)
   46dd0:	691b      	ldr	r3, [r3, #16]
   46dd2:	b113      	cbz	r3, 46dda <next_timeout+0x42>
   46dd4:	4298      	cmp	r0, r3
   46dd6:	bfa8      	it	ge
   46dd8:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   46dda:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   46ddc:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   46de0:	e7f5      	b.n	46dce <next_timeout+0x36>
   46de2:	2000      	movs	r0, #0
   46de4:	e7f3      	b.n	46dce <next_timeout+0x36>
   46de6:	bf00      	nop
   46de8:	2001a58c 	.word	0x2001a58c
   46dec:	2001acfc 	.word	0x2001acfc

00046df0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46df0:	f1b3 3fff 	cmp.w	r3, #4294967295
   46df4:	bf08      	it	eq
   46df6:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
   46dfa:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46dfe:	4604      	mov	r4, r0
   46e00:	4692      	mov	sl, r2
   46e02:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46e04:	d073      	beq.n	46eee <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   46e06:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   46e08:	f04f 0320 	mov.w	r3, #32
   46e0c:	f3ef 8511 	mrs	r5, BASEPRI
   46e10:	f383 8812 	msr	BASEPRI_MAX, r3
   46e14:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   46e18:	f06f 0301 	mvn.w	r3, #1
   46e1c:	f04f 32ff 	mov.w	r2, #4294967295
   46e20:	ebb3 080a 	subs.w	r8, r3, sl
   46e24:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   46e28:	f1b8 0f00 	cmp.w	r8, #0
   46e2c:	f179 0100 	sbcs.w	r1, r9, #0
   46e30:	db1c      	blt.n	46e6c <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   46e32:	4830      	ldr	r0, [pc, #192]	; (46ef4 <z_add_timeout+0x104>)
   46e34:	e9d0 1000 	ldrd	r1, r0, [r0]
   46e38:	1a5b      	subs	r3, r3, r1
   46e3a:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   46e3e:	ebb3 060a 	subs.w	r6, r3, sl
   46e42:	eb62 070b 	sbc.w	r7, r2, fp
   46e46:	2e01      	cmp	r6, #1
   46e48:	f177 0300 	sbcs.w	r3, r7, #0
   46e4c:	bfbc      	itt	lt
   46e4e:	2601      	movlt	r6, #1
   46e50:	2700      	movlt	r7, #0
   46e52:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   46e56:	4a28      	ldr	r2, [pc, #160]	; (46ef8 <z_add_timeout+0x108>)
   46e58:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46e5c:	4293      	cmp	r3, r2
   46e5e:	d11e      	bne.n	46e9e <z_add_timeout+0xae>
	node->prev = tail;
   46e60:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   46e64:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   46e68:	6054      	str	r4, [r2, #4]
}
   46e6a:	e02d      	b.n	46ec8 <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   46e6c:	f7ff ff70 	bl	46d50 <elapsed>
   46e70:	f11a 0301 	adds.w	r3, sl, #1
   46e74:	9300      	str	r3, [sp, #0]
   46e76:	f14b 0300 	adc.w	r3, fp, #0
   46e7a:	9301      	str	r3, [sp, #4]
   46e7c:	e9dd 2300 	ldrd	r2, r3, [sp]
   46e80:	1812      	adds	r2, r2, r0
   46e82:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   46e86:	e9c4 2304 	strd	r2, r3, [r4, #16]
   46e8a:	e7e4      	b.n	46e56 <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   46e8c:	ebb6 0008 	subs.w	r0, r6, r8
   46e90:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   46e94:	4563      	cmp	r3, ip
   46e96:	e9c4 0104 	strd	r0, r1, [r4, #16]
   46e9a:	d0e1      	beq.n	46e60 <z_add_timeout+0x70>
   46e9c:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   46e9e:	2b00      	cmp	r3, #0
   46ea0:	d0de      	beq.n	46e60 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   46ea2:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   46ea6:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   46eaa:	4546      	cmp	r6, r8
   46eac:	eb77 0109 	sbcs.w	r1, r7, r9
   46eb0:	daec      	bge.n	46e8c <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   46eb2:	ebb8 0006 	subs.w	r0, r8, r6
   46eb6:	eb69 0107 	sbc.w	r1, r9, r7
   46eba:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   46ebe:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46ec0:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   46ec4:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   46ec6:	605c      	str	r4, [r3, #4]
	return list->head == list;
   46ec8:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46eca:	4293      	cmp	r3, r2
   46ecc:	d00b      	beq.n	46ee6 <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   46ece:	429c      	cmp	r4, r3
   46ed0:	d109      	bne.n	46ee6 <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   46ed2:	f7ff ff61 	bl	46d98 <next_timeout>

			if (next_time == 0 ||
   46ed6:	b118      	cbz	r0, 46ee0 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   46ed8:	4b08      	ldr	r3, [pc, #32]	; (46efc <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   46eda:	691b      	ldr	r3, [r3, #16]
   46edc:	4283      	cmp	r3, r0
   46ede:	d002      	beq.n	46ee6 <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   46ee0:	2100      	movs	r1, #0
   46ee2:	f7fc fce5 	bl	438b0 <sys_clock_set_timeout>
	__asm__ volatile(
   46ee6:	f385 8811 	msr	BASEPRI, r5
   46eea:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   46eee:	b003      	add	sp, #12
   46ef0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   46ef4:	2001a7e0 	.word	0x2001a7e0
   46ef8:	2001a58c 	.word	0x2001a58c
   46efc:	2001acfc 	.word	0x2001acfc

00046f00 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   46f00:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46f04:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   46f06:	f7ff fc7f 	bl	46808 <z_time_slice>
	__asm__ volatile(
   46f0a:	f04f 0320 	mov.w	r3, #32
   46f0e:	f3ef 8411 	mrs	r4, BASEPRI
   46f12:	f383 8812 	msr	BASEPRI_MAX, r3
   46f16:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   46f1a:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 46fcc <sys_clock_announce+0xcc>
   46f1e:	4d2a      	ldr	r5, [pc, #168]	; (46fc8 <sys_clock_announce+0xc8>)
   46f20:	4651      	mov	r1, sl
	return list->head == list;
   46f22:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 46fd0 <sys_clock_announce+0xd0>
   46f26:	602e      	str	r6, [r5, #0]
   46f28:	f8d5 c000 	ldr.w	ip, [r5]
   46f2c:	f8db 0000 	ldr.w	r0, [fp]
   46f30:	4662      	mov	r2, ip
   46f32:	e9da 8900 	ldrd	r8, r9, [sl]
   46f36:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f38:	4558      	cmp	r0, fp
   46f3a:	e9cd 2300 	strd	r2, r3, [sp]
   46f3e:	d00d      	beq.n	46f5c <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   46f40:	b160      	cbz	r0, 46f5c <sys_clock_announce+0x5c>
   46f42:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   46f46:	45b4      	cmp	ip, r6
   46f48:	41bb      	sbcs	r3, r7
   46f4a:	da1d      	bge.n	46f88 <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   46f4c:	9b00      	ldr	r3, [sp, #0]
   46f4e:	ebb6 0c03 	subs.w	ip, r6, r3
   46f52:	9b01      	ldr	r3, [sp, #4]
   46f54:	eb67 0603 	sbc.w	r6, r7, r3
   46f58:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   46f5c:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   46f5e:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   46f60:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   46f62:	eb13 0208 	adds.w	r2, r3, r8
   46f66:	9b01      	ldr	r3, [sp, #4]
   46f68:	eb43 0309 	adc.w	r3, r3, r9
   46f6c:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   46f70:	f7ff ff12 	bl	46d98 <next_timeout>
   46f74:	4631      	mov	r1, r6
   46f76:	f7fc fc9b 	bl	438b0 <sys_clock_set_timeout>
	__asm__ volatile(
   46f7a:	f384 8811 	msr	BASEPRI, r4
   46f7e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   46f82:	b003      	add	sp, #12
   46f84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   46f88:	2200      	movs	r2, #0
   46f8a:	2300      	movs	r3, #0
		curr_tick += dt;
   46f8c:	eb18 0806 	adds.w	r8, r8, r6
   46f90:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   46f94:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   46f98:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   46f9c:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   46fa0:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   46fa2:	f7ff fedf 	bl	46d64 <remove_timeout>
   46fa6:	f384 8811 	msr	BASEPRI, r4
   46faa:	f3bf 8f6f 	isb	sy
		t->fn(t);
   46fae:	6883      	ldr	r3, [r0, #8]
   46fb0:	4798      	blx	r3
	__asm__ volatile(
   46fb2:	f04f 0320 	mov.w	r3, #32
   46fb6:	f3ef 8411 	mrs	r4, BASEPRI
   46fba:	f383 8812 	msr	BASEPRI_MAX, r3
   46fbe:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   46fc2:	4902      	ldr	r1, [pc, #8]	; (46fcc <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   46fc4:	e7b0      	b.n	46f28 <sys_clock_announce+0x28>
   46fc6:	bf00      	nop
   46fc8:	2001ad30 	.word	0x2001ad30
   46fcc:	2001a7e0 	.word	0x2001a7e0
   46fd0:	2001a58c 	.word	0x2001a58c

00046fd4 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   46fd4:	b510      	push	{r4, lr}
   46fd6:	f04f 0320 	mov.w	r3, #32
   46fda:	f3ef 8411 	mrs	r4, BASEPRI
   46fde:	f383 8812 	msr	BASEPRI_MAX, r3
   46fe2:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   46fe6:	f7fc fc97 	bl	43918 <sys_clock_elapsed>
   46fea:	4b06      	ldr	r3, [pc, #24]	; (47004 <sys_clock_tick_get+0x30>)
   46fec:	e9d3 2300 	ldrd	r2, r3, [r3]
   46ff0:	1812      	adds	r2, r2, r0
   46ff2:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   46ff6:	f384 8811 	msr	BASEPRI, r4
   46ffa:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   46ffe:	4610      	mov	r0, r2
   47000:	4619      	mov	r1, r3
   47002:	bd10      	pop	{r4, pc}
   47004:	2001a7e0 	.word	0x2001a7e0

00047008 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   47008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4700a:	4604      	mov	r4, r0
	__asm__ volatile(
   4700c:	f04f 0320 	mov.w	r3, #32
   47010:	f3ef 8511 	mrs	r5, BASEPRI
   47014:	f383 8812 	msr	BASEPRI_MAX, r3
   47018:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   4701c:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   47020:	1c56      	adds	r6, r2, #1
   47022:	f143 0700 	adc.w	r7, r3, #0
   47026:	2f00      	cmp	r7, #0
   47028:	bf08      	it	eq
   4702a:	2e02      	cmpeq	r6, #2
   4702c:	d302      	bcc.n	47034 <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   4702e:	4917      	ldr	r1, [pc, #92]	; (4708c <z_timer_expiration_handler+0x84>)
   47030:	f7ff fede 	bl	46df0 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   47034:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47036:	3301      	adds	r3, #1
   47038:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   4703a:	6a23      	ldr	r3, [r4, #32]
   4703c:	b173      	cbz	r3, 4705c <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   4703e:	f385 8811 	msr	BASEPRI, r5
   47042:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   47046:	4620      	mov	r0, r4
   47048:	6a23      	ldr	r3, [r4, #32]
   4704a:	4798      	blx	r3
	__asm__ volatile(
   4704c:	f04f 0320 	mov.w	r3, #32
   47050:	f3ef 8511 	mrs	r5, BASEPRI
   47054:	f383 8812 	msr	BASEPRI_MAX, r3
   47058:	f3bf 8f6f 	isb	sy
	return list->head == list;
   4705c:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47060:	42a6      	cmp	r6, r4
   47062:	d000      	beq.n	47066 <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   47064:	b926      	cbnz	r6, 47070 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   47066:	f385 8811 	msr	BASEPRI, r5
   4706a:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   4706e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   47070:	4630      	mov	r0, r6
   47072:	f001 fb5c 	bl	4872e <z_unpend_thread_no_timeout>
   47076:	2300      	movs	r3, #0
   47078:	67b3      	str	r3, [r6, #120]	; 0x78
   4707a:	f385 8811 	msr	BASEPRI, r5
   4707e:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   47082:	4630      	mov	r0, r6
}
   47084:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   47088:	f001 bb95 	b.w	487b6 <z_ready_thread>
   4708c:	00047009 	.word	0x00047009

00047090 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   47090:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   47094:	4619      	mov	r1, r3
   47096:	4606      	mov	r6, r0
   47098:	4610      	mov	r0, r2
   4709a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   4709e:	1c4c      	adds	r4, r1, #1
   470a0:	bf08      	it	eq
   470a2:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   470a6:	4680      	mov	r8, r0
   470a8:	4689      	mov	r9, r1
   470aa:	d04c      	beq.n	47146 <z_impl_k_timer_start+0xb6>
   470ac:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   470ae:	1c6b      	adds	r3, r5, #1
   470b0:	bf08      	it	eq
   470b2:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   470b6:	4614      	mov	r4, r2
   470b8:	d019      	beq.n	470ee <z_impl_k_timer_start+0x5e>
   470ba:	ea54 0305 	orrs.w	r3, r4, r5
   470be:	d016      	beq.n	470ee <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   470c0:	f06f 0301 	mvn.w	r3, #1
   470c4:	ebb3 0a02 	subs.w	sl, r3, r2
   470c8:	f04f 33ff 	mov.w	r3, #4294967295
   470cc:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   470d0:	f1ba 0f00 	cmp.w	sl, #0
   470d4:	f17b 0300 	sbcs.w	r3, fp, #0
   470d8:	da09      	bge.n	470ee <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   470da:	f112 34ff 	adds.w	r4, r2, #4294967295
   470de:	f145 35ff 	adc.w	r5, r5, #4294967295
   470e2:	2c01      	cmp	r4, #1
   470e4:	f175 0300 	sbcs.w	r3, r5, #0
   470e8:	bfbc      	itt	lt
   470ea:	2401      	movlt	r4, #1
   470ec:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   470ee:	f06f 0301 	mvn.w	r3, #1
   470f2:	1a1b      	subs	r3, r3, r0
   470f4:	9300      	str	r3, [sp, #0]
   470f6:	f04f 33ff 	mov.w	r3, #4294967295
   470fa:	eb63 0301 	sbc.w	r3, r3, r1
   470fe:	9301      	str	r3, [sp, #4]
   47100:	e9dd 2300 	ldrd	r2, r3, [sp]
   47104:	2a00      	cmp	r2, #0
   47106:	f173 0300 	sbcs.w	r3, r3, #0
   4710a:	da0c      	bge.n	47126 <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   4710c:	f110 38ff 	adds.w	r8, r0, #4294967295
   47110:	f141 39ff 	adc.w	r9, r1, #4294967295
   47114:	f1b8 0f00 	cmp.w	r8, #0
   47118:	f179 0300 	sbcs.w	r3, r9, #0
   4711c:	bfbc      	itt	lt
   4711e:	f04f 0800 	movlt.w	r8, #0
   47122:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   47126:	4630      	mov	r0, r6
   47128:	f001 fbe1 	bl	488ee <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   4712c:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   4712e:	4642      	mov	r2, r8
	timer->status = 0U;
   47130:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47132:	4630      	mov	r0, r6
   47134:	464b      	mov	r3, r9
   47136:	4905      	ldr	r1, [pc, #20]	; (4714c <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   47138:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   4713c:	b002      	add	sp, #8
   4713e:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47142:	f7ff be55 	b.w	46df0 <z_add_timeout>
}
   47146:	b002      	add	sp, #8
   47148:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   4714c:	00047009 	.word	0x00047009

00047150 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   47150:	4a02      	ldr	r2, [pc, #8]	; (4715c <boot_banner+0xc>)
   47152:	4903      	ldr	r1, [pc, #12]	; (47160 <boot_banner+0x10>)
   47154:	4803      	ldr	r0, [pc, #12]	; (47164 <boot_banner+0x14>)
   47156:	f000 b8f1 	b.w	4733c <printk>
   4715a:	bf00      	nop
   4715c:	00049092 	.word	0x00049092
   47160:	000497a7 	.word	0x000497a7
   47164:	000497b4 	.word	0x000497b4

00047168 <tfm_platform_system_reset>:
#include "tfm_ns_interface.h"
#include "tfm_veneers.h"

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   47168:	2300      	movs	r3, #0
{
   4716a:	b507      	push	{r0, r1, r2, lr}
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   4716c:	461a      	mov	r2, r3
   4716e:	4619      	mov	r1, r3
   47170:	9300      	str	r3, [sp, #0]
   47172:	4803      	ldr	r0, [pc, #12]	; (47180 <tfm_platform_system_reset+0x18>)
   47174:	f7fc fd9c 	bl	43cb0 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_platform_sp_system_reset_veneer,
                                0,
                                0,
                                0,
                                0);
}
   47178:	b003      	add	sp, #12
   4717a:	f85d fb04 	ldr.w	pc, [sp], #4
   4717e:	bf00      	nop
   47180:	00037e41 	.word	0x00037e41

00047184 <psa_generate_random>:
    return status;
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   47184:	b530      	push	{r4, r5, lr}
   47186:	b093      	sub	sp, #76	; 0x4c
   47188:	4605      	mov	r5, r0
   4718a:	460c      	mov	r4, r1
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   4718c:	2228      	movs	r2, #40	; 0x28
   4718e:	2100      	movs	r1, #0
   47190:	a808      	add	r0, sp, #32
   47192:	f000 ff34 	bl	47ffe <memset>
   47196:	233f      	movs	r3, #63	; 0x3f
   47198:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_GENERATE_RANDOM_SID,
    };

    psa_invec in_vec[] = {
   4719a:	ab07      	add	r3, sp, #28
   4719c:	9303      	str	r3, [sp, #12]
   4719e:	232c      	movs	r3, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   471a0:	9406      	str	r4, [sp, #24]
   471a2:	e9cd 3504 	strd	r3, r5, [sp, #16]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   471a6:	b144      	cbz	r4, 471ba <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    status = API_DISPATCH(tfm_crypto_generate_random,
   471a8:	2201      	movs	r2, #1
   471aa:	4805      	ldr	r0, [pc, #20]	; (471c0 <psa_generate_random+0x3c>)
   471ac:	9200      	str	r2, [sp, #0]
   471ae:	ab05      	add	r3, sp, #20
   471b0:	a903      	add	r1, sp, #12
   471b2:	f7fc fd7d 	bl	43cb0 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_RANDOM);

    return status;
}
   471b6:	b013      	add	sp, #76	; 0x4c
   471b8:	bd30      	pop	{r4, r5, pc}
        return PSA_SUCCESS;
   471ba:	4620      	mov	r0, r4
   471bc:	e7fb      	b.n	471b6 <psa_generate_random+0x32>
   471be:	bf00      	nop
   471c0:	00037c11 	.word	0x00037c11

000471c4 <ethers_keccak256>:
  void ethers_keccak256(const uint8_t *data, uint16_t length, uint8_t *result) {
   471c4:	b570      	push	{r4, r5, r6, lr}
   471c6:	460e      	mov	r6, r1
   471c8:	4605      	mov	r5, r0
   471ca:	4614      	mov	r4, r2
   471cc:	b0e4      	sub	sp, #400	; 0x190
    keccak_init(&context);
   471ce:	4668      	mov	r0, sp
   471d0:	f000 f811 	bl	471f6 <keccak_init>
    keccak_update(&context, (const unsigned char*)data, (size_t)length);
   471d4:	4632      	mov	r2, r6
   471d6:	4629      	mov	r1, r5
   471d8:	4668      	mov	r0, sp
   471da:	f000 f811 	bl	47200 <keccak_update>
    keccak_final(&context, (unsigned char*)result);
   471de:	4621      	mov	r1, r4
   471e0:	4668      	mov	r0, sp
   471e2:	f000 f852 	bl	4728a <keccak_final>
    memset((char*)&context, 0, sizeof(SHA3_CTX));
   471e6:	f44f 72c8 	mov.w	r2, #400	; 0x190
   471ea:	2100      	movs	r1, #0
   471ec:	4668      	mov	r0, sp
   471ee:	f000 ff06 	bl	47ffe <memset>
}
   471f2:	b064      	add	sp, #400	; 0x190
   471f4:	bd70      	pop	{r4, r5, r6, pc}

000471f6 <keccak_init>:
    memset(ctx, 0, sizeof(SHA3_CTX));
   471f6:	f44f 72c8 	mov.w	r2, #400	; 0x190
   471fa:	2100      	movs	r1, #0
   471fc:	f000 beff 	b.w	47ffe <memset>

00047200 <keccak_update>:
 * @param ctx the algorithm context containing current hashing state
 * @param msg message chunk
 * @param size length of the message chunk
 */
void keccak_update(SHA3_CTX *ctx, const unsigned char *msg, uint16_t size)
{
   47200:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47204:	4606      	mov	r6, r0
    uint16_t idx = (uint16_t)ctx->rest;
   47206:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
{
   4720a:	4614      	mov	r4, r2

    //if (ctx->rest & SHA3_FINALIZED) return; /* too late for additional input */
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   4720c:	1887      	adds	r7, r0, r2
   4720e:	2288      	movs	r2, #136	; 0x88
   47210:	fbb7 f3f2 	udiv	r3, r7, r2
   47214:	fb02 7313 	mls	r3, r2, r3, r7
{
   47218:	460d      	mov	r5, r1
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   4721a:	f8a6 3188 	strh.w	r3, [r6, #392]	; 0x188

    /* fill partial block */
    if (idx) {
   4721e:	b198      	cbz	r0, 47248 <keccak_update+0x48>
        uint16_t left = BLOCK_SIZE - idx;
   47220:	1a17      	subs	r7, r2, r0
   47222:	b2bf      	uxth	r7, r7
        memcpy((char*)ctx->message + idx, msg, (size < left ? size : left));
   47224:	42bc      	cmp	r4, r7
   47226:	f106 08c8 	add.w	r8, r6, #200	; 0xc8
   4722a:	4622      	mov	r2, r4
   4722c:	4440      	add	r0, r8
   4722e:	bf28      	it	cs
   47230:	463a      	movcs	r2, r7
   47232:	f000 fed9 	bl	47fe8 <memcpy>
        if (size < left) return;
   47236:	42bc      	cmp	r4, r7
   47238:	d325      	bcc.n	47286 <keccak_update+0x86>

        /* process partial block */
        sha3_process_block(ctx->hash, ctx->message);
   4723a:	4641      	mov	r1, r8
   4723c:	4630      	mov	r0, r6
   4723e:	f7f9 f92b 	bl	40498 <sha3_process_block>
        msg  += left;
        size -= left;
   47242:	1be4      	subs	r4, r4, r7
        msg  += left;
   47244:	443d      	add	r5, r7
        size -= left;
   47246:	b2a4      	uxth	r4, r4
        uint64_t* aligned_message_block;
        if (IS_ALIGNED_64(msg)) {
            // the most common case is processing of an already aligned message without copying it
            aligned_message_block = (uint64_t*)(void*)msg;
        } else {
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47248:	f106 07c8 	add.w	r7, r6, #200	; 0xc8
    while (size >= BLOCK_SIZE) {
   4724c:	2c87      	cmp	r4, #135	; 0x87
   4724e:	d808      	bhi.n	47262 <keccak_update+0x62>
        sha3_process_block(ctx->hash, aligned_message_block);
        msg  += BLOCK_SIZE;
        size -= BLOCK_SIZE;
    }

    if (size) {
   47250:	b1cc      	cbz	r4, 47286 <keccak_update+0x86>
        memcpy(ctx->message, msg, size); /* save leftovers */
   47252:	4622      	mov	r2, r4
   47254:	4629      	mov	r1, r5
   47256:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
    }
}
   4725a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        memcpy(ctx->message, msg, size); /* save leftovers */
   4725e:	f000 bec3 	b.w	47fe8 <memcpy>
        if (IS_ALIGNED_64(msg)) {
   47262:	076b      	lsls	r3, r5, #29
   47264:	d00d      	beq.n	47282 <keccak_update+0x82>
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47266:	2288      	movs	r2, #136	; 0x88
   47268:	4629      	mov	r1, r5
   4726a:	4638      	mov	r0, r7
   4726c:	46b8      	mov	r8, r7
   4726e:	f000 febb 	bl	47fe8 <memcpy>
        sha3_process_block(ctx->hash, aligned_message_block);
   47272:	4641      	mov	r1, r8
   47274:	4630      	mov	r0, r6
   47276:	3c88      	subs	r4, #136	; 0x88
   47278:	f7f9 f90e 	bl	40498 <sha3_process_block>
        msg  += BLOCK_SIZE;
   4727c:	3588      	adds	r5, #136	; 0x88
        size -= BLOCK_SIZE;
   4727e:	b2a4      	uxth	r4, r4
   47280:	e7e4      	b.n	4724c <keccak_update+0x4c>
   47282:	46a8      	mov	r8, r5
   47284:	e7f5      	b.n	47272 <keccak_update+0x72>
}
   47286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004728a <keccak_final>:
*
* @param ctx the algorithm context containing current hashing state
* @param result calculated hash in binary form
*/
void keccak_final(SHA3_CTX *ctx, unsigned char* result)
{
   4728a:	b570      	push	{r4, r5, r6, lr}
   4728c:	4604      	mov	r4, r0
   4728e:	460d      	mov	r5, r1
    uint16_t digest_length = 100 - BLOCK_SIZE / 2;

//    if (!(ctx->rest & SHA3_FINALIZED)) {
        /* clear the rest of the data queue */
        memset((char*)ctx->message + ctx->rest, 0, BLOCK_SIZE - ctx->rest);
   47290:	f100 06c8 	add.w	r6, r0, #200	; 0xc8
   47294:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
   47298:	2100      	movs	r1, #0
   4729a:	f1c0 0288 	rsb	r2, r0, #136	; 0x88
   4729e:	4430      	add	r0, r6
   472a0:	f000 fead 	bl	47ffe <memset>
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   472a4:	f8b4 2188 	ldrh.w	r2, [r4, #392]	; 0x188
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;

        /* process final block */
        sha3_process_block(ctx->hash, ctx->message);
   472a8:	4631      	mov	r1, r6
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   472aa:	5cb3      	ldrb	r3, [r6, r2]
        sha3_process_block(ctx->hash, ctx->message);
   472ac:	4620      	mov	r0, r4
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   472ae:	f043 0301 	orr.w	r3, r3, #1
   472b2:	54b3      	strb	r3, [r6, r2]
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;
   472b4:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
   472b8:	f063 037f 	orn	r3, r3, #127	; 0x7f
   472bc:	f884 314f 	strb.w	r3, [r4, #335]	; 0x14f
        sha3_process_block(ctx->hash, ctx->message);
   472c0:	f7f9 f8ea 	bl	40498 <sha3_process_block>
//        ctx->rest = SHA3_FINALIZED; /* mark context as finalized */
//    }

    if (result) {
   472c4:	b135      	cbz	r5, 472d4 <keccak_final+0x4a>
         me64_to_le_str(result, ctx->hash, digest_length);
   472c6:	4621      	mov	r1, r4
   472c8:	4628      	mov	r0, r5
    }
}
   472ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
         me64_to_le_str(result, ctx->hash, digest_length);
   472ce:	2220      	movs	r2, #32
   472d0:	f000 be8a 	b.w	47fe8 <memcpy>
}
   472d4:	bd70      	pop	{r4, r5, r6, pc}

000472d6 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   472d6:	4603      	mov	r3, r0
   472d8:	b158      	cbz	r0, 472f2 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   472da:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   472dc:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   472e0:	2a01      	cmp	r2, #1
   472e2:	d003      	beq.n	472ec <sys_notify_validate+0x16>
   472e4:	2a03      	cmp	r2, #3
   472e6:	d104      	bne.n	472f2 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   472e8:	6802      	ldr	r2, [r0, #0]
   472ea:	b112      	cbz	r2, 472f2 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   472ec:	2000      	movs	r0, #0
   472ee:	6098      	str	r0, [r3, #8]
   472f0:	4770      	bx	lr
		return -EINVAL;
   472f2:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   472f6:	4770      	bx	lr

000472f8 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   472f8:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   472fa:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   472fc:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   47300:	2a03      	cmp	r2, #3
   47302:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   47306:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   47308:	bf14      	ite	ne
   4730a:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   4730c:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   4730e:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   47310:	4770      	bx	lr

00047312 <arch_printk_char_out>:
}
   47312:	2000      	movs	r0, #0
   47314:	4770      	bx	lr

00047316 <str_out>:
{
   47316:	b530      	push	{r4, r5, lr}
   47318:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   4731a:	680c      	ldr	r4, [r1, #0]
   4731c:	1c55      	adds	r5, r2, #1
   4731e:	b114      	cbz	r4, 47326 <str_out+0x10>
   47320:	684b      	ldr	r3, [r1, #4]
   47322:	4293      	cmp	r3, r2
   47324:	dc01      	bgt.n	4732a <str_out+0x14>
		ctx->count++;
   47326:	608d      	str	r5, [r1, #8]
}
   47328:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   4732a:	3b01      	subs	r3, #1
   4732c:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   4732e:	bf08      	it	eq
   47330:	2200      	moveq	r2, #0
   47332:	608d      	str	r5, [r1, #8]
   47334:	bf0c      	ite	eq
   47336:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   47338:	54a0      	strbne	r0, [r4, r2]
   4733a:	e7f5      	b.n	47328 <str_out+0x12>

0004733c <printk>:
{
   4733c:	b40f      	push	{r0, r1, r2, r3}
   4733e:	b507      	push	{r0, r1, r2, lr}
   47340:	a904      	add	r1, sp, #16
   47342:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   47346:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   47348:	f7f9 f9f0 	bl	4072c <vprintk>
}
   4734c:	b003      	add	sp, #12
   4734e:	f85d eb04 	ldr.w	lr, [sp], #4
   47352:	b004      	add	sp, #16
   47354:	4770      	bx	lr

00047356 <snprintk>:
{
   47356:	b40c      	push	{r2, r3}
   47358:	b507      	push	{r0, r1, r2, lr}
   4735a:	ab04      	add	r3, sp, #16
   4735c:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   47360:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   47362:	f7f9 f9f1 	bl	40748 <vsnprintk>
}
   47366:	b003      	add	sp, #12
   47368:	f85d eb04 	ldr.w	lr, [sp], #4
   4736c:	b002      	add	sp, #8
   4736e:	4770      	bx	lr

00047370 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47370:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   47372:	f013 0307 	ands.w	r3, r3, #7
   47376:	d105      	bne.n	47384 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   47378:	6803      	ldr	r3, [r0, #0]
   4737a:	2b00      	cmp	r3, #0
		evt = EVT_START;
   4737c:	bf0c      	ite	eq
   4737e:	2000      	moveq	r0, #0
   47380:	2003      	movne	r0, #3
   47382:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   47384:	2b02      	cmp	r3, #2
   47386:	d105      	bne.n	47394 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   47388:	8b43      	ldrh	r3, [r0, #26]
   4738a:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   4738c:	bf14      	ite	ne
   4738e:	2000      	movne	r0, #0
   47390:	2004      	moveq	r0, #4
   47392:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   47394:	2b01      	cmp	r3, #1
   47396:	d105      	bne.n	473a4 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   47398:	6803      	ldr	r3, [r0, #0]
   4739a:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   4739c:	bf0c      	ite	eq
   4739e:	2000      	moveq	r0, #0
   473a0:	2005      	movne	r0, #5
   473a2:	4770      	bx	lr
	int evt = EVT_NOP;
   473a4:	2000      	movs	r0, #0
}
   473a6:	4770      	bx	lr

000473a8 <notify_one>:
{
   473a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   473ac:	460d      	mov	r5, r1
   473ae:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   473b0:	4619      	mov	r1, r3
   473b2:	1d28      	adds	r0, r5, #4
{
   473b4:	4690      	mov	r8, r2
   473b6:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   473b8:	f7ff ff9e 	bl	472f8 <sys_notify_finalize>
	if (cb) {
   473bc:	4604      	mov	r4, r0
   473be:	b138      	cbz	r0, 473d0 <notify_one+0x28>
		cb(mgr, cli, state, res);
   473c0:	4633      	mov	r3, r6
   473c2:	4642      	mov	r2, r8
   473c4:	4629      	mov	r1, r5
   473c6:	4638      	mov	r0, r7
   473c8:	46a4      	mov	ip, r4
}
   473ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   473ce:	4760      	bx	ip
}
   473d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000473d4 <transition_complete>:
{
   473d4:	b410      	push	{r4}
	__asm__ volatile(
   473d6:	f04f 0420 	mov.w	r4, #32
   473da:	f3ef 8211 	mrs	r2, BASEPRI
   473de:	f384 8812 	msr	BASEPRI_MAX, r4
   473e2:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   473e6:	6141      	str	r1, [r0, #20]
}
   473e8:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   473ea:	2101      	movs	r1, #1
   473ec:	f7f9 b9c0 	b.w	40770 <process_event>

000473f0 <validate_args>:
{
   473f0:	b510      	push	{r4, lr}
   473f2:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   473f4:	b140      	cbz	r0, 47408 <validate_args+0x18>
   473f6:	b139      	cbz	r1, 47408 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   473f8:	1d08      	adds	r0, r1, #4
   473fa:	f7ff ff6c 	bl	472d6 <sys_notify_validate>
	if ((rv == 0)
   473fe:	b928      	cbnz	r0, 4740c <validate_args+0x1c>
	    && ((cli->notify.flags
   47400:	68a3      	ldr	r3, [r4, #8]
   47402:	f033 0303 	bics.w	r3, r3, #3
   47406:	d001      	beq.n	4740c <validate_args+0x1c>
		rv = -EINVAL;
   47408:	f06f 0015 	mvn.w	r0, #21
}
   4740c:	bd10      	pop	{r4, pc}

0004740e <onoff_manager_init>:
{
   4740e:	b538      	push	{r3, r4, r5, lr}
   47410:	460c      	mov	r4, r1
	if ((mgr == NULL)
   47412:	4605      	mov	r5, r0
   47414:	b158      	cbz	r0, 4742e <onoff_manager_init+0x20>
	    || (transitions == NULL)
   47416:	b151      	cbz	r1, 4742e <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   47418:	680b      	ldr	r3, [r1, #0]
   4741a:	b143      	cbz	r3, 4742e <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   4741c:	684b      	ldr	r3, [r1, #4]
   4741e:	b133      	cbz	r3, 4742e <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   47420:	221c      	movs	r2, #28
   47422:	2100      	movs	r1, #0
   47424:	f000 fdeb 	bl	47ffe <memset>
	return 0;
   47428:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   4742a:	612c      	str	r4, [r5, #16]
}
   4742c:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   4742e:	f06f 0015 	mvn.w	r0, #21
   47432:	e7fb      	b.n	4742c <onoff_manager_init+0x1e>

00047434 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   47434:	b570      	push	{r4, r5, r6, lr}
   47436:	4604      	mov	r4, r0
   47438:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   4743a:	f7ff ffd9 	bl	473f0 <validate_args>

	if (rv < 0) {
   4743e:	1e05      	subs	r5, r0, #0
   47440:	db31      	blt.n	474a6 <onoff_request+0x72>
   47442:	f04f 0320 	mov.w	r3, #32
   47446:	f3ef 8111 	mrs	r1, BASEPRI
   4744a:	f383 8812 	msr	BASEPRI_MAX, r3
   4744e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   47452:	f64f 75ff 	movw	r5, #65535	; 0xffff
   47456:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47458:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   4745a:	42ab      	cmp	r3, r5
   4745c:	f000 0207 	and.w	r2, r0, #7
   47460:	d02e      	beq.n	474c0 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   47462:	2a02      	cmp	r2, #2
   47464:	d10e      	bne.n	47484 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   47466:	3301      	adds	r3, #1
   47468:	8363      	strh	r3, [r4, #26]
	rv = state;
   4746a:	4615      	mov	r5, r2
		notify = true;
   4746c:	2301      	movs	r3, #1
	__asm__ volatile(
   4746e:	f381 8811 	msr	BASEPRI, r1
   47472:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   47476:	b1b3      	cbz	r3, 474a6 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   47478:	2300      	movs	r3, #0
   4747a:	4631      	mov	r1, r6
   4747c:	4620      	mov	r0, r4
   4747e:	f7ff ff93 	bl	473a8 <notify_one>
   47482:	e010      	b.n	474a6 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   47484:	0783      	lsls	r3, r0, #30
   47486:	d001      	beq.n	4748c <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   47488:	2a06      	cmp	r2, #6
   4748a:	d10e      	bne.n	474aa <onoff_request+0x76>
	parent->next = child;
   4748c:	2300      	movs	r3, #0
   4748e:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   47490:	6863      	ldr	r3, [r4, #4]
   47492:	b993      	cbnz	r3, 474ba <onoff_request+0x86>
	list->head = node;
   47494:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   47498:	4615      	mov	r5, r2
   4749a:	b962      	cbnz	r2, 474b6 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   4749c:	460a      	mov	r2, r1
   4749e:	4620      	mov	r0, r4
   474a0:	2102      	movs	r1, #2
   474a2:	f7f9 f965 	bl	40770 <process_event>
		}
	}

	return rv;
}
   474a6:	4628      	mov	r0, r5
   474a8:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   474aa:	2a05      	cmp	r2, #5
   474ac:	bf0c      	ite	eq
   474ae:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   474b2:	f06f 0504 	mvnne.w	r5, #4
   474b6:	2300      	movs	r3, #0
   474b8:	e7d9      	b.n	4746e <onoff_request+0x3a>
	parent->next = child;
   474ba:	601e      	str	r6, [r3, #0]
	list->tail = node;
   474bc:	6066      	str	r6, [r4, #4]
}
   474be:	e7eb      	b.n	47498 <onoff_request+0x64>
		rv = -EAGAIN;
   474c0:	f06f 050a 	mvn.w	r5, #10
   474c4:	e7f7      	b.n	474b6 <onoff_request+0x82>

000474c6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   474c6:	4604      	mov	r4, r0
   474c8:	b508      	push	{r3, lr}
   474ca:	4608      	mov	r0, r1
   474cc:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   474ce:	461a      	mov	r2, r3
   474d0:	47a0      	blx	r4
	return z_impl_z_current_get();
   474d2:	f7ff fbcb 	bl	46c6c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   474d6:	f7fb f915 	bl	42704 <z_impl_k_thread_abort>

000474da <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   474da:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   474de:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   474e0:	0840      	lsrs	r0, r0, #1
   474e2:	4770      	bx	lr

000474e4 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   474e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   474e6:	4603      	mov	r3, r0
   474e8:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   474ea:	f7ff fff6 	bl	474da <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   474ee:	fab0 f080 	clz	r0, r0
   474f2:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   474f6:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   474fa:	f8dc 6010 	ldr.w	r6, [ip, #16]
   474fe:	00ca      	lsls	r2, r1, #3
   47500:	1d17      	adds	r7, r2, #4
   47502:	b28d      	uxth	r5, r1
   47504:	3206      	adds	r2, #6
   47506:	b956      	cbnz	r6, 4751e <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   47508:	2101      	movs	r1, #1
   4750a:	fa01 f000 	lsl.w	r0, r1, r0
   4750e:	68d9      	ldr	r1, [r3, #12]
   47510:	4301      	orrs	r1, r0
   47512:	60d9      	str	r1, [r3, #12]
		b->next = c;
   47514:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   47518:	53dd      	strh	r5, [r3, r7]
   4751a:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   4751c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   4751e:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   47520:	3104      	adds	r1, #4
   47522:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   47524:	53d8      	strh	r0, [r3, r7]
   47526:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   4752a:	529e      	strh	r6, [r3, r2]
   4752c:	80c5      	strh	r5, [r0, #6]
   4752e:	525d      	strh	r5, [r3, r1]
   47530:	e7f4      	b.n	4751c <free_list_add+0x38>

00047532 <free_list_remove_bidx>:
{
   47532:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   47534:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   47538:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   4753a:	4299      	cmp	r1, r3
   4753c:	f102 0104 	add.w	r1, r2, #4
   47540:	d10a      	bne.n	47558 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   47542:	2301      	movs	r3, #1
   47544:	fa03 f202 	lsl.w	r2, r3, r2
   47548:	68c3      	ldr	r3, [r0, #12]
   4754a:	ea23 0302 	bic.w	r3, r3, r2
   4754e:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   47550:	2300      	movs	r3, #0
   47552:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   47556:	bd10      	pop	{r4, pc}
   47558:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   4755a:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   4755e:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   47562:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   47566:	80cb      	strh	r3, [r1, #6]
   47568:	8082      	strh	r2, [r0, #4]
}
   4756a:	e7f4      	b.n	47556 <free_list_remove_bidx+0x24>

0004756c <free_list_remove>:
{
   4756c:	b510      	push	{r4, lr}
   4756e:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   47570:	f7ff ffb3 	bl	474da <chunk_size>
}
   47574:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   47578:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   4757c:	4618      	mov	r0, r3
   4757e:	f1c2 021f 	rsb	r2, r2, #31
   47582:	f7ff bfd6 	b.w	47532 <free_list_remove_bidx>

00047586 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   47586:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4758a:	fab1 f581 	clz	r5, r1
   4758e:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   47592:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   47596:	693a      	ldr	r2, [r7, #16]
{
   47598:	4603      	mov	r3, r0
   4759a:	460e      	mov	r6, r1
	if (b->next) {
   4759c:	b1ca      	cbz	r2, 475d2 <alloc_chunk+0x4c>
   4759e:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   475a2:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   475a4:	4618      	mov	r0, r3
   475a6:	4621      	mov	r1, r4
   475a8:	f7ff ff97 	bl	474da <chunk_size>
   475ac:	42b0      	cmp	r0, r6
   475ae:	d307      	bcc.n	475c0 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   475b0:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   475b2:	4621      	mov	r1, r4
   475b4:	4618      	mov	r0, r3
   475b6:	f7ff ffbc 	bl	47532 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   475ba:	4620      	mov	r0, r4
   475bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   475c0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   475c4:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   475c6:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   475ca:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   475cc:	d001      	beq.n	475d2 <alloc_chunk+0x4c>
   475ce:	428a      	cmp	r2, r1
   475d0:	d1e7      	bne.n	475a2 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   475d2:	f04f 34ff 	mov.w	r4, #4294967295
   475d6:	68d9      	ldr	r1, [r3, #12]
   475d8:	f1c5 0520 	rsb	r5, r5, #32
   475dc:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   475de:	400c      	ands	r4, r1
   475e0:	d0eb      	beq.n	475ba <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   475e2:	fa94 f2a4 	rbit	r2, r4
   475e6:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   475ea:	1d11      	adds	r1, r2, #4
   475ec:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   475f0:	e7df      	b.n	475b2 <alloc_chunk+0x2c>

000475f2 <merge_chunks>:
{
   475f2:	b538      	push	{r3, r4, r5, lr}
   475f4:	4603      	mov	r3, r0
   475f6:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   475f8:	f7ff ff6f 	bl	474da <chunk_size>
   475fc:	4611      	mov	r1, r2
   475fe:	4604      	mov	r4, r0
   47600:	4618      	mov	r0, r3
   47602:	f7ff ff6a 	bl	474da <chunk_size>
   47606:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   47608:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   4760c:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   4760e:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   47610:	4618      	mov	r0, r3
   47612:	4611      	mov	r1, r2
   47614:	f7ff ff61 	bl	474da <chunk_size>
	void *cmem = &buf[c];
   47618:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   4761a:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   4761e:	bd38      	pop	{r3, r4, r5, pc}

00047620 <split_chunks>:
{
   47620:	b538      	push	{r3, r4, r5, lr}
   47622:	4603      	mov	r3, r0
   47624:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   47626:	f7ff ff58 	bl	474da <chunk_size>
	chunksz_t lsz = rc - lc;
   4762a:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   4762c:	1aa5      	subs	r5, r4, r2
   4762e:	4405      	add	r5, r0
   47630:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47634:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   47636:	8060      	strh	r0, [r4, #2]
   47638:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   4763c:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   4763e:	8044      	strh	r4, [r0, #2]
   47640:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   47644:	4618      	mov	r0, r3
   47646:	4611      	mov	r1, r2
   47648:	f7ff ff47 	bl	474da <chunk_size>
	void *cmem = &buf[c];
   4764c:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   4764e:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   47652:	bd38      	pop	{r3, r4, r5, pc}

00047654 <free_chunk>:
{
   47654:	b538      	push	{r3, r4, r5, lr}
   47656:	4605      	mov	r5, r0
   47658:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   4765a:	f7ff ff3e 	bl	474da <chunk_size>
   4765e:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   47660:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   47664:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   47666:	07da      	lsls	r2, r3, #31
   47668:	d40a      	bmi.n	47680 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   4766a:	4628      	mov	r0, r5
   4766c:	f7ff ff7e 	bl	4756c <free_list_remove>
	return c + chunk_size(h, c);
   47670:	4621      	mov	r1, r4
   47672:	4628      	mov	r0, r5
   47674:	f7ff ff31 	bl	474da <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   47678:	1822      	adds	r2, r4, r0
   4767a:	4628      	mov	r0, r5
   4767c:	f7ff ffb9 	bl	475f2 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   47680:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47684:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   47686:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   4768a:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   4768c:	07db      	lsls	r3, r3, #31
   4768e:	d40c      	bmi.n	476aa <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   47690:	4628      	mov	r0, r5
   47692:	f7ff ff6b 	bl	4756c <free_list_remove>
		return ((uint16_t *)cmem)[f];
   47696:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   4769a:	4622      	mov	r2, r4
   4769c:	1a61      	subs	r1, r4, r1
   4769e:	4628      	mov	r0, r5
   476a0:	f7ff ffa7 	bl	475f2 <merge_chunks>
   476a4:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   476a8:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   476aa:	4621      	mov	r1, r4
   476ac:	4628      	mov	r0, r5
}
   476ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   476b2:	f7ff bf17 	b.w	474e4 <free_list_add>

000476b6 <sys_heap_free>:
	if (mem == NULL) {
   476b6:	b161      	cbz	r1, 476d2 <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   476b8:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   476ba:	3904      	subs	r1, #4
   476bc:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   476be:	f021 0307 	bic.w	r3, r1, #7
   476c2:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   476c4:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   476c6:	08c9      	lsrs	r1, r1, #3
   476c8:	f022 0201 	bic.w	r2, r2, #1
   476cc:	805a      	strh	r2, [r3, #2]
   476ce:	f7ff bfc1 	b.w	47654 <free_chunk>
}
   476d2:	4770      	bx	lr

000476d4 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   476d4:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   476d6:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   476d8:	b909      	cbnz	r1, 476de <sys_heap_alloc+0xa>
		return NULL;
   476da:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   476dc:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   476de:	68ab      	ldr	r3, [r5, #8]
   476e0:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   476e4:	d9f9      	bls.n	476da <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   476e6:	310b      	adds	r1, #11
   476e8:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   476ea:	4621      	mov	r1, r4
   476ec:	4628      	mov	r0, r5
   476ee:	f7ff ff4a 	bl	47586 <alloc_chunk>
	if (c == 0U) {
   476f2:	4606      	mov	r6, r0
   476f4:	2800      	cmp	r0, #0
   476f6:	d0f0      	beq.n	476da <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   476f8:	4601      	mov	r1, r0
   476fa:	4628      	mov	r0, r5
   476fc:	f7ff feed 	bl	474da <chunk_size>
   47700:	42a0      	cmp	r0, r4
   47702:	d908      	bls.n	47716 <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   47704:	4434      	add	r4, r6
   47706:	4628      	mov	r0, r5
   47708:	4622      	mov	r2, r4
   4770a:	f7ff ff89 	bl	47620 <split_chunks>
		free_list_add(h, c + chunk_sz);
   4770e:	4621      	mov	r1, r4
   47710:	4628      	mov	r0, r5
   47712:	f7ff fee7 	bl	474e4 <free_list_add>
	void *cmem = &buf[c];
   47716:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   4771a:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   4771c:	8853      	ldrh	r3, [r2, #2]
   4771e:	3004      	adds	r0, #4
   47720:	f043 0301 	orr.w	r3, r3, #1
   47724:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   47726:	e7d9      	b.n	476dc <sys_heap_alloc+0x8>

00047728 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   47728:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4772c:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   4772e:	424a      	negs	r2, r1
   47730:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   47734:	ea31 0202 	bics.w	r2, r1, r2
{
   47738:	4603      	mov	r3, r0
	if (align != rew) {
   4773a:	d00a      	beq.n	47752 <sys_heap_aligned_alloc+0x2a>
		return false;
   4773c:	2f04      	cmp	r7, #4
   4773e:	463a      	mov	r2, r7
   47740:	bf28      	it	cs
   47742:	2204      	movcs	r2, #4
   47744:	46b9      	mov	r9, r7
		align -= rew;
   47746:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   47748:	b974      	cbnz	r4, 47768 <sys_heap_aligned_alloc+0x40>
		return NULL;
   4774a:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   4774c:	4628      	mov	r0, r5
   4774e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   47752:	2904      	cmp	r1, #4
   47754:	d804      	bhi.n	47760 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   47756:	4621      	mov	r1, r4
}
   47758:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   4775c:	f7ff bfba 	b.w	476d4 <sys_heap_alloc>
		rew = 0;
   47760:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   47764:	2204      	movs	r2, #4
   47766:	e7ef      	b.n	47748 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   47768:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   4776a:	68b3      	ldr	r3, [r6, #8]
   4776c:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   47770:	d9eb      	bls.n	4774a <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47772:	f104 010b 	add.w	r1, r4, #11
   47776:	4439      	add	r1, r7
   47778:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   4777a:	4630      	mov	r0, r6
   4777c:	08c9      	lsrs	r1, r1, #3
   4777e:	f7ff ff02 	bl	47586 <alloc_chunk>
	if (c0 == 0) {
   47782:	4680      	mov	r8, r0
   47784:	2800      	cmp	r0, #0
   47786:	d0e0      	beq.n	4774a <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   47788:	f109 0504 	add.w	r5, r9, #4
   4778c:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   47790:	1e7b      	subs	r3, r7, #1
   47792:	4435      	add	r5, r6
   47794:	441d      	add	r5, r3
   47796:	427f      	negs	r7, r7
   47798:	403d      	ands	r5, r7
   4779a:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   4779e:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   477a0:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   477a2:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   477a4:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   477a6:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   477aa:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   477ac:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   477b0:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   477b4:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   477b8:	d208      	bcs.n	477cc <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   477ba:	4601      	mov	r1, r0
   477bc:	463a      	mov	r2, r7
   477be:	4630      	mov	r0, r6
   477c0:	f7ff ff2e 	bl	47620 <split_chunks>
		free_list_add(h, c0);
   477c4:	4641      	mov	r1, r8
   477c6:	4630      	mov	r0, r6
   477c8:	f7ff fe8c 	bl	474e4 <free_list_add>
	return c + chunk_size(h, c);
   477cc:	4639      	mov	r1, r7
   477ce:	4630      	mov	r0, r6
   477d0:	f7ff fe83 	bl	474da <chunk_size>
   477d4:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   477d6:	4284      	cmp	r4, r0
   477d8:	d207      	bcs.n	477ea <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   477da:	4630      	mov	r0, r6
   477dc:	4622      	mov	r2, r4
   477de:	f7ff ff1f 	bl	47620 <split_chunks>
		free_list_add(h, c_end);
   477e2:	4621      	mov	r1, r4
   477e4:	4630      	mov	r0, r6
   477e6:	f7ff fe7d 	bl	474e4 <free_list_add>
	void *cmem = &buf[c];
   477ea:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   477ee:	8873      	ldrh	r3, [r6, #2]
   477f0:	f043 0301 	orr.w	r3, r3, #1
   477f4:	8073      	strh	r3, [r6, #2]
   477f6:	e7a9      	b.n	4774c <sys_heap_aligned_alloc+0x24>

000477f8 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   477f8:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   477fa:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   477fc:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   477fe:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47802:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   47806:	1ad2      	subs	r2, r2, r3
{
   47808:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   4780a:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   4780c:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   4780e:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   47812:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   47814:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   47818:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   4781a:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   4781c:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   4781e:	60dd      	str	r5, [r3, #12]
   47820:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   47822:	f103 0610 	add.w	r6, r3, #16
   47826:	4418      	add	r0, r3
   47828:	4286      	cmp	r6, r0
   4782a:	d118      	bne.n	4785e <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   4782c:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   4782e:	f040 0001 	orr.w	r0, r0, #1
   47832:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   47834:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47836:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   47838:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   4783c:	801d      	strh	r5, [r3, #0]
   4783e:	8077      	strh	r7, [r6, #2]
   47840:	189e      	adds	r6, r3, r2
   47842:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   47846:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   4784a:	8075      	strh	r5, [r6, #2]
   4784c:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   4784e:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   47850:	4618      	mov	r0, r3
   47852:	f042 0201 	orr.w	r2, r2, #1
   47856:	8062      	strh	r2, [r4, #2]
}
   47858:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   4785a:	f7ff be43 	b.w	474e4 <free_list_add>
		h->buckets[i].next = 0;
   4785e:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   47862:	e7e1      	b.n	47828 <sys_heap_init+0x30>

00047864 <encode_uint>:
{
   47864:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   47868:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   4786a:	78d3      	ldrb	r3, [r2, #3]
{
   4786c:	4614      	mov	r4, r2
	switch (specifier) {
   4786e:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   47870:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   47874:	4606      	mov	r6, r0
   47876:	460f      	mov	r7, r1
   47878:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   4787a:	d02d      	beq.n	478d8 <encode_uint+0x74>
   4787c:	d828      	bhi.n	478d0 <encode_uint+0x6c>
		return 16;
   4787e:	2b58      	cmp	r3, #88	; 0x58
   47880:	bf14      	ite	ne
   47882:	250a      	movne	r5, #10
   47884:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   47886:	46aa      	mov	sl, r5
   47888:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   4788c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   47890:	4652      	mov	r2, sl
   47892:	465b      	mov	r3, fp
   47894:	4630      	mov	r0, r6
   47896:	4639      	mov	r1, r7
   47898:	f7f8 fc54 	bl	40144 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   4789c:	2a09      	cmp	r2, #9
   4789e:	b2d3      	uxtb	r3, r2
   478a0:	d81f      	bhi.n	478e2 <encode_uint+0x7e>
   478a2:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   478a4:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   478a6:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   478a8:	bf08      	it	eq
   478aa:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   478ac:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   478b0:	d301      	bcc.n	478b6 <encode_uint+0x52>
   478b2:	45c8      	cmp	r8, r9
   478b4:	d812      	bhi.n	478dc <encode_uint+0x78>
	if (conv->flag_hash) {
   478b6:	7823      	ldrb	r3, [r4, #0]
   478b8:	069b      	lsls	r3, r3, #26
   478ba:	d505      	bpl.n	478c8 <encode_uint+0x64>
		if (radix == 8) {
   478bc:	2d08      	cmp	r5, #8
   478be:	d116      	bne.n	478ee <encode_uint+0x8a>
			conv->altform_0 = true;
   478c0:	78a3      	ldrb	r3, [r4, #2]
   478c2:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   478c6:	70a3      	strb	r3, [r4, #2]
}
   478c8:	4640      	mov	r0, r8
   478ca:	b003      	add	sp, #12
   478cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   478d0:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   478d4:	2b70      	cmp	r3, #112	; 0x70
   478d6:	e7d3      	b.n	47880 <encode_uint+0x1c>
	switch (specifier) {
   478d8:	2508      	movs	r5, #8
   478da:	e7d4      	b.n	47886 <encode_uint+0x22>
		value /= radix;
   478dc:	4606      	mov	r6, r0
   478de:	460f      	mov	r7, r1
   478e0:	e7d6      	b.n	47890 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   478e2:	9a01      	ldr	r2, [sp, #4]
   478e4:	2a19      	cmp	r2, #25
   478e6:	bf94      	ite	ls
   478e8:	3337      	addls	r3, #55	; 0x37
   478ea:	3357      	addhi	r3, #87	; 0x57
   478ec:	e7da      	b.n	478a4 <encode_uint+0x40>
		} else if (radix == 16) {
   478ee:	2d10      	cmp	r5, #16
   478f0:	d1ea      	bne.n	478c8 <encode_uint+0x64>
			conv->altform_0c = true;
   478f2:	78a3      	ldrb	r3, [r4, #2]
   478f4:	f043 0310 	orr.w	r3, r3, #16
   478f8:	e7e5      	b.n	478c6 <encode_uint+0x62>

000478fa <outs>:
{
   478fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   478fe:	4607      	mov	r7, r0
   47900:	4688      	mov	r8, r1
   47902:	4615      	mov	r5, r2
   47904:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   47906:	4614      	mov	r4, r2
   47908:	42b4      	cmp	r4, r6
   4790a:	eba4 0005 	sub.w	r0, r4, r5
   4790e:	d302      	bcc.n	47916 <outs+0x1c>
   47910:	b93e      	cbnz	r6, 47922 <outs+0x28>
   47912:	7823      	ldrb	r3, [r4, #0]
   47914:	b12b      	cbz	r3, 47922 <outs+0x28>
		int rc = out((int)*sp++, ctx);
   47916:	4641      	mov	r1, r8
   47918:	f814 0b01 	ldrb.w	r0, [r4], #1
   4791c:	47b8      	blx	r7
		if (rc < 0) {
   4791e:	2800      	cmp	r0, #0
   47920:	daf2      	bge.n	47908 <outs+0xe>
}
   47922:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047926 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   47926:	4770      	bx	lr

00047928 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   47928:	b084      	sub	sp, #16
   4792a:	ab04      	add	r3, sp, #16
   4792c:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   47930:	f89d 3004 	ldrb.w	r3, [sp, #4]
   47934:	2b06      	cmp	r3, #6
   47936:	d108      	bne.n	4794a <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   47938:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   4793c:	2201      	movs	r2, #1
   4793e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   47942:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   47946:	bf20      	wfe
    while (true)
   47948:	e7fd      	b.n	47946 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   4794a:	b004      	add	sp, #16
   4794c:	4770      	bx	lr

0004794e <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   4794e:	b084      	sub	sp, #16
   47950:	ab04      	add	r3, sp, #16
   47952:	e903 0007 	stmdb	r3, {r0, r1, r2}
   47956:	2300      	movs	r3, #0
   47958:	f383 8811 	msr	BASEPRI, r3
   4795c:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   47960:	b004      	add	sp, #16
   47962:	4770      	bx	lr

00047964 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   47964:	2300      	movs	r3, #0
	list->head = NULL;
   47966:	e9c0 3300 	strd	r3, r3, [r0]
}
   4796a:	4770      	bx	lr

0004796c <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   4796c:	6803      	ldr	r3, [r0, #0]
   4796e:	b923      	cbnz	r3, 4797a <log_list_add_tail+0xe>
		list->head = msg;
   47970:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   47972:	2300      	movs	r3, #0
	list->tail = msg;
   47974:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   47976:	600b      	str	r3, [r1, #0]
}
   47978:	4770      	bx	lr
		list->tail->next = msg;
   4797a:	6843      	ldr	r3, [r0, #4]
   4797c:	6019      	str	r1, [r3, #0]
   4797e:	e7f8      	b.n	47972 <log_list_add_tail+0x6>

00047980 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   47980:	6800      	ldr	r0, [r0, #0]
   47982:	4770      	bx	lr

00047984 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   47984:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   47986:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   47988:	b108      	cbz	r0, 4798e <log_list_head_get+0xa>
		list->head = list->head->next;
   4798a:	6802      	ldr	r2, [r0, #0]
   4798c:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   4798e:	4770      	bx	lr

00047990 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   47990:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   47992:	f7f9 fe6d 	bl	41670 <log_msg_chunk_alloc>

	if (msg != NULL) {
   47996:	b118      	cbz	r0, 479a0 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   47998:	2301      	movs	r3, #1
   4799a:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   4799c:	2300      	movs	r3, #0
   4799e:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
   479a0:	bd08      	pop	{r3, pc}

000479a2 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   479a2:	f000 bc97 	b.w	482d4 <sys_clock_cycle_get_32>

000479a6 <dummy_timestamp>:
   479a6:	2000      	movs	r0, #0
   479a8:	4770      	bx	lr

000479aa <z_log_get_s_mask>:
{
   479aa:	b5f0      	push	{r4, r5, r6, r7, lr}
   479ac:	4605      	mov	r5, r0
	uint32_t mask = 0U;
   479ae:	2000      	movs	r0, #0
				mask |= BIT(arg);
   479b0:	2701      	movs	r7, #1
	uint32_t arg = 0U;
   479b2:	4603      	mov	r3, r0
	bool arm = false;
   479b4:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
   479b6:	f815 4b01 	ldrb.w	r4, [r5], #1
   479ba:	b10c      	cbz	r4, 479c0 <z_log_get_s_mask+0x16>
   479bc:	428b      	cmp	r3, r1
   479be:	d300      	bcc.n	479c2 <z_log_get_s_mask+0x18>
}
   479c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   479c2:	2c25      	cmp	r4, #37	; 0x25
   479c4:	d102      	bne.n	479cc <z_log_get_s_mask+0x22>
			arm = !arm;
   479c6:	f082 0201 	eor.w	r2, r2, #1
   479ca:	e7f4      	b.n	479b6 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   479cc:	2a00      	cmp	r2, #0
   479ce:	d0f2      	beq.n	479b6 <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   479d0:	f044 0620 	orr.w	r6, r4, #32
   479d4:	3e61      	subs	r6, #97	; 0x61
   479d6:	2e19      	cmp	r6, #25
   479d8:	d8ed      	bhi.n	479b6 <z_log_get_s_mask+0xc>
			if (curr == 's') {
   479da:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   479dc:	bf04      	itt	eq
   479de:	fa07 f203 	lsleq.w	r2, r7, r3
   479e2:	4310      	orreq	r0, r2
			arg++;
   479e4:	3301      	adds	r3, #1
			arm = false;
   479e6:	2200      	movs	r2, #0
   479e8:	e7e5      	b.n	479b6 <z_log_get_s_mask+0xc>

000479ea <log_0>:
{
   479ea:	b538      	push	{r3, r4, r5, lr}
   479ec:	4605      	mov	r5, r0
   479ee:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   479f0:	f7ff ffce 	bl	47990 <z_log_msg_std_alloc>

	if (msg != NULL) {
   479f4:	b128      	cbz	r0, 47a02 <log_0+0x18>
		msg_finalize(msg, src_level);
   479f6:	4621      	mov	r1, r4
		msg->str = str;
   479f8:	6105      	str	r5, [r0, #16]
}
   479fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   479fe:	f7f9 bd3d 	b.w	4147c <msg_finalize>
}
   47a02:	bd38      	pop	{r3, r4, r5, pc}

00047a04 <log_1>:
{
   47a04:	b570      	push	{r4, r5, r6, lr}
   47a06:	4606      	mov	r6, r0
   47a08:	460d      	mov	r5, r1
   47a0a:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47a0c:	f7ff ffc0 	bl	47990 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47a10:	b158      	cbz	r0, 47a2a <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   47a12:	2101      	movs	r1, #1
   47a14:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   47a16:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   47a18:	f361 1207 	bfi	r2, r1, #4, #4
   47a1c:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
   47a1e:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
   47a20:	6145      	str	r5, [r0, #20]
}
   47a22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   47a26:	f7f9 bd29 	b.w	4147c <msg_finalize>
}
   47a2a:	bd70      	pop	{r4, r5, r6, pc}

00047a2c <log_2>:
{
   47a2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47a30:	4680      	mov	r8, r0
   47a32:	460f      	mov	r7, r1
   47a34:	4616      	mov	r6, r2
   47a36:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47a38:	f7ff ffaa 	bl	47990 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47a3c:	b168      	cbz	r0, 47a5a <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   47a3e:	2202      	movs	r2, #2
   47a40:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47a42:	4629      	mov	r1, r5
   47a44:	f362 1307 	bfi	r3, r2, #4, #4
   47a48:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47a4a:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47a4e:	f8c0 8010 	str.w	r8, [r0, #16]
}
   47a52:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   47a56:	f7f9 bd11 	b.w	4147c <msg_finalize>
}
   47a5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047a5e <log_3>:
{
   47a5e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47a62:	4680      	mov	r8, r0
   47a64:	460f      	mov	r7, r1
   47a66:	4616      	mov	r6, r2
   47a68:	461d      	mov	r5, r3
   47a6a:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47a6e:	f7ff ff8f 	bl	47990 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47a72:	b170      	cbz	r0, 47a92 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   47a74:	2203      	movs	r2, #3
   47a76:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47a78:	4649      	mov	r1, r9
   47a7a:	f362 1307 	bfi	r3, r2, #4, #4
   47a7e:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47a80:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47a84:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
   47a88:	61c5      	str	r5, [r0, #28]
}
   47a8a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   47a8e:	f7f9 bcf5 	b.w	4147c <msg_finalize>
}
   47a92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00047a96 <z_log_get_tag>:
}
   47a96:	2000      	movs	r0, #0
   47a98:	4770      	bx	lr

00047a9a <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   47a9a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47a9e:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47aa0:	8903      	ldrh	r3, [r0, #8]
{
   47aa2:	460e      	mov	r6, r1
   47aa4:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47aa6:	f3c3 028d 	ubfx	r2, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   47aaa:	42a2      	cmp	r2, r4
{
   47aac:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
   47ab0:	d803      	bhi.n	47aba <log_msg_hexdump_data_op+0x20>
		*length = 0;
   47ab2:	2300      	movs	r3, #0
   47ab4:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   47ab6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   47aba:	680b      	ldr	r3, [r1, #0]
   47abc:	4423      	add	r3, r4
   47abe:	4293      	cmp	r3, r2
		*length = available_len - offset;
   47ac0:	bf84      	itt	hi
   47ac2:	1b13      	subhi	r3, r2, r4
   47ac4:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47ac6:	2a0c      	cmp	r2, #12
	req_len = *length;
   47ac8:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47acc:	d92a      	bls.n	47b24 <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   47ace:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   47ad0:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   47ad4:	d82d      	bhi.n	47b32 <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   47ad6:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
   47ad8:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47ada:	454a      	cmp	r2, r9
   47adc:	bf28      	it	cs
   47ade:	464a      	movcs	r2, r9
   47ae0:	4420      	add	r0, r4
   47ae2:	4615      	mov	r5, r2
		if (put_op) {
   47ae4:	b317      	cbz	r7, 47b2c <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
   47ae6:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   47ae8:	f000 fa7e 	bl	47fe8 <memcpy>
		req_len -= cpy_len;
   47aec:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47af0:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
   47af2:	f1b9 0f00 	cmp.w	r9, #0
   47af6:	d0de      	beq.n	47ab6 <log_msg_hexdump_data_op+0x1c>
   47af8:	f1b8 0f00 	cmp.w	r8, #0
   47afc:	d0db      	beq.n	47ab6 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   47afe:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47b02:	454d      	cmp	r5, r9
   47b04:	bf28      	it	cs
   47b06:	464d      	movcs	r5, r9
		if (put_op) {
   47b08:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
   47b0a:	462a      	mov	r2, r5
   47b0c:	4440      	add	r0, r8
		if (put_op) {
   47b0e:	b1bf      	cbz	r7, 47b40 <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
   47b10:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   47b12:	f000 fa69 	bl	47fe8 <memcpy>
		offset = 0;
   47b16:	2400      	movs	r4, #0
		cont = cont->next;
   47b18:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
   47b1c:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47b20:	442e      	add	r6, r5
   47b22:	e7e6      	b.n	47af2 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
   47b24:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
   47b28:	3014      	adds	r0, #20
	if (offset < chunk_len) {
   47b2a:	e7d6      	b.n	47ada <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   47b2c:	4601      	mov	r1, r0
   47b2e:	4630      	mov	r0, r6
   47b30:	e7da      	b.n	47ae8 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   47b32:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   47b34:	2c1b      	cmp	r4, #27
   47b36:	d9dc      	bls.n	47af2 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   47b38:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   47b3c:	3c1c      	subs	r4, #28
   47b3e:	e7f9      	b.n	47b34 <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
   47b40:	4601      	mov	r1, r0
   47b42:	4630      	mov	r0, r6
   47b44:	e7e5      	b.n	47b12 <log_msg_hexdump_data_op+0x78>

00047b46 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   47b46:	3004      	adds	r0, #4
   47b48:	e8d0 3fef 	ldaex	r3, [r0]
   47b4c:	3301      	adds	r3, #1
   47b4e:	e8c0 3fe2 	stlex	r2, r3, [r0]
   47b52:	2a00      	cmp	r2, #0
   47b54:	d1f8      	bne.n	47b48 <log_msg_get+0x2>
}
   47b56:	4770      	bx	lr

00047b58 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   47b58:	7a40      	ldrb	r0, [r0, #9]
}
   47b5a:	0900      	lsrs	r0, r0, #4
   47b5c:	4770      	bx	lr

00047b5e <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   47b5e:	7a43      	ldrb	r3, [r0, #9]
   47b60:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   47b64:	ea4f 1213 	mov.w	r2, r3, lsr #4
   47b68:	d216      	bcs.n	47b98 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   47b6a:	2a03      	cmp	r2, #3
   47b6c:	d803      	bhi.n	47b76 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   47b6e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47b72:	6948      	ldr	r0, [r1, #20]
   47b74:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   47b76:	2901      	cmp	r1, #1
   47b78:	d803      	bhi.n	47b82 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   47b7a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47b7e:	6988      	ldr	r0, [r1, #24]
   47b80:	4770      	bx	lr
	cont = msg->payload.ext.next;
   47b82:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   47b84:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   47b86:	2906      	cmp	r1, #6
   47b88:	d803      	bhi.n	47b92 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   47b8a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   47b8e:	6848      	ldr	r0, [r1, #4]
   47b90:	4770      	bx	lr
		cont = cont->next;
   47b92:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   47b94:	3907      	subs	r1, #7
		cont = cont->next;
   47b96:	e7f6      	b.n	47b86 <log_msg_arg_get+0x28>
		return 0;
   47b98:	2000      	movs	r0, #0
}
   47b9a:	4770      	bx	lr

00047b9c <log_msg_put>:
{
   47b9c:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   47b9e:	1d02      	adds	r2, r0, #4
   47ba0:	e8d2 1fef 	ldaex	r1, [r2]
   47ba4:	3901      	subs	r1, #1
   47ba6:	e8c2 1fec 	stlex	ip, r1, [r2]
   47baa:	f1bc 0f00 	cmp.w	ip, #0
   47bae:	d1f7      	bne.n	47ba0 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
   47bb0:	685b      	ldr	r3, [r3, #4]
   47bb2:	b90b      	cbnz	r3, 47bb8 <log_msg_put+0x1c>
		msg_free(msg);
   47bb4:	f7f9 bd70 	b.w	41698 <msg_free>
}
   47bb8:	4770      	bx	lr

00047bba <log_msg_str_get>:
}
   47bba:	6900      	ldr	r0, [r0, #16]
   47bbc:	4770      	bx	lr

00047bbe <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   47bbe:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   47bc0:	2400      	movs	r4, #0
   47bc2:	9400      	str	r4, [sp, #0]
   47bc4:	f7ff ff69 	bl	47a9a <log_msg_hexdump_data_op>
}
   47bc8:	b002      	add	sp, #8
   47bca:	bd10      	pop	{r4, pc}

00047bcc <buffer_write>:
{
   47bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47bce:	4606      	mov	r6, r0
   47bd0:	460d      	mov	r5, r1
   47bd2:	4614      	mov	r4, r2
   47bd4:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   47bd6:	4621      	mov	r1, r4
   47bd8:	4628      	mov	r0, r5
   47bda:	463a      	mov	r2, r7
   47bdc:	47b0      	blx	r6
	} while (len != 0);
   47bde:	1a24      	subs	r4, r4, r0
		buf += processed;
   47be0:	4405      	add	r5, r0
	} while (len != 0);
   47be2:	d1f8      	bne.n	47bd6 <buffer_write+0xa>
}
   47be4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00047be6 <std_print>:
{
   47be6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   47bea:	b08e      	sub	sp, #56	; 0x38
   47bec:	af0e      	add	r7, sp, #56	; 0x38
   47bee:	4680      	mov	r8, r0
   47bf0:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   47bf2:	f7ff ffe2 	bl	47bba <log_msg_str_get>
   47bf6:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
   47bf8:	4640      	mov	r0, r8
   47bfa:	f7ff ffad 	bl	47b58 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
   47bfe:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
   47c02:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
   47c04:	0083      	lsls	r3, r0, #2
   47c06:	3307      	adds	r3, #7
   47c08:	f023 0307 	bic.w	r3, r3, #7
   47c0c:	ebad 0d03 	sub.w	sp, sp, r3
   47c10:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   47c12:	45d1      	cmp	r9, sl
   47c14:	d116      	bne.n	47c44 <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   47c16:	4640      	mov	r0, r8
   47c18:	f7ff ff9e 	bl	47b58 <log_msg_nargs_get>
   47c1c:	280f      	cmp	r0, #15
   47c1e:	d81e      	bhi.n	47c5e <std_print+0x78>
   47c20:	e8df f010 	tbh	[pc, r0, lsl #1]
   47c24:	00200019 	.word	0x00200019
   47c28:	002d0026 	.word	0x002d0026
   47c2c:	00410036 	.word	0x00410036
   47c30:	005d004e 	.word	0x005d004e
   47c34:	0081006e 	.word	0x0081006e
   47c38:	00ad0096 	.word	0x00ad0096
   47c3c:	00e100c6 	.word	0x00e100c6
   47c40:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
   47c44:	4649      	mov	r1, r9
   47c46:	4640      	mov	r0, r8
   47c48:	f7ff ff89 	bl	47b5e <log_msg_arg_get>
   47c4c:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   47c50:	f109 0901 	add.w	r9, r9, #1
   47c54:	e7dd      	b.n	47c12 <std_print+0x2c>
		print_formatted(output, str);
   47c56:	4631      	mov	r1, r6
   47c58:	4628      	mov	r0, r5
   47c5a:	f7f9 fd5b 	bl	41714 <print_formatted>
}
   47c5e:	46bd      	mov	sp, r7
   47c60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
   47c64:	4631      	mov	r1, r6
   47c66:	4628      	mov	r0, r5
   47c68:	6822      	ldr	r2, [r4, #0]
   47c6a:	f7f9 fd53 	bl	41714 <print_formatted>
		break;
   47c6e:	e7f6      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
   47c70:	4631      	mov	r1, r6
   47c72:	e9d4 2300 	ldrd	r2, r3, [r4]
   47c76:	4628      	mov	r0, r5
   47c78:	f7f9 fd4c 	bl	41714 <print_formatted>
		break;
   47c7c:	e7ef      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
   47c7e:	68a3      	ldr	r3, [r4, #8]
   47c80:	4631      	mov	r1, r6
   47c82:	9300      	str	r3, [sp, #0]
   47c84:	4628      	mov	r0, r5
   47c86:	e9d4 2300 	ldrd	r2, r3, [r4]
   47c8a:	f7f9 fd43 	bl	41714 <print_formatted>
		break;
   47c8e:	e7e6      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47c90:	68e3      	ldr	r3, [r4, #12]
   47c92:	4631      	mov	r1, r6
   47c94:	9301      	str	r3, [sp, #4]
   47c96:	68a3      	ldr	r3, [r4, #8]
   47c98:	4628      	mov	r0, r5
   47c9a:	9300      	str	r3, [sp, #0]
   47c9c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47ca0:	f7f9 fd38 	bl	41714 <print_formatted>
		break;
   47ca4:	e7db      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47ca6:	6923      	ldr	r3, [r4, #16]
   47ca8:	4631      	mov	r1, r6
   47caa:	9302      	str	r3, [sp, #8]
   47cac:	68e3      	ldr	r3, [r4, #12]
   47cae:	4628      	mov	r0, r5
   47cb0:	9301      	str	r3, [sp, #4]
   47cb2:	68a3      	ldr	r3, [r4, #8]
   47cb4:	9300      	str	r3, [sp, #0]
   47cb6:	e9d4 2300 	ldrd	r2, r3, [r4]
   47cba:	f7f9 fd2b 	bl	41714 <print_formatted>
		break;
   47cbe:	e7ce      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47cc0:	6963      	ldr	r3, [r4, #20]
   47cc2:	4631      	mov	r1, r6
   47cc4:	9303      	str	r3, [sp, #12]
   47cc6:	6923      	ldr	r3, [r4, #16]
   47cc8:	4628      	mov	r0, r5
   47cca:	9302      	str	r3, [sp, #8]
   47ccc:	68e3      	ldr	r3, [r4, #12]
   47cce:	9301      	str	r3, [sp, #4]
   47cd0:	68a3      	ldr	r3, [r4, #8]
   47cd2:	9300      	str	r3, [sp, #0]
   47cd4:	e9d4 2300 	ldrd	r2, r3, [r4]
   47cd8:	f7f9 fd1c 	bl	41714 <print_formatted>
		break;
   47cdc:	e7bf      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47cde:	69a3      	ldr	r3, [r4, #24]
   47ce0:	4631      	mov	r1, r6
   47ce2:	9304      	str	r3, [sp, #16]
   47ce4:	6963      	ldr	r3, [r4, #20]
   47ce6:	4628      	mov	r0, r5
   47ce8:	9303      	str	r3, [sp, #12]
   47cea:	6923      	ldr	r3, [r4, #16]
   47cec:	9302      	str	r3, [sp, #8]
   47cee:	68e3      	ldr	r3, [r4, #12]
   47cf0:	9301      	str	r3, [sp, #4]
   47cf2:	68a3      	ldr	r3, [r4, #8]
   47cf4:	9300      	str	r3, [sp, #0]
   47cf6:	e9d4 2300 	ldrd	r2, r3, [r4]
   47cfa:	f7f9 fd0b 	bl	41714 <print_formatted>
		break;
   47cfe:	e7ae      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47d00:	69e3      	ldr	r3, [r4, #28]
   47d02:	4631      	mov	r1, r6
   47d04:	9305      	str	r3, [sp, #20]
   47d06:	69a3      	ldr	r3, [r4, #24]
   47d08:	4628      	mov	r0, r5
   47d0a:	9304      	str	r3, [sp, #16]
   47d0c:	6963      	ldr	r3, [r4, #20]
   47d0e:	9303      	str	r3, [sp, #12]
   47d10:	6923      	ldr	r3, [r4, #16]
   47d12:	9302      	str	r3, [sp, #8]
   47d14:	68e3      	ldr	r3, [r4, #12]
   47d16:	9301      	str	r3, [sp, #4]
   47d18:	68a3      	ldr	r3, [r4, #8]
   47d1a:	9300      	str	r3, [sp, #0]
   47d1c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47d20:	f7f9 fcf8 	bl	41714 <print_formatted>
		break;
   47d24:	e79b      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47d26:	6a23      	ldr	r3, [r4, #32]
   47d28:	4631      	mov	r1, r6
   47d2a:	9306      	str	r3, [sp, #24]
   47d2c:	69e3      	ldr	r3, [r4, #28]
   47d2e:	4628      	mov	r0, r5
   47d30:	9305      	str	r3, [sp, #20]
   47d32:	69a3      	ldr	r3, [r4, #24]
   47d34:	9304      	str	r3, [sp, #16]
   47d36:	6963      	ldr	r3, [r4, #20]
   47d38:	9303      	str	r3, [sp, #12]
   47d3a:	6923      	ldr	r3, [r4, #16]
   47d3c:	9302      	str	r3, [sp, #8]
   47d3e:	68e3      	ldr	r3, [r4, #12]
   47d40:	9301      	str	r3, [sp, #4]
   47d42:	68a3      	ldr	r3, [r4, #8]
   47d44:	9300      	str	r3, [sp, #0]
   47d46:	e9d4 2300 	ldrd	r2, r3, [r4]
   47d4a:	f7f9 fce3 	bl	41714 <print_formatted>
		break;
   47d4e:	e786      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47d50:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47d52:	4631      	mov	r1, r6
   47d54:	9307      	str	r3, [sp, #28]
   47d56:	6a23      	ldr	r3, [r4, #32]
   47d58:	4628      	mov	r0, r5
   47d5a:	9306      	str	r3, [sp, #24]
   47d5c:	69e3      	ldr	r3, [r4, #28]
   47d5e:	9305      	str	r3, [sp, #20]
   47d60:	69a3      	ldr	r3, [r4, #24]
   47d62:	9304      	str	r3, [sp, #16]
   47d64:	6963      	ldr	r3, [r4, #20]
   47d66:	9303      	str	r3, [sp, #12]
   47d68:	6923      	ldr	r3, [r4, #16]
   47d6a:	9302      	str	r3, [sp, #8]
   47d6c:	68e3      	ldr	r3, [r4, #12]
   47d6e:	9301      	str	r3, [sp, #4]
   47d70:	68a3      	ldr	r3, [r4, #8]
   47d72:	9300      	str	r3, [sp, #0]
   47d74:	e9d4 2300 	ldrd	r2, r3, [r4]
   47d78:	f7f9 fccc 	bl	41714 <print_formatted>
		break;
   47d7c:	e76f      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47d7e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47d80:	4631      	mov	r1, r6
   47d82:	9308      	str	r3, [sp, #32]
   47d84:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47d86:	4628      	mov	r0, r5
   47d88:	9307      	str	r3, [sp, #28]
   47d8a:	6a23      	ldr	r3, [r4, #32]
   47d8c:	9306      	str	r3, [sp, #24]
   47d8e:	69e3      	ldr	r3, [r4, #28]
   47d90:	9305      	str	r3, [sp, #20]
   47d92:	69a3      	ldr	r3, [r4, #24]
   47d94:	9304      	str	r3, [sp, #16]
   47d96:	6963      	ldr	r3, [r4, #20]
   47d98:	9303      	str	r3, [sp, #12]
   47d9a:	6923      	ldr	r3, [r4, #16]
   47d9c:	9302      	str	r3, [sp, #8]
   47d9e:	68e3      	ldr	r3, [r4, #12]
   47da0:	9301      	str	r3, [sp, #4]
   47da2:	68a3      	ldr	r3, [r4, #8]
   47da4:	9300      	str	r3, [sp, #0]
   47da6:	e9d4 2300 	ldrd	r2, r3, [r4]
   47daa:	f7f9 fcb3 	bl	41714 <print_formatted>
		break;
   47dae:	e756      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47db0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47db2:	4631      	mov	r1, r6
   47db4:	9309      	str	r3, [sp, #36]	; 0x24
   47db6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47db8:	4628      	mov	r0, r5
   47dba:	9308      	str	r3, [sp, #32]
   47dbc:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47dbe:	9307      	str	r3, [sp, #28]
   47dc0:	6a23      	ldr	r3, [r4, #32]
   47dc2:	9306      	str	r3, [sp, #24]
   47dc4:	69e3      	ldr	r3, [r4, #28]
   47dc6:	9305      	str	r3, [sp, #20]
   47dc8:	69a3      	ldr	r3, [r4, #24]
   47dca:	9304      	str	r3, [sp, #16]
   47dcc:	6963      	ldr	r3, [r4, #20]
   47dce:	9303      	str	r3, [sp, #12]
   47dd0:	6923      	ldr	r3, [r4, #16]
   47dd2:	9302      	str	r3, [sp, #8]
   47dd4:	68e3      	ldr	r3, [r4, #12]
   47dd6:	9301      	str	r3, [sp, #4]
   47dd8:	68a3      	ldr	r3, [r4, #8]
   47dda:	9300      	str	r3, [sp, #0]
   47ddc:	e9d4 2300 	ldrd	r2, r3, [r4]
   47de0:	f7f9 fc98 	bl	41714 <print_formatted>
		break;
   47de4:	e73b      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47de6:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47de8:	4631      	mov	r1, r6
   47dea:	930a      	str	r3, [sp, #40]	; 0x28
   47dec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47dee:	4628      	mov	r0, r5
   47df0:	9309      	str	r3, [sp, #36]	; 0x24
   47df2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47df4:	9308      	str	r3, [sp, #32]
   47df6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47df8:	9307      	str	r3, [sp, #28]
   47dfa:	6a23      	ldr	r3, [r4, #32]
   47dfc:	9306      	str	r3, [sp, #24]
   47dfe:	69e3      	ldr	r3, [r4, #28]
   47e00:	9305      	str	r3, [sp, #20]
   47e02:	69a3      	ldr	r3, [r4, #24]
   47e04:	9304      	str	r3, [sp, #16]
   47e06:	6963      	ldr	r3, [r4, #20]
   47e08:	9303      	str	r3, [sp, #12]
   47e0a:	6923      	ldr	r3, [r4, #16]
   47e0c:	9302      	str	r3, [sp, #8]
   47e0e:	68e3      	ldr	r3, [r4, #12]
   47e10:	9301      	str	r3, [sp, #4]
   47e12:	68a3      	ldr	r3, [r4, #8]
   47e14:	9300      	str	r3, [sp, #0]
   47e16:	e9d4 2300 	ldrd	r2, r3, [r4]
   47e1a:	f7f9 fc7b 	bl	41714 <print_formatted>
		break;
   47e1e:	e71e      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47e20:	6b63      	ldr	r3, [r4, #52]	; 0x34
   47e22:	4631      	mov	r1, r6
   47e24:	930b      	str	r3, [sp, #44]	; 0x2c
   47e26:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47e28:	4628      	mov	r0, r5
   47e2a:	930a      	str	r3, [sp, #40]	; 0x28
   47e2c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47e2e:	9309      	str	r3, [sp, #36]	; 0x24
   47e30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47e32:	9308      	str	r3, [sp, #32]
   47e34:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47e36:	9307      	str	r3, [sp, #28]
   47e38:	6a23      	ldr	r3, [r4, #32]
   47e3a:	9306      	str	r3, [sp, #24]
   47e3c:	69e3      	ldr	r3, [r4, #28]
   47e3e:	9305      	str	r3, [sp, #20]
   47e40:	69a3      	ldr	r3, [r4, #24]
   47e42:	9304      	str	r3, [sp, #16]
   47e44:	6963      	ldr	r3, [r4, #20]
   47e46:	9303      	str	r3, [sp, #12]
   47e48:	6923      	ldr	r3, [r4, #16]
   47e4a:	9302      	str	r3, [sp, #8]
   47e4c:	68e3      	ldr	r3, [r4, #12]
   47e4e:	9301      	str	r3, [sp, #4]
   47e50:	68a3      	ldr	r3, [r4, #8]
   47e52:	9300      	str	r3, [sp, #0]
   47e54:	e9d4 2300 	ldrd	r2, r3, [r4]
   47e58:	f7f9 fc5c 	bl	41714 <print_formatted>
		break;
   47e5c:	e6ff      	b.n	47c5e <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47e5e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   47e60:	4631      	mov	r1, r6
   47e62:	930c      	str	r3, [sp, #48]	; 0x30
   47e64:	6b63      	ldr	r3, [r4, #52]	; 0x34
   47e66:	4628      	mov	r0, r5
   47e68:	930b      	str	r3, [sp, #44]	; 0x2c
   47e6a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47e6c:	930a      	str	r3, [sp, #40]	; 0x28
   47e6e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47e70:	9309      	str	r3, [sp, #36]	; 0x24
   47e72:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47e74:	9308      	str	r3, [sp, #32]
   47e76:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47e78:	9307      	str	r3, [sp, #28]
   47e7a:	6a23      	ldr	r3, [r4, #32]
   47e7c:	9306      	str	r3, [sp, #24]
   47e7e:	69e3      	ldr	r3, [r4, #28]
   47e80:	9305      	str	r3, [sp, #20]
   47e82:	69a3      	ldr	r3, [r4, #24]
   47e84:	9304      	str	r3, [sp, #16]
   47e86:	6963      	ldr	r3, [r4, #20]
   47e88:	9303      	str	r3, [sp, #12]
   47e8a:	6923      	ldr	r3, [r4, #16]
   47e8c:	9302      	str	r3, [sp, #8]
   47e8e:	68e3      	ldr	r3, [r4, #12]
   47e90:	9301      	str	r3, [sp, #4]
   47e92:	68a3      	ldr	r3, [r4, #8]
   47e94:	9300      	str	r3, [sp, #0]
   47e96:	e9d4 2300 	ldrd	r2, r3, [r4]
   47e9a:	f7f9 fc3b 	bl	41714 <print_formatted>
}
   47e9e:	e6de      	b.n	47c5e <std_print+0x78>

00047ea0 <log_output_flush>:
		     output->control_block->offset,
   47ea0:	6842      	ldr	r2, [r0, #4]
{
   47ea2:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
   47ea4:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   47ea8:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   47eaa:	6881      	ldr	r1, [r0, #8]
   47eac:	6800      	ldr	r0, [r0, #0]
   47eae:	f7ff fe8d 	bl	47bcc <buffer_write>
	output->control_block->offset = 0;
   47eb2:	2200      	movs	r2, #0
   47eb4:	6863      	ldr	r3, [r4, #4]
   47eb6:	601a      	str	r2, [r3, #0]
}
   47eb8:	bd10      	pop	{r4, pc}

00047eba <out_func>:
{
   47eba:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   47ebc:	684b      	ldr	r3, [r1, #4]
{
   47ebe:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
   47ec0:	681a      	ldr	r2, [r3, #0]
   47ec2:	68cb      	ldr	r3, [r1, #12]
{
   47ec4:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   47ec6:	429a      	cmp	r2, r3
   47ec8:	d102      	bne.n	47ed0 <out_func+0x16>
		log_output_flush(out_ctx);
   47eca:	4608      	mov	r0, r1
   47ecc:	f7ff ffe8 	bl	47ea0 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   47ed0:	6863      	ldr	r3, [r4, #4]
   47ed2:	e8d3 2fef 	ldaex	r2, [r3]
   47ed6:	1c51      	adds	r1, r2, #1
   47ed8:	e8c3 1fe0 	stlex	r0, r1, [r3]
   47edc:	2800      	cmp	r0, #0
   47ede:	d1f8      	bne.n	47ed2 <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
   47ee0:	68a3      	ldr	r3, [r4, #8]
}
   47ee2:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
   47ee4:	549d      	strb	r5, [r3, r2]
}
   47ee6:	bd38      	pop	{r3, r4, r5, pc}

00047ee8 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   47ee8:	2200      	movs	r2, #0
   47eea:	e9c0 2200 	strd	r2, r2, [r0]
   47eee:	6082      	str	r2, [r0, #8]
}
   47ef0:	4770      	bx	lr

00047ef2 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   47ef2:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   47ef4:	6800      	ldr	r0, [r0, #0]
   47ef6:	f7f9 bff9 	b.w	41eec <z_arm_fatal_error>

00047efa <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   47efa:	2100      	movs	r1, #0
   47efc:	2001      	movs	r0, #1
   47efe:	f7f9 bff5 	b.w	41eec <z_arm_fatal_error>

00047f02 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   47f02:	b508      	push	{r3, lr}
	handler();
   47f04:	f7fa f86c 	bl	41fe0 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   47f08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   47f0c:	f7fa b934 	b.w	42178 <z_arm_exc_exit>

00047f10 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   47f10:	6e43      	ldr	r3, [r0, #100]	; 0x64
   47f12:	f383 880b 	msr	PSPLIM, r3
}
   47f16:	4770      	bx	lr

00047f18 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   47f18:	4770      	bx	lr

00047f1a <z_arm_restore_fp_context>:
   47f1a:	4770      	bx	lr

00047f1c <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   47f1c:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   47f20:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   47f24:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   47f26:	bf08      	it	eq
   47f28:	f06f 0015 	mvneq.w	r0, #21
   47f2c:	4770      	bx	lr

00047f2e <mpu_configure_region>:
{
   47f2e:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   47f30:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   47f32:	680c      	ldr	r4, [r1, #0]
{
   47f34:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   47f36:	890a      	ldrh	r2, [r1, #8]
   47f38:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   47f3a:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47f3c:	3b01      	subs	r3, #1
   47f3e:	f024 041f 	bic.w	r4, r4, #31
   47f42:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   47f44:	f002 021f 	and.w	r2, r2, #31
   47f48:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47f4c:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   47f50:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
   47f52:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   47f56:	9303      	str	r3, [sp, #12]
   47f58:	f7fa fc1a 	bl	42790 <region_allocate_and_init>
}
   47f5c:	b005      	add	sp, #20
   47f5e:	bd30      	pop	{r4, r5, pc}

00047f60 <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
   47f60:	4770      	bx	lr

00047f62 <calloc>:

#endif /* CONFIG_MINIMAL_LIBC_MALLOC */

#ifdef CONFIG_MINIMAL_LIBC_CALLOC
void *calloc(size_t nmemb, size_t size)
{
   47f62:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   47f64:	fba0 4501 	umull	r4, r5, r0, r1
   47f68:	b935      	cbnz	r5, 47f78 <calloc+0x16>
	if (size_mul_overflow(nmemb, size, &size)) {
		errno = ENOMEM;
		return NULL;
	}

	ret = malloc(size);
   47f6a:	4620      	mov	r0, r4
   47f6c:	f7fa fd7c 	bl	42a68 <malloc>

	if (ret != NULL) {
   47f70:	4606      	mov	r6, r0
   47f72:	b938      	cbnz	r0, 47f84 <calloc+0x22>
		(void)memset(ret, 0, size);
	}

	return ret;
}
   47f74:	4630      	mov	r0, r6
   47f76:	bd70      	pop	{r4, r5, r6, pc}
   47f78:	f7fe f832 	bl	45fe0 <z_impl_z_errno>
		errno = ENOMEM;
   47f7c:	230c      	movs	r3, #12
		return NULL;
   47f7e:	2600      	movs	r6, #0
		errno = ENOMEM;
   47f80:	6003      	str	r3, [r0, #0]
		return NULL;
   47f82:	e7f7      	b.n	47f74 <calloc+0x12>
		(void)memset(ret, 0, size);
   47f84:	4622      	mov	r2, r4
   47f86:	4629      	mov	r1, r5
   47f88:	f000 f839 	bl	47ffe <memset>
   47f8c:	e7f2      	b.n	47f74 <calloc+0x12>

00047f8e <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   47f8e:	4603      	mov	r3, r0
   47f90:	3901      	subs	r1, #1
   47f92:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   47f96:	b90a      	cbnz	r2, 47f9c <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   47f98:	701a      	strb	r2, [r3, #0]

	return dest;
}
   47f9a:	4770      	bx	lr
		*d = *s;
   47f9c:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   47fa0:	e7f7      	b.n	47f92 <strcpy+0x4>

00047fa2 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
   47fa2:	b570      	push	{r4, r5, r6, lr}
   47fa4:	4605      	mov	r5, r0
   47fa6:	3901      	subs	r1, #1
   47fa8:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   47faa:	b142      	cbz	r2, 47fbe <strncpy+0x1c>
   47fac:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   47fb0:	1e56      	subs	r6, r2, #1
   47fb2:	b92b      	cbnz	r3, 47fc0 <strncpy+0x1e>
   47fb4:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   47fb6:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   47fba:	42a2      	cmp	r2, r4
   47fbc:	d1fb      	bne.n	47fb6 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   47fbe:	bd70      	pop	{r4, r5, r6, pc}
		n--;
   47fc0:	4632      	mov	r2, r6
		*d = *s;
   47fc2:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   47fc6:	e7ef      	b.n	47fa8 <strncpy+0x6>

00047fc8 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   47fc8:	4603      	mov	r3, r0
	size_t n = 0;
   47fca:	2000      	movs	r0, #0

	while (*s != '\0') {
   47fcc:	5c1a      	ldrb	r2, [r3, r0]
   47fce:	b902      	cbnz	r2, 47fd2 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   47fd0:	4770      	bx	lr
		n++;
   47fd2:	3001      	adds	r0, #1
   47fd4:	e7fa      	b.n	47fcc <strlen+0x4>

00047fd6 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   47fd6:	4603      	mov	r3, r0
	size_t n = 0;
   47fd8:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   47fda:	5c1a      	ldrb	r2, [r3, r0]
   47fdc:	b10a      	cbz	r2, 47fe2 <strnlen+0xc>
   47fde:	4288      	cmp	r0, r1
   47fe0:	d100      	bne.n	47fe4 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   47fe2:	4770      	bx	lr
		n++;
   47fe4:	3001      	adds	r0, #1
   47fe6:	e7f8      	b.n	47fda <strnlen+0x4>

00047fe8 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   47fe8:	b510      	push	{r4, lr}
   47fea:	1e43      	subs	r3, r0, #1
   47fec:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   47fee:	4291      	cmp	r1, r2
   47ff0:	d100      	bne.n	47ff4 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   47ff2:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   47ff4:	f811 4b01 	ldrb.w	r4, [r1], #1
   47ff8:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   47ffc:	e7f7      	b.n	47fee <memcpy+0x6>

00047ffe <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   47ffe:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   48000:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   48002:	4402      	add	r2, r0
   48004:	4293      	cmp	r3, r2
   48006:	d100      	bne.n	4800a <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   48008:	4770      	bx	lr
		*(d_byte++) = c_byte;
   4800a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   4800e:	e7f9      	b.n	48004 <memset+0x6>

00048010 <_stdout_hook_default>:
}
   48010:	f04f 30ff 	mov.w	r0, #4294967295
   48014:	4770      	bx	lr

00048016 <fputc>:
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
   48016:	f7fa bd4d 	b.w	42ab4 <z_impl_zephyr_fputc>

0004801a <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   4801a:	b2cb      	uxtb	r3, r1
   4801c:	210c      	movs	r1, #12
   4801e:	6902      	ldr	r2, [r0, #16]
   48020:	fb03 2101 	mla	r1, r3, r1, r2
   48024:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   48026:	f000 0007 	and.w	r0, r0, #7
   4802a:	4770      	bx	lr

0004802c <set_off_state>:
	__asm__ volatile(
   4802c:	f04f 0320 	mov.w	r3, #32
   48030:	f3ef 8211 	mrs	r2, BASEPRI
   48034:	f383 8812 	msr	BASEPRI_MAX, r3
   48038:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   4803c:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   4803e:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   48042:	d001      	beq.n	48048 <set_off_state+0x1c>
   48044:	428b      	cmp	r3, r1
   48046:	d107      	bne.n	48058 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   48048:	2301      	movs	r3, #1
   4804a:	6003      	str	r3, [r0, #0]
	int err = 0;
   4804c:	2000      	movs	r0, #0
	__asm__ volatile(
   4804e:	f382 8811 	msr	BASEPRI, r2
   48052:	f3bf 8f6f 	isb	sy
}
   48056:	4770      	bx	lr
		err = -EPERM;
   48058:	f04f 30ff 	mov.w	r0, #4294967295
   4805c:	e7f7      	b.n	4804e <set_off_state+0x22>

0004805e <set_starting_state>:
{
   4805e:	b510      	push	{r4, lr}
	__asm__ volatile(
   48060:	f04f 0320 	mov.w	r3, #32
   48064:	f3ef 8211 	mrs	r2, BASEPRI
   48068:	f383 8812 	msr	BASEPRI_MAX, r3
   4806c:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   48070:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   48072:	f003 0407 	and.w	r4, r3, #7
   48076:	2c01      	cmp	r4, #1
   48078:	d106      	bne.n	48088 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   4807a:	6001      	str	r1, [r0, #0]
	int err = 0;
   4807c:	2000      	movs	r0, #0
	__asm__ volatile(
   4807e:	f382 8811 	msr	BASEPRI, r2
   48082:	f3bf 8f6f 	isb	sy
}
   48086:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   48088:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   4808c:	428b      	cmp	r3, r1
		err = -EALREADY;
   4808e:	bf14      	ite	ne
   48090:	f04f 30ff 	movne.w	r0, #4294967295
   48094:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   48098:	e7f1      	b.n	4807e <set_starting_state+0x20>

0004809a <set_on_state>:
	__asm__ volatile(
   4809a:	f04f 0320 	mov.w	r3, #32
   4809e:	f3ef 8211 	mrs	r2, BASEPRI
   480a2:	f383 8812 	msr	BASEPRI_MAX, r3
   480a6:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   480aa:	6803      	ldr	r3, [r0, #0]
   480ac:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   480b0:	f043 0302 	orr.w	r3, r3, #2
   480b4:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   480b6:	f382 8811 	msr	BASEPRI, r2
   480ba:	f3bf 8f6f 	isb	sy
}
   480be:	4770      	bx	lr

000480c0 <onoff_started_callback>:
{
   480c0:	b410      	push	{r4}
	notify(mgr, 0);
   480c2:	241c      	movs	r4, #28
	return &data->mgr[type];
   480c4:	6900      	ldr	r0, [r0, #16]
   480c6:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   480c8:	fb03 0004 	mla	r0, r3, r4, r0
   480cc:	2100      	movs	r1, #0
}
   480ce:	bc10      	pop	{r4}
	notify(mgr, 0);
   480d0:	4710      	bx	r2

000480d2 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   480d2:	2000      	movs	r0, #0
   480d4:	f7fb be66 	b.w	43da4 <nrfx_clock_start>

000480d8 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   480d8:	2000      	movs	r0, #0
   480da:	f7fb be95 	b.w	43e08 <nrfx_clock_stop>

000480de <blocking_start_callback>:
{
   480de:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   480e0:	f7fe ba8a 	b.w	465f8 <z_impl_k_sem_give>

000480e4 <api_stop>:
{
   480e4:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   480e6:	240c      	movs	r4, #12
   480e8:	b2c9      	uxtb	r1, r1
   480ea:	434c      	muls	r4, r1
{
   480ec:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   480ee:	6900      	ldr	r0, [r0, #16]
   480f0:	f104 0340 	add.w	r3, r4, #64	; 0x40
   480f4:	2180      	movs	r1, #128	; 0x80
   480f6:	4418      	add	r0, r3
   480f8:	f7ff ff98 	bl	4802c <set_off_state>
	if (err < 0) {
   480fc:	2800      	cmp	r0, #0
   480fe:	db04      	blt.n	4810a <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   48100:	6869      	ldr	r1, [r5, #4]
   48102:	440c      	add	r4, r1
   48104:	6863      	ldr	r3, [r4, #4]
   48106:	4798      	blx	r3
	return 0;
   48108:	2000      	movs	r0, #0
}
   4810a:	bd38      	pop	{r3, r4, r5, pc}

0004810c <api_start>:
{
   4810c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   48110:	240c      	movs	r4, #12
   48112:	b2c9      	uxtb	r1, r1
   48114:	434c      	muls	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   48116:	6905      	ldr	r5, [r0, #16]
{
   48118:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   4811a:	f104 0040 	add.w	r0, r4, #64	; 0x40
   4811e:	2180      	movs	r1, #128	; 0x80
   48120:	4428      	add	r0, r5
{
   48122:	4690      	mov	r8, r2
   48124:	461f      	mov	r7, r3
	err = set_starting_state(&subdata->flags, ctx);
   48126:	f7ff ff9a 	bl	4805e <set_starting_state>
	if (err < 0) {
   4812a:	2800      	cmp	r0, #0
   4812c:	db06      	blt.n	4813c <api_start+0x30>
	subdata->cb = cb;
   4812e:	4425      	add	r5, r4
	subdata->user_data = user_data;
   48130:	e9c5 870e 	strd	r8, r7, [r5, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   48134:	6873      	ldr	r3, [r6, #4]
   48136:	591b      	ldr	r3, [r3, r4]
   48138:	4798      	blx	r3
	return 0;
   4813a:	2000      	movs	r0, #0
}
   4813c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00048140 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48140:	6843      	ldr	r3, [r0, #4]
}
   48142:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48144:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   48146:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   48148:	600b      	str	r3, [r1, #0]
}
   4814a:	4770      	bx	lr

0004814c <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4814c:	6843      	ldr	r3, [r0, #4]
   4814e:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   48150:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   48152:	4042      	eors	r2, r0
   48154:	400a      	ands	r2, r1
   48156:	4042      	eors	r2, r0
    p_reg->OUT = value;
   48158:	605a      	str	r2, [r3, #4]
}
   4815a:	2000      	movs	r0, #0
   4815c:	4770      	bx	lr

0004815e <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4815e:	6843      	ldr	r3, [r0, #4]
}
   48160:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48162:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   48164:	6099      	str	r1, [r3, #8]
}
   48166:	4770      	bx	lr

00048168 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48168:	6843      	ldr	r3, [r0, #4]
}
   4816a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4816c:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   4816e:	60d9      	str	r1, [r3, #12]
}
   48170:	4770      	bx	lr

00048172 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48172:	6843      	ldr	r3, [r0, #4]
}
   48174:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48176:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   48178:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   4817a:	404b      	eors	r3, r1
    p_reg->OUT = value;
   4817c:	6053      	str	r3, [r2, #4]
}
   4817e:	4770      	bx	lr

00048180 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   48180:	6903      	ldr	r3, [r0, #16]
{
   48182:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   48184:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   48186:	b158      	cbz	r0, 481a0 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48188:	2400      	movs	r4, #0
   4818a:	4281      	cmp	r1, r0
   4818c:	d113      	bne.n	481b6 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   4818e:	6808      	ldr	r0, [r1, #0]
   48190:	b95c      	cbnz	r4, 481aa <gpio_nrfx_manage_callback+0x2a>
   48192:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   48194:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   48196:	42a1      	cmp	r1, r4
   48198:	d100      	bne.n	4819c <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   4819a:	6098      	str	r0, [r3, #8]
	parent->next = child;
   4819c:	2000      	movs	r0, #0
   4819e:	6008      	str	r0, [r1, #0]
	if (set) {
   481a0:	b972      	cbnz	r2, 481c0 <gpio_nrfx_manage_callback+0x40>
	return 0;
   481a2:	2000      	movs	r0, #0
}
   481a4:	bd30      	pop	{r4, r5, pc}
   481a6:	4628      	mov	r0, r5
   481a8:	e7ef      	b.n	4818a <gpio_nrfx_manage_callback+0xa>
   481aa:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   481ac:	6898      	ldr	r0, [r3, #8]
   481ae:	4281      	cmp	r1, r0
	list->tail = node;
   481b0:	bf08      	it	eq
   481b2:	609c      	streq	r4, [r3, #8]
}
   481b4:	e7f2      	b.n	4819c <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   481b6:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   481b8:	4604      	mov	r4, r0
   481ba:	2d00      	cmp	r5, #0
   481bc:	d1f3      	bne.n	481a6 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   481be:	b13a      	cbz	r2, 481d0 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   481c0:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   481c2:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   481c4:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   481c6:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   481c8:	2800      	cmp	r0, #0
   481ca:	d1ea      	bne.n	481a2 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   481cc:	6099      	str	r1, [r3, #8]
}
   481ce:	e7e9      	b.n	481a4 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   481d0:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   481d4:	e7e6      	b.n	481a4 <gpio_nrfx_manage_callback+0x24>

000481d6 <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   481d6:	6843      	ldr	r3, [r0, #4]
   481d8:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   481da:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   481de:	05d1      	lsls	r1, r2, #23
   481e0:	d518      	bpl.n	48214 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   481e2:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   481e6:	b1aa      	cbz	r2, 48214 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   481e8:	f04f 0120 	mov.w	r1, #32
   481ec:	f3ef 8211 	mrs	r2, BASEPRI
   481f0:	f381 8812 	msr	BASEPRI_MAX, r1
   481f4:	f3bf 8f6f 	isb	sy
   481f8:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   481fc:	b131      	cbz	r1, 4820c <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   481fe:	2100      	movs	r1, #0
   48200:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   48204:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48208:	2101      	movs	r1, #1
   4820a:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   4820c:	f382 8811 	msr	BASEPRI, r2
   48210:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   48214:	6842      	ldr	r2, [r0, #4]
   48216:	6852      	ldr	r2, [r2, #4]
   48218:	06d2      	lsls	r2, r2, #27
   4821a:	d515      	bpl.n	48248 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   4821c:	f04f 0120 	mov.w	r1, #32
   48220:	f3ef 8211 	mrs	r2, BASEPRI
   48224:	f381 8812 	msr	BASEPRI_MAX, r1
   48228:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4822c:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   48230:	b111      	cbz	r1, 48238 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   48232:	2100      	movs	r1, #0
   48234:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   48238:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   4823c:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   48240:	f382 8811 	msr	BASEPRI, r2
   48244:	f3bf 8f6f 	isb	sy
}
   48248:	4770      	bx	lr

0004824a <uarte_nrfx_config_get>:
{
   4824a:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   4824c:	6902      	ldr	r2, [r0, #16]
   4824e:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   48252:	e883 0003 	stmia.w	r3, {r0, r1}
}
   48256:	2000      	movs	r0, #0
   48258:	4770      	bx	lr

0004825a <uarte_nrfx_err_check>:
	return config->uarte_regs;
   4825a:	6843      	ldr	r3, [r0, #4]
   4825c:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   4825e:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   48262:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   48266:	4770      	bx	lr

00048268 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   48268:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   4826a:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4826c:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   48270:	b940      	cbnz	r0, 48284 <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   48272:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   48274:	0792      	lsls	r2, r2, #30
   48276:	d406      	bmi.n	48286 <is_tx_ready+0x1e>
   48278:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   4827c:	3800      	subs	r0, #0
   4827e:	bf18      	it	ne
   48280:	2001      	movne	r0, #1
   48282:	4770      	bx	lr
   48284:	2001      	movs	r0, #1
}
   48286:	4770      	bx	lr

00048288 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   48288:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   4828a:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   4828c:	681b      	ldr	r3, [r3, #0]
   4828e:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   48292:	b148      	cbz	r0, 482a8 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48294:	2000      	movs	r0, #0
	*c = data->rx_data;
   48296:	7c52      	ldrb	r2, [r2, #17]
   48298:	700a      	strb	r2, [r1, #0]
   4829a:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   4829e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   482a2:	2201      	movs	r2, #1
   482a4:	601a      	str	r2, [r3, #0]
	return 0;
   482a6:	4770      	bx	lr
		return -1;
   482a8:	f04f 30ff 	mov.w	r0, #4294967295
}
   482ac:	4770      	bx	lr

000482ae <entropy_cc3xx_rng_get_entropy>:

static int entropy_cc3xx_rng_get_entropy(
	const struct device *dev,
	uint8_t *buffer,
	uint16_t length)
{
   482ae:	4608      	mov	r0, r1
   482b0:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buffer != NULL);


#if defined(CONFIG_BUILD_WITH_TFM)

	res = psa_generate_random(buffer, length);
   482b2:	4611      	mov	r1, r2
   482b4:	f7fe ff66 	bl	47184 <psa_generate_random>
	if (res != PSA_SUCCESS) {
   482b8:	2800      	cmp	r0, #0
		offset += chunk_size;
	}
#endif

	return res;
}
   482ba:	bf18      	it	ne
   482bc:	f06f 0015 	mvnne.w	r0, #21
   482c0:	bd08      	pop	{r3, pc}

000482c2 <entropy_cc3xx_rng_init>:

static int entropy_cc3xx_rng_init(const struct device *dev)
{
   482c2:	b508      	push	{r3, lr}
	(void)dev;

	#if defined(CONFIG_BUILD_WITH_TFM)
		int ret = -1;

		ret = psa_crypto_init();
   482c4:	f000 fbb0 	bl	48a28 <psa_crypto_init>
		if (ret != PSA_SUCCESS) {
   482c8:	2800      	cmp	r0, #0
			return -EINVAL;
		}
	#endif

	return 0;
}
   482ca:	bf18      	it	ne
   482cc:	f06f 0015 	mvnne.w	r0, #21
   482d0:	bd08      	pop	{r3, pc}

000482d2 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   482d2:	4770      	bx	lr

000482d4 <sys_clock_cycle_get_32>:
{
   482d4:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   482d6:	f7fb f973 	bl	435c0 <z_nrf_rtc_timer_read>
}
   482da:	bd08      	pop	{r3, pc}

000482dc <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   482dc:	f000 bb4d 	b.w	4897a <z_impl_k_busy_wait>

000482e0 <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   482e0:	f000 b9ee 	b.w	486c0 <k_is_in_isr>

000482e4 <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   482e4:	f7fe b988 	b.w	465f8 <z_impl_k_sem_give>

000482e8 <nrf_modem_os_sem_take>:
{
   482e8:	b508      	push	{r3, lr}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   482ea:	1c4b      	adds	r3, r1, #1
   482ec:	bf13      	iteet	ne
   482ee:	ea21 72e1 	bicne.w	r2, r1, r1, asr #31
   482f2:	f04f 32ff 	moveq.w	r2, #4294967295
   482f6:	f04f 33ff 	moveq.w	r3, #4294967295
   482fa:	17d3      	asrne	r3, r2, #31
	return z_impl_k_sem_take(sem, timeout);
   482fc:	f7fe f99c 	bl	46638 <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   48300:	f110 0f0b 	cmn.w	r0, #11
}
   48304:	bf0c      	ite	eq
   48306:	2074      	moveq	r0, #116	; 0x74
   48308:	2000      	movne	r0, #0
   4830a:	bd08      	pop	{r3, pc}

0004830c <read_task_create>:
{
   4830c:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   4830e:	201c      	movs	r0, #28
   48310:	2200      	movs	r2, #0
   48312:	2106      	movs	r1, #6
   48314:	f7f9 fe40 	bl	41f98 <z_arm_irq_priority_set>
}
   48318:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   4831c:	201c      	movs	r0, #28
   4831e:	f7f9 be1d 	b.w	41f5c <arch_irq_enable>

00048322 <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   48322:	2000      	movs	r0, #0
   48324:	4770      	bx	lr

00048326 <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   48326:	2000      	movs	r0, #0
   48328:	4770      	bx	lr

0004832a <sys_arch_reboot>:
#if defined(CONFIG_TFM_PARTITION_PLATFORM)
void sys_arch_reboot(int type)
{
	ARG_UNUSED(type);

	(void)tfm_platform_system_reset();
   4832a:	f7fe bf1d 	b.w	47168 <tfm_platform_system_reset>

0004832e <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   4832e:	4700      	bx	r0

00048330 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   48330:	f000 bb23 	b.w	4897a <z_impl_k_busy_wait>

00048334 <nrfx_clock_enable>:
{
   48334:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   48336:	2005      	movs	r0, #5
   48338:	f7f9 fe20 	bl	41f7c <arch_irq_is_enabled>
   4833c:	b920      	cbnz	r0, 48348 <nrfx_clock_enable+0x14>
}
   4833e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   48342:	2005      	movs	r0, #5
   48344:	f7f9 be0a 	b.w	41f5c <arch_irq_enable>
   48348:	bd08      	pop	{r3, pc}

0004834a <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   4834a:	f7fc b98f 	b.w	4466c <_DoInit>

0004834e <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   4834e:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   48350:	f7ff fffb 	bl	4834a <SEGGER_RTT_Init>

	return 0;
}
   48354:	2000      	movs	r0, #0
   48356:	bd08      	pop	{r3, pc}

00048358 <rpc_handle_ctrl_message>:
   48358:	2902      	cmp	r1, #2
   4835a:	b510      	push	{r4, lr}
   4835c:	4604      	mov	r4, r0
   4835e:	d005      	beq.n	4836c <rpc_handle_ctrl_message+0x14>
   48360:	2904      	cmp	r1, #4
   48362:	d001      	beq.n	48368 <rpc_handle_ctrl_message+0x10>
   48364:	2901      	cmp	r1, #1
   48366:	d107      	bne.n	48378 <rpc_handle_ctrl_message+0x20>
   48368:	2000      	movs	r0, #0
   4836a:	bd10      	pop	{r4, pc}
   4836c:	6880      	ldr	r0, [r0, #8]
   4836e:	2800      	cmp	r0, #0
   48370:	d0fa      	beq.n	48368 <rpc_handle_ctrl_message+0x10>
   48372:	f000 f831 	bl	483d8 <rpc_transport_local_data_free>
   48376:	e7f7      	b.n	48368 <rpc_handle_ctrl_message+0x10>
   48378:	6880      	ldr	r0, [r0, #8]
   4837a:	b108      	cbz	r0, 48380 <rpc_handle_ctrl_message+0x28>
   4837c:	f000 f82c 	bl	483d8 <rpc_transport_local_data_free>
   48380:	4620      	mov	r0, r4
   48382:	f000 f825 	bl	483d0 <rpc_transport_msg_free>
   48386:	e7ef      	b.n	48368 <rpc_handle_ctrl_message+0x10>

00048388 <rpc_message_send>:
   48388:	6843      	ldr	r3, [r0, #4]
   4838a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   4838e:	f043 0302 	orr.w	r3, r3, #2
   48392:	6043      	str	r3, [r0, #4]
   48394:	f000 b824 	b.w	483e0 <rpc_transport_data_msg_send>

00048398 <rpc_message_alloc>:
   48398:	b570      	push	{r4, r5, r6, lr}
   4839a:	4606      	mov	r6, r0
   4839c:	b130      	cbz	r0, 483ac <rpc_message_alloc+0x14>
   4839e:	f000 f819 	bl	483d4 <rpc_transport_data_alloc>
   483a2:	4605      	mov	r5, r0
   483a4:	b918      	cbnz	r0, 483ae <rpc_message_alloc+0x16>
   483a6:	2400      	movs	r4, #0
   483a8:	4620      	mov	r0, r4
   483aa:	bd70      	pop	{r4, r5, r6, pc}
   483ac:	4605      	mov	r5, r0
   483ae:	f000 f80d 	bl	483cc <rpc_transport_data_msg_alloc>
   483b2:	4604      	mov	r4, r0
   483b4:	b110      	cbz	r0, 483bc <rpc_message_alloc+0x24>
   483b6:	60c6      	str	r6, [r0, #12]
   483b8:	6085      	str	r5, [r0, #8]
   483ba:	e7f5      	b.n	483a8 <rpc_message_alloc+0x10>
   483bc:	2d00      	cmp	r5, #0
   483be:	d0f2      	beq.n	483a6 <rpc_message_alloc+0xe>
   483c0:	4628      	mov	r0, r5
   483c2:	f000 f809 	bl	483d8 <rpc_transport_local_data_free>
   483c6:	e7ef      	b.n	483a8 <rpc_message_alloc+0x10>

000483c8 <rpc_message_data_free>:
   483c8:	f000 b808 	b.w	483dc <rpc_transport_peer_data_free>

000483cc <rpc_transport_data_msg_alloc>:
   483cc:	f7fc bc36 	b.w	44c3c <rpc_transport_ipc_data_msg_alloc>

000483d0 <rpc_transport_msg_free>:
   483d0:	f7fc bc80 	b.w	44cd4 <rpc_transport_ipc_msg_free>

000483d4 <rpc_transport_data_alloc>:
   483d4:	f7fc bc64 	b.w	44ca0 <rpc_transport_ipc_data_alloc>

000483d8 <rpc_transport_local_data_free>:
   483d8:	f000 b804 	b.w	483e4 <rpc_transport_ipc_local_data_free>

000483dc <rpc_transport_peer_data_free>:
   483dc:	f000 b809 	b.w	483f2 <rpc_transport_ipc_peer_data_free>

000483e0 <rpc_transport_data_msg_send>:
   483e0:	f7fc bbf0 	b.w	44bc4 <rpc_transport_ipc_data_msg_send>

000483e4 <rpc_transport_ipc_local_data_free>:
   483e4:	b508      	push	{r3, lr}
   483e6:	f7fb fc1b 	bl	43c20 <nrf_modem_os_shm_tx_free>
   483ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   483ee:	f7fb bbe1 	b.w	43bb4 <nrf_modem_os_application_irq_set>

000483f2 <rpc_transport_ipc_peer_data_free>:
   483f2:	b510      	push	{r4, lr}
   483f4:	4604      	mov	r4, r0
   483f6:	f7fc fc33 	bl	44c60 <rpc_transport_ipc_ctrl_msg_alloc>
   483fa:	2101      	movs	r1, #1
   483fc:	2200      	movs	r2, #0
   483fe:	7001      	strb	r1, [r0, #0]
   48400:	2102      	movs	r1, #2
   48402:	6084      	str	r4, [r0, #8]
   48404:	7042      	strb	r2, [r0, #1]
   48406:	7081      	strb	r1, [r0, #2]
   48408:	70c2      	strb	r2, [r0, #3]
   4840a:	f7fc fbf9 	bl	44c00 <rpc_transport_ipc_ctrl_msg_send>
   4840e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   48412:	f7fb bbcf 	b.w	43bb4 <nrf_modem_os_application_irq_set>

00048416 <rpc_client_request_alloc>:
   48416:	b508      	push	{r3, lr}
   48418:	f7ff ffbe 	bl	48398 <rpc_message_alloc>
   4841c:	b100      	cbz	r0, 48420 <rpc_client_request_alloc+0xa>
   4841e:	3008      	adds	r0, #8
   48420:	bd08      	pop	{r3, pc}

00048422 <rpc_client_request_send>:
   48422:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   48426:	4610      	mov	r0, r2
   48428:	f840 1d08 	str.w	r1, [r0, #-8]!
   4842c:	f7ff bfac 	b.w	48388 <rpc_message_send>

00048430 <rpc_client_data_free>:
   48430:	f7ff bfca 	b.w	483c8 <rpc_message_data_free>

00048434 <ip_interface_request_create>:
   48434:	b570      	push	{r4, r5, r6, lr}
   48436:	4606      	mov	r6, r0
   48438:	4618      	mov	r0, r3
   4843a:	460d      	mov	r5, r1
   4843c:	4614      	mov	r4, r2
   4843e:	f7ff ffea 	bl	48416 <rpc_client_request_alloc>
   48442:	b148      	cbz	r0, 48458 <ip_interface_request_create+0x24>
   48444:	2300      	movs	r3, #0
   48446:	2208      	movs	r2, #8
   48448:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   4844c:	60c4      	str	r4, [r0, #12]
   4844e:	6105      	str	r5, [r0, #16]
   48450:	7202      	strb	r2, [r0, #8]
   48452:	7243      	strb	r3, [r0, #9]
   48454:	7283      	strb	r3, [r0, #10]
   48456:	72c3      	strb	r3, [r0, #11]
   48458:	bd70      	pop	{r4, r5, r6, pc}

0004845a <ip_interface_wait>:
   4845a:	b538      	push	{r3, r4, r5, lr}
   4845c:	4605      	mov	r5, r0
   4845e:	f7fc fdbf 	bl	44fe0 <interface_socket_wait>
   48462:	4604      	mov	r4, r0
   48464:	b938      	cbnz	r0, 48476 <ip_interface_wait+0x1c>
   48466:	4628      	mov	r0, r5
   48468:	f7fc fe34 	bl	450d4 <interface_socket_from_handle_get>
   4846c:	b118      	cbz	r0, 48476 <ip_interface_wait+0x1c>
   4846e:	6844      	ldr	r4, [r0, #4]
   48470:	b10c      	cbz	r4, 48476 <ip_interface_wait+0x1c>
   48472:	2300      	movs	r3, #0
   48474:	6043      	str	r3, [r0, #4]
   48476:	4620      	mov	r0, r4
   48478:	bd38      	pop	{r3, r4, r5, pc}

0004847a <secure_client_socket>:
   4847a:	f04f 33ff 	mov.w	r3, #4294967295
   4847e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   48480:	9301      	str	r3, [sp, #4]
   48482:	680b      	ldr	r3, [r1, #0]
   48484:	4606      	mov	r6, r0
   48486:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   4848a:	600b      	str	r3, [r1, #0]
   4848c:	680b      	ldr	r3, [r1, #0]
   4848e:	460c      	mov	r4, r1
   48490:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   48494:	600b      	str	r3, [r1, #0]
   48496:	680f      	ldr	r7, [r1, #0]
   48498:	463a      	mov	r2, r7
   4849a:	f7fd f8e7 	bl	4566c <secure_socket_attach_initiate>
   4849e:	4605      	mov	r5, r0
   484a0:	b950      	cbnz	r0, 484b8 <secure_client_socket+0x3e>
   484a2:	220c      	movs	r2, #12
   484a4:	4630      	mov	r0, r6
   484a6:	4611      	mov	r1, r2
   484a8:	ab01      	add	r3, sp, #4
   484aa:	f7ff ffd6 	bl	4845a <ip_interface_wait>
   484ae:	4605      	mov	r5, r0
   484b0:	b128      	cbz	r0, 484be <secure_client_socket+0x44>
   484b2:	2877      	cmp	r0, #119	; 0x77
   484b4:	d000      	beq.n	484b8 <secure_client_socket+0x3e>
   484b6:	6027      	str	r7, [r4, #0]
   484b8:	4628      	mov	r0, r5
   484ba:	b003      	add	sp, #12
   484bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   484be:	4630      	mov	r0, r6
   484c0:	f7fd f8c2 	bl	45648 <hostname_free>
   484c4:	6823      	ldr	r3, [r4, #0]
   484c6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   484ca:	6023      	str	r3, [r4, #0]
   484cc:	6823      	ldr	r3, [r4, #0]
   484ce:	0c1b      	lsrs	r3, r3, #16
   484d0:	041b      	lsls	r3, r3, #16
   484d2:	f043 030c 	orr.w	r3, r3, #12
   484d6:	6023      	str	r3, [r4, #0]
   484d8:	6823      	ldr	r3, [r4, #0]
   484da:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   484de:	6023      	str	r3, [r4, #0]
   484e0:	6823      	ldr	r3, [r4, #0]
   484e2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   484e6:	6023      	str	r3, [r4, #0]
   484e8:	e7e6      	b.n	484b8 <secure_client_socket+0x3e>

000484ea <nrf_modem_recoverable_error_handler>:
   484ea:	4770      	bx	lr

000484ec <nrf_modem_platform_error_handler>:
   484ec:	b508      	push	{r3, lr}
   484ee:	f7ff fffc 	bl	484ea <nrf_modem_recoverable_error_handler>
   484f2:	bd08      	pop	{r3, pc}

000484f4 <rpc_transport_ipc_fault_handler>:
   484f4:	f7ff bffa 	b.w	484ec <nrf_modem_platform_error_handler>

000484f8 <nrf_modem_platform_init>:
   484f8:	b513      	push	{r0, r1, r4, lr}
   484fa:	4604      	mov	r4, r0
   484fc:	f7fb fb96 	bl	43c2c <nrf_modem_os_init>
   48500:	6a23      	ldr	r3, [r4, #32]
   48502:	4668      	mov	r0, sp
   48504:	9400      	str	r4, [sp, #0]
   48506:	f88d 3004 	strb.w	r3, [sp, #4]
   4850a:	f7fc fc09 	bl	44d20 <rpc_transport_ipc_init>
   4850e:	4604      	mov	r4, r0
   48510:	b948      	cbnz	r0, 48526 <nrf_modem_platform_init+0x2e>
   48512:	f7fc fd59 	bl	44fc8 <interface_init>
   48516:	f7fd f99d 	bl	45854 <nrf_modem_at_init>
   4851a:	4604      	mov	r4, r0
   4851c:	b918      	cbnz	r0, 48526 <nrf_modem_platform_init+0x2e>
   4851e:	f7fc fe11 	bl	45144 <ip_interface_init>
   48522:	f7fd f8f5 	bl	45710 <tls_interface_init>
   48526:	4620      	mov	r0, r4
   48528:	b002      	add	sp, #8
   4852a:	bd10      	pop	{r4, pc}

0004852c <mbedtls_heap_init>:
{
	mbedtls_memory_buffer_alloc_free();
}

static int mbedtls_heap_init(const struct device *dev)
{
   4852c:	b508      	push	{r3, lr}
	ARG_UNUSED(dev);

	_heap_init();
   4852e:	f7fd fbb9 	bl	45ca4 <_heap_init>

	return 0;
}
   48532:	2000      	movs	r0, #0
   48534:	bd08      	pop	{r3, pc}

00048536 <z_device_state_init>:
}
   48536:	4770      	bx	lr

00048538 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   48538:	b138      	cbz	r0, 4854a <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   4853a:	68c3      	ldr	r3, [r0, #12]
   4853c:	8818      	ldrh	r0, [r3, #0]
   4853e:	f3c0 0008 	ubfx	r0, r0, #0, #9
   48542:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   48546:	4258      	negs	r0, r3
   48548:	4158      	adcs	r0, r3
}
   4854a:	4770      	bx	lr

0004854c <k_heap_init>:
{
   4854c:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   4854e:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   48552:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   48556:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   48558:	f7ff b94e 	b.w	477f8 <sys_heap_init>

0004855c <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   4855c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   48560:	b087      	sub	sp, #28
   48562:	4604      	mov	r4, r0
   48564:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48566:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   4856a:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   4856c:	f000 fa09 	bl	48982 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   48570:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48574:	4605      	mov	r5, r0
   48576:	4688      	mov	r8, r1
	__asm__ volatile(
   48578:	f04f 0320 	mov.w	r3, #32
   4857c:	f3ef 8b11 	mrs	fp, BASEPRI
   48580:	f383 8812 	msr	BASEPRI_MAX, r3
   48584:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   48588:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   4858c:	463a      	mov	r2, r7
   4858e:	4631      	mov	r1, r6
   48590:	4620      	mov	r0, r4
   48592:	f7ff f8c9 	bl	47728 <sys_heap_aligned_alloc>
   48596:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   48598:	f7fe fd1c 	bl	46fd4 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   4859c:	9b05      	ldr	r3, [sp, #20]
   4859e:	b13b      	cbz	r3, 485b0 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   485a0:	f38b 8811 	msr	BASEPRI, fp
   485a4:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   485a8:	4618      	mov	r0, r3
   485aa:	b007      	add	sp, #28
   485ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   485b0:	1a2a      	subs	r2, r5, r0
   485b2:	9202      	str	r2, [sp, #8]
   485b4:	eb68 0201 	sbc.w	r2, r8, r1
   485b8:	9203      	str	r2, [sp, #12]
   485ba:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   485be:	2901      	cmp	r1, #1
   485c0:	f172 0200 	sbcs.w	r2, r2, #0
   485c4:	dbec      	blt.n	485a0 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   485c6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   485ca:	4659      	mov	r1, fp
   485cc:	e9cd 2300 	strd	r2, r3, [sp]
   485d0:	4648      	mov	r0, r9
   485d2:	4652      	mov	r2, sl
   485d4:	f7fe f9ee 	bl	469b4 <z_pend_curr>
	__asm__ volatile(
   485d8:	f04f 0320 	mov.w	r3, #32
   485dc:	f3ef 8b11 	mrs	fp, BASEPRI
   485e0:	f383 8812 	msr	BASEPRI_MAX, r3
   485e4:	f3bf 8f6f 	isb	sy
   485e8:	e7d0      	b.n	4858c <k_heap_aligned_alloc+0x30>

000485ea <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   485ea:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   485ec:	e9cd 2300 	strd	r2, r3, [sp]
   485f0:	460a      	mov	r2, r1
   485f2:	2104      	movs	r1, #4
   485f4:	f7ff ffb2 	bl	4855c <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   485f8:	b003      	add	sp, #12
   485fa:	f85d fb04 	ldr.w	pc, [sp], #4

000485fe <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   485fe:	b538      	push	{r3, r4, r5, lr}
   48600:	4604      	mov	r4, r0
   48602:	f04f 0320 	mov.w	r3, #32
   48606:	f3ef 8511 	mrs	r5, BASEPRI
   4860a:	f383 8812 	msr	BASEPRI_MAX, r3
   4860e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   48612:	f7ff f850 	bl	476b6 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   48616:	f104 000c 	add.w	r0, r4, #12
   4861a:	f000 f958 	bl	488ce <z_unpend_all>
   4861e:	b130      	cbz	r0, 4862e <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   48620:	4629      	mov	r1, r5
   48622:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   48626:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   4862a:	f7fe b869 	b.w	46700 <z_reschedule>
	__asm__ volatile(
   4862e:	f385 8811 	msr	BASEPRI, r5
   48632:	f3bf 8f6f 	isb	sy
}
   48636:	bd38      	pop	{r3, r4, r5, pc}

00048638 <k_mem_slab_init>:
{
   48638:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   4863a:	2400      	movs	r4, #0
   4863c:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   4863e:	ea41 0402 	orr.w	r4, r1, r2
   48642:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   48646:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   4864a:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   4864c:	d10c      	bne.n	48668 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   4864e:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   48650:	42a3      	cmp	r3, r4
   48652:	d103      	bne.n	4865c <k_mem_slab_init+0x24>
   48654:	e9c0 0000 	strd	r0, r0, [r0]
}
   48658:	2000      	movs	r0, #0
}
   4865a:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   4865c:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   4865e:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   48660:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   48662:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   48664:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   48666:	e7f3      	b.n	48650 <k_mem_slab_init+0x18>
		return -EINVAL;
   48668:	f06f 0015 	mvn.w	r0, #21
	return rc;
   4866c:	e7f5      	b.n	4865a <k_mem_slab_init+0x22>

0004866e <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   4866e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   48670:	4604      	mov	r4, r0
   48672:	460d      	mov	r5, r1
	__asm__ volatile(
   48674:	f04f 0320 	mov.w	r3, #32
   48678:	f3ef 8611 	mrs	r6, BASEPRI
   4867c:	f383 8812 	msr	BASEPRI_MAX, r3
   48680:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   48684:	6947      	ldr	r7, [r0, #20]
   48686:	b977      	cbnz	r7, 486a6 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   48688:	f000 f909 	bl	4889e <z_unpend_first_thread>

		if (pending_thread != NULL) {
   4868c:	b158      	cbz	r0, 486a6 <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   4868e:	682a      	ldr	r2, [r5, #0]
   48690:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   48692:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   48694:	f000 f88f 	bl	487b6 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   48698:	4631      	mov	r1, r6
   4869a:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   4869e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   486a2:	f7fe b82d 	b.w	46700 <z_reschedule>
	**(char ***) mem = slab->free_list;
   486a6:	682b      	ldr	r3, [r5, #0]
   486a8:	6962      	ldr	r2, [r4, #20]
   486aa:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   486ac:	682b      	ldr	r3, [r5, #0]
   486ae:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   486b0:	69a3      	ldr	r3, [r4, #24]
   486b2:	3b01      	subs	r3, #1
   486b4:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   486b6:	f386 8811 	msr	BASEPRI, r6
   486ba:	f3bf 8f6f 	isb	sy
}
   486be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000486c0 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   486c0:	f3ef 8005 	mrs	r0, IPSR
}
   486c4:	3800      	subs	r0, #0
   486c6:	bf18      	it	ne
   486c8:	2001      	movne	r0, #1
   486ca:	4770      	bx	lr

000486cc <z_impl_k_thread_name_set>:
}
   486cc:	f06f 0057 	mvn.w	r0, #87	; 0x57
   486d0:	4770      	bx	lr

000486d2 <k_thread_name_get>:
}
   486d2:	2000      	movs	r0, #0
   486d4:	4770      	bx	lr

000486d6 <z_pm_save_idle_exit>:
{
   486d6:	b508      	push	{r3, lr}
	pm_system_resume();
   486d8:	f7f9 fb2a 	bl	41d30 <pm_system_resume>
}
   486dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   486e0:	f7ff bdf7 	b.w	482d2 <sys_clock_idle_exit>

000486e4 <z_impl_k_mutex_init>:
{
   486e4:	4603      	mov	r3, r0
	mutex->owner = NULL;
   486e6:	2000      	movs	r0, #0
   486e8:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   486ec:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   486f0:	4770      	bx	lr

000486f2 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   486f2:	b13a      	cbz	r2, 48704 <z_impl_k_sem_init+0x12>
   486f4:	428a      	cmp	r2, r1
   486f6:	d305      	bcc.n	48704 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   486f8:	e9c0 1202 	strd	r1, r2, [r0, #8]
   486fc:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   48700:	2000      	movs	r0, #0
   48702:	4770      	bx	lr
		return -EINVAL;
   48704:	f06f 0015 	mvn.w	r0, #21
}
   48708:	4770      	bx	lr

0004870a <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   4870a:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   4870e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   48710:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   48712:	2300      	movs	r3, #0
	node->prev = NULL;
   48714:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   48718:	4770      	bx	lr

0004871a <unpend_thread_no_timeout>:
{
   4871a:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   4871c:	f7ff fff5 	bl	4870a <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   48720:	7b43      	ldrb	r3, [r0, #13]
   48722:	f023 0302 	bic.w	r3, r3, #2
   48726:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   48728:	2300      	movs	r3, #0
   4872a:	6083      	str	r3, [r0, #8]
}
   4872c:	bd08      	pop	{r3, pc}

0004872e <z_unpend_thread_no_timeout>:
{
   4872e:	b508      	push	{r3, lr}
	__asm__ volatile(
   48730:	f04f 0320 	mov.w	r3, #32
   48734:	f3ef 8111 	mrs	r1, BASEPRI
   48738:	f383 8812 	msr	BASEPRI_MAX, r3
   4873c:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   48740:	f7ff ffeb 	bl	4871a <unpend_thread_no_timeout>
	__asm__ volatile(
   48744:	f381 8811 	msr	BASEPRI, r1
   48748:	f3bf 8f6f 	isb	sy
}
   4874c:	bd08      	pop	{r3, pc}

0004874e <z_unpend_thread>:
{
   4874e:	b510      	push	{r4, lr}
	__asm__ volatile(
   48750:	f04f 0320 	mov.w	r3, #32
   48754:	f3ef 8411 	mrs	r4, BASEPRI
   48758:	f383 8812 	msr	BASEPRI_MAX, r3
   4875c:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   48760:	f7ff ffdb 	bl	4871a <unpend_thread_no_timeout>
	__asm__ volatile(
   48764:	f384 8811 	msr	BASEPRI, r4
   48768:	f3bf 8f6f 	isb	sy
}
   4876c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   48770:	3018      	adds	r0, #24
   48772:	f000 b8bc 	b.w	488ee <z_abort_timeout>

00048776 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   48776:	4603      	mov	r3, r0
   48778:	b920      	cbnz	r0, 48784 <z_reschedule_irqlock+0xe>
   4877a:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   4877e:	b90a      	cbnz	r2, 48784 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   48780:	f7f9 bc4e 	b.w	42020 <arch_swap>
   48784:	f383 8811 	msr	BASEPRI, r3
   48788:	f3bf 8f6f 	isb	sy
}
   4878c:	4770      	bx	lr

0004878e <z_reschedule_unlocked>:
	__asm__ volatile(
   4878e:	f04f 0320 	mov.w	r3, #32
   48792:	f3ef 8011 	mrs	r0, BASEPRI
   48796:	f383 8812 	msr	BASEPRI_MAX, r3
   4879a:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   4879e:	f7ff bfea 	b.w	48776 <z_reschedule_irqlock>

000487a2 <z_priq_dumb_best>:
{
   487a2:	4603      	mov	r3, r0
	return list->head == list;
   487a4:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   487a6:	4283      	cmp	r3, r0
   487a8:	d003      	beq.n	487b2 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   487aa:	2800      	cmp	r0, #0
   487ac:	bf38      	it	cc
   487ae:	2000      	movcc	r0, #0
   487b0:	4770      	bx	lr
	struct k_thread *thread = NULL;
   487b2:	2000      	movs	r0, #0
}
   487b4:	4770      	bx	lr

000487b6 <z_ready_thread>:
{
   487b6:	b510      	push	{r4, lr}
   487b8:	f04f 0320 	mov.w	r3, #32
   487bc:	f3ef 8411 	mrs	r4, BASEPRI
   487c0:	f383 8812 	msr	BASEPRI_MAX, r3
   487c4:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   487c8:	f7fe f860 	bl	4688c <ready_thread>
	__asm__ volatile(
   487cc:	f384 8811 	msr	BASEPRI, r4
   487d0:	f3bf 8f6f 	isb	sy
}
   487d4:	bd10      	pop	{r4, pc}

000487d6 <z_thread_timeout>:
{
   487d6:	4601      	mov	r1, r0
   487d8:	b510      	push	{r4, lr}
	__asm__ volatile(
   487da:	f04f 0320 	mov.w	r3, #32
   487de:	f3ef 8411 	mrs	r4, BASEPRI
   487e2:	f383 8812 	msr	BASEPRI_MAX, r3
   487e6:	f3bf 8f6f 	isb	sy
		if (!killed) {
   487ea:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   487ee:	f013 0f28 	tst.w	r3, #40	; 0x28
   487f2:	d10d      	bne.n	48810 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   487f4:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   487f8:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   487fa:	b10b      	cbz	r3, 48800 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   487fc:	f7ff ff8d 	bl	4871a <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   48800:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   48804:	f023 0314 	bic.w	r3, r3, #20
   48808:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   4880c:	f7fe f83e 	bl	4688c <ready_thread>
	__asm__ volatile(
   48810:	f384 8811 	msr	BASEPRI, r4
   48814:	f3bf 8f6f 	isb	sy
}
   48818:	bd10      	pop	{r4, pc}

0004881a <add_to_waitq_locked>:
{
   4881a:	b538      	push	{r3, r4, r5, lr}
   4881c:	4604      	mov	r4, r0
   4881e:	460d      	mov	r5, r1
	unready_thread(thread);
   48820:	f7fe f88a 	bl	46938 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   48824:	7b63      	ldrb	r3, [r4, #13]
   48826:	f043 0302 	orr.w	r3, r3, #2
   4882a:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   4882c:	b1b5      	cbz	r5, 4885c <add_to_waitq_locked+0x42>
	return list->head == list;
   4882e:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   48830:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48832:	429d      	cmp	r5, r3
   48834:	bf08      	it	eq
   48836:	2300      	moveq	r3, #0
   48838:	2b00      	cmp	r3, #0
   4883a:	bf38      	it	cc
   4883c:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   4883e:	b19b      	cbz	r3, 48868 <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   48840:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   48844:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   48848:	4291      	cmp	r1, r2
   4884a:	d008      	beq.n	4885e <add_to_waitq_locked+0x44>
		return b2 - b1;
   4884c:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   4884e:	2a00      	cmp	r2, #0
   48850:	dd05      	ble.n	4885e <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   48852:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   48854:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   48858:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   4885a:	605c      	str	r4, [r3, #4]
}
   4885c:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   4885e:	686a      	ldr	r2, [r5, #4]
   48860:	4293      	cmp	r3, r2
   48862:	d001      	beq.n	48868 <add_to_waitq_locked+0x4e>
   48864:	681b      	ldr	r3, [r3, #0]
   48866:	e7ea      	b.n	4883e <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   48868:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   4886a:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   4886e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   48870:	606c      	str	r4, [r5, #4]
   48872:	e7f3      	b.n	4885c <add_to_waitq_locked+0x42>

00048874 <z_unpend1_no_timeout>:
{
   48874:	b510      	push	{r4, lr}
	__asm__ volatile(
   48876:	f04f 0320 	mov.w	r3, #32
   4887a:	f3ef 8411 	mrs	r4, BASEPRI
   4887e:	f383 8812 	msr	BASEPRI_MAX, r3
   48882:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48886:	f7ff ff8c 	bl	487a2 <z_priq_dumb_best>
		if (thread != NULL) {
   4888a:	4601      	mov	r1, r0
   4888c:	b108      	cbz	r0, 48892 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   4888e:	f7ff ff44 	bl	4871a <unpend_thread_no_timeout>
	__asm__ volatile(
   48892:	f384 8811 	msr	BASEPRI, r4
   48896:	f3bf 8f6f 	isb	sy
}
   4889a:	4608      	mov	r0, r1
   4889c:	bd10      	pop	{r4, pc}

0004889e <z_unpend_first_thread>:
{
   4889e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   488a0:	f04f 0320 	mov.w	r3, #32
   488a4:	f3ef 8511 	mrs	r5, BASEPRI
   488a8:	f383 8812 	msr	BASEPRI_MAX, r3
   488ac:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   488b0:	f7ff ff77 	bl	487a2 <z_priq_dumb_best>
		if (thread != NULL) {
   488b4:	4604      	mov	r4, r0
   488b6:	b120      	cbz	r0, 488c2 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   488b8:	f7ff ff2f 	bl	4871a <unpend_thread_no_timeout>
   488bc:	3018      	adds	r0, #24
   488be:	f000 f816 	bl	488ee <z_abort_timeout>
	__asm__ volatile(
   488c2:	f385 8811 	msr	BASEPRI, r5
   488c6:	f3bf 8f6f 	isb	sy
}
   488ca:	4620      	mov	r0, r4
   488cc:	bd38      	pop	{r3, r4, r5, pc}

000488ce <z_unpend_all>:
{
   488ce:	b538      	push	{r3, r4, r5, lr}
   488d0:	4605      	mov	r5, r0
	int need_sched = 0;
   488d2:	2000      	movs	r0, #0
	return list->head == list;
   488d4:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   488d6:	42a5      	cmp	r5, r4
   488d8:	d000      	beq.n	488dc <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   488da:	b904      	cbnz	r4, 488de <z_unpend_all+0x10>
}
   488dc:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   488de:	4620      	mov	r0, r4
   488e0:	f7ff ff35 	bl	4874e <z_unpend_thread>
		z_ready_thread(thread);
   488e4:	4620      	mov	r0, r4
   488e6:	f7ff ff66 	bl	487b6 <z_ready_thread>
		need_sched = 1;
   488ea:	2001      	movs	r0, #1
   488ec:	e7f2      	b.n	488d4 <z_unpend_all+0x6>

000488ee <z_abort_timeout>:
{
   488ee:	b510      	push	{r4, lr}
	__asm__ volatile(
   488f0:	f04f 0220 	mov.w	r2, #32
   488f4:	f3ef 8411 	mrs	r4, BASEPRI
   488f8:	f382 8812 	msr	BASEPRI_MAX, r2
   488fc:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   48900:	6803      	ldr	r3, [r0, #0]
   48902:	b13b      	cbz	r3, 48914 <z_abort_timeout+0x26>
			remove_timeout(to);
   48904:	f7fe fa2e 	bl	46d64 <remove_timeout>
			ret = 0;
   48908:	2000      	movs	r0, #0
	__asm__ volatile(
   4890a:	f384 8811 	msr	BASEPRI, r4
   4890e:	f3bf 8f6f 	isb	sy
}
   48912:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   48914:	f06f 0015 	mvn.w	r0, #21
   48918:	e7f7      	b.n	4890a <z_abort_timeout+0x1c>

0004891a <z_get_next_timeout_expiry>:
{
   4891a:	b510      	push	{r4, lr}
	__asm__ volatile(
   4891c:	f04f 0320 	mov.w	r3, #32
   48920:	f3ef 8411 	mrs	r4, BASEPRI
   48924:	f383 8812 	msr	BASEPRI_MAX, r3
   48928:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   4892c:	f7fe fa34 	bl	46d98 <next_timeout>
	__asm__ volatile(
   48930:	f384 8811 	msr	BASEPRI, r4
   48934:	f3bf 8f6f 	isb	sy
}
   48938:	bd10      	pop	{r4, pc}

0004893a <z_set_timeout_expiry>:
{
   4893a:	b570      	push	{r4, r5, r6, lr}
   4893c:	4604      	mov	r4, r0
   4893e:	460d      	mov	r5, r1
	__asm__ volatile(
   48940:	f04f 0320 	mov.w	r3, #32
   48944:	f3ef 8611 	mrs	r6, BASEPRI
   48948:	f383 8812 	msr	BASEPRI_MAX, r3
   4894c:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   48950:	f7fe fa22 	bl	46d98 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   48954:	2801      	cmp	r0, #1
   48956:	dd05      	ble.n	48964 <z_set_timeout_expiry+0x2a>
   48958:	42a0      	cmp	r0, r4
   4895a:	db03      	blt.n	48964 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   4895c:	4629      	mov	r1, r5
   4895e:	4620      	mov	r0, r4
   48960:	f7fa ffa6 	bl	438b0 <sys_clock_set_timeout>
	__asm__ volatile(
   48964:	f386 8811 	msr	BASEPRI, r6
   48968:	f3bf 8f6f 	isb	sy
}
   4896c:	bd70      	pop	{r4, r5, r6, pc}

0004896e <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   4896e:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   48970:	f7fe fb30 	bl	46fd4 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   48974:	bd08      	pop	{r3, pc}

00048976 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   48976:	f7fe bb2d 	b.w	46fd4 <sys_clock_tick_get>

0004897a <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   4897a:	b108      	cbz	r0, 48980 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   4897c:	f7f8 bbb2 	b.w	410e4 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   48980:	4770      	bx	lr

00048982 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   48982:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48984:	1c4b      	adds	r3, r1, #1
   48986:	bf08      	it	eq
   48988:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   4898c:	4604      	mov	r4, r0
   4898e:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48990:	d013      	beq.n	489ba <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   48992:	ea54 0105 	orrs.w	r1, r4, r5
   48996:	d103      	bne.n	489a0 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   48998:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   4899c:	f7fe bb1a 	b.w	46fd4 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   489a0:	f06f 0101 	mvn.w	r1, #1
   489a4:	1a0a      	subs	r2, r1, r0
   489a6:	f04f 31ff 	mov.w	r1, #4294967295
   489aa:	eb61 0305 	sbc.w	r3, r1, r5
   489ae:	2a00      	cmp	r2, #0
   489b0:	f173 0100 	sbcs.w	r1, r3, #0
   489b4:	db02      	blt.n	489bc <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   489b6:	4610      	mov	r0, r2
   489b8:	4619      	mov	r1, r3
}
   489ba:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   489bc:	f7fe fb0a 	bl	46fd4 <sys_clock_tick_get>
   489c0:	2c01      	cmp	r4, #1
   489c2:	f175 0300 	sbcs.w	r3, r5, #0
   489c6:	bfbc      	itt	lt
   489c8:	2401      	movlt	r4, #1
   489ca:	2500      	movlt	r5, #0
   489cc:	1820      	adds	r0, r4, r0
   489ce:	eb45 0101 	adc.w	r1, r5, r1
   489d2:	e7f2      	b.n	489ba <sys_clock_timeout_end_calc+0x38>

000489d4 <k_timer_init>:
	timer->status = 0U;
   489d4:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   489d6:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
   489da:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   489de:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   489e2:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   489e6:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   489e8:	6343      	str	r3, [r0, #52]	; 0x34
}
   489ea:	4770      	bx	lr

000489ec <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   489ec:	b510      	push	{r4, lr}
   489ee:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   489f0:	f7ff ff7d 	bl	488ee <z_abort_timeout>

	if (inactive) {
   489f4:	b9b0      	cbnz	r0, 48a24 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   489f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   489f8:	b10b      	cbz	r3, 489fe <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   489fa:	4620      	mov	r0, r4
   489fc:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   489fe:	f104 0018 	add.w	r0, r4, #24
   48a02:	f7ff ff37 	bl	48874 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   48a06:	b168      	cbz	r0, 48a24 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   48a08:	f7ff fed5 	bl	487b6 <z_ready_thread>
	__asm__ volatile(
   48a0c:	f04f 0320 	mov.w	r3, #32
   48a10:	f3ef 8011 	mrs	r0, BASEPRI
   48a14:	f383 8812 	msr	BASEPRI_MAX, r3
   48a18:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   48a1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   48a20:	f7ff bea9 	b.w	48776 <z_reschedule_irqlock>
   48a24:	bd10      	pop	{r4, pc}

00048a26 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   48a26:	4770      	bx	lr

00048a28 <psa_crypto_init>:
}
   48a28:	2000      	movs	r0, #0
   48a2a:	4770      	bx	lr

00048a2c <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   48a2c:	f7fb b964 	b.w	43cf8 <SystemInit>
