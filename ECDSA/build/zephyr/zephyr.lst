
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00040000 <_vector_start>:
   40000:	200232b0 	.word	0x200232b0
   40004:	000426d9 	.word	0x000426d9
   40008:	0004814f 	.word	0x0004814f
   4000c:	000426ad 	.word	0x000426ad
   40010:	000426ad 	.word	0x000426ad
   40014:	000426ad 	.word	0x000426ad
   40018:	000426ad 	.word	0x000426ad
   4001c:	000426ad 	.word	0x000426ad
	...
   4002c:	00042155 	.word	0x00042155
   40030:	000426ad 	.word	0x000426ad
   40034:	00000000 	.word	0x00000000
   40038:	000420f5 	.word	0x000420f5
   4003c:	000426ad 	.word	0x000426ad

00040040 <_irq_vector_table>:
   40040:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40050:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40060:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40070:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40080:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40090:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   400a0:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   400b0:	00043a59 000421d9 000421d9 000421d9     Y:...!...!...!..
   400c0:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   400d0:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   400e0:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   400f0:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40100:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40110:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40120:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40130:	000421d9 000421d9 000421d9 000421d9     .!...!...!...!..
   40140:	000421d9                                .!..

Disassembly of section text:

00040144 <__aeabi_uldivmod>:
   40144:	b953      	cbnz	r3, 4015c <__aeabi_uldivmod+0x18>
   40146:	b94a      	cbnz	r2, 4015c <__aeabi_uldivmod+0x18>
   40148:	2900      	cmp	r1, #0
   4014a:	bf08      	it	eq
   4014c:	2800      	cmpeq	r0, #0
   4014e:	bf1c      	itt	ne
   40150:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   40154:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   40158:	f000 b970 	b.w	4043c <__aeabi_idiv0>
   4015c:	f1ad 0c08 	sub.w	ip, sp, #8
   40160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   40164:	f000 f806 	bl	40174 <__udivmoddi4>
   40168:	f8dd e004 	ldr.w	lr, [sp, #4]
   4016c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   40170:	b004      	add	sp, #16
   40172:	4770      	bx	lr

00040174 <__udivmoddi4>:
   40174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   40178:	9e08      	ldr	r6, [sp, #32]
   4017a:	460d      	mov	r5, r1
   4017c:	4604      	mov	r4, r0
   4017e:	468a      	mov	sl, r1
   40180:	2b00      	cmp	r3, #0
   40182:	d17f      	bne.n	40284 <__udivmoddi4+0x110>
   40184:	428a      	cmp	r2, r1
   40186:	4617      	mov	r7, r2
   40188:	d941      	bls.n	4020e <__udivmoddi4+0x9a>
   4018a:	fab2 f282 	clz	r2, r2
   4018e:	b14a      	cbz	r2, 401a4 <__udivmoddi4+0x30>
   40190:	f1c2 0120 	rsb	r1, r2, #32
   40194:	fa05 f302 	lsl.w	r3, r5, r2
   40198:	4097      	lsls	r7, r2
   4019a:	4094      	lsls	r4, r2
   4019c:	fa20 f101 	lsr.w	r1, r0, r1
   401a0:	ea41 0a03 	orr.w	sl, r1, r3
   401a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
   401a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   401ac:	fa1f f987 	uxth.w	r9, r7
   401b0:	fbba fef8 	udiv	lr, sl, r8
   401b4:	fb08 a31e 	mls	r3, r8, lr, sl
   401b8:	fb0e f109 	mul.w	r1, lr, r9
   401bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   401c0:	4299      	cmp	r1, r3
   401c2:	d906      	bls.n	401d2 <__udivmoddi4+0x5e>
   401c4:	18fb      	adds	r3, r7, r3
   401c6:	d202      	bcs.n	401ce <__udivmoddi4+0x5a>
   401c8:	4299      	cmp	r1, r3
   401ca:	f200 8124 	bhi.w	40416 <__udivmoddi4+0x2a2>
   401ce:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   401d2:	1a59      	subs	r1, r3, r1
   401d4:	b2a3      	uxth	r3, r4
   401d6:	fbb1 f0f8 	udiv	r0, r1, r8
   401da:	fb08 1110 	mls	r1, r8, r0, r1
   401de:	fb00 f909 	mul.w	r9, r0, r9
   401e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   401e6:	45a1      	cmp	r9, r4
   401e8:	d905      	bls.n	401f6 <__udivmoddi4+0x82>
   401ea:	193c      	adds	r4, r7, r4
   401ec:	d202      	bcs.n	401f4 <__udivmoddi4+0x80>
   401ee:	45a1      	cmp	r9, r4
   401f0:	f200 810e 	bhi.w	40410 <__udivmoddi4+0x29c>
   401f4:	3801      	subs	r0, #1
   401f6:	eba4 0409 	sub.w	r4, r4, r9
   401fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   401fe:	2100      	movs	r1, #0
   40200:	b11e      	cbz	r6, 4020a <__udivmoddi4+0x96>
   40202:	40d4      	lsrs	r4, r2
   40204:	2300      	movs	r3, #0
   40206:	e9c6 4300 	strd	r4, r3, [r6]
   4020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4020e:	b902      	cbnz	r2, 40212 <__udivmoddi4+0x9e>
   40210:	deff      	udf	#255	; 0xff
   40212:	fab2 f282 	clz	r2, r2
   40216:	2a00      	cmp	r2, #0
   40218:	d14f      	bne.n	402ba <__udivmoddi4+0x146>
   4021a:	1bcb      	subs	r3, r1, r7
   4021c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   40220:	fa1f f887 	uxth.w	r8, r7
   40224:	2101      	movs	r1, #1
   40226:	0c25      	lsrs	r5, r4, #16
   40228:	fbb3 fcfe 	udiv	ip, r3, lr
   4022c:	fb0e 301c 	mls	r0, lr, ip, r3
   40230:	462b      	mov	r3, r5
   40232:	fb08 f90c 	mul.w	r9, r8, ip
   40236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   4023a:	45a9      	cmp	r9, r5
   4023c:	d90a      	bls.n	40254 <__udivmoddi4+0xe0>
   4023e:	197d      	adds	r5, r7, r5
   40240:	bf2c      	ite	cs
   40242:	2301      	movcs	r3, #1
   40244:	2300      	movcc	r3, #0
   40246:	45a9      	cmp	r9, r5
   40248:	d902      	bls.n	40250 <__udivmoddi4+0xdc>
   4024a:	2b00      	cmp	r3, #0
   4024c:	f000 80d9 	beq.w	40402 <__udivmoddi4+0x28e>
   40250:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   40254:	eba5 0509 	sub.w	r5, r5, r9
   40258:	b2a3      	uxth	r3, r4
   4025a:	fbb5 f0fe 	udiv	r0, r5, lr
   4025e:	fb0e 5510 	mls	r5, lr, r0, r5
   40262:	fb08 f800 	mul.w	r8, r8, r0
   40266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   4026a:	45a0      	cmp	r8, r4
   4026c:	d905      	bls.n	4027a <__udivmoddi4+0x106>
   4026e:	193c      	adds	r4, r7, r4
   40270:	d202      	bcs.n	40278 <__udivmoddi4+0x104>
   40272:	45a0      	cmp	r8, r4
   40274:	f200 80c9 	bhi.w	4040a <__udivmoddi4+0x296>
   40278:	3801      	subs	r0, #1
   4027a:	eba4 0408 	sub.w	r4, r4, r8
   4027e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   40282:	e7bd      	b.n	40200 <__udivmoddi4+0x8c>
   40284:	428b      	cmp	r3, r1
   40286:	d908      	bls.n	4029a <__udivmoddi4+0x126>
   40288:	2e00      	cmp	r6, #0
   4028a:	f000 80b1 	beq.w	403f0 <__udivmoddi4+0x27c>
   4028e:	2100      	movs	r1, #0
   40290:	e9c6 0500 	strd	r0, r5, [r6]
   40294:	4608      	mov	r0, r1
   40296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4029a:	fab3 f183 	clz	r1, r3
   4029e:	2900      	cmp	r1, #0
   402a0:	d146      	bne.n	40330 <__udivmoddi4+0x1bc>
   402a2:	42ab      	cmp	r3, r5
   402a4:	f0c0 80a7 	bcc.w	403f6 <__udivmoddi4+0x282>
   402a8:	4282      	cmp	r2, r0
   402aa:	f240 80a4 	bls.w	403f6 <__udivmoddi4+0x282>
   402ae:	4608      	mov	r0, r1
   402b0:	2e00      	cmp	r6, #0
   402b2:	d0aa      	beq.n	4020a <__udivmoddi4+0x96>
   402b4:	e9c6 4a00 	strd	r4, sl, [r6]
   402b8:	e7a7      	b.n	4020a <__udivmoddi4+0x96>
   402ba:	f1c2 0020 	rsb	r0, r2, #32
   402be:	4097      	lsls	r7, r2
   402c0:	fa01 f302 	lsl.w	r3, r1, r2
   402c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   402c8:	40c1      	lsrs	r1, r0
   402ca:	fa24 f500 	lsr.w	r5, r4, r0
   402ce:	fa1f f887 	uxth.w	r8, r7
   402d2:	4094      	lsls	r4, r2
   402d4:	431d      	orrs	r5, r3
   402d6:	fbb1 f0fe 	udiv	r0, r1, lr
   402da:	0c2b      	lsrs	r3, r5, #16
   402dc:	fb0e 1110 	mls	r1, lr, r0, r1
   402e0:	fb00 fc08 	mul.w	ip, r0, r8
   402e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   402e8:	459c      	cmp	ip, r3
   402ea:	d909      	bls.n	40300 <__udivmoddi4+0x18c>
   402ec:	18fb      	adds	r3, r7, r3
   402ee:	bf2c      	ite	cs
   402f0:	2101      	movcs	r1, #1
   402f2:	2100      	movcc	r1, #0
   402f4:	459c      	cmp	ip, r3
   402f6:	d902      	bls.n	402fe <__udivmoddi4+0x18a>
   402f8:	2900      	cmp	r1, #0
   402fa:	f000 8095 	beq.w	40428 <__udivmoddi4+0x2b4>
   402fe:	3801      	subs	r0, #1
   40300:	eba3 030c 	sub.w	r3, r3, ip
   40304:	b2ad      	uxth	r5, r5
   40306:	fbb3 f1fe 	udiv	r1, r3, lr
   4030a:	fb0e 3311 	mls	r3, lr, r1, r3
   4030e:	fb01 fc08 	mul.w	ip, r1, r8
   40312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   40316:	45ac      	cmp	ip, r5
   40318:	d905      	bls.n	40326 <__udivmoddi4+0x1b2>
   4031a:	197d      	adds	r5, r7, r5
   4031c:	d202      	bcs.n	40324 <__udivmoddi4+0x1b0>
   4031e:	45ac      	cmp	ip, r5
   40320:	f200 8089 	bhi.w	40436 <__udivmoddi4+0x2c2>
   40324:	3901      	subs	r1, #1
   40326:	eba5 030c 	sub.w	r3, r5, ip
   4032a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   4032e:	e77a      	b.n	40226 <__udivmoddi4+0xb2>
   40330:	f1c1 0420 	rsb	r4, r1, #32
   40334:	408b      	lsls	r3, r1
   40336:	fa02 f701 	lsl.w	r7, r2, r1
   4033a:	fa05 fc01 	lsl.w	ip, r5, r1
   4033e:	40e2      	lsrs	r2, r4
   40340:	fa20 f804 	lsr.w	r8, r0, r4
   40344:	40e5      	lsrs	r5, r4
   40346:	fa00 fe01 	lsl.w	lr, r0, r1
   4034a:	4313      	orrs	r3, r2
   4034c:	ea48 020c 	orr.w	r2, r8, ip
   40350:	ea4f 4813 	mov.w	r8, r3, lsr #16
   40354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   40358:	fa1f f983 	uxth.w	r9, r3
   4035c:	fbb5 faf8 	udiv	sl, r5, r8
   40360:	fb08 551a 	mls	r5, r8, sl, r5
   40364:	fb0a f009 	mul.w	r0, sl, r9
   40368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   4036c:	4560      	cmp	r0, ip
   4036e:	d90a      	bls.n	40386 <__udivmoddi4+0x212>
   40370:	eb13 0c0c 	adds.w	ip, r3, ip
   40374:	bf2c      	ite	cs
   40376:	2501      	movcs	r5, #1
   40378:	2500      	movcc	r5, #0
   4037a:	4560      	cmp	r0, ip
   4037c:	d901      	bls.n	40382 <__udivmoddi4+0x20e>
   4037e:	2d00      	cmp	r5, #0
   40380:	d055      	beq.n	4042e <__udivmoddi4+0x2ba>
   40382:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   40386:	ebac 0c00 	sub.w	ip, ip, r0
   4038a:	b292      	uxth	r2, r2
   4038c:	fbbc f0f8 	udiv	r0, ip, r8
   40390:	fb08 cc10 	mls	ip, r8, r0, ip
   40394:	fb00 f909 	mul.w	r9, r0, r9
   40398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   4039c:	45e1      	cmp	r9, ip
   4039e:	d905      	bls.n	403ac <__udivmoddi4+0x238>
   403a0:	eb13 0c0c 	adds.w	ip, r3, ip
   403a4:	d201      	bcs.n	403aa <__udivmoddi4+0x236>
   403a6:	45e1      	cmp	r9, ip
   403a8:	d83b      	bhi.n	40422 <__udivmoddi4+0x2ae>
   403aa:	3801      	subs	r0, #1
   403ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   403b0:	ebac 0c09 	sub.w	ip, ip, r9
   403b4:	fba0 8907 	umull	r8, r9, r0, r7
   403b8:	45cc      	cmp	ip, r9
   403ba:	4645      	mov	r5, r8
   403bc:	464a      	mov	r2, r9
   403be:	d302      	bcc.n	403c6 <__udivmoddi4+0x252>
   403c0:	d106      	bne.n	403d0 <__udivmoddi4+0x25c>
   403c2:	45c6      	cmp	lr, r8
   403c4:	d204      	bcs.n	403d0 <__udivmoddi4+0x25c>
   403c6:	3801      	subs	r0, #1
   403c8:	ebb8 0507 	subs.w	r5, r8, r7
   403cc:	eb69 0203 	sbc.w	r2, r9, r3
   403d0:	b32e      	cbz	r6, 4041e <__udivmoddi4+0x2aa>
   403d2:	ebbe 0305 	subs.w	r3, lr, r5
   403d6:	eb6c 0c02 	sbc.w	ip, ip, r2
   403da:	fa23 f201 	lsr.w	r2, r3, r1
   403de:	fa0c f404 	lsl.w	r4, ip, r4
   403e2:	fa2c f301 	lsr.w	r3, ip, r1
   403e6:	2100      	movs	r1, #0
   403e8:	4314      	orrs	r4, r2
   403ea:	e9c6 4300 	strd	r4, r3, [r6]
   403ee:	e70c      	b.n	4020a <__udivmoddi4+0x96>
   403f0:	4631      	mov	r1, r6
   403f2:	4630      	mov	r0, r6
   403f4:	e709      	b.n	4020a <__udivmoddi4+0x96>
   403f6:	1a84      	subs	r4, r0, r2
   403f8:	eb65 0303 	sbc.w	r3, r5, r3
   403fc:	2001      	movs	r0, #1
   403fe:	469a      	mov	sl, r3
   40400:	e756      	b.n	402b0 <__udivmoddi4+0x13c>
   40402:	f1ac 0c02 	sub.w	ip, ip, #2
   40406:	443d      	add	r5, r7
   40408:	e724      	b.n	40254 <__udivmoddi4+0xe0>
   4040a:	3802      	subs	r0, #2
   4040c:	443c      	add	r4, r7
   4040e:	e734      	b.n	4027a <__udivmoddi4+0x106>
   40410:	3802      	subs	r0, #2
   40412:	443c      	add	r4, r7
   40414:	e6ef      	b.n	401f6 <__udivmoddi4+0x82>
   40416:	f1ae 0e02 	sub.w	lr, lr, #2
   4041a:	443b      	add	r3, r7
   4041c:	e6d9      	b.n	401d2 <__udivmoddi4+0x5e>
   4041e:	4631      	mov	r1, r6
   40420:	e6f3      	b.n	4020a <__udivmoddi4+0x96>
   40422:	3802      	subs	r0, #2
   40424:	449c      	add	ip, r3
   40426:	e7c1      	b.n	403ac <__udivmoddi4+0x238>
   40428:	3802      	subs	r0, #2
   4042a:	443b      	add	r3, r7
   4042c:	e768      	b.n	40300 <__udivmoddi4+0x18c>
   4042e:	f1aa 0a02 	sub.w	sl, sl, #2
   40432:	449c      	add	ip, r3
   40434:	e7a7      	b.n	40386 <__udivmoddi4+0x212>
   40436:	3902      	subs	r1, #2
   40438:	443d      	add	r5, r7
   4043a:	e774      	b.n	40326 <__udivmoddi4+0x1b2>

0004043c <__aeabi_idiv0>:
   4043c:	4770      	bx	lr
   4043e:	bf00      	nop

00040440 <crypto_finish>:

	return APP_SUCCESS;
}

int crypto_finish(void)
{
   40440:	b508      	push	{r3, lr}
	psa_status_t status;

	/* Destroy the key handle */
	status = psa_destroy_key(keypair_handle);
   40442:	4b11      	ldr	r3, [pc, #68]	; (40488 <crypto_finish+0x48>)
   40444:	6818      	ldr	r0, [r3, #0]
   40446:	f006 fef3 	bl	47230 <psa_destroy_key>
	if (status != PSA_SUCCESS) {
   4044a:	4601      	mov	r1, r0
   4044c:	b160      	cbz	r0, 40468 <crypto_finish+0x28>
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
   4044e:	4a0f      	ldr	r2, [pc, #60]	; (4048c <crypto_finish+0x4c>)
   40450:	4b0f      	ldr	r3, [pc, #60]	; (40490 <crypto_finish+0x50>)
   40452:	1ad2      	subs	r2, r2, r3
   40454:	08d2      	lsrs	r2, r2, #3
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   40456:	0192      	lsls	r2, r2, #6
   40458:	f042 0203 	orr.w	r2, r2, #3
		return APP_ERROR;
	}

	status = psa_destroy_key(pub_key_handle);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   4045c:	480d      	ldr	r0, [pc, #52]	; (40494 <crypto_finish+0x54>)
   4045e:	f007 fb99 	bl	47b94 <log_1>
		return APP_ERROR;
   40462:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	return APP_SUCCESS;
}
   40466:	bd08      	pop	{r3, pc}
	status = psa_destroy_key(pub_key_handle);
   40468:	4b0b      	ldr	r3, [pc, #44]	; (40498 <crypto_finish+0x58>)
   4046a:	6818      	ldr	r0, [r3, #0]
   4046c:	f006 fee0 	bl	47230 <psa_destroy_key>
	if (status != PSA_SUCCESS) {
   40470:	2800      	cmp	r0, #0
   40472:	d0f8      	beq.n	40466 <crypto_finish+0x26>
   40474:	4a05      	ldr	r2, [pc, #20]	; (4048c <crypto_finish+0x4c>)
   40476:	4b06      	ldr	r3, [pc, #24]	; (40490 <crypto_finish+0x50>)
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   40478:	4601      	mov	r1, r0
   4047a:	1ad2      	subs	r2, r2, r3
   4047c:	08d2      	lsrs	r2, r2, #3
   4047e:	0192      	lsls	r2, r2, #6
   40480:	f042 0203 	orr.w	r2, r2, #3
   40484:	e7ea      	b.n	4045c <crypto_finish+0x1c>
   40486:	bf00      	nop
   40488:	2001a850 	.word	0x2001a850
   4048c:	00048f60 	.word	0x00048f60
   40490:	00048f58 	.word	0x00048f58
   40494:	000491d8 	.word	0x000491d8
   40498:	2001a854 	.word	0x2001a854

0004049c <generate_ecdsa_keypair>:

int generate_ecdsa_keypair(void)
{
   4049c:	b530      	push	{r4, r5, lr}
   4049e:	4b1b      	ldr	r3, [pc, #108]	; (4050c <generate_ecdsa_keypair+0x70>)
   404a0:	4c1b      	ldr	r4, [pc, #108]	; (40510 <generate_ecdsa_keypair+0x74>)
   404a2:	b087      	sub	sp, #28
   404a4:	1ae4      	subs	r4, r4, r3
   404a6:	08e4      	lsrs	r4, r4, #3
	psa_status_t status;
	size_t olen;

	LOG_INF("Generating random ECDSA keypair...");
   404a8:	01a4      	lsls	r4, r4, #6
   404aa:	f044 0403 	orr.w	r4, r4, #3
   404ae:	4621      	mov	r1, r4
   404b0:	4818      	ldr	r0, [pc, #96]	; (40514 <generate_ecdsa_keypair+0x78>)
   404b2:	f007 fb62 	bl	47b7a <log_0>
}

static inline void psa_set_key_lifetime(psa_key_attributes_t *attributes,
                                        psa_key_lifetime_t lifetime)
{
    attributes->lifetime = lifetime;
   404b6:	2300      	movs	r3, #0
}

static inline void psa_set_key_algorithm(psa_key_attributes_t *attributes,
                                         psa_algorithm_t alg)
{
    attributes->alg = alg;
   404b8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    attributes->lifetime = lifetime;
   404bc:	4a16      	ldr	r2, [pc, #88]	; (40518 <generate_ecdsa_keypair+0x7c>)
        attributes->id = 0;
   404be:	9303      	str	r3, [sp, #12]
    attributes->lifetime = lifetime;
   404c0:	e9cd 2301 	strd	r2, r3, [sp, #4]
	psa_set_key_bits(&key_attributes, 256);

	/* Generate a random keypair. The keypair is not exposed to the application,
	 * we can use it to signing/verification the key handle.
	 */
	status = psa_generate_key(&key_attributes, &keypair_handle);
   404c4:	4d15      	ldr	r5, [pc, #84]	; (4051c <generate_ecdsa_keypair+0x80>)
    attributes->alg = alg;
   404c6:	4b16      	ldr	r3, [pc, #88]	; (40520 <generate_ecdsa_keypair+0x84>)
   404c8:	a801      	add	r0, sp, #4
   404ca:	e9cd 1304 	strd	r1, r3, [sp, #16]
   404ce:	4629      	mov	r1, r5
   404d0:	f006 ff9e 	bl	47410 <psa_generate_key>
	if (status != PSA_SUCCESS) {
   404d4:	4601      	mov	r1, r0
   404d6:	b140      	cbz	r0, 404ea <generate_ecdsa_keypair+0x4e>
		LOG_INF("psa_generate_key failed! (Error: %d)", status);
   404d8:	4622      	mov	r2, r4
   404da:	4812      	ldr	r0, [pc, #72]	; (40524 <generate_ecdsa_keypair+0x88>)
	}

	/* Export the public key */
	status = psa_export_public_key(keypair_handle, m_pub_key, sizeof(m_pub_key), &olen);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
   404dc:	f007 fb5a 	bl	47b94 <log_1>
		return APP_ERROR;
   404e0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

	/* After the key handle is acquired the attributes are not needed */
	psa_reset_key_attributes(&key_attributes);

	return APP_SUCCESS;
}
   404e4:	4628      	mov	r0, r5
   404e6:	b007      	add	sp, #28
   404e8:	bd30      	pop	{r4, r5, pc}
	status = psa_export_public_key(keypair_handle, m_pub_key, sizeof(m_pub_key), &olen);
   404ea:	6828      	ldr	r0, [r5, #0]
   404ec:	466b      	mov	r3, sp
   404ee:	2241      	movs	r2, #65	; 0x41
   404f0:	490d      	ldr	r1, [pc, #52]	; (40528 <generate_ecdsa_keypair+0x8c>)
   404f2:	f006 fed3 	bl	4729c <psa_export_public_key>
	if (status != PSA_SUCCESS) {
   404f6:	4605      	mov	r5, r0
   404f8:	b118      	cbz	r0, 40502 <generate_ecdsa_keypair+0x66>
		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
   404fa:	4601      	mov	r1, r0
   404fc:	4622      	mov	r2, r4
   404fe:	480b      	ldr	r0, [pc, #44]	; (4052c <generate_ecdsa_keypair+0x90>)
   40500:	e7ec      	b.n	404dc <generate_ecdsa_keypair+0x40>
	psa_reset_key_attributes(&key_attributes);
   40502:	a801      	add	r0, sp, #4
   40504:	f006 feae 	bl	47264 <psa_reset_key_attributes>
	return APP_SUCCESS;
   40508:	e7ec      	b.n	404e4 <generate_ecdsa_keypair+0x48>
   4050a:	bf00      	nop
   4050c:	00048f58 	.word	0x00048f58
   40510:	00048f60 	.word	0x00048f60
   40514:	000491fc 	.word	0x000491fc
   40518:	01007112 	.word	0x01007112
   4051c:	2001a850 	.word	0x2001a850
   40520:	06000609 	.word	0x06000609
   40524:	0004921f 	.word	0x0004921f
   40528:	2001add2 	.word	0x2001add2
   4052c:	00049244 	.word	0x00049244

00040530 <import_ecdsa_pub_key>:
    attributes->lifetime = lifetime;
   40530:	2300      	movs	r3, #0
    attributes->alg = alg;
   40532:	f44f 5100 	mov.w	r1, #8192	; 0x2000

int import_ecdsa_pub_key(void)
{
   40536:	b510      	push	{r4, lr}
    attributes->lifetime = lifetime;
   40538:	4a11      	ldr	r2, [pc, #68]	; (40580 <import_ecdsa_pub_key+0x50>)
   4053a:	b086      	sub	sp, #24
   4053c:	e9cd 2301 	strd	r2, r3, [sp, #4]
        attributes->id = 0;
   40540:	9303      	str	r3, [sp, #12]
    attributes->alg = alg;
   40542:	4b10      	ldr	r3, [pc, #64]	; (40584 <import_ecdsa_pub_key+0x54>)
	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(PSA_ECC_FAMILY_SECP_R1));
	psa_set_key_bits(&key_attributes, 256);

	status = psa_import_key(&key_attributes, m_pub_key, sizeof(m_pub_key), &pub_key_handle);
   40544:	2241      	movs	r2, #65	; 0x41
   40546:	e9cd 1304 	strd	r1, r3, [sp, #16]
   4054a:	a801      	add	r0, sp, #4
   4054c:	4b0e      	ldr	r3, [pc, #56]	; (40588 <import_ecdsa_pub_key+0x58>)
   4054e:	490f      	ldr	r1, [pc, #60]	; (4058c <import_ecdsa_pub_key+0x5c>)
   40550:	f006 fe4a 	bl	471e8 <psa_import_key>
	if (status != PSA_SUCCESS) {
   40554:	4604      	mov	r4, r0
   40556:	b178      	cbz	r0, 40578 <import_ecdsa_pub_key+0x48>
   40558:	4b0d      	ldr	r3, [pc, #52]	; (40590 <import_ecdsa_pub_key+0x60>)
   4055a:	4a0e      	ldr	r2, [pc, #56]	; (40594 <import_ecdsa_pub_key+0x64>)
		LOG_INF("psa_import_key failed! (Error: %d)", status);
   4055c:	4601      	mov	r1, r0
   4055e:	1ad2      	subs	r2, r2, r3
   40560:	08d2      	lsrs	r2, r2, #3
   40562:	0192      	lsls	r2, r2, #6
   40564:	480c      	ldr	r0, [pc, #48]	; (40598 <import_ecdsa_pub_key+0x68>)
   40566:	f042 0203 	orr.w	r2, r2, #3
   4056a:	f007 fb13 	bl	47b94 <log_1>
		return APP_ERROR;
   4056e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

	/* After the key handle is acquired the attributes are not needed */
	psa_reset_key_attributes(&key_attributes);

	return APP_SUCCESS;
}
   40572:	4620      	mov	r0, r4
   40574:	b006      	add	sp, #24
   40576:	bd10      	pop	{r4, pc}
	psa_reset_key_attributes(&key_attributes);
   40578:	a801      	add	r0, sp, #4
   4057a:	f006 fe73 	bl	47264 <psa_reset_key_attributes>
	return APP_SUCCESS;
   4057e:	e7f8      	b.n	40572 <import_ecdsa_pub_key+0x42>
   40580:	01004112 	.word	0x01004112
   40584:	06000609 	.word	0x06000609
   40588:	2001a854 	.word	0x2001a854
   4058c:	2001add2 	.word	0x2001add2
   40590:	00048f58 	.word	0x00048f58
   40594:	00048f60 	.word	0x00048f60
   40598:	0004926e 	.word	0x0004926e

0004059c <sign_message>:

int sign_message(void)
{
   4059c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	psa_status_t status;

	LOG_INF("Signing a message using ECDSA...");

	/* Compute the SHA256 hash*/
	status = psa_hash_compute(PSA_ALG_SHA_256,
   405a0:	2620      	movs	r6, #32
   405a2:	4b36      	ldr	r3, [pc, #216]	; (4067c <sign_message+0xe0>)
   405a4:	4c36      	ldr	r4, [pc, #216]	; (40680 <sign_message+0xe4>)
{
   405a6:	b086      	sub	sp, #24
   405a8:	1ae4      	subs	r4, r4, r3
   405aa:	08e4      	lsrs	r4, r4, #3
	LOG_INF("Signing a message using ECDSA...");
   405ac:	01a4      	lsls	r4, r4, #6
   405ae:	f044 0403 	orr.w	r4, r4, #3
   405b2:	4621      	mov	r1, r4
   405b4:	4833      	ldr	r0, [pc, #204]	; (40684 <sign_message+0xe8>)
	status = psa_hash_compute(PSA_ALG_SHA_256,
   405b6:	ad05      	add	r5, sp, #20
	LOG_INF("Signing a message using ECDSA...");
   405b8:	f007 fadf 	bl	47b7a <log_0>
	status = psa_hash_compute(PSA_ALG_SHA_256,
   405bc:	4932      	ldr	r1, [pc, #200]	; (40688 <sign_message+0xec>)
   405be:	2264      	movs	r2, #100	; 0x64
   405c0:	4b32      	ldr	r3, [pc, #200]	; (4068c <sign_message+0xf0>)
   405c2:	4833      	ldr	r0, [pc, #204]	; (40690 <sign_message+0xf4>)
   405c4:	9501      	str	r5, [sp, #4]
   405c6:	9600      	str	r6, [sp, #0]
   405c8:	f006 fe8a 	bl	472e0 <psa_hash_compute>
				  m_plain_text,
				  sizeof(m_plain_text),
				  m_hash,
				  sizeof(m_hash),
				  &output_len);
	if (status != PSA_SUCCESS) {
   405cc:	4601      	mov	r1, r0
   405ce:	b148      	cbz	r0, 405e4 <sign_message+0x48>
		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
   405d0:	4622      	mov	r2, r4
   405d2:	4830      	ldr	r0, [pc, #192]	; (40694 <sign_message+0xf8>)
			       sizeof(m_hash),
			       m_signature,
			       sizeof(m_signature),
			       &output_len);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
   405d4:	f007 fade 	bl	47b94 <log_1>
		return APP_ERROR;
   405d8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
	PRINT_HEX("SHA256 hash", m_hash, sizeof(m_hash));
	PRINT_HEX("Signature", m_signature, sizeof(m_signature));

	return APP_SUCCESS;
}
   405dc:	4628      	mov	r0, r5
   405de:	b006      	add	sp, #24
   405e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status = psa_sign_hash(keypair_handle,
   405e4:	2740      	movs	r7, #64	; 0x40
   405e6:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 406c0 <sign_message+0x124>
   405ea:	482b      	ldr	r0, [pc, #172]	; (40698 <sign_message+0xfc>)
   405ec:	9502      	str	r5, [sp, #8]
   405ee:	9701      	str	r7, [sp, #4]
   405f0:	f8cd 8000 	str.w	r8, [sp]
   405f4:	4633      	mov	r3, r6
   405f6:	4a25      	ldr	r2, [pc, #148]	; (4068c <sign_message+0xf0>)
   405f8:	4928      	ldr	r1, [pc, #160]	; (4069c <sign_message+0x100>)
   405fa:	6800      	ldr	r0, [r0, #0]
   405fc:	f006 fe98 	bl	47330 <psa_sign_hash>
	if (status != PSA_SUCCESS) {
   40600:	4605      	mov	r5, r0
   40602:	b118      	cbz	r0, 4060c <sign_message+0x70>
		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
   40604:	4601      	mov	r1, r0
   40606:	4622      	mov	r2, r4
   40608:	4825      	ldr	r0, [pc, #148]	; (406a0 <sign_message+0x104>)
   4060a:	e7e3      	b.n	405d4 <sign_message+0x38>
	LOG_INF("Signing the message successful!");
   4060c:	4621      	mov	r1, r4
   4060e:	4825      	ldr	r0, [pc, #148]	; (406a4 <sign_message+0x108>)
   40610:	f007 fab3 	bl	47b7a <log_0>
	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
   40614:	4623      	mov	r3, r4
   40616:	2264      	movs	r2, #100	; 0x64
   40618:	4923      	ldr	r1, [pc, #140]	; (406a8 <sign_message+0x10c>)
   4061a:	4824      	ldr	r0, [pc, #144]	; (406ac <sign_message+0x110>)
   4061c:	f007 face 	bl	47bbc <log_2>
   40620:	4623      	mov	r3, r4
   40622:	2264      	movs	r2, #100	; 0x64
   40624:	4918      	ldr	r1, [pc, #96]	; (40688 <sign_message+0xec>)
   40626:	4822      	ldr	r0, [pc, #136]	; (406b0 <sign_message+0x114>)
   40628:	f007 fafd 	bl	47c26 <log_hexdump>
   4062c:	4622      	mov	r2, r4
   4062e:	491e      	ldr	r1, [pc, #120]	; (406a8 <sign_message+0x10c>)
   40630:	4820      	ldr	r0, [pc, #128]	; (406b4 <sign_message+0x118>)
   40632:	f007 faaf 	bl	47b94 <log_1>
	PRINT_HEX("SHA256 hash", m_hash, sizeof(m_hash));
   40636:	4623      	mov	r3, r4
   40638:	4632      	mov	r2, r6
   4063a:	491f      	ldr	r1, [pc, #124]	; (406b8 <sign_message+0x11c>)
   4063c:	481b      	ldr	r0, [pc, #108]	; (406ac <sign_message+0x110>)
   4063e:	f007 fabd 	bl	47bbc <log_2>
   40642:	4623      	mov	r3, r4
   40644:	4632      	mov	r2, r6
   40646:	4911      	ldr	r1, [pc, #68]	; (4068c <sign_message+0xf0>)
   40648:	4819      	ldr	r0, [pc, #100]	; (406b0 <sign_message+0x114>)
   4064a:	f007 faec 	bl	47c26 <log_hexdump>
   4064e:	4622      	mov	r2, r4
   40650:	4919      	ldr	r1, [pc, #100]	; (406b8 <sign_message+0x11c>)
   40652:	4818      	ldr	r0, [pc, #96]	; (406b4 <sign_message+0x118>)
   40654:	f007 fa9e 	bl	47b94 <log_1>
	PRINT_HEX("Signature", m_signature, sizeof(m_signature));
   40658:	4623      	mov	r3, r4
   4065a:	463a      	mov	r2, r7
   4065c:	4917      	ldr	r1, [pc, #92]	; (406bc <sign_message+0x120>)
   4065e:	4813      	ldr	r0, [pc, #76]	; (406ac <sign_message+0x110>)
   40660:	f007 faac 	bl	47bbc <log_2>
   40664:	463a      	mov	r2, r7
   40666:	4641      	mov	r1, r8
   40668:	4623      	mov	r3, r4
   4066a:	4811      	ldr	r0, [pc, #68]	; (406b0 <sign_message+0x114>)
   4066c:	f007 fadb 	bl	47c26 <log_hexdump>
   40670:	4622      	mov	r2, r4
   40672:	4912      	ldr	r1, [pc, #72]	; (406bc <sign_message+0x120>)
   40674:	480f      	ldr	r0, [pc, #60]	; (406b4 <sign_message+0x118>)
   40676:	f007 fa8d 	bl	47b94 <log_1>
	return APP_SUCCESS;
   4067a:	e7af      	b.n	405dc <sign_message+0x40>
   4067c:	00048f58 	.word	0x00048f58
   40680:	00048f60 	.word	0x00048f60
   40684:	00049291 	.word	0x00049291
   40688:	2001a594 	.word	0x2001a594
   4068c:	2001adb2 	.word	0x2001adb2
   40690:	02000009 	.word	0x02000009
   40694:	000492b2 	.word	0x000492b2
   40698:	2001a850 	.word	0x2001a850
   4069c:	06000609 	.word	0x06000609
   406a0:	000492d7 	.word	0x000492d7
   406a4:	000492f9 	.word	0x000492f9
   406a8:	00049319 	.word	0x00049319
   406ac:	00049323 	.word	0x00049323
   406b0:	0004933b 	.word	0x0004933b
   406b4:	00049344 	.word	0x00049344
   406b8:	00049356 	.word	0x00049356
   406bc:	00049362 	.word	0x00049362
   406c0:	2001ae13 	.word	0x2001ae13

000406c4 <verify_message>:

int verify_message(void)
{
   406c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   406c6:	4b13      	ldr	r3, [pc, #76]	; (40714 <verify_message+0x50>)
   406c8:	4c13      	ldr	r4, [pc, #76]	; (40718 <verify_message+0x54>)
	psa_status_t status;

	LOG_INF("Verifying ECDSA signature...");
   406ca:	4814      	ldr	r0, [pc, #80]	; (4071c <verify_message+0x58>)
   406cc:	1ae4      	subs	r4, r4, r3
   406ce:	08e4      	lsrs	r4, r4, #3
   406d0:	01a4      	lsls	r4, r4, #6
   406d2:	f044 0403 	orr.w	r4, r4, #3
   406d6:	4621      	mov	r1, r4
   406d8:	f007 fa4f 	bl	47b7a <log_0>

	/* Verify the signature of the hash */
	status = psa_verify_hash(pub_key_handle,
   406dc:	2340      	movs	r3, #64	; 0x40
   406de:	9301      	str	r3, [sp, #4]
   406e0:	4b0f      	ldr	r3, [pc, #60]	; (40720 <verify_message+0x5c>)
   406e2:	4810      	ldr	r0, [pc, #64]	; (40724 <verify_message+0x60>)
   406e4:	9300      	str	r3, [sp, #0]
   406e6:	4a10      	ldr	r2, [pc, #64]	; (40728 <verify_message+0x64>)
   406e8:	2320      	movs	r3, #32
   406ea:	4910      	ldr	r1, [pc, #64]	; (4072c <verify_message+0x68>)
   406ec:	6800      	ldr	r0, [r0, #0]
   406ee:	f006 fe49 	bl	47384 <psa_verify_hash>
				 PSA_ALG_ECDSA(PSA_ALG_SHA_256),
				 m_hash,
				 sizeof(m_hash),
				 m_signature,
				 sizeof(m_signature));
	if (status != PSA_SUCCESS) {
   406f2:	4605      	mov	r5, r0
   406f4:	b148      	cbz	r0, 4070a <verify_message+0x46>
		LOG_INF("psa_verify_hash failed! (Error: %d)", status);
   406f6:	4601      	mov	r1, r0
   406f8:	4622      	mov	r2, r4
   406fa:	480d      	ldr	r0, [pc, #52]	; (40730 <verify_message+0x6c>)
   406fc:	f007 fa4a 	bl	47b94 <log_1>
		return APP_ERROR;
   40700:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	}

	LOG_INF("Signature verification was successful!");

	return APP_SUCCESS;
}
   40704:	4628      	mov	r0, r5
   40706:	b003      	add	sp, #12
   40708:	bd30      	pop	{r4, r5, pc}
	LOG_INF("Signature verification was successful!");
   4070a:	4621      	mov	r1, r4
   4070c:	4809      	ldr	r0, [pc, #36]	; (40734 <verify_message+0x70>)
   4070e:	f007 fa34 	bl	47b7a <log_0>
	return APP_SUCCESS;
   40712:	e7f7      	b.n	40704 <verify_message+0x40>
   40714:	00048f58 	.word	0x00048f58
   40718:	00048f60 	.word	0x00048f60
   4071c:	0004936c 	.word	0x0004936c
   40720:	2001ae13 	.word	0x2001ae13
   40724:	2001a854 	.word	0x2001a854
   40728:	2001adb2 	.word	0x2001adb2
   4072c:	06000609 	.word	0x06000609
   40730:	00049389 	.word	0x00049389
   40734:	000493ad 	.word	0x000493ad

00040738 <main>:

int main(void)
{
   40738:	b538      	push	{r3, r4, r5, lr}
   4073a:	4b18      	ldr	r3, [pc, #96]	; (4079c <main+0x64>)
   4073c:	4c18      	ldr	r4, [pc, #96]	; (407a0 <main+0x68>)
	int status;

	LOG_INF("Starting ECDSA example...");
   4073e:	4819      	ldr	r0, [pc, #100]	; (407a4 <main+0x6c>)
   40740:	1ae4      	subs	r4, r4, r3
   40742:	08e4      	lsrs	r4, r4, #3
   40744:	01a4      	lsls	r4, r4, #6
   40746:	f044 0403 	orr.w	r4, r4, #3
   4074a:	4621      	mov	r1, r4
   4074c:	f007 fa15 	bl	47b7a <log_0>

	status = crypto_init();
   40750:	f006 fe81 	bl	47456 <crypto_init>
	if (status != APP_SUCCESS) {
   40754:	b138      	cbz	r0, 40766 <main+0x2e>
		return APP_ERROR;
	}

	status = verify_message();
	if (status != APP_SUCCESS) {
		LOG_INF(APP_ERROR_MESSAGE);
   40756:	4621      	mov	r1, r4
		return APP_ERROR;
	}

	status = crypto_finish();
	if (status != APP_SUCCESS) {
		LOG_INF(APP_ERROR_MESSAGE);
   40758:	4813      	ldr	r0, [pc, #76]	; (407a8 <main+0x70>)
   4075a:	f007 fa0e 	bl	47b7a <log_0>
		return APP_ERROR;
   4075e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	}

	LOG_INF(APP_SUCCESS_MESSAGE);

	return APP_SUCCESS;
}
   40762:	4628      	mov	r0, r5
   40764:	bd38      	pop	{r3, r4, r5, pc}
	status = generate_ecdsa_keypair();
   40766:	f7ff fe99 	bl	4049c <generate_ecdsa_keypair>
	if (status != APP_SUCCESS) {
   4076a:	2800      	cmp	r0, #0
   4076c:	d1f3      	bne.n	40756 <main+0x1e>
	status = import_ecdsa_pub_key();
   4076e:	f7ff fedf 	bl	40530 <import_ecdsa_pub_key>
	if (status != APP_SUCCESS) {
   40772:	2800      	cmp	r0, #0
   40774:	d1ef      	bne.n	40756 <main+0x1e>
	status = sign_message();
   40776:	f7ff ff11 	bl	4059c <sign_message>
	if (status != APP_SUCCESS) {
   4077a:	2800      	cmp	r0, #0
   4077c:	d1eb      	bne.n	40756 <main+0x1e>
	status = verify_message();
   4077e:	f7ff ffa1 	bl	406c4 <verify_message>
	if (status != APP_SUCCESS) {
   40782:	2800      	cmp	r0, #0
   40784:	d1e7      	bne.n	40756 <main+0x1e>
	status = crypto_finish();
   40786:	f7ff fe5b 	bl	40440 <crypto_finish>
		LOG_INF(APP_ERROR_MESSAGE);
   4078a:	4621      	mov	r1, r4
	if (status != APP_SUCCESS) {
   4078c:	4605      	mov	r5, r0
   4078e:	2800      	cmp	r0, #0
   40790:	d1e2      	bne.n	40758 <main+0x20>
	LOG_INF(APP_SUCCESS_MESSAGE);
   40792:	4806      	ldr	r0, [pc, #24]	; (407ac <main+0x74>)
   40794:	f007 f9f1 	bl	47b7a <log_0>
	return APP_SUCCESS;
   40798:	e7e3      	b.n	40762 <main+0x2a>
   4079a:	bf00      	nop
   4079c:	00048f58 	.word	0x00048f58
   407a0:	00048f60 	.word	0x00048f60
   407a4:	000493d4 	.word	0x000493d4
   407a8:	000493ee 	.word	0x000493ee
   407ac:	00049409 	.word	0x00049409

000407b0 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   407b0:	680b      	ldr	r3, [r1, #0]
   407b2:	3301      	adds	r3, #1
   407b4:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   407b6:	4b01      	ldr	r3, [pc, #4]	; (407bc <char_out+0xc>)
   407b8:	681b      	ldr	r3, [r3, #0]
   407ba:	4718      	bx	r3
   407bc:	2001a500 	.word	0x2001a500

000407c0 <__printk_hook_install>:
	_char_out = fn;
   407c0:	4b01      	ldr	r3, [pc, #4]	; (407c8 <__printk_hook_install+0x8>)
   407c2:	6018      	str	r0, [r3, #0]
}
   407c4:	4770      	bx	lr
   407c6:	bf00      	nop
   407c8:	2001a500 	.word	0x2001a500

000407cc <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   407cc:	b507      	push	{r0, r1, r2, lr}
   407ce:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   407d0:	2100      	movs	r1, #0
{
   407d2:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   407d4:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   407d6:	4803      	ldr	r0, [pc, #12]	; (407e4 <vprintk+0x18>)
   407d8:	a901      	add	r1, sp, #4
   407da:	f000 f8ff 	bl	409dc <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   407de:	b003      	add	sp, #12
   407e0:	f85d fb04 	ldr.w	pc, [sp], #4
   407e4:	000407b1 	.word	0x000407b1

000407e8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   407e8:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   407ea:	2500      	movs	r5, #0
{
   407ec:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   407ee:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   407f2:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
   407f4:	a901      	add	r1, sp, #4
   407f6:	4805      	ldr	r0, [pc, #20]	; (4080c <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   407f8:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
   407fa:	f000 f8ef 	bl	409dc <cbvprintf>

	if (ctx.count < ctx.max) {
   407fe:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   40802:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   40804:	bfb8      	it	lt
   40806:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   40808:	b005      	add	sp, #20
   4080a:	bd30      	pop	{r4, r5, pc}
   4080c:	000474a7 	.word	0x000474a7

00040810 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   40810:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40814:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   40818:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   4081a:	f019 0808 	ands.w	r8, r9, #8
{
   4081e:	4693      	mov	fp, r2
	if (processing) {
   40820:	d00d      	beq.n	4083e <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   40822:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   40824:	bf0c      	ite	eq
   40826:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   4082a:	f049 0920 	orrne.w	r9, r9, #32
   4082e:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   40832:	f38b 8811 	msr	BASEPRI, fp
   40836:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   4083a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4083e:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   40842:	2902      	cmp	r1, #2
   40844:	d107      	bne.n	40856 <process_event+0x46>
			evt = process_recheck(mgr);
   40846:	4620      	mov	r0, r4
   40848:	f006 fe5a 	bl	47500 <process_recheck>
		if (evt == EVT_NOP) {
   4084c:	2800      	cmp	r0, #0
   4084e:	d0f0      	beq.n	40832 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   40850:	2801      	cmp	r0, #1
   40852:	8b23      	ldrh	r3, [r4, #24]
   40854:	d150      	bne.n	408f8 <process_event+0xe8>
			res = mgr->last_res;
   40856:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40858:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   4085a:	2f00      	cmp	r7, #0
   4085c:	da15      	bge.n	4088a <process_event+0x7a>
		*clients = mgr->clients;
   4085e:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40860:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   40864:	e9c4 8800 	strd	r8, r8, [r4]
   40868:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   4086c:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   4086e:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   40870:	8b21      	ldrh	r1, [r4, #24]
   40872:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   40876:	45ca      	cmp	sl, r9
   40878:	d002      	beq.n	40880 <process_event+0x70>
		if (do_monitors
   4087a:	68a3      	ldr	r3, [r4, #8]
   4087c:	2b00      	cmp	r3, #0
   4087e:	d15c      	bne.n	4093a <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   40880:	b90d      	cbnz	r5, 40886 <process_event+0x76>
		    || (transit != NULL)) {
   40882:	2e00      	cmp	r6, #0
   40884:	d074      	beq.n	40970 <process_event+0x160>
   40886:	2300      	movs	r3, #0
   40888:	e058      	b.n	4093c <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4088a:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   4088e:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   40890:	2a01      	cmp	r2, #1
   40892:	d820      	bhi.n	408d6 <process_event+0xc6>
		*clients = mgr->clients;
   40894:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   40898:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   4089a:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   4089c:	b289      	uxth	r1, r1
	list->tail = NULL;
   4089e:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   408a2:	d10c      	bne.n	408be <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   408a4:	2d00      	cmp	r5, #0
   408a6:	462b      	mov	r3, r5
   408a8:	bf38      	it	cc
   408aa:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   408ac:	b12b      	cbz	r3, 408ba <process_event+0xaa>
				mgr->refs += 1U;
   408ae:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   408b0:	681b      	ldr	r3, [r3, #0]
   408b2:	3201      	adds	r2, #1
   408b4:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   408b6:	2b00      	cmp	r3, #0
   408b8:	d1f8      	bne.n	408ac <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   408ba:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   408be:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   408c0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   408c2:	f006 fe1d 	bl	47500 <process_recheck>
   408c6:	4606      	mov	r6, r0
   408c8:	2800      	cmp	r0, #0
   408ca:	d0d1      	beq.n	40870 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   408cc:	8b23      	ldrh	r3, [r4, #24]
   408ce:	f043 0320 	orr.w	r3, r3, #32
   408d2:	8323      	strh	r3, [r4, #24]
   408d4:	e7cb      	b.n	4086e <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   408d6:	2b04      	cmp	r3, #4
   408d8:	d10c      	bne.n	408f4 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   408da:	f021 0107 	bic.w	r1, r1, #7
   408de:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   408e0:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   408e2:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   408e4:	f006 fe0c 	bl	47500 <process_recheck>
   408e8:	4605      	mov	r5, r0
   408ea:	2800      	cmp	r0, #0
   408ec:	d0bf      	beq.n	4086e <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   408ee:	f041 0120 	orr.w	r1, r1, #32
   408f2:	8321      	strh	r1, [r4, #24]
   408f4:	2500      	movs	r5, #0
   408f6:	e7ba      	b.n	4086e <process_event+0x5e>
		} else if (evt == EVT_START) {
   408f8:	2803      	cmp	r0, #3
   408fa:	d109      	bne.n	40910 <process_event+0x100>
			transit = mgr->transitions->start;
   408fc:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   408fe:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   40902:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40904:	f043 0306 	orr.w	r3, r3, #6
}
   40908:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   4090a:	8323      	strh	r3, [r4, #24]
		res = 0;
   4090c:	462f      	mov	r7, r5
   4090e:	e7af      	b.n	40870 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   40910:	2804      	cmp	r0, #4
   40912:	d106      	bne.n	40922 <process_event+0x112>
			transit = mgr->transitions->stop;
   40914:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40916:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   4091a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4091c:	f043 0304 	orr.w	r3, r3, #4
   40920:	e7f2      	b.n	40908 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   40922:	2805      	cmp	r0, #5
   40924:	d106      	bne.n	40934 <process_event+0x124>
			transit = mgr->transitions->reset;
   40926:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40928:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   4092c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   4092e:	f043 0305 	orr.w	r3, r3, #5
   40932:	e7e9      	b.n	40908 <process_event+0xf8>
   40934:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   40936:	462e      	mov	r6, r5
   40938:	e7e8      	b.n	4090c <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   4093a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   4093c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   40940:	8321      	strh	r1, [r4, #24]
   40942:	f38b 8811 	msr	BASEPRI, fp
   40946:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   4094a:	bb03      	cbnz	r3, 4098e <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   4094c:	2d00      	cmp	r5, #0
   4094e:	d133      	bne.n	409b8 <process_event+0x1a8>
			if (transit != NULL) {
   40950:	b116      	cbz	r6, 40958 <process_event+0x148>
				transit(mgr, transition_complete);
   40952:	4620      	mov	r0, r4
   40954:	4920      	ldr	r1, [pc, #128]	; (409d8 <process_event+0x1c8>)
   40956:	47b0      	blx	r6
	__asm__ volatile(
   40958:	f04f 0320 	mov.w	r3, #32
   4095c:	f3ef 8b11 	mrs	fp, BASEPRI
   40960:	f383 8812 	msr	BASEPRI_MAX, r3
   40964:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   40968:	8b23      	ldrh	r3, [r4, #24]
   4096a:	f023 0308 	bic.w	r3, r3, #8
   4096e:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   40970:	8b23      	ldrh	r3, [r4, #24]
   40972:	06da      	lsls	r2, r3, #27
   40974:	d528      	bpl.n	409c8 <process_event+0x1b8>
			evt = EVT_COMPLETE;
   40976:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   40978:	f023 0310 	bic.w	r3, r3, #16
   4097c:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   4097e:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   40982:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   40986:	2900      	cmp	r1, #0
   40988:	f47f af5b 	bne.w	40842 <process_event+0x32>
out:
   4098c:	e751      	b.n	40832 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   4098e:	68a1      	ldr	r1, [r4, #8]
   40990:	2900      	cmp	r1, #0
   40992:	d0db      	beq.n	4094c <process_event+0x13c>
	return node->next;
   40994:	680b      	ldr	r3, [r1, #0]
   40996:	2b00      	cmp	r3, #0
   40998:	bf38      	it	cc
   4099a:	2300      	movcc	r3, #0
   4099c:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   4099e:	4652      	mov	r2, sl
   409a0:	463b      	mov	r3, r7
   409a2:	4620      	mov	r0, r4
   409a4:	f8d1 b004 	ldr.w	fp, [r1, #4]
   409a8:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   409aa:	f1b9 0f00 	cmp.w	r9, #0
   409ae:	d0cd      	beq.n	4094c <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   409b0:	4649      	mov	r1, r9
   409b2:	f8d9 3000 	ldr.w	r3, [r9]
   409b6:	e7ee      	b.n	40996 <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   409b8:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   409ba:	463b      	mov	r3, r7
   409bc:	4652      	mov	r2, sl
   409be:	4620      	mov	r0, r4
   409c0:	682d      	ldr	r5, [r5, #0]
   409c2:	f006 fdb9 	bl	47538 <notify_one>
   409c6:	e7c1      	b.n	4094c <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   409c8:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   409cc:	bf1e      	ittt	ne
   409ce:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   409d2:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   409d4:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   409d6:	e7d2      	b.n	4097e <process_event+0x16e>
   409d8:	00047565 	.word	0x00047565

000409dc <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   409dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   409e0:	468b      	mov	fp, r1
   409e2:	4692      	mov	sl, r2
   409e4:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   409e6:	2500      	movs	r5, #0
{
   409e8:	b091      	sub	sp, #68	; 0x44
   409ea:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   409ec:	f89a 0000 	ldrb.w	r0, [sl]
   409f0:	b908      	cbnz	r0, 409f6 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   409f2:	4628      	mov	r0, r5
   409f4:	e35e      	b.n	410b4 <cbvprintf+0x6d8>
		if (*fp != '%') {
   409f6:	2825      	cmp	r0, #37	; 0x25
   409f8:	f10a 0701 	add.w	r7, sl, #1
   409fc:	d007      	beq.n	40a0e <cbvprintf+0x32>
			OUTC('%');
   409fe:	4659      	mov	r1, fp
   40a00:	9b02      	ldr	r3, [sp, #8]
   40a02:	4798      	blx	r3
   40a04:	2800      	cmp	r0, #0
   40a06:	f2c0 8355 	blt.w	410b4 <cbvprintf+0x6d8>
   40a0a:	3501      	adds	r5, #1
			break;
   40a0c:	e210      	b.n	40e30 <cbvprintf+0x454>
		} state = {
   40a0e:	2218      	movs	r2, #24
   40a10:	2100      	movs	r1, #0
   40a12:	a80a      	add	r0, sp, #40	; 0x28
   40a14:	f007 fc19 	bl	4824a <memset>
	if (*sp == '%') {
   40a18:	f89a 3001 	ldrb.w	r3, [sl, #1]
   40a1c:	2b25      	cmp	r3, #37	; 0x25
   40a1e:	d078      	beq.n	40b12 <cbvprintf+0x136>
   40a20:	2200      	movs	r2, #0
   40a22:	4694      	mov	ip, r2
   40a24:	4616      	mov	r6, r2
   40a26:	4696      	mov	lr, r2
   40a28:	4610      	mov	r0, r2
   40a2a:	4639      	mov	r1, r7
		switch (*sp) {
   40a2c:	f817 3b01 	ldrb.w	r3, [r7], #1
   40a30:	2b2b      	cmp	r3, #43	; 0x2b
   40a32:	f000 809d 	beq.w	40b70 <cbvprintf+0x194>
   40a36:	f200 8094 	bhi.w	40b62 <cbvprintf+0x186>
   40a3a:	2b20      	cmp	r3, #32
   40a3c:	f000 809b 	beq.w	40b76 <cbvprintf+0x19a>
   40a40:	2b23      	cmp	r3, #35	; 0x23
   40a42:	f000 809a 	beq.w	40b7a <cbvprintf+0x19e>
   40a46:	b128      	cbz	r0, 40a54 <cbvprintf+0x78>
   40a48:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40a4c:	f040 0004 	orr.w	r0, r0, #4
   40a50:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40a54:	f1be 0f00 	cmp.w	lr, #0
   40a58:	d005      	beq.n	40a66 <cbvprintf+0x8a>
   40a5a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40a5e:	f040 0008 	orr.w	r0, r0, #8
   40a62:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40a66:	b12e      	cbz	r6, 40a74 <cbvprintf+0x98>
   40a68:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40a6c:	f040 0010 	orr.w	r0, r0, #16
   40a70:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40a74:	f1bc 0f00 	cmp.w	ip, #0
   40a78:	d005      	beq.n	40a86 <cbvprintf+0xaa>
   40a7a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40a7e:	f040 0020 	orr.w	r0, r0, #32
   40a82:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40a86:	b12a      	cbz	r2, 40a94 <cbvprintf+0xb8>
   40a88:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40a8c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   40a90:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   40a94:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40a98:	f002 0044 	and.w	r0, r2, #68	; 0x44
   40a9c:	2844      	cmp	r0, #68	; 0x44
   40a9e:	d103      	bne.n	40aa8 <cbvprintf+0xcc>
		conv->flag_zero = false;
   40aa0:	f36f 1286 	bfc	r2, #6, #1
   40aa4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   40aa8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40aac:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   40aae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   40ab2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40ab6:	d17b      	bne.n	40bb0 <cbvprintf+0x1d4>
		conv->width_star = true;
   40ab8:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40abc:	1c4b      	adds	r3, r1, #1
   40abe:	f042 0201 	orr.w	r2, r2, #1
   40ac2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   40ac6:	781a      	ldrb	r2, [r3, #0]
   40ac8:	2a2e      	cmp	r2, #46	; 0x2e
   40aca:	bf0c      	ite	eq
   40acc:	2101      	moveq	r1, #1
   40ace:	2100      	movne	r1, #0
   40ad0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40ad4:	f361 0241 	bfi	r2, r1, #1, #1
   40ad8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   40adc:	d174      	bne.n	40bc8 <cbvprintf+0x1ec>
	if (*sp == '*') {
   40ade:	785a      	ldrb	r2, [r3, #1]
   40ae0:	2a2a      	cmp	r2, #42	; 0x2a
   40ae2:	d06a      	beq.n	40bba <cbvprintf+0x1de>
	size_t val = 0;
   40ae4:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   40ae6:	260a      	movs	r6, #10
   40ae8:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   40aea:	4618      	mov	r0, r3
   40aec:	f810 2b01 	ldrb.w	r2, [r0], #1
   40af0:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40af4:	2f09      	cmp	r7, #9
   40af6:	f240 808e 	bls.w	40c16 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   40afa:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   40afe:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   40b00:	f3c2 0040 	ubfx	r0, r2, #1, #1
   40b04:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   40b08:	f361 0241 	bfi	r2, r1, #1, #1
   40b0c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40b10:	e05a      	b.n	40bc8 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   40b12:	f10a 0702 	add.w	r7, sl, #2
   40b16:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   40b1a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40b1e:	07d9      	lsls	r1, r3, #31
   40b20:	f140 8149 	bpl.w	40db6 <cbvprintf+0x3da>
			width = va_arg(ap, int);
   40b24:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   40b28:	f1b9 0f00 	cmp.w	r9, #0
   40b2c:	da07      	bge.n	40b3e <cbvprintf+0x162>
				conv->flag_dash = true;
   40b2e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   40b32:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   40b36:	f042 0204 	orr.w	r2, r2, #4
   40b3a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   40b3e:	075a      	lsls	r2, r3, #29
   40b40:	f140 8142 	bpl.w	40dc8 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   40b44:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   40b48:	f1b8 0f00 	cmp.w	r8, #0
   40b4c:	f280 8141 	bge.w	40dd2 <cbvprintf+0x3f6>
				conv->prec_present = false;
   40b50:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40b54:	f36f 0341 	bfc	r3, #1, #1
   40b58:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   40b5c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   40b60:	e137      	b.n	40dd2 <cbvprintf+0x3f6>
		switch (*sp) {
   40b62:	2b2d      	cmp	r3, #45	; 0x2d
   40b64:	d00c      	beq.n	40b80 <cbvprintf+0x1a4>
   40b66:	2b30      	cmp	r3, #48	; 0x30
   40b68:	f47f af6d 	bne.w	40a46 <cbvprintf+0x6a>
			conv->flag_zero = true;
   40b6c:	2201      	movs	r2, #1
	} while (loop);
   40b6e:	e75c      	b.n	40a2a <cbvprintf+0x4e>
			conv->flag_plus = true;
   40b70:	f04f 0e01 	mov.w	lr, #1
   40b74:	e759      	b.n	40a2a <cbvprintf+0x4e>
			conv->flag_space = true;
   40b76:	2601      	movs	r6, #1
   40b78:	e757      	b.n	40a2a <cbvprintf+0x4e>
			conv->flag_hash = true;
   40b7a:	f04f 0c01 	mov.w	ip, #1
   40b7e:	e754      	b.n	40a2a <cbvprintf+0x4e>
		switch (*sp) {
   40b80:	2001      	movs	r0, #1
   40b82:	e752      	b.n	40a2a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   40b84:	4633      	mov	r3, r6
   40b86:	fb0c 0202 	mla	r2, ip, r2, r0
   40b8a:	3a30      	subs	r2, #48	; 0x30
   40b8c:	461e      	mov	r6, r3
   40b8e:	f816 0b01 	ldrb.w	r0, [r6], #1
   40b92:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40b96:	2f09      	cmp	r7, #9
   40b98:	d9f4      	bls.n	40b84 <cbvprintf+0x1a8>
	if (sp != wp) {
   40b9a:	4299      	cmp	r1, r3
   40b9c:	d093      	beq.n	40ac6 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   40b9e:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   40ba2:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   40ba4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   40ba6:	f362 0141 	bfi	r1, r2, #1, #1
   40baa:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   40bae:	e78a      	b.n	40ac6 <cbvprintf+0xea>
   40bb0:	460b      	mov	r3, r1
	size_t val = 0;
   40bb2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   40bb4:	f04f 0c0a 	mov.w	ip, #10
   40bb8:	e7e8      	b.n	40b8c <cbvprintf+0x1b0>
		conv->prec_star = true;
   40bba:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   40bbe:	3302      	adds	r3, #2
		conv->prec_star = true;
   40bc0:	f042 0204 	orr.w	r2, r2, #4
   40bc4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   40bc8:	461f      	mov	r7, r3
   40bca:	f817 2b01 	ldrb.w	r2, [r7], #1
   40bce:	2a6c      	cmp	r2, #108	; 0x6c
   40bd0:	d041      	beq.n	40c56 <cbvprintf+0x27a>
   40bd2:	d825      	bhi.n	40c20 <cbvprintf+0x244>
   40bd4:	2a68      	cmp	r2, #104	; 0x68
   40bd6:	d02b      	beq.n	40c30 <cbvprintf+0x254>
   40bd8:	2a6a      	cmp	r2, #106	; 0x6a
   40bda:	d046      	beq.n	40c6a <cbvprintf+0x28e>
   40bdc:	2a4c      	cmp	r2, #76	; 0x4c
   40bde:	d04c      	beq.n	40c7a <cbvprintf+0x29e>
   40be0:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   40be2:	f817 2b01 	ldrb.w	r2, [r7], #1
   40be6:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   40bea:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   40bec:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   40bf0:	f200 80d9 	bhi.w	40da6 <cbvprintf+0x3ca>
   40bf4:	2a57      	cmp	r2, #87	; 0x57
   40bf6:	d84d      	bhi.n	40c94 <cbvprintf+0x2b8>
   40bf8:	2a41      	cmp	r2, #65	; 0x41
   40bfa:	d003      	beq.n	40c04 <cbvprintf+0x228>
   40bfc:	3a45      	subs	r2, #69	; 0x45
   40bfe:	2a02      	cmp	r2, #2
   40c00:	f200 80d1 	bhi.w	40da6 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   40c04:	2204      	movs	r2, #4
   40c06:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40c0a:	f362 0302 	bfi	r3, r2, #0, #3
   40c0e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   40c12:	2301      	movs	r3, #1
			break;
   40c14:	e09e      	b.n	40d54 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   40c16:	fb06 2101 	mla	r1, r6, r1, r2
   40c1a:	4603      	mov	r3, r0
   40c1c:	3930      	subs	r1, #48	; 0x30
   40c1e:	e764      	b.n	40aea <cbvprintf+0x10e>
	switch (*sp) {
   40c20:	2a74      	cmp	r2, #116	; 0x74
   40c22:	d026      	beq.n	40c72 <cbvprintf+0x296>
   40c24:	2a7a      	cmp	r2, #122	; 0x7a
   40c26:	d1db      	bne.n	40be0 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   40c28:	2206      	movs	r2, #6
   40c2a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40c2e:	e00d      	b.n	40c4c <cbvprintf+0x270>
		if (*++sp == 'h') {
   40c30:	785a      	ldrb	r2, [r3, #1]
   40c32:	2a68      	cmp	r2, #104	; 0x68
   40c34:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40c38:	d106      	bne.n	40c48 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   40c3a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   40c3c:	f361 02c6 	bfi	r2, r1, #3, #4
   40c40:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   40c44:	1c9f      	adds	r7, r3, #2
   40c46:	e7cc      	b.n	40be2 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   40c48:	4613      	mov	r3, r2
   40c4a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   40c4c:	f362 03c6 	bfi	r3, r2, #3, #4
   40c50:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   40c54:	e7c5      	b.n	40be2 <cbvprintf+0x206>
		if (*++sp == 'l') {
   40c56:	785a      	ldrb	r2, [r3, #1]
   40c58:	2a6c      	cmp	r2, #108	; 0x6c
   40c5a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40c5e:	d101      	bne.n	40c64 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   40c60:	2104      	movs	r1, #4
   40c62:	e7eb      	b.n	40c3c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   40c64:	4613      	mov	r3, r2
   40c66:	2203      	movs	r2, #3
   40c68:	e7f0      	b.n	40c4c <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   40c6a:	2205      	movs	r2, #5
   40c6c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40c70:	e7ec      	b.n	40c4c <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   40c72:	2207      	movs	r2, #7
   40c74:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40c78:	e7e8      	b.n	40c4c <cbvprintf+0x270>
		conv->unsupported = true;
   40c7a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   40c7e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   40c82:	f023 0302 	bic.w	r3, r3, #2
   40c86:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   40c8a:	f043 0302 	orr.w	r3, r3, #2
   40c8e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   40c92:	e7a6      	b.n	40be2 <cbvprintf+0x206>
   40c94:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   40c98:	2920      	cmp	r1, #32
   40c9a:	f200 8084 	bhi.w	40da6 <cbvprintf+0x3ca>
   40c9e:	a001      	add	r0, pc, #4	; (adr r0, 40ca4 <cbvprintf+0x2c8>)
   40ca0:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   40ca4:	00040d69 	.word	0x00040d69
   40ca8:	00040da7 	.word	0x00040da7
   40cac:	00040da7 	.word	0x00040da7
   40cb0:	00040da7 	.word	0x00040da7
   40cb4:	00040da7 	.word	0x00040da7
   40cb8:	00040da7 	.word	0x00040da7
   40cbc:	00040da7 	.word	0x00040da7
   40cc0:	00040da7 	.word	0x00040da7
   40cc4:	00040da7 	.word	0x00040da7
   40cc8:	00040c05 	.word	0x00040c05
   40ccc:	00040da7 	.word	0x00040da7
   40cd0:	00040d69 	.word	0x00040d69
   40cd4:	00040d29 	.word	0x00040d29
   40cd8:	00040c05 	.word	0x00040c05
   40cdc:	00040c05 	.word	0x00040c05
   40ce0:	00040c05 	.word	0x00040c05
   40ce4:	00040da7 	.word	0x00040da7
   40ce8:	00040d29 	.word	0x00040d29
   40cec:	00040da7 	.word	0x00040da7
   40cf0:	00040da7 	.word	0x00040da7
   40cf4:	00040da7 	.word	0x00040da7
   40cf8:	00040da7 	.word	0x00040da7
   40cfc:	00040d71 	.word	0x00040d71
   40d00:	00040d69 	.word	0x00040d69
   40d04:	00040d8d 	.word	0x00040d8d
   40d08:	00040da7 	.word	0x00040da7
   40d0c:	00040da7 	.word	0x00040da7
   40d10:	00040d8d 	.word	0x00040d8d
   40d14:	00040da7 	.word	0x00040da7
   40d18:	00040d69 	.word	0x00040d69
   40d1c:	00040da7 	.word	0x00040da7
   40d20:	00040da7 	.word	0x00040da7
   40d24:	00040d69 	.word	0x00040d69
		conv->specifier_cat = SPECIFIER_SINT;
   40d28:	2001      	movs	r0, #1
   40d2a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40d2e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   40d32:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40d36:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   40d38:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   40d3c:	bf02      	ittt	eq
   40d3e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   40d42:	f041 0101 	orreq.w	r1, r1, #1
   40d46:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   40d4a:	2a63      	cmp	r2, #99	; 0x63
   40d4c:	d131      	bne.n	40db2 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   40d4e:	3b00      	subs	r3, #0
   40d50:	bf18      	it	ne
   40d52:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   40d54:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40d58:	f3c2 0140 	ubfx	r1, r2, #1, #1
   40d5c:	430b      	orrs	r3, r1
   40d5e:	f363 0241 	bfi	r2, r3, #1, #1
   40d62:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40d66:	e6d8      	b.n	40b1a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   40d68:	2002      	movs	r0, #2
   40d6a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   40d6e:	e7de      	b.n	40d2e <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   40d70:	2103      	movs	r1, #3
   40d72:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40d76:	f003 0378 	and.w	r3, r3, #120	; 0x78
   40d7a:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   40d7e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40d82:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   40d84:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40d88:	4143      	adcs	r3, r0
   40d8a:	e7e3      	b.n	40d54 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   40d8c:	2103      	movs	r1, #3
   40d8e:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40d92:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   40d96:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   40d9a:	bf14      	ite	ne
   40d9c:	2301      	movne	r3, #1
   40d9e:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   40da0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40da4:	e7d6      	b.n	40d54 <cbvprintf+0x378>
		conv->invalid = true;
   40da6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40daa:	f043 0301 	orr.w	r3, r3, #1
   40dae:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   40db2:	2300      	movs	r3, #0
   40db4:	e7ce      	b.n	40d54 <cbvprintf+0x378>
		} else if (conv->width_present) {
   40db6:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   40dba:	2a00      	cmp	r2, #0
		int width = -1;
   40dbc:	bfac      	ite	ge
   40dbe:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
			width = conv->width_value;
   40dc2:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   40dc6:	e6ba      	b.n	40b3e <cbvprintf+0x162>
		} else if (conv->prec_present) {
   40dc8:	079b      	lsls	r3, r3, #30
   40dca:	f57f aec7 	bpl.w	40b5c <cbvprintf+0x180>
			precision = conv->prec_value;
   40dce:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   40dd2:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   40dd4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   40dd8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   40ddc:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   40de0:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   40de4:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   40de6:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   40dea:	d136      	bne.n	40e5a <cbvprintf+0x47e>
			switch (length_mod) {
   40dec:	1ed3      	subs	r3, r2, #3
   40dee:	2b04      	cmp	r3, #4
   40df0:	d820      	bhi.n	40e34 <cbvprintf+0x458>
   40df2:	e8df f003 	tbb	[pc, r3]
   40df6:	0703      	.short	0x0703
   40df8:	1f07      	.short	0x1f07
   40dfa:	1f          	.byte	0x1f
   40dfb:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   40dfc:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   40e00:	17c1      	asrs	r1, r0, #31
   40e02:	e004      	b.n	40e0e <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   40e04:	3407      	adds	r4, #7
   40e06:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   40e0a:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   40e0e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   40e12:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40e16:	f013 0603 	ands.w	r6, r3, #3
   40e1a:	d054      	beq.n	40ec6 <cbvprintf+0x4ea>
			OUTS(sp, fp);
   40e1c:	463b      	mov	r3, r7
   40e1e:	4652      	mov	r2, sl
   40e20:	4659      	mov	r1, fp
   40e22:	9802      	ldr	r0, [sp, #8]
   40e24:	f006 fe31 	bl	47a8a <outs>
   40e28:	2800      	cmp	r0, #0
   40e2a:	f2c0 8143 	blt.w	410b4 <cbvprintf+0x6d8>
   40e2e:	4405      	add	r5, r0
			continue;
   40e30:	46ba      	mov	sl, r7
   40e32:	e5db      	b.n	409ec <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40e34:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   40e38:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40e3a:	ea4f 71e0 	mov.w	r1, r0, asr #31
   40e3e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   40e42:	d105      	bne.n	40e50 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   40e44:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   40e48:	930a      	str	r3, [sp, #40]	; 0x28
   40e4a:	2300      	movs	r3, #0
   40e4c:	930b      	str	r3, [sp, #44]	; 0x2c
   40e4e:	e7e0      	b.n	40e12 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   40e50:	2a02      	cmp	r2, #2
   40e52:	d1de      	bne.n	40e12 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   40e54:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   40e58:	e7d2      	b.n	40e00 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   40e5a:	2b02      	cmp	r3, #2
   40e5c:	d123      	bne.n	40ea6 <cbvprintf+0x4ca>
			switch (length_mod) {
   40e5e:	1ed3      	subs	r3, r2, #3
   40e60:	2b04      	cmp	r3, #4
   40e62:	d813      	bhi.n	40e8c <cbvprintf+0x4b0>
   40e64:	e8df f003 	tbb	[pc, r3]
   40e68:	120a0a03 	.word	0x120a0a03
   40e6c:	12          	.byte	0x12
   40e6d:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   40e6e:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   40e70:	6820      	ldr	r0, [r4, #0]
   40e72:	1d23      	adds	r3, r4, #4
   40e74:	900a      	str	r0, [sp, #40]	; 0x28
   40e76:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   40e78:	461c      	mov	r4, r3
   40e7a:	e7ca      	b.n	40e12 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   40e7c:	3407      	adds	r4, #7
   40e7e:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   40e82:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   40e86:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   40e8a:	e7f5      	b.n	40e78 <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   40e8c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   40e90:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   40e92:	930a      	str	r3, [sp, #40]	; 0x28
   40e94:	f04f 0300 	mov.w	r3, #0
   40e98:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   40e9a:	d0d3      	beq.n	40e44 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   40e9c:	2a02      	cmp	r2, #2
   40e9e:	d1b8      	bne.n	40e12 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   40ea0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   40ea4:	e7d0      	b.n	40e48 <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   40ea6:	2b04      	cmp	r3, #4
   40ea8:	d107      	bne.n	40eba <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   40eaa:	3407      	adds	r4, #7
   40eac:	f024 0407 	bic.w	r4, r4, #7
   40eb0:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   40eb4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   40eb8:	e7ab      	b.n	40e12 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   40eba:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   40ebc:	bf04      	itt	eq
   40ebe:	f854 3b04 	ldreq.w	r3, [r4], #4
   40ec2:	930a      	streq	r3, [sp, #40]	; 0x28
   40ec4:	e7a5      	b.n	40e12 <cbvprintf+0x436>
		switch (conv->specifier) {
   40ec6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   40eca:	2878      	cmp	r0, #120	; 0x78
   40ecc:	d8b0      	bhi.n	40e30 <cbvprintf+0x454>
   40ece:	2862      	cmp	r0, #98	; 0x62
   40ed0:	d822      	bhi.n	40f18 <cbvprintf+0x53c>
   40ed2:	2825      	cmp	r0, #37	; 0x25
   40ed4:	f43f ad93 	beq.w	409fe <cbvprintf+0x22>
   40ed8:	2858      	cmp	r0, #88	; 0x58
   40eda:	d1a9      	bne.n	40e30 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   40edc:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   40ee0:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40ee4:	9300      	str	r3, [sp, #0]
   40ee6:	aa0c      	add	r2, sp, #48	; 0x30
   40ee8:	ab04      	add	r3, sp, #16
   40eea:	f006 fd83 	bl	479f4 <encode_uint>
   40eee:	4682      	mov	sl, r0
			if (precision >= 0) {
   40ef0:	f1b8 0f00 	cmp.w	r8, #0
   40ef4:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   40ef8:	db0c      	blt.n	40f14 <cbvprintf+0x538>
				conv->flag_zero = false;
   40efa:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   40efe:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   40f02:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   40f06:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   40f08:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   40f0c:	d902      	bls.n	40f14 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   40f0e:	eba8 0303 	sub.w	r3, r8, r3
   40f12:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   40f14:	4680      	mov	r8, r0
   40f16:	e03d      	b.n	40f94 <cbvprintf+0x5b8>
   40f18:	3863      	subs	r0, #99	; 0x63
   40f1a:	2815      	cmp	r0, #21
   40f1c:	d888      	bhi.n	40e30 <cbvprintf+0x454>
   40f1e:	a101      	add	r1, pc, #4	; (adr r1, 40f24 <cbvprintf+0x548>)
   40f20:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   40f24:	00040fa5 	.word	0x00040fa5
   40f28:	00041009 	.word	0x00041009
   40f2c:	00040e31 	.word	0x00040e31
   40f30:	00040e31 	.word	0x00040e31
   40f34:	00040e31 	.word	0x00040e31
   40f38:	00040e31 	.word	0x00040e31
   40f3c:	00041009 	.word	0x00041009
   40f40:	00040e31 	.word	0x00040e31
   40f44:	00040e31 	.word	0x00040e31
   40f48:	00040e31 	.word	0x00040e31
   40f4c:	00040e31 	.word	0x00040e31
   40f50:	00041067 	.word	0x00041067
   40f54:	00041035 	.word	0x00041035
   40f58:	00041039 	.word	0x00041039
   40f5c:	00040e31 	.word	0x00040e31
   40f60:	00040e31 	.word	0x00040e31
   40f64:	00040f7d 	.word	0x00040f7d
   40f68:	00040e31 	.word	0x00040e31
   40f6c:	00041035 	.word	0x00041035
   40f70:	00040e31 	.word	0x00040e31
   40f74:	00040e31 	.word	0x00040e31
   40f78:	00041035 	.word	0x00041035
			if (precision >= 0) {
   40f7c:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   40f80:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   40f84:	db0a      	blt.n	40f9c <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   40f86:	4641      	mov	r1, r8
   40f88:	4650      	mov	r0, sl
   40f8a:	f007 f94a 	bl	48222 <strnlen>
		char sign = 0;
   40f8e:	2600      	movs	r6, #0
			bpe = bps + len;
   40f90:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   40f94:	f1ba 0f00 	cmp.w	sl, #0
   40f98:	d10c      	bne.n	40fb4 <cbvprintf+0x5d8>
   40f9a:	e749      	b.n	40e30 <cbvprintf+0x454>
				len = strlen(bps);
   40f9c:	4650      	mov	r0, sl
   40f9e:	f007 f939 	bl	48214 <strlen>
   40fa2:	e7f4      	b.n	40f8e <cbvprintf+0x5b2>
			break;
   40fa4:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40fa6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   40fa8:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   40fac:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   40fb0:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   40fb4:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   40fb8:	b106      	cbz	r6, 40fbc <cbvprintf+0x5e0>
			nj_len += 1U;
   40fba:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   40fbc:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   40fc0:	06d0      	lsls	r0, r2, #27
   40fc2:	d56b      	bpl.n	4109c <cbvprintf+0x6c0>
			nj_len += 2U;
   40fc4:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   40fc6:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   40fc8:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   40fca:	bf48      	it	mi
   40fcc:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   40fce:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   40fd0:	bf48      	it	mi
   40fd2:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   40fd4:	f1b9 0f00 	cmp.w	r9, #0
   40fd8:	dd79      	ble.n	410ce <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   40fda:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   40fde:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   40fe2:	f3c2 0380 	ubfx	r3, r2, #2, #1
   40fe6:	9303      	str	r3, [sp, #12]
   40fe8:	0753      	lsls	r3, r2, #29
   40fea:	d470      	bmi.n	410ce <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   40fec:	0650      	lsls	r0, r2, #25
   40fee:	d564      	bpl.n	410ba <cbvprintf+0x6de>
					if (sign != 0) {
   40ff0:	b146      	cbz	r6, 41004 <cbvprintf+0x628>
						OUTC(sign);
   40ff2:	4659      	mov	r1, fp
   40ff4:	4630      	mov	r0, r6
   40ff6:	9b02      	ldr	r3, [sp, #8]
   40ff8:	4798      	blx	r3
   40ffa:	2800      	cmp	r0, #0
   40ffc:	db5a      	blt.n	410b4 <cbvprintf+0x6d8>
						sign = 0;
   40ffe:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   41000:	3501      	adds	r5, #1
						sign = 0;
   41002:	461e      	mov	r6, r3
					pad = '0';
   41004:	2330      	movs	r3, #48	; 0x30
   41006:	e059      	b.n	410bc <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   41008:	071e      	lsls	r6, r3, #28
   4100a:	d411      	bmi.n	41030 <cbvprintf+0x654>
				sign = ' ';
   4100c:	f013 0610 	ands.w	r6, r3, #16
   41010:	bf18      	it	ne
   41012:	2620      	movne	r6, #32
			sint = value->sint;
   41014:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   41018:	2a00      	cmp	r2, #0
   4101a:	f173 0100 	sbcs.w	r1, r3, #0
   4101e:	f6bf af5d 	bge.w	40edc <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   41022:	4252      	negs	r2, r2
   41024:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   41028:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   4102a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   4102e:	e755      	b.n	40edc <cbvprintf+0x500>
				sign = '+';
   41030:	262b      	movs	r6, #43	; 0x2b
   41032:	e7ef      	b.n	41014 <cbvprintf+0x638>
		switch (conv->specifier) {
   41034:	2600      	movs	r6, #0
   41036:	e751      	b.n	40edc <cbvprintf+0x500>
			if (value->ptr != NULL) {
   41038:	980a      	ldr	r0, [sp, #40]	; 0x28
   4103a:	b348      	cbz	r0, 41090 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   4103c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   41040:	9300      	str	r3, [sp, #0]
   41042:	2100      	movs	r1, #0
   41044:	ab04      	add	r3, sp, #16
   41046:	aa0c      	add	r2, sp, #48	; 0x30
   41048:	f006 fcd4 	bl	479f4 <encode_uint>
				conv->altform_0c = true;
   4104c:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   41050:	4682      	mov	sl, r0
				conv->altform_0c = true;
   41052:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   41056:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   4105a:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   4105e:	2600      	movs	r6, #0
				conv->altform_0c = true;
   41060:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   41064:	e744      	b.n	40ef0 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   41066:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   41068:	2a07      	cmp	r2, #7
   4106a:	f63f aee1 	bhi.w	40e30 <cbvprintf+0x454>
   4106e:	e8df f002 	tbb	[pc, r2]
   41072:	040d      	.short	0x040d
   41074:	08080d06 	.word	0x08080d06
   41078:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   4107a:	701d      	strb	r5, [r3, #0]
		break;
   4107c:	e6d8      	b.n	40e30 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   4107e:	801d      	strh	r5, [r3, #0]
		break;
   41080:	e6d6      	b.n	40e30 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   41082:	4628      	mov	r0, r5
   41084:	17e9      	asrs	r1, r5, #31
   41086:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   4108a:	e6d1      	b.n	40e30 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   4108c:	601d      	str	r5, [r3, #0]
		break;
   4108e:	e6cf      	b.n	40e30 <cbvprintf+0x454>
			bpe = bps + 5;
   41090:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 41158 <cbvprintf+0x77c>
   41094:	4606      	mov	r6, r0
			bps = "(nil)";
   41096:	f1a8 0a05 	sub.w	sl, r8, #5
   4109a:	e78b      	b.n	40fb4 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   4109c:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   4109e:	bf48      	it	mi
   410a0:	3301      	addmi	r3, #1
   410a2:	e790      	b.n	40fc6 <cbvprintf+0x5ea>
					OUTC(pad);
   410a4:	4618      	mov	r0, r3
   410a6:	9303      	str	r3, [sp, #12]
   410a8:	4659      	mov	r1, fp
   410aa:	9b02      	ldr	r3, [sp, #8]
   410ac:	4798      	blx	r3
   410ae:	2800      	cmp	r0, #0
   410b0:	9b03      	ldr	r3, [sp, #12]
   410b2:	da04      	bge.n	410be <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   410b4:	b011      	add	sp, #68	; 0x44
   410b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   410ba:	2320      	movs	r3, #32
   410bc:	444d      	add	r5, r9
   410be:	464a      	mov	r2, r9
				while (width-- > 0) {
   410c0:	2a00      	cmp	r2, #0
   410c2:	eba5 0109 	sub.w	r1, r5, r9
   410c6:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   410ca:	dceb      	bgt.n	410a4 <cbvprintf+0x6c8>
   410cc:	460d      	mov	r5, r1
		if (sign != 0) {
   410ce:	b136      	cbz	r6, 410de <cbvprintf+0x702>
			OUTC(sign);
   410d0:	4659      	mov	r1, fp
   410d2:	4630      	mov	r0, r6
   410d4:	9b02      	ldr	r3, [sp, #8]
   410d6:	4798      	blx	r3
   410d8:	2800      	cmp	r0, #0
   410da:	dbeb      	blt.n	410b4 <cbvprintf+0x6d8>
   410dc:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   410de:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   410e2:	06d9      	lsls	r1, r3, #27
   410e4:	d401      	bmi.n	410ea <cbvprintf+0x70e>
   410e6:	071a      	lsls	r2, r3, #28
   410e8:	d506      	bpl.n	410f8 <cbvprintf+0x71c>
				OUTC('0');
   410ea:	4659      	mov	r1, fp
   410ec:	2030      	movs	r0, #48	; 0x30
   410ee:	9b02      	ldr	r3, [sp, #8]
   410f0:	4798      	blx	r3
   410f2:	2800      	cmp	r0, #0
   410f4:	dbde      	blt.n	410b4 <cbvprintf+0x6d8>
   410f6:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   410f8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   410fc:	06db      	lsls	r3, r3, #27
   410fe:	d507      	bpl.n	41110 <cbvprintf+0x734>
				OUTC(conv->specifier);
   41100:	4659      	mov	r1, fp
   41102:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   41106:	9b02      	ldr	r3, [sp, #8]
   41108:	4798      	blx	r3
   4110a:	2800      	cmp	r0, #0
   4110c:	dbd2      	blt.n	410b4 <cbvprintf+0x6d8>
   4110e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   41110:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   41112:	442e      	add	r6, r5
   41114:	1b73      	subs	r3, r6, r5
   41116:	2b00      	cmp	r3, #0
   41118:	dc16      	bgt.n	41148 <cbvprintf+0x76c>
			OUTS(bps, bpe);
   4111a:	4643      	mov	r3, r8
   4111c:	4652      	mov	r2, sl
   4111e:	4659      	mov	r1, fp
   41120:	9802      	ldr	r0, [sp, #8]
   41122:	f006 fcb2 	bl	47a8a <outs>
   41126:	2800      	cmp	r0, #0
   41128:	dbc4      	blt.n	410b4 <cbvprintf+0x6d8>
   4112a:	4405      	add	r5, r0
		while (width > 0) {
   4112c:	44a9      	add	r9, r5
   4112e:	eba9 0305 	sub.w	r3, r9, r5
   41132:	2b00      	cmp	r3, #0
   41134:	f77f ae7c 	ble.w	40e30 <cbvprintf+0x454>
			OUTC(' ');
   41138:	4659      	mov	r1, fp
   4113a:	2020      	movs	r0, #32
   4113c:	9b02      	ldr	r3, [sp, #8]
   4113e:	4798      	blx	r3
   41140:	2800      	cmp	r0, #0
   41142:	dbb7      	blt.n	410b4 <cbvprintf+0x6d8>
   41144:	3501      	adds	r5, #1
			--width;
   41146:	e7f2      	b.n	4112e <cbvprintf+0x752>
				OUTC('0');
   41148:	4659      	mov	r1, fp
   4114a:	2030      	movs	r0, #48	; 0x30
   4114c:	9b02      	ldr	r3, [sp, #8]
   4114e:	4798      	blx	r3
   41150:	2800      	cmp	r0, #0
   41152:	dbaf      	blt.n	410b4 <cbvprintf+0x6d8>
   41154:	3501      	adds	r5, #1
   41156:	e7dd      	b.n	41114 <cbvprintf+0x738>
   41158:	00049433 	.word	0x00049433

0004115c <nordicsemi_nrf91_init>:
   4115c:	f04f 0220 	mov.w	r2, #32
   41160:	f3ef 8311 	mrs	r3, BASEPRI
   41164:	f382 8812 	msr	BASEPRI_MAX, r2
   41168:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   4116c:	2101      	movs	r1, #1
   4116e:	4a04      	ldr	r2, [pc, #16]	; (41180 <nordicsemi_nrf91_init+0x24>)
   41170:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   41174:	f383 8811 	msr	BASEPRI, r3
   41178:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   4117c:	2000      	movs	r0, #0
   4117e:	4770      	bx	lr
   41180:	40039000 	.word	0x40039000

00041184 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   41184:	b120      	cbz	r0, 41190 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   41186:	4b03      	ldr	r3, [pc, #12]	; (41194 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   41188:	0180      	lsls	r0, r0, #6
   4118a:	f043 0301 	orr.w	r3, r3, #1
   4118e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   41190:	4770      	bx	lr
   41192:	bf00      	nop
   41194:	00048ff0 	.word	0x00048ff0

00041198 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
   41198:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   4119a:	2200      	movs	r2, #0
{
   4119c:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
   4119e:	490f      	ldr	r1, [pc, #60]	; (411dc <enable_logger+0x44>)
   411a0:	480f      	ldr	r0, [pc, #60]	; (411e0 <enable_logger+0x48>)
   411a2:	f007 fd3b 	bl	48c1c <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   411a6:	2200      	movs	r2, #0
   411a8:	2300      	movs	r3, #0
   411aa:	2400      	movs	r4, #0
   411ac:	e9cd 2306 	strd	r2, r3, [sp, #24]
   411b0:	230e      	movs	r3, #14
   411b2:	4d0c      	ldr	r5, [pc, #48]	; (411e4 <enable_logger+0x4c>)
   411b4:	e9cd 3403 	strd	r3, r4, [sp, #12]
   411b8:	f44f 7240 	mov.w	r2, #768	; 0x300
   411bc:	4628      	mov	r0, r5
   411be:	e9cd 4401 	strd	r4, r4, [sp, #4]
   411c2:	4b09      	ldr	r3, [pc, #36]	; (411e8 <enable_logger+0x50>)
   411c4:	4909      	ldr	r1, [pc, #36]	; (411ec <enable_logger+0x54>)
   411c6:	9400      	str	r4, [sp, #0]
   411c8:	f005 f8fa 	bl	463c0 <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
   411cc:	4908      	ldr	r1, [pc, #32]	; (411f0 <enable_logger+0x58>)
   411ce:	4628      	mov	r0, r5
   411d0:	f007 fba0 	bl	48914 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   411d4:	4620      	mov	r0, r4
   411d6:	b009      	add	sp, #36	; 0x24
   411d8:	bd30      	pop	{r4, r5, pc}
   411da:	bf00      	nop
   411dc:	000411f5 	.word	0x000411f5
   411e0:	2001a658 	.word	0x2001a658
   411e4:	2001a690 	.word	0x2001a690
   411e8:	000415d5 	.word	0x000415d5
   411ec:	20020bb0 	.word	0x20020bb0
   411f0:	00049438 	.word	0x00049438

000411f4 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   411f4:	4801      	ldr	r0, [pc, #4]	; (411fc <log_process_thread_timer_expiry_fn+0x8>)
   411f6:	f005 ba31 	b.w	4665c <z_impl_k_sem_give>
   411fa:	bf00      	nop
   411fc:	2001a644 	.word	0x2001a644

00041200 <log_core_init>:
	panic_mode = false;
   41200:	2300      	movs	r3, #0
   41202:	4a0c      	ldr	r2, [pc, #48]	; (41234 <log_core_init+0x34>)
{
   41204:	b510      	push	{r4, lr}
	panic_mode = false;
   41206:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
   41208:	4a0b      	ldr	r2, [pc, #44]	; (41238 <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
   4120a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	dropped_cnt = 0;
   4120e:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
   41210:	4b0a      	ldr	r3, [pc, #40]	; (4123c <log_core_init+0x3c>)
   41212:	4a0b      	ldr	r2, [pc, #44]	; (41240 <log_core_init+0x40>)
   41214:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   41216:	f000 fcb5 	bl	41b84 <log_output_timestamp_freq_set>
		log_msg_pool_init();
   4121a:	f000 fa55 	bl	416c8 <log_msg_pool_init>
		log_list_init(&list);
   4121e:	4809      	ldr	r0, [pc, #36]	; (41244 <log_core_init+0x44>)
   41220:	f006 fc68 	bl	47af4 <log_list_init>
}
   41224:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   41228:	2304      	movs	r3, #4
   4122a:	2228      	movs	r2, #40	; 0x28
   4122c:	4906      	ldr	r1, [pc, #24]	; (41248 <log_core_init+0x48>)
   4122e:	4807      	ldr	r0, [pc, #28]	; (4124c <log_core_init+0x4c>)
   41230:	f007 bb26 	b.w	48880 <k_mem_slab_init>
   41234:	2001ae54 	.word	0x2001ae54
   41238:	2001a85c 	.word	0x2001a85c
   4123c:	2001a504 	.word	0x2001a504
   41240:	00047b33 	.word	0x00047b33
   41244:	2001a864 	.word	0x2001a864
   41248:	20023bf0 	.word	0x20023bf0
   4124c:	2001a86c 	.word	0x2001a86c

00041250 <log_init>:
{
   41250:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   41252:	4b10      	ldr	r3, [pc, #64]	; (41294 <log_init+0x44>)
   41254:	e8d3 5fef 	ldaex	r5, [r3]
   41258:	1c6a      	adds	r2, r5, #1
   4125a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4125e:	2900      	cmp	r1, #0
   41260:	d1f8      	bne.n	41254 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
   41262:	b92d      	cbnz	r5, 41270 <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   41264:	4c0c      	ldr	r4, [pc, #48]	; (41298 <log_init+0x48>)
   41266:	4e0d      	ldr	r6, [pc, #52]	; (4129c <log_init+0x4c>)
   41268:	1b36      	subs	r6, r6, r4
   4126a:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   4126c:	42b5      	cmp	r5, r6
   4126e:	db00      	blt.n	41272 <log_init+0x22>
}
   41270:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   41272:	7b23      	ldrb	r3, [r4, #12]
   41274:	b153      	cbz	r3, 4128c <log_init+0x3c>
			if (backend->api->init != NULL) {
   41276:	6823      	ldr	r3, [r4, #0]
   41278:	699b      	ldr	r3, [r3, #24]
   4127a:	b10b      	cbz	r3, 41280 <log_init+0x30>
				backend->api->init(backend);
   4127c:	4620      	mov	r0, r4
   4127e:	4798      	blx	r3
			log_backend_enable(backend,
   41280:	6863      	ldr	r3, [r4, #4]
   41282:	2204      	movs	r2, #4
   41284:	4620      	mov	r0, r4
   41286:	6819      	ldr	r1, [r3, #0]
   41288:	f000 fa10 	bl	416ac <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   4128c:	3501      	adds	r5, #1
   4128e:	3410      	adds	r4, #16
   41290:	e7ec      	b.n	4126c <log_init+0x1c>
   41292:	bf00      	nop
   41294:	2001a860 	.word	0x2001a860
   41298:	00048fb0 	.word	0x00048fb0
   4129c:	00048fd0 	.word	0x00048fd0

000412a0 <get_msg>:
{
   412a0:	b510      	push	{r4, lr}
	__asm__ volatile(
   412a2:	f04f 0320 	mov.w	r3, #32
   412a6:	f3ef 8411 	mrs	r4, BASEPRI
   412aa:	f383 8812 	msr	BASEPRI_MAX, r3
   412ae:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
   412b2:	4804      	ldr	r0, [pc, #16]	; (412c4 <get_msg+0x24>)
   412b4:	f006 fc2e 	bl	47b14 <log_list_head_get>
	__asm__ volatile(
   412b8:	f384 8811 	msr	BASEPRI, r4
   412bc:	f3bf 8f6f 	isb	sy
}
   412c0:	bd10      	pop	{r4, pc}
   412c2:	bf00      	nop
   412c4:	2001a864 	.word	0x2001a864

000412c8 <z_log_notify_backend_enabled>:
{
   412c8:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
   412ca:	4c04      	ldr	r4, [pc, #16]	; (412dc <z_log_notify_backend_enabled+0x14>)
   412cc:	7822      	ldrb	r2, [r4, #0]
   412ce:	b912      	cbnz	r2, 412d6 <z_log_notify_backend_enabled+0xe>
   412d0:	4803      	ldr	r0, [pc, #12]	; (412e0 <z_log_notify_backend_enabled+0x18>)
   412d2:	f005 f9c3 	bl	4665c <z_impl_k_sem_give>
	backend_attached = true;
   412d6:	2301      	movs	r3, #1
   412d8:	7023      	strb	r3, [r4, #0]
}
   412da:	bd10      	pop	{r4, pc}
   412dc:	2001ae53 	.word	0x2001ae53
   412e0:	2001a644 	.word	0x2001a644

000412e4 <z_log_dropped>:
   412e4:	4b08      	ldr	r3, [pc, #32]	; (41308 <z_log_dropped+0x24>)
   412e6:	e8d3 2fef 	ldaex	r2, [r3]
   412ea:	3201      	adds	r2, #1
   412ec:	e8c3 2fe1 	stlex	r1, r2, [r3]
   412f0:	2900      	cmp	r1, #0
   412f2:	d1f8      	bne.n	412e6 <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   412f4:	4b05      	ldr	r3, [pc, #20]	; (4130c <z_log_dropped+0x28>)
   412f6:	e8d3 2fef 	ldaex	r2, [r3]
   412fa:	3a01      	subs	r2, #1
   412fc:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41300:	2900      	cmp	r1, #0
   41302:	d1f8      	bne.n	412f6 <z_log_dropped+0x12>
}
   41304:	4770      	bx	lr
   41306:	bf00      	nop
   41308:	2001a85c 	.word	0x2001a85c
   4130c:	2001a858 	.word	0x2001a858

00041310 <z_log_dropped_read_and_clear>:
}
   41310:	2000      	movs	r0, #0
   41312:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   41314:	4b03      	ldr	r3, [pc, #12]	; (41324 <z_log_dropped_read_and_clear+0x14>)
   41316:	e8d3 0fef 	ldaex	r0, [r3]
   4131a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4131e:	2900      	cmp	r1, #0
   41320:	d1f9      	bne.n	41316 <z_log_dropped_read_and_clear+0x6>
   41322:	4770      	bx	lr
   41324:	2001a85c 	.word	0x2001a85c

00041328 <dropped_notify>:
{
   41328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
   4132a:	f7ff fff1 	bl	41310 <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
   4132e:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
   41330:	4607      	mov	r7, r0
   41332:	4c09      	ldr	r4, [pc, #36]	; (41358 <dropped_notify+0x30>)
   41334:	4d09      	ldr	r5, [pc, #36]	; (4135c <dropped_notify+0x34>)
   41336:	1b2d      	subs	r5, r5, r4
   41338:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   4133a:	42ae      	cmp	r6, r5
   4133c:	db00      	blt.n	41340 <dropped_notify+0x18>
}
   4133e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   41340:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41342:	795b      	ldrb	r3, [r3, #5]
   41344:	b12b      	cbz	r3, 41352 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
   41346:	6823      	ldr	r3, [r4, #0]
   41348:	691b      	ldr	r3, [r3, #16]
   4134a:	b113      	cbz	r3, 41352 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
   4134c:	4639      	mov	r1, r7
   4134e:	4620      	mov	r0, r4
   41350:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41352:	3601      	adds	r6, #1
   41354:	3410      	adds	r4, #16
   41356:	e7f0      	b.n	4133a <dropped_notify+0x12>
   41358:	00048fb0 	.word	0x00048fb0
   4135c:	00048fd0 	.word	0x00048fd0

00041360 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   41360:	4b14      	ldr	r3, [pc, #80]	; (413b4 <z_log_strdup+0x54>)
{
   41362:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
   41364:	4298      	cmp	r0, r3
{
   41366:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41368:	d302      	bcc.n	41370 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   4136a:	4b13      	ldr	r3, [pc, #76]	; (413b8 <z_log_strdup+0x58>)
   4136c:	4298      	cmp	r0, r3
   4136e:	d31c      	bcc.n	413aa <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   41370:	2200      	movs	r2, #0
   41372:	2300      	movs	r3, #0
   41374:	4811      	ldr	r0, [pc, #68]	; (413bc <z_log_strdup+0x5c>)
   41376:	a901      	add	r1, sp, #4
   41378:	f004 ffc2 	bl	46300 <k_mem_slab_alloc>
	if (err != 0) {
   4137c:	4605      	mov	r5, r0
   4137e:	b9b8      	cbnz	r0, 413b0 <z_log_strdup+0x50>
   41380:	2201      	movs	r2, #1
   41382:	9b01      	ldr	r3, [sp, #4]
   41384:	e8d3 1fef 	ldaex	r1, [r3]
   41388:	e8c3 2fe0 	stlex	r0, r2, [r3]
   4138c:	2800      	cmp	r0, #0
   4138e:	d1f9      	bne.n	41384 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   41390:	9801      	ldr	r0, [sp, #4]
   41392:	4621      	mov	r1, r4
   41394:	221f      	movs	r2, #31
   41396:	3004      	adds	r0, #4
   41398:	f006 ff29 	bl	481ee <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   4139c:	237e      	movs	r3, #126	; 0x7e
   4139e:	9c01      	ldr	r4, [sp, #4]
   413a0:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   413a4:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   413a8:	3404      	adds	r4, #4
}
   413aa:	4620      	mov	r0, r4
   413ac:	b003      	add	sp, #12
   413ae:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   413b0:	4c03      	ldr	r4, [pc, #12]	; (413c0 <z_log_strdup+0x60>)
   413b2:	e7fa      	b.n	413aa <z_log_strdup+0x4a>
   413b4:	00048c80 	.word	0x00048c80
   413b8:	00049c2c 	.word	0x00049c2c
   413bc:	2001a86c 	.word	0x2001a86c
   413c0:	00049440 	.word	0x00049440

000413c4 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
   413c4:	b148      	cbz	r0, 413da <log_is_strdup+0x16>
   413c6:	4b05      	ldr	r3, [pc, #20]	; (413dc <log_is_strdup+0x18>)
   413c8:	4298      	cmp	r0, r3
   413ca:	d305      	bcc.n	413d8 <log_is_strdup+0x14>
   413cc:	33a0      	adds	r3, #160	; 0xa0
   413ce:	4298      	cmp	r0, r3
   413d0:	bf2c      	ite	cs
   413d2:	2000      	movcs	r0, #0
   413d4:	2001      	movcc	r0, #1
   413d6:	4770      	bx	lr
   413d8:	2000      	movs	r0, #0
}
   413da:	4770      	bx	lr
   413dc:	20023bf0 	.word	0x20023bf0

000413e0 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
   413e0:	4b41      	ldr	r3, [pc, #260]	; (414e8 <z_impl_log_process+0x108>)
{
   413e2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   413e6:	781b      	ldrb	r3, [r3, #0]
{
   413e8:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   413ea:	b903      	cbnz	r3, 413ee <z_impl_log_process+0xe>
   413ec:	b1a0      	cbz	r0, 41418 <z_impl_log_process+0x38>
	msg = get_msg();
   413ee:	f7ff ff57 	bl	412a0 <get_msg>
	if (msg.msg) {
   413f2:	4605      	mov	r5, r0
   413f4:	b118      	cbz	r0, 413fe <z_impl_log_process+0x1e>
		if (!bypass) {
   413f6:	b19c      	cbz	r4, 41420 <z_impl_log_process+0x40>
			log_msg_put(msg.msg);
   413f8:	4628      	mov	r0, r5
   413fa:	f006 fca2 	bl	47d42 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
   413fe:	b92c      	cbnz	r4, 4140c <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
   41400:	4b3a      	ldr	r3, [pc, #232]	; (414ec <z_impl_log_process+0x10c>)
	if (!bypass && z_log_dropped_pending()) {
   41402:	681b      	ldr	r3, [r3, #0]
   41404:	2b00      	cmp	r3, #0
   41406:	dd01      	ble.n	4140c <z_impl_log_process+0x2c>
		dropped_notify();
   41408:	f7ff ff8e 	bl	41328 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   4140c:	4838      	ldr	r0, [pc, #224]	; (414f0 <z_impl_log_process+0x110>)
   4140e:	f006 fb7f 	bl	47b10 <log_list_head_peek>
   41412:	1e04      	subs	r4, r0, #0
   41414:	bf18      	it	ne
   41416:	2401      	movne	r4, #1
}
   41418:	4620      	mov	r0, r4
   4141a:	b003      	add	sp, #12
   4141c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41420:	4b34      	ldr	r3, [pc, #208]	; (414f4 <z_impl_log_process+0x114>)
   41422:	e8d3 2fef 	ldaex	r2, [r3]
   41426:	3a01      	subs	r2, #1
   41428:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4142c:	2900      	cmp	r1, #0
   4142e:	d1f8      	bne.n	41422 <z_impl_log_process+0x42>
		    !panic_mode) {
   41430:	4b31      	ldr	r3, [pc, #196]	; (414f8 <z_impl_log_process+0x118>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
   41432:	781b      	ldrb	r3, [r3, #0]
   41434:	b9bb      	cbnz	r3, 41466 <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41436:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   41438:	07db      	lsls	r3, r3, #31
   4143a:	d414      	bmi.n	41466 <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
   4143c:	f006 fc90 	bl	47d60 <log_msg_str_get>
   41440:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
   41442:	4628      	mov	r0, r5
   41444:	f006 fc5b 	bl	47cfe <log_msg_nargs_get>
   41448:	4601      	mov	r1, r0
   4144a:	4640      	mov	r0, r8
   4144c:	f006 fb75 	bl	47b3a <z_log_get_s_mask>
   41450:	4606      	mov	r6, r0
   41452:	4b2a      	ldr	r3, [pc, #168]	; (414fc <z_impl_log_process+0x11c>)
   41454:	4a2a      	ldr	r2, [pc, #168]	; (41500 <z_impl_log_process+0x120>)
		if (!is_rodata(str) && !log_is_strdup(str) &&
   41456:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 41514 <z_impl_log_process+0x134>
   4145a:	1a9b      	subs	r3, r3, r2
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   4145c:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 41518 <z_impl_log_process+0x138>
   41460:	ea4f 09d3 	mov.w	r9, r3, lsr #3
	while (mask) {
   41464:	b936      	cbnz	r6, 41474 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
   41466:	4e27      	ldr	r6, [pc, #156]	; (41504 <z_impl_log_process+0x124>)
   41468:	4f27      	ldr	r7, [pc, #156]	; (41508 <z_impl_log_process+0x128>)
   4146a:	f04f 0800 	mov.w	r8, #0
   4146e:	1bbf      	subs	r7, r7, r6
   41470:	113f      	asrs	r7, r7, #4
   41472:	e036      	b.n	414e2 <z_impl_log_process+0x102>
		idx = 31 - __builtin_clz(mask);
   41474:	fab6 f786 	clz	r7, r6
   41478:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   4147c:	4639      	mov	r1, r7
   4147e:	4628      	mov	r0, r5
   41480:	f006 fc40 	bl	47d04 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   41484:	4b21      	ldr	r3, [pc, #132]	; (4150c <z_impl_log_process+0x12c>)
		str = (const char *)log_msg_arg_get(msg, idx);
   41486:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41488:	4298      	cmp	r0, r3
   4148a:	d302      	bcc.n	41492 <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   4148c:	4b20      	ldr	r3, [pc, #128]	; (41510 <z_impl_log_process+0x130>)
   4148e:	4298      	cmp	r0, r3
   41490:	d316      	bcc.n	414c0 <z_impl_log_process+0xe0>
   41492:	4610      	mov	r0, r2
   41494:	f7ff ff96 	bl	413c4 <log_is_strdup>
   41498:	b990      	cbnz	r0, 414c0 <z_impl_log_process+0xe0>
   4149a:	4552      	cmp	r2, sl
   4149c:	d010      	beq.n	414c0 <z_impl_log_process+0xe0>
	return msg->hdr.ids.source_id;
   4149e:	8969      	ldrh	r1, [r5, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   414a0:	f3c1 1189 	ubfx	r1, r1, #6, #10
   414a4:	f000 f8f4 	bl	41690 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   414a8:	ea4f 1389 	mov.w	r3, r9, lsl #6
   414ac:	f043 0301 	orr.w	r3, r3, #1
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   414b0:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   414b2:	f8ad 3000 	strh.w	r3, [sp]
   414b6:	4639      	mov	r1, r7
   414b8:	4643      	mov	r3, r8
   414ba:	4658      	mov	r0, fp
   414bc:	f006 fb97 	bl	47bee <log_3>
		mask &= ~BIT(idx);
   414c0:	2301      	movs	r3, #1
   414c2:	fa03 f707 	lsl.w	r7, r3, r7
   414c6:	ea26 0607 	bic.w	r6, r6, r7
   414ca:	e7cb      	b.n	41464 <z_impl_log_process+0x84>
	return backend->cb->active;
   414cc:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
   414ce:	795b      	ldrb	r3, [r3, #5]
   414d0:	b123      	cbz	r3, 414dc <z_impl_log_process+0xfc>
	backend->api->put(backend, msg);
   414d2:	6833      	ldr	r3, [r6, #0]
   414d4:	4629      	mov	r1, r5
   414d6:	4630      	mov	r0, r6
   414d8:	685b      	ldr	r3, [r3, #4]
   414da:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   414dc:	f108 0801 	add.w	r8, r8, #1
   414e0:	3610      	adds	r6, #16
   414e2:	45b8      	cmp	r8, r7
   414e4:	dbf2      	blt.n	414cc <z_impl_log_process+0xec>
   414e6:	e787      	b.n	413f8 <z_impl_log_process+0x18>
   414e8:	2001ae53 	.word	0x2001ae53
   414ec:	2001a85c 	.word	0x2001a85c
   414f0:	2001a864 	.word	0x2001a864
   414f4:	2001a858 	.word	0x2001a858
   414f8:	2001ae54 	.word	0x2001ae54
   414fc:	00048f70 	.word	0x00048f70
   41500:	00048f58 	.word	0x00048f58
   41504:	00048fb0 	.word	0x00048fb0
   41508:	00048fd0 	.word	0x00048fd0
   4150c:	00048c80 	.word	0x00048c80
   41510:	00049c2c 	.word	0x00049c2c
   41514:	00049440 	.word	0x00049440
   41518:	0004945a 	.word	0x0004945a

0004151c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   4151c:	4b26      	ldr	r3, [pc, #152]	; (415b8 <msg_finalize+0x9c>)
{
   4151e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
   41520:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   41522:	8141      	strh	r1, [r0, #10]
{
   41524:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
   41526:	4798      	blx	r3
   41528:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4152a:	f04f 0320 	mov.w	r3, #32
   4152e:	f3ef 8511 	mrs	r5, BASEPRI
   41532:	f383 8812 	msr	BASEPRI_MAX, r3
   41536:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   4153a:	4820      	ldr	r0, [pc, #128]	; (415bc <msg_finalize+0xa0>)
   4153c:	4621      	mov	r1, r4
   4153e:	f006 fadd 	bl	47afc <log_list_add_tail>
	__asm__ volatile(
   41542:	f385 8811 	msr	BASEPRI, r5
   41546:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4154a:	4b1d      	ldr	r3, [pc, #116]	; (415c0 <msg_finalize+0xa4>)
   4154c:	e8d3 2fef 	ldaex	r2, [r3]
   41550:	1c51      	adds	r1, r2, #1
   41552:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41556:	2800      	cmp	r0, #0
   41558:	d1f8      	bne.n	4154c <msg_finalize+0x30>
	if (panic_mode) {
   4155a:	4b1a      	ldr	r3, [pc, #104]	; (415c4 <msg_finalize+0xa8>)
   4155c:	781b      	ldrb	r3, [r3, #0]
   4155e:	b183      	cbz	r3, 41582 <msg_finalize+0x66>
	__asm__ volatile(
   41560:	f04f 0320 	mov.w	r3, #32
   41564:	f3ef 8411 	mrs	r4, BASEPRI
   41568:	f383 8812 	msr	BASEPRI_MAX, r3
   4156c:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   41570:	2000      	movs	r0, #0
   41572:	f7ff ff35 	bl	413e0 <z_impl_log_process>
	__asm__ volatile(
   41576:	f384 8811 	msr	BASEPRI, r4
   4157a:	f3bf 8f6f 	isb	sy
}
   4157e:	b003      	add	sp, #12
   41580:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && cnt == 0) {
   41582:	4b11      	ldr	r3, [pc, #68]	; (415c8 <msg_finalize+0xac>)
   41584:	681b      	ldr	r3, [r3, #0]
   41586:	2b00      	cmp	r3, #0
   41588:	d0f9      	beq.n	4157e <msg_finalize+0x62>
   4158a:	b952      	cbnz	r2, 415a2 <msg_finalize+0x86>
	z_impl_k_timer_start(timer, duration, period);
   4158c:	2200      	movs	r2, #0
   4158e:	2300      	movs	r3, #0
   41590:	480e      	ldr	r0, [pc, #56]	; (415cc <msg_finalize+0xb0>)
   41592:	e9cd 2300 	strd	r2, r3, [sp]
   41596:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   4159a:	2300      	movs	r3, #0
   4159c:	f005 fdaa 	bl	470f4 <z_impl_k_timer_start>
   415a0:	e7ed      	b.n	4157e <msg_finalize+0x62>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   415a2:	2a0a      	cmp	r2, #10
   415a4:	d1eb      	bne.n	4157e <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
   415a6:	4809      	ldr	r0, [pc, #36]	; (415cc <msg_finalize+0xb0>)
   415a8:	f007 fb44 	bl	48c34 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   415ac:	4808      	ldr	r0, [pc, #32]	; (415d0 <msg_finalize+0xb4>)
}
   415ae:	b003      	add	sp, #12
   415b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   415b4:	f005 b852 	b.w	4665c <z_impl_k_sem_give>
   415b8:	2001a504 	.word	0x2001a504
   415bc:	2001a864 	.word	0x2001a864
   415c0:	2001a858 	.word	0x2001a858
   415c4:	2001ae54 	.word	0x2001ae54
   415c8:	2001a888 	.word	0x2001a888
   415cc:	2001a658 	.word	0x2001a658
   415d0:	2001a644 	.word	0x2001a644

000415d4 <log_process_thread_func>:
{
   415d4:	b510      	push	{r4, lr}
	log_init();
   415d6:	f7ff fe3b 	bl	41250 <log_init>
	return z_impl_z_current_get();
   415da:	f005 fb79 	bl	46cd0 <z_impl_z_current_get>
	proc_tid = process_tid;
   415de:	4b0c      	ldr	r3, [pc, #48]	; (41610 <log_process_thread_func+0x3c>)
   415e0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   415e2:	b130      	cbz	r0, 415f2 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   415e4:	4b0b      	ldr	r3, [pc, #44]	; (41614 <log_process_thread_func+0x40>)
	    process_tid &&
   415e6:	681b      	ldr	r3, [r3, #0]
   415e8:	2b09      	cmp	r3, #9
   415ea:	dd02      	ble.n	415f2 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   415ec:	480a      	ldr	r0, [pc, #40]	; (41618 <log_process_thread_func+0x44>)
   415ee:	f005 f835 	bl	4665c <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   415f2:	4c09      	ldr	r4, [pc, #36]	; (41618 <log_process_thread_func+0x44>)
   415f4:	2000      	movs	r0, #0
   415f6:	f7ff fef3 	bl	413e0 <z_impl_log_process>
		if (log_process(false) == false) {
   415fa:	2800      	cmp	r0, #0
   415fc:	d1fa      	bne.n	415f4 <log_process_thread_func+0x20>
   415fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   41602:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41606:	4620      	mov	r0, r4
   41608:	f005 f848 	bl	4669c <z_impl_k_sem_take>
   4160c:	e7f2      	b.n	415f4 <log_process_thread_func+0x20>
   4160e:	bf00      	nop
   41610:	2001a888 	.word	0x2001a888
   41614:	2001a858 	.word	0x2001a858
   41618:	2001a644 	.word	0x2001a644

0004161c <z_impl_log_panic>:
{
   4161c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   4161e:	4f0e      	ldr	r7, [pc, #56]	; (41658 <z_impl_log_panic+0x3c>)
   41620:	783d      	ldrb	r5, [r7, #0]
   41622:	b975      	cbnz	r5, 41642 <z_impl_log_panic+0x26>
	log_init();
   41624:	f7ff fe14 	bl	41250 <log_init>
	return __log_backends_end - __log_backends_start;
   41628:	4c0c      	ldr	r4, [pc, #48]	; (4165c <z_impl_log_panic+0x40>)
   4162a:	4e0d      	ldr	r6, [pc, #52]	; (41660 <z_impl_log_panic+0x44>)
   4162c:	1b36      	subs	r6, r6, r4
   4162e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   41630:	42b5      	cmp	r5, r6
   41632:	db07      	blt.n	41644 <z_impl_log_panic+0x28>
   41634:	2000      	movs	r0, #0
   41636:	f7ff fed3 	bl	413e0 <z_impl_log_process>
		while (log_process(false) == true) {
   4163a:	2800      	cmp	r0, #0
   4163c:	d1fa      	bne.n	41634 <z_impl_log_panic+0x18>
	panic_mode = true;
   4163e:	2301      	movs	r3, #1
   41640:	703b      	strb	r3, [r7, #0]
}
   41642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   41644:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41646:	795b      	ldrb	r3, [r3, #5]
   41648:	b11b      	cbz	r3, 41652 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   4164a:	6823      	ldr	r3, [r4, #0]
   4164c:	4620      	mov	r0, r4
   4164e:	695b      	ldr	r3, [r3, #20]
   41650:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41652:	3501      	adds	r5, #1
   41654:	3410      	adds	r4, #16
   41656:	e7eb      	b.n	41630 <z_impl_log_panic+0x14>
   41658:	2001ae54 	.word	0x2001ae54
   4165c:	00048fb0 	.word	0x00048fb0
   41660:	00048fd0 	.word	0x00048fd0

00041664 <z_log_free>:
{
   41664:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   41666:	3804      	subs	r0, #4
   41668:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4166a:	e8d0 3fef 	ldaex	r3, [r0]
   4166e:	1e5a      	subs	r2, r3, #1
   41670:	e8c0 2fe1 	stlex	r1, r2, [r0]
   41674:	2900      	cmp	r1, #0
   41676:	d1f8      	bne.n	4166a <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
   41678:	2b01      	cmp	r3, #1
   4167a:	d103      	bne.n	41684 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   4167c:	4803      	ldr	r0, [pc, #12]	; (4168c <z_log_free+0x28>)
   4167e:	a901      	add	r1, sp, #4
   41680:	f007 f919 	bl	488b6 <k_mem_slab_free>
}
   41684:	b003      	add	sp, #12
   41686:	f85d fb04 	ldr.w	pc, [sp], #4
   4168a:	bf00      	nop
   4168c:	2001a86c 	.word	0x2001a86c

00041690 <log_source_name_get>:
   41690:	4a04      	ldr	r2, [pc, #16]	; (416a4 <log_source_name_get+0x14>)
   41692:	4b05      	ldr	r3, [pc, #20]	; (416a8 <log_source_name_get+0x18>)
   41694:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   41696:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   4169a:	bf34      	ite	cc
   4169c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   416a0:	2000      	movcs	r0, #0
}
   416a2:	4770      	bx	lr
   416a4:	00048f58 	.word	0x00048f58
   416a8:	00048fb0 	.word	0x00048fb0

000416ac <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   416ac:	4b05      	ldr	r3, [pc, #20]	; (416c4 <log_backend_enable+0x18>)

	log_backend_id_set(backend, id);
   416ae:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
   416b0:	1ac3      	subs	r3, r0, r3
   416b2:	111b      	asrs	r3, r3, #4
   416b4:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   416b6:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
   416b8:	2201      	movs	r2, #1
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);
   416ba:	6843      	ldr	r3, [r0, #4]
	backend->cb->ctx = ctx;
   416bc:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
   416be:	715a      	strb	r2, [r3, #5]

	z_log_notify_backend_enabled();
   416c0:	f7ff be02 	b.w	412c8 <z_log_notify_backend_enabled>
   416c4:	00048fb0 	.word	0x00048fb0

000416c8 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   416c8:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   416cc:	2220      	movs	r2, #32
   416ce:	4902      	ldr	r1, [pc, #8]	; (416d8 <log_msg_pool_init+0x10>)
   416d0:	4802      	ldr	r0, [pc, #8]	; (416dc <log_msg_pool_init+0x14>)
   416d2:	f007 b8d5 	b.w	48880 <k_mem_slab_init>
   416d6:	bf00      	nop
   416d8:	20023c90 	.word	0x20023c90
   416dc:	2001a88c 	.word	0x2001a88c

000416e0 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
   416e0:	2300      	movs	r3, #0
{
   416e2:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   416e4:	4d09      	ldr	r5, [pc, #36]	; (4170c <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   416e6:	9301      	str	r3, [sp, #4]
   416e8:	2001      	movs	r0, #1
   416ea:	f7ff fe79 	bl	413e0 <z_impl_log_process>
   416ee:	4604      	mov	r4, r0
			z_log_dropped();
   416f0:	f7ff fdf8 	bl	412e4 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   416f4:	2200      	movs	r2, #0
   416f6:	2300      	movs	r3, #0
   416f8:	4628      	mov	r0, r5
   416fa:	a901      	add	r1, sp, #4
   416fc:	f004 fe00 	bl	46300 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   41700:	b108      	cbz	r0, 41706 <log_msg_no_space_handle+0x26>
   41702:	2c00      	cmp	r4, #0
   41704:	d1f0      	bne.n	416e8 <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
   41706:	9801      	ldr	r0, [sp, #4]
   41708:	b003      	add	sp, #12
   4170a:	bd30      	pop	{r4, r5, pc}
   4170c:	2001a88c 	.word	0x2001a88c

00041710 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
   41710:	2300      	movs	r3, #0
{
   41712:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41714:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
   41716:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41718:	4806      	ldr	r0, [pc, #24]	; (41734 <log_msg_chunk_alloc+0x24>)
   4171a:	2300      	movs	r3, #0
   4171c:	a901      	add	r1, sp, #4
   4171e:	f004 fdef 	bl	46300 <k_mem_slab_alloc>
	if (err != 0) {
   41722:	b110      	cbz	r0, 4172a <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
   41724:	f7ff ffdc 	bl	416e0 <log_msg_no_space_handle>
   41728:	9001      	str	r0, [sp, #4]
}
   4172a:	9801      	ldr	r0, [sp, #4]
   4172c:	b003      	add	sp, #12
   4172e:	f85d fb04 	ldr.w	pc, [sp], #4
   41732:	bf00      	nop
   41734:	2001a88c 	.word	0x2001a88c

00041738 <msg_free>:
{
   41738:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4173a:	7a03      	ldrb	r3, [r0, #8]
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
   4173c:	7a45      	ldrb	r5, [r0, #9]
{
   4173e:	b085      	sub	sp, #20
   41740:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   41742:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
   41744:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   41748:	d41c      	bmi.n	41784 <msg_free+0x4c>
   4174a:	b1dd      	cbz	r5, 41784 <msg_free+0x4c>
		uint32_t smask = 0U;
   4174c:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
   4174e:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
   41750:	4631      	mov	r1, r6
   41752:	9801      	ldr	r0, [sp, #4]
   41754:	f006 fad6 	bl	47d04 <log_msg_arg_get>
   41758:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
   4175a:	f7ff fe33 	bl	413c4 <log_is_strdup>
   4175e:	b170      	cbz	r0, 4177e <msg_free+0x46>
				if (smask == 0U) {
   41760:	b934      	cbnz	r4, 41770 <msg_free+0x38>
					smask = z_log_get_s_mask(
   41762:	9b01      	ldr	r3, [sp, #4]
   41764:	4629      	mov	r1, r5
   41766:	6918      	ldr	r0, [r3, #16]
   41768:	f006 f9e7 	bl	47b3a <z_log_get_s_mask>
					if (smask == 0U) {
   4176c:	4604      	mov	r4, r0
   4176e:	b148      	cbz	r0, 41784 <msg_free+0x4c>
				if (smask & BIT(i)) {
   41770:	fa24 f306 	lsr.w	r3, r4, r6
   41774:	07d9      	lsls	r1, r3, #31
   41776:	d502      	bpl.n	4177e <msg_free+0x46>
					z_log_free(buf);
   41778:	4638      	mov	r0, r7
   4177a:	f7ff ff73 	bl	41664 <z_log_free>
		for (i = 0U; i < nargs; i++) {
   4177e:	3601      	adds	r6, #1
   41780:	42ae      	cmp	r6, r5
   41782:	d3e5      	bcc.n	41750 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
   41784:	9b01      	ldr	r3, [sp, #4]
   41786:	7a1a      	ldrb	r2, [r3, #8]
   41788:	0792      	lsls	r2, r2, #30
   4178a:	d504      	bpl.n	41796 <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
   4178c:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   4178e:	4c08      	ldr	r4, [pc, #32]	; (417b0 <msg_free+0x78>)
   41790:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   41792:	9b03      	ldr	r3, [sp, #12]
   41794:	b92b      	cbnz	r3, 417a2 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   41796:	4806      	ldr	r0, [pc, #24]	; (417b0 <msg_free+0x78>)
   41798:	a901      	add	r1, sp, #4
   4179a:	f007 f88c 	bl	488b6 <k_mem_slab_free>
}
   4179e:	b005      	add	sp, #20
   417a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
   417a2:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   417a4:	4620      	mov	r0, r4
   417a6:	a903      	add	r1, sp, #12
   417a8:	f007 f885 	bl	488b6 <k_mem_slab_free>
		cont = next;
   417ac:	9503      	str	r5, [sp, #12]
   417ae:	e7f0      	b.n	41792 <msg_free+0x5a>
   417b0:	2001a88c 	.word	0x2001a88c

000417b4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
   417b4:	b40e      	push	{r1, r2, r3}
   417b6:	b503      	push	{r0, r1, lr}
   417b8:	ab03      	add	r3, sp, #12
   417ba:	f853 2b04 	ldr.w	r2, [r3], #4
   417be:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
   417c0:	4804      	ldr	r0, [pc, #16]	; (417d4 <print_formatted+0x20>)
	va_start(args, fmt);
   417c2:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
   417c4:	f7ff f90a 	bl	409dc <cbvprintf>
	va_end(args);

	return length;
}
   417c8:	b002      	add	sp, #8
   417ca:	f85d eb04 	ldr.w	lr, [sp], #4
   417ce:	b003      	add	sp, #12
   417d0:	4770      	bx	lr
   417d2:	bf00      	nop
   417d4:	00048107 	.word	0x00048107

000417d8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
   417d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   417dc:	461f      	mov	r7, r3
   417de:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   417e0:	f001 0301 	and.w	r3, r1, #1
{
   417e4:	9205      	str	r2, [sp, #20]
   417e6:	4606      	mov	r6, r0
   417e8:	4688      	mov	r8, r1
   417ea:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
   417ee:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   417f2:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   417f6:	9304      	str	r3, [sp, #16]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   417f8:	f001 0508 	and.w	r5, r1, #8
	const char *tag = z_log_get_tag();
   417fc:	f006 fa1e 	bl	47c3c <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
   41800:	4602      	mov	r2, r0
   41802:	2800      	cmp	r0, #0
   41804:	d044      	beq.n	41890 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
   41806:	4630      	mov	r0, r6
   41808:	4938      	ldr	r1, [pc, #224]	; (418ec <prefix_print+0x114>)
   4180a:	f7ff ffd3 	bl	417b4 <print_formatted>
   4180e:	4604      	mov	r4, r0
	}

	if (stamp) {
   41810:	f1bb 0f00 	cmp.w	fp, #0
   41814:	d008      	beq.n	41828 <prefix_print+0x50>
	if (!format) {
   41816:	f018 0f44 	tst.w	r8, #68	; 0x44
   4181a:	d13b      	bne.n	41894 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
   4181c:	463a      	mov	r2, r7
   4181e:	4630      	mov	r0, r6
   41820:	4933      	ldr	r1, [pc, #204]	; (418f0 <prefix_print+0x118>)
   41822:	f7ff ffc7 	bl	417b4 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
   41826:	4404      	add	r4, r0
	if (color) {
   41828:	9b04      	ldr	r3, [sp, #16]
   4182a:	b153      	cbz	r3, 41842 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
   4182c:	4b31      	ldr	r3, [pc, #196]	; (418f4 <prefix_print+0x11c>)
		print_formatted(output, "%s", log_color);
   4182e:	4630      	mov	r0, r6
		const char *log_color = start && (colors[level] != NULL) ?
   41830:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
   41834:	4b30      	ldr	r3, [pc, #192]	; (418f8 <prefix_print+0x120>)
   41836:	4931      	ldr	r1, [pc, #196]	; (418fc <prefix_print+0x124>)
   41838:	2a00      	cmp	r2, #0
   4183a:	bf08      	it	eq
   4183c:	461a      	moveq	r2, r3
   4183e:	f7ff ffb9 	bl	417b4 <print_formatted>
	if (level_on) {
   41842:	b13d      	cbz	r5, 41854 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
   41844:	4b2e      	ldr	r3, [pc, #184]	; (41900 <prefix_print+0x128>)
   41846:	4630      	mov	r0, r6
   41848:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   4184c:	492d      	ldr	r1, [pc, #180]	; (41904 <prefix_print+0x12c>)
   4184e:	f7ff ffb1 	bl	417b4 <print_formatted>
   41852:	4605      	mov	r5, r0
	if (source_id >= 0) {
   41854:	f1ba 0f00 	cmp.w	sl, #0
   41858:	db16      	blt.n	41888 <prefix_print+0xb0>
		total += print_formatted(output,
   4185a:	9b05      	ldr	r3, [sp, #20]
   4185c:	2b00      	cmp	r3, #0
   4185e:	d043      	beq.n	418e8 <prefix_print+0x110>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   41860:	2301      	movs	r3, #1
   41862:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
   41866:	4b28      	ldr	r3, [pc, #160]	; (41908 <prefix_print+0x130>)
   41868:	f019 0f10 	tst.w	r9, #16
   4186c:	4f27      	ldr	r7, [pc, #156]	; (4190c <prefix_print+0x134>)
   4186e:	bf18      	it	ne
   41870:	461f      	movne	r7, r3
   41872:	4651      	mov	r1, sl
   41874:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
   41878:	f7ff ff0a 	bl	41690 <log_source_name_get>
   4187c:	4639      	mov	r1, r7
   4187e:	4602      	mov	r2, r0
   41880:	4630      	mov	r0, r6
   41882:	f7ff ff97 	bl	417b4 <print_formatted>
   41886:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
   41888:	1928      	adds	r0, r5, r4
   4188a:	b007      	add	sp, #28
   4188c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
   41890:	4604      	mov	r4, r0
   41892:	e7bd      	b.n	41810 <prefix_print+0x38>
	} else if (freq != 0U) {
   41894:	4b1e      	ldr	r3, [pc, #120]	; (41910 <prefix_print+0x138>)
   41896:	6818      	ldr	r0, [r3, #0]
   41898:	2800      	cmp	r0, #0
   4189a:	d0c4      	beq.n	41826 <prefix_print+0x4e>
		timestamp /= timestamp_div;
   4189c:	4b1d      	ldr	r3, [pc, #116]	; (41914 <prefix_print+0x13c>)
   4189e:	f44f 6c61 	mov.w	ip, #3600	; 0xe10
   418a2:	6819      	ldr	r1, [r3, #0]
		mins = seconds / 60U;
   418a4:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
		timestamp /= timestamp_div;
   418a8:	fbb7 f7f1 	udiv	r7, r7, r1
		total_seconds = timestamp / freq;
   418ac:	fbb7 f1f0 	udiv	r1, r7, r0
		seconds -= hours * 3600U;
   418b0:	fbb1 f2fc 	udiv	r2, r1, ip
		remainder = timestamp % freq;
   418b4:	fb00 7711 	mls	r7, r0, r1, r7
   418b8:	fb0c 1c12 	mls	ip, ip, r2, r1
		ms = (remainder * 1000U) / freq;
   418bc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   418c0:	434f      	muls	r7, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   418c2:	fbb7 f8f0 	udiv	r8, r7, r0
   418c6:	fb00 7718 	mls	r7, r0, r8, r7
		mins = seconds / 60U;
   418ca:	fbbc f3fe 	udiv	r3, ip, lr
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   418ce:	434f      	muls	r7, r1
   418d0:	fbb7 f0f0 	udiv	r0, r7, r0
			length = print_formatted(output,
   418d4:	fb0e c113 	mls	r1, lr, r3, ip
   418d8:	e9cd 8001 	strd	r8, r0, [sp, #4]
   418dc:	9100      	str	r1, [sp, #0]
   418de:	4630      	mov	r0, r6
   418e0:	490d      	ldr	r1, [pc, #52]	; (41918 <prefix_print+0x140>)
   418e2:	f7ff ff67 	bl	417b4 <print_formatted>
   418e6:	e79e      	b.n	41826 <prefix_print+0x4e>
		total += print_formatted(output,
   418e8:	4f08      	ldr	r7, [pc, #32]	; (4190c <prefix_print+0x134>)
   418ea:	e7c2      	b.n	41872 <prefix_print+0x9a>
   418ec:	000494ac 	.word	0x000494ac
   418f0:	000494b0 	.word	0x000494b0
   418f4:	00048ff8 	.word	0x00048ff8
   418f8:	0004949e 	.word	0x0004949e
   418fc:	000494d5 	.word	0x000494d5
   41900:	0004900c 	.word	0x0004900c
   41904:	000494d8 	.word	0x000494d8
   41908:	000494a8 	.word	0x000494a8
   4190c:	000494a3 	.word	0x000494a3
   41910:	2001a8a8 	.word	0x2001a8a8
   41914:	2001a8ac 	.word	0x2001a8ac
   41918:	000494b9 	.word	0x000494b9

0004191c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
   4191c:	b538      	push	{r3, r4, r5, lr}
   4191e:	460c      	mov	r4, r1
	if (color) {
   41920:	07e1      	lsls	r1, r4, #31
{
   41922:	4605      	mov	r5, r0
	if (color) {
   41924:	d503      	bpl.n	4192e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
   41926:	4a08      	ldr	r2, [pc, #32]	; (41948 <postfix_print+0x2c>)
   41928:	4908      	ldr	r1, [pc, #32]	; (4194c <postfix_print+0x30>)
   4192a:	f7ff ff43 	bl	417b4 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   4192e:	06e2      	lsls	r2, r4, #27
   41930:	d408      	bmi.n	41944 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41932:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   41934:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
   41936:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   4193a:	bf4c      	ite	mi
   4193c:	4904      	ldrmi	r1, [pc, #16]	; (41950 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   4193e:	4905      	ldrpl	r1, [pc, #20]	; (41954 <postfix_print+0x38>)
   41940:	f7ff bf38 	b.w	417b4 <print_formatted>
}
   41944:	bd38      	pop	{r3, r4, r5, pc}
   41946:	bf00      	nop
   41948:	0004949e 	.word	0x0004949e
   4194c:	000494d5 	.word	0x000494d5
   41950:	000494df 	.word	0x000494df
   41954:	000494de 	.word	0x000494de

00041958 <hexdump_line_print>:
{
   41958:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4195c:	461d      	mov	r5, r3
   4195e:	9b08      	ldr	r3, [sp, #32]
   41960:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41962:	06da      	lsls	r2, r3, #27
{
   41964:	4604      	mov	r4, r0
   41966:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41968:	d405      	bmi.n	41976 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   4196a:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   4196c:	bf4c      	ite	mi
   4196e:	492a      	ldrmi	r1, [pc, #168]	; (41a18 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   41970:	492a      	ldrpl	r1, [pc, #168]	; (41a1c <hexdump_line_print+0xc4>)
   41972:	f7ff ff1f 	bl	417b4 <print_formatted>
{
   41976:	f04f 0800 	mov.w	r8, #0
		print_formatted(output, " ");
   4197a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 41a24 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   4197e:	45a8      	cmp	r8, r5
   41980:	db2a      	blt.n	419d8 <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41982:	2500      	movs	r5, #0
			print_formatted(output, "   ");
   41984:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 41a28 <hexdump_line_print+0xd0>
			print_formatted(output, "%02x ", data[i]);
   41988:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 41a2c <hexdump_line_print+0xd4>
			print_formatted(output, " ");
   4198c:	f8df a094 	ldr.w	sl, [pc, #148]	; 41a24 <hexdump_line_print+0xcc>
		if (i < length) {
   41990:	42bd      	cmp	r5, r7
   41992:	d22f      	bcs.n	419f4 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
   41994:	4649      	mov	r1, r9
   41996:	4620      	mov	r0, r4
   41998:	5d72      	ldrb	r2, [r6, r5]
   4199a:	f7ff ff0b 	bl	417b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   4199e:	3501      	adds	r5, #1
   419a0:	2d10      	cmp	r5, #16
   419a2:	d120      	bne.n	419e6 <hexdump_line_print+0x8e>
	print_formatted(output, "|");
   419a4:	4620      	mov	r0, r4
   419a6:	491e      	ldr	r1, [pc, #120]	; (41a20 <hexdump_line_print+0xc8>)
   419a8:	f7ff ff04 	bl	417b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   419ac:	2500      	movs	r5, #0
			print_formatted(output, " ");
   419ae:	f8df 8074 	ldr.w	r8, [pc, #116]	; 41a24 <hexdump_line_print+0xcc>
			print_formatted(output, "%c",
   419b2:	f8df 907c 	ldr.w	r9, [pc, #124]	; 41a30 <hexdump_line_print+0xd8>
		if (i < length) {
   419b6:	42af      	cmp	r7, r5
   419b8:	d928      	bls.n	41a0c <hexdump_line_print+0xb4>
			char c = (char)data[i];
   419ba:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
   419bc:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
   419be:	f1a2 0320 	sub.w	r3, r2, #32
   419c2:	2b5f      	cmp	r3, #95	; 0x5f
   419c4:	bf28      	it	cs
   419c6:	222e      	movcs	r2, #46	; 0x2e
   419c8:	4620      	mov	r0, r4
   419ca:	f7ff fef3 	bl	417b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   419ce:	3501      	adds	r5, #1
   419d0:	2d10      	cmp	r5, #16
   419d2:	d114      	bne.n	419fe <hexdump_line_print+0xa6>
}
   419d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
   419d8:	4649      	mov	r1, r9
   419da:	4620      	mov	r0, r4
   419dc:	f7ff feea 	bl	417b4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   419e0:	f108 0801 	add.w	r8, r8, #1
   419e4:	e7cb      	b.n	4197e <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
   419e6:	076a      	lsls	r2, r5, #29
   419e8:	d1d2      	bne.n	41990 <hexdump_line_print+0x38>
			print_formatted(output, " ");
   419ea:	4651      	mov	r1, sl
   419ec:	4620      	mov	r0, r4
   419ee:	f7ff fee1 	bl	417b4 <print_formatted>
   419f2:	e7cd      	b.n	41990 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
   419f4:	4641      	mov	r1, r8
   419f6:	4620      	mov	r0, r4
   419f8:	f7ff fedc 	bl	417b4 <print_formatted>
   419fc:	e7cf      	b.n	4199e <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
   419fe:	076b      	lsls	r3, r5, #29
   41a00:	d1d9      	bne.n	419b6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41a02:	4641      	mov	r1, r8
   41a04:	4620      	mov	r0, r4
   41a06:	f7ff fed5 	bl	417b4 <print_formatted>
   41a0a:	e7d4      	b.n	419b6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41a0c:	4641      	mov	r1, r8
   41a0e:	4620      	mov	r0, r4
   41a10:	f7ff fed0 	bl	417b4 <print_formatted>
   41a14:	e7db      	b.n	419ce <hexdump_line_print+0x76>
   41a16:	bf00      	nop
   41a18:	000494df 	.word	0x000494df
   41a1c:	000494de 	.word	0x000494de
   41a20:	000494eb 	.word	0x000494eb
   41a24:	000494e9 	.word	0x000494e9
   41a28:	000494e7 	.word	0x000494e7
   41a2c:	000494e1 	.word	0x000494e1
   41a30:	000494ed 	.word	0x000494ed

00041a34 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
   41a34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   41a38:	7a8b      	ldrb	r3, [r1, #10]
   41a3a:	4617      	mov	r7, r2
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
   41a3c:	f013 0807 	ands.w	r8, r3, #7
{
   41a40:	4605      	mov	r5, r0
   41a42:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41a44:	7a0a      	ldrb	r2, [r1, #8]
   41a46:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
   41a48:	d021      	beq.n	41a8e <log_output_msg_process+0x5a>
   41a4a:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
   41a4c:	8949      	ldrh	r1, [r1, #10]
   41a4e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   41a52:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41a56:	e9cd 8300 	strd	r8, r3, [sp]
   41a5a:	9102      	str	r1, [sp, #8]
   41a5c:	68f3      	ldr	r3, [r6, #12]
   41a5e:	4639      	mov	r1, r7
   41a60:	f002 0201 	and.w	r2, r2, #1
   41a64:	f7ff feb8 	bl	417d8 <prefix_print>
   41a68:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41a6a:	7a34      	ldrb	r4, [r6, #8]
   41a6c:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   41a6e:	f014 0401 	ands.w	r4, r4, #1
   41a72:	d00e      	beq.n	41a92 <log_output_msg_process+0x5e>
		std_print(msg, output);
   41a74:	4629      	mov	r1, r5
   41a76:	4630      	mov	r0, r6
   41a78:	f006 f9db 	bl	47e32 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
   41a7c:	f1b8 0f00 	cmp.w	r8, #0
   41a80:	d02b      	beq.n	41ada <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
   41a82:	4642      	mov	r2, r8
   41a84:	4639      	mov	r1, r7
   41a86:	4628      	mov	r0, r5
   41a88:	f7ff ff48 	bl	4191c <postfix_print>
   41a8c:	e025      	b.n	41ada <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
   41a8e:	46c1      	mov	r9, r8
   41a90:	e7eb      	b.n	41a6a <log_output_msg_process+0x36>
	} else if (raw_string) {
   41a92:	f1b8 0f00 	cmp.w	r8, #0
   41a96:	d126      	bne.n	41ae6 <log_output_msg_process+0xb2>
	size_t offset = 0;
   41a98:	4627      	mov	r7, r4
		length = output->size;
   41a9a:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41a9c:	aa06      	add	r2, sp, #24
		length = output->size;
   41a9e:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41aa0:	4630      	mov	r0, r6
   41aa2:	463b      	mov	r3, r7
   41aa4:	68a9      	ldr	r1, [r5, #8]
   41aa6:	f006 f9b0 	bl	47e0a <log_msg_hexdump_data_get>
		output->control_block->offset = length;
   41aaa:	9a06      	ldr	r2, [sp, #24]
   41aac:	686b      	ldr	r3, [r5, #4]
   41aae:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   41ab0:	b13a      	cbz	r2, 41ac2 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
   41ab2:	68ab      	ldr	r3, [r5, #8]
   41ab4:	4413      	add	r3, r2
   41ab6:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   41aba:	f1a4 030a 	sub.w	r3, r4, #10
   41abe:	425c      	negs	r4, r3
   41ac0:	415c      	adcs	r4, r3
		log_output_flush(output);
   41ac2:	4628      	mov	r0, r5
   41ac4:	f006 fb12 	bl	480ec <log_output_flush>
		offset += length;
   41ac8:	9b06      	ldr	r3, [sp, #24]
   41aca:	441f      	add	r7, r3
	} while (length > 0);
   41acc:	2b00      	cmp	r3, #0
   41ace:	d1e4      	bne.n	41a9a <log_output_msg_process+0x66>
	if (eol) {
   41ad0:	b11c      	cbz	r4, 41ada <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
   41ad2:	4628      	mov	r0, r5
   41ad4:	4913      	ldr	r1, [pc, #76]	; (41b24 <log_output_msg_process+0xf0>)
   41ad6:	f7ff fe6d 	bl	417b4 <print_formatted>
	}

	log_output_flush(output);
   41ada:	4628      	mov	r0, r5
   41adc:	f006 fb06 	bl	480ec <log_output_flush>
}
   41ae0:	b00a      	add	sp, #40	; 0x28
   41ae2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(output, "%s", log_msg_str_get(msg));
   41ae6:	4630      	mov	r0, r6
   41ae8:	f006 f93a 	bl	47d60 <log_msg_str_get>
   41aec:	490e      	ldr	r1, [pc, #56]	; (41b28 <log_output_msg_process+0xf4>)
   41aee:	4602      	mov	r2, r0
   41af0:	4628      	mov	r0, r5
   41af2:	f7ff fe5f 	bl	417b4 <print_formatted>
		length = sizeof(buf);
   41af6:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41afa:	aa05      	add	r2, sp, #20
   41afc:	4623      	mov	r3, r4
   41afe:	4630      	mov	r0, r6
   41b00:	a906      	add	r1, sp, #24
		length = sizeof(buf);
   41b02:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41b06:	f006 f980 	bl	47e0a <log_msg_hexdump_data_get>
		if (length) {
   41b0a:	9a05      	ldr	r2, [sp, #20]
   41b0c:	2a00      	cmp	r2, #0
   41b0e:	d0b8      	beq.n	41a82 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
   41b10:	464b      	mov	r3, r9
   41b12:	4628      	mov	r0, r5
   41b14:	9700      	str	r7, [sp, #0]
   41b16:	a906      	add	r1, sp, #24
   41b18:	f7ff ff1e 	bl	41958 <hexdump_line_print>
			offset += length;
   41b1c:	9b05      	ldr	r3, [sp, #20]
   41b1e:	441c      	add	r4, r3
		length = sizeof(buf);
   41b20:	e7eb      	b.n	41afa <log_output_msg_process+0xc6>
   41b22:	bf00      	nop
   41b24:	000494f0 	.word	0x000494f0
   41b28:	000494d5 	.word	0x000494d5

00041b2c <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41b2c:	f242 730f 	movw	r3, #9999	; 0x270f
{
   41b30:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41b32:	428b      	cmp	r3, r1
   41b34:	bf28      	it	cs
   41b36:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
   41b38:	6805      	ldr	r5, [r0, #0]
{
   41b3a:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41b3c:	2105      	movs	r1, #5
   41b3e:	4668      	mov	r0, sp
   41b40:	4a0d      	ldr	r2, [pc, #52]	; (41b78 <log_output_dropped_process+0x4c>)
   41b42:	f005 fcd0 	bl	474e6 <snprintk>
   41b46:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
   41b48:	6863      	ldr	r3, [r4, #4]
   41b4a:	4628      	mov	r0, r5
   41b4c:	220b      	movs	r2, #11
   41b4e:	685b      	ldr	r3, [r3, #4]
   41b50:	490a      	ldr	r1, [pc, #40]	; (41b7c <log_output_dropped_process+0x50>)
   41b52:	f006 f961 	bl	47e18 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
   41b56:	6863      	ldr	r3, [r4, #4]
   41b58:	4632      	mov	r2, r6
   41b5a:	4669      	mov	r1, sp
   41b5c:	4628      	mov	r0, r5
   41b5e:	685b      	ldr	r3, [r3, #4]
   41b60:	f006 f95a 	bl	47e18 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
   41b64:	6863      	ldr	r3, [r4, #4]
   41b66:	221b      	movs	r2, #27
   41b68:	4628      	mov	r0, r5
   41b6a:	685b      	ldr	r3, [r3, #4]
   41b6c:	4904      	ldr	r1, [pc, #16]	; (41b80 <log_output_dropped_process+0x54>)
   41b6e:	f006 f953 	bl	47e18 <buffer_write>
		     output->control_block->ctx);
}
   41b72:	b002      	add	sp, #8
   41b74:	bd70      	pop	{r4, r5, r6, pc}
   41b76:	bf00      	nop
   41b78:	00049b67 	.word	0x00049b67
   41b7c:	0004952e 	.word	0x0004952e
   41b80:	00049512 	.word	0x00049512

00041b84 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
   41b84:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   41b86:	2100      	movs	r1, #0
	timestamp_div = 1U;
   41b88:	4a07      	ldr	r2, [pc, #28]	; (41ba8 <log_output_timestamp_freq_set+0x24>)
{
   41b8a:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   41b8c:	4c07      	ldr	r4, [pc, #28]	; (41bac <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   41b8e:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   41b90:	42a0      	cmp	r0, r4
   41b92:	d804      	bhi.n	41b9e <log_output_timestamp_freq_set+0x1a>
   41b94:	b101      	cbz	r1, 41b98 <log_output_timestamp_freq_set+0x14>
   41b96:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   41b98:	4b05      	ldr	r3, [pc, #20]	; (41bb0 <log_output_timestamp_freq_set+0x2c>)
   41b9a:	6018      	str	r0, [r3, #0]
}
   41b9c:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
   41b9e:	2101      	movs	r1, #1
		frequency /= 2U;
   41ba0:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   41ba2:	005b      	lsls	r3, r3, #1
   41ba4:	e7f4      	b.n	41b90 <log_output_timestamp_freq_set+0xc>
   41ba6:	bf00      	nop
   41ba8:	2001a8ac 	.word	0x2001a8ac
   41bac:	000f4240 	.word	0x000f4240
   41bb0:	2001a8a8 	.word	0x2001a8a8

00041bb4 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
   41bb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   41bb6:	460d      	mov	r5, r1
   41bb8:	4604      	mov	r4, r0
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
   41bba:	4f06      	ldr	r7, [pc, #24]	; (41bd4 <char_out+0x20>)
   41bbc:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
   41bbe:	42b4      	cmp	r4, r6
   41bc0:	d101      	bne.n	41bc6 <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
   41bc2:	4628      	mov	r0, r5
   41bc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
   41bc6:	6838      	ldr	r0, [r7, #0]
   41bc8:	f814 1b01 	ldrb.w	r1, [r4], #1
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   41bcc:	6883      	ldr	r3, [r0, #8]
   41bce:	685b      	ldr	r3, [r3, #4]
   41bd0:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
   41bd2:	e7f4      	b.n	41bbe <char_out+0xa>
   41bd4:	2001a8c4 	.word	0x2001a8c4

00041bd8 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   41bd8:	4b01      	ldr	r3, [pc, #4]	; (41be0 <log_backend_uart_init+0x8>)
   41bda:	4a02      	ldr	r2, [pc, #8]	; (41be4 <log_backend_uart_init+0xc>)
   41bdc:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
   41bde:	4770      	bx	lr
   41be0:	2001a8c4 	.word	0x2001a8c4
   41be4:	00048d38 	.word	0x00048d38

00041be8 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
   41be8:	2201      	movs	r2, #1
   41bea:	4b02      	ldr	r3, [pc, #8]	; (41bf4 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
   41bec:	4802      	ldr	r0, [pc, #8]	; (41bf8 <panic+0x10>)
   41bee:	701a      	strb	r2, [r3, #0]
   41bf0:	f006 ba7c 	b.w	480ec <log_output_flush>
   41bf4:	2001ae55 	.word	0x2001ae55
   41bf8:	0004903c 	.word	0x0004903c

00041bfc <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
   41bfc:	4801      	ldr	r0, [pc, #4]	; (41c04 <dropped+0x8>)
   41bfe:	f7ff bf95 	b.w	41b2c <log_output_dropped_process>
   41c02:	bf00      	nop
   41c04:	0004903c 	.word	0x0004903c

00041c08 <put>:
{
   41c08:	b510      	push	{r4, lr}
   41c0a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41c0c:	4608      	mov	r0, r1
   41c0e:	f006 f86d 	bl	47cec <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41c12:	4621      	mov	r1, r4
   41c14:	4804      	ldr	r0, [pc, #16]	; (41c28 <put+0x20>)
   41c16:	220f      	movs	r2, #15
   41c18:	f7ff ff0c 	bl	41a34 <log_output_msg_process>
	log_msg_put(msg);
   41c1c:	4620      	mov	r0, r4
}
   41c1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41c22:	f006 b88e 	b.w	47d42 <log_msg_put>
   41c26:	bf00      	nop
   41c28:	0004903c 	.word	0x0004903c

00041c2c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   41c2c:	2201      	movs	r2, #1
   41c2e:	4b01      	ldr	r3, [pc, #4]	; (41c34 <log_backend_rtt_init+0x8>)
   41c30:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   41c32:	4770      	bx	lr
   41c34:	2001ae67 	.word	0x2001ae67

00041c38 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
   41c38:	2201      	movs	r2, #1
   41c3a:	4b02      	ldr	r3, [pc, #8]	; (41c44 <panic+0xc>)
	log_output_flush(output);
   41c3c:	4802      	ldr	r0, [pc, #8]	; (41c48 <panic+0x10>)
   41c3e:	701a      	strb	r2, [r3, #0]
   41c40:	f006 ba54 	b.w	480ec <log_output_flush>
   41c44:	2001ae68 	.word	0x2001ae68
   41c48:	00049068 	.word	0x00049068

00041c4c <dropped>:
	log_output_dropped_process(output, cnt);
   41c4c:	4801      	ldr	r0, [pc, #4]	; (41c54 <dropped+0x8>)
   41c4e:	f7ff bf6d 	b.w	41b2c <log_output_dropped_process>
   41c52:	bf00      	nop
   41c54:	00049068 	.word	0x00049068

00041c58 <put>:
{
   41c58:	b510      	push	{r4, lr}
   41c5a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41c5c:	4608      	mov	r0, r1
   41c5e:	f006 f845 	bl	47cec <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41c62:	4621      	mov	r1, r4
   41c64:	4804      	ldr	r0, [pc, #16]	; (41c78 <put+0x20>)
   41c66:	220f      	movs	r2, #15
   41c68:	f7ff fee4 	bl	41a34 <log_output_msg_process>
	log_msg_put(msg);
   41c6c:	4620      	mov	r0, r4
}
   41c6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41c72:	f006 b866 	b.w	47d42 <log_msg_put>
   41c76:	bf00      	nop
   41c78:	00049068 	.word	0x00049068

00041c7c <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41c7c:	4b05      	ldr	r3, [pc, #20]	; (41c94 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
   41c7e:	781b      	ldrb	r3, [r3, #0]
   41c80:	b11b      	cbz	r3, 41c8a <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
   41c82:	f241 3088 	movw	r0, #5000	; 0x1388
   41c86:	f006 bf9c 	b.w	48bc2 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
   41c8a:	2005      	movs	r0, #5
   41c8c:	2100      	movs	r1, #0
   41c8e:	f005 b80b 	b.w	46ca8 <z_impl_k_sleep>
   41c92:	bf00      	nop
   41c94:	2001ae68 	.word	0x2001ae68

00041c98 <data_out_block_mode>:
{
   41c98:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41c9c:	f8df 9094 	ldr.w	r9, [pc, #148]	; 41d34 <data_out_block_mode+0x9c>
{
   41ca0:	4680      	mov	r8, r0
   41ca2:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
   41ca4:	2404      	movs	r4, #4
   41ca6:	46cb      	mov	fp, r9
	return z_impl_k_mutex_lock(mutex, timeout);
   41ca8:	f8df a08c 	ldr.w	sl, [pc, #140]	; 41d38 <data_out_block_mode+0xa0>
		if (!is_sync_mode()) {
   41cac:	f899 5000 	ldrb.w	r5, [r9]
   41cb0:	b9cd      	cbnz	r5, 41ce6 <data_out_block_mode+0x4e>
   41cb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41cb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   41cba:	4650      	mov	r0, sl
   41cbc:	f004 fc0a 	bl	464d4 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41cc0:	463a      	mov	r2, r7
   41cc2:	4641      	mov	r1, r8
   41cc4:	4628      	mov	r0, r5
   41cc6:	f002 fd33 	bl	44730 <SEGGER_RTT_WriteSkipNoLock>
   41cca:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   41ccc:	4650      	mov	r0, sl
   41cce:	f004 fc7f 	bl	465d0 <z_impl_k_mutex_unlock>
		if (ret) {
   41cd2:	4d17      	ldr	r5, [pc, #92]	; (41d30 <data_out_block_mode+0x98>)
   41cd4:	b1fe      	cbz	r6, 41d16 <data_out_block_mode+0x7e>
	host_present = true;
   41cd6:	2301      	movs	r3, #1
   41cd8:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
   41cda:	f89b 3000 	ldrb.w	r3, [fp]
   41cde:	b96b      	cbnz	r3, 41cfc <data_out_block_mode+0x64>
}
   41ce0:	4638      	mov	r0, r7
   41ce2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41ce6:	463a      	mov	r2, r7
   41ce8:	4641      	mov	r1, r8
   41cea:	2000      	movs	r0, #0
   41cec:	f002 fd20 	bl	44730 <SEGGER_RTT_WriteSkipNoLock>
   41cf0:	4606      	mov	r6, r0
   41cf2:	e7ee      	b.n	41cd2 <data_out_block_mode+0x3a>
	if (retry_cnt == 0) {
   41cf4:	b95c      	cbnz	r4, 41d0e <data_out_block_mode+0x76>
		host_present = false;
   41cf6:	702c      	strb	r4, [r5, #0]
   41cf8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   41cfc:	2000      	movs	r0, #0
   41cfe:	f002 fd63 	bl	447c8 <SEGGER_RTT_HasDataUp>
   41d02:	2800      	cmp	r0, #0
   41d04:	d0ec      	beq.n	41ce0 <data_out_block_mode+0x48>
   41d06:	782b      	ldrb	r3, [r5, #0]
   41d08:	2b00      	cmp	r3, #0
   41d0a:	d1f3      	bne.n	41cf4 <data_out_block_mode+0x5c>
   41d0c:	e7e8      	b.n	41ce0 <data_out_block_mode+0x48>
			on_failed_write(retry_cnt--);
   41d0e:	3c01      	subs	r4, #1
   41d10:	f7ff ffb4 	bl	41c7c <on_failed_write.part.0>
   41d14:	e7f2      	b.n	41cfc <data_out_block_mode+0x64>
		} else if (host_present) {
   41d16:	782b      	ldrb	r3, [r5, #0]
   41d18:	b113      	cbz	r3, 41d20 <data_out_block_mode+0x88>
	if (retry_cnt == 0) {
   41d1a:	3c01      	subs	r4, #1
   41d1c:	d104      	bne.n	41d28 <data_out_block_mode+0x90>
		host_present = false;
   41d1e:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   41d20:	782b      	ldrb	r3, [r5, #0]
   41d22:	2b00      	cmp	r3, #0
   41d24:	d1c2      	bne.n	41cac <data_out_block_mode+0x14>
   41d26:	e7db      	b.n	41ce0 <data_out_block_mode+0x48>
   41d28:	f7ff ffa8 	bl	41c7c <on_failed_write.part.0>
   41d2c:	e7f8      	b.n	41d20 <data_out_block_mode+0x88>
   41d2e:	bf00      	nop
   41d30:	2001ae67 	.word	0x2001ae67
   41d34:	2001ae68 	.word	0x2001ae68
   41d38:	2001a61c 	.word	0x2001a61c

00041d3c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   41d3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   41d40:	4605      	mov	r5, r0
	__asm__ volatile(
   41d42:	f04f 0320 	mov.w	r3, #32
   41d46:	f3ef 8611 	mrs	r6, BASEPRI
   41d4a:	f383 8812 	msr	BASEPRI_MAX, r3
   41d4e:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41d52:	4b10      	ldr	r3, [pc, #64]	; (41d94 <pm_state_notify+0x58>)
   41d54:	681c      	ldr	r4, [r3, #0]
   41d56:	2c00      	cmp	r4, #0
   41d58:	bf38      	it	cc
   41d5a:	2400      	movcc	r4, #0
   41d5c:	b19c      	cbz	r4, 41d86 <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   41d5e:	f04f 090c 	mov.w	r9, #12
   41d62:	4f0d      	ldr	r7, [pc, #52]	; (41d98 <pm_state_notify+0x5c>)
   41d64:	f8df 8034 	ldr.w	r8, [pc, #52]	; 41d9c <pm_state_notify+0x60>
			callback = notifier->state_exit;
   41d68:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   41d6c:	2d00      	cmp	r5, #0
   41d6e:	bf08      	it	eq
   41d70:	4613      	moveq	r3, r2
		if (callback) {
   41d72:	b12b      	cbz	r3, 41d80 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   41d74:	f898 2014 	ldrb.w	r2, [r8, #20]
   41d78:	fb09 f202 	mul.w	r2, r9, r2
   41d7c:	5cb8      	ldrb	r0, [r7, r2]
   41d7e:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   41d80:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41d82:	2c00      	cmp	r4, #0
   41d84:	d1f0      	bne.n	41d68 <pm_state_notify+0x2c>
	__asm__ volatile(
   41d86:	f386 8811 	msr	BASEPRI, r6
   41d8a:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   41d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   41d92:	bf00      	nop
   41d94:	2001a8dc 	.word	0x2001a8dc
   41d98:	2001a8e8 	.word	0x2001a8e8
   41d9c:	2001ad6c 	.word	0x2001ad6c

00041da0 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41da0:	2201      	movs	r2, #1
   41da2:	f000 031f 	and.w	r3, r0, #31
   41da6:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41da8:	4b08      	ldr	r3, [pc, #32]	; (41dcc <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   41daa:	0940      	lsrs	r0, r0, #5
   41dac:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   41db0:	e8d0 3fef 	ldaex	r3, [r0]
   41db4:	ea43 0102 	orr.w	r1, r3, r2
   41db8:	e8c0 1fec 	stlex	ip, r1, [r0]
   41dbc:	f1bc 0f00 	cmp.w	ip, #0
   41dc0:	d1f6      	bne.n	41db0 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   41dc2:	421a      	tst	r2, r3
}
   41dc4:	bf14      	ite	ne
   41dc6:	2001      	movne	r0, #1
   41dc8:	2000      	moveq	r0, #0
   41dca:	4770      	bx	lr
   41dcc:	2001a8f4 	.word	0x2001a8f4

00041dd0 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   41dd0:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   41dd2:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   41dd4:	4b1a      	ldr	r3, [pc, #104]	; (41e40 <pm_system_resume+0x70>)
{
   41dd6:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   41dd8:	7d1d      	ldrb	r5, [r3, #20]
   41dda:	f005 031f 	and.w	r3, r5, #31
   41dde:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41de0:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41de2:	4b18      	ldr	r3, [pc, #96]	; (41e44 <pm_system_resume+0x74>)
   41de4:	0969      	lsrs	r1, r5, #5
   41de6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   41dea:	e8d3 1fef 	ldaex	r1, [r3]
   41dee:	ea01 0400 	and.w	r4, r1, r0
   41df2:	e8c3 4fec 	stlex	ip, r4, [r3]
   41df6:	f1bc 0f00 	cmp.w	ip, #0
   41dfa:	d1f6      	bne.n	41dea <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   41dfc:	4211      	tst	r1, r2
   41dfe:	d017      	beq.n	41e30 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   41e00:	220c      	movs	r2, #12
   41e02:	4c11      	ldr	r4, [pc, #68]	; (41e48 <pm_system_resume+0x78>)
   41e04:	ab01      	add	r3, sp, #4
   41e06:	fb02 4205 	mla	r2, r2, r5, r4
   41e0a:	ca07      	ldmia	r2, {r0, r1, r2}
   41e0c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   41e10:	4a0e      	ldr	r2, [pc, #56]	; (41e4c <pm_system_resume+0x7c>)
   41e12:	b17a      	cbz	r2, 41e34 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   41e14:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41e18:	f005 fe61 	bl	47ade <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   41e1c:	2000      	movs	r0, #0
   41e1e:	f7ff ff8d 	bl	41d3c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   41e22:	230c      	movs	r3, #12
   41e24:	2200      	movs	r2, #0
   41e26:	436b      	muls	r3, r5
   41e28:	18e1      	adds	r1, r4, r3
   41e2a:	50e2      	str	r2, [r4, r3]
   41e2c:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   41e30:	b005      	add	sp, #20
   41e32:	bd30      	pop	{r4, r5, pc}
   41e34:	f382 8811 	msr	BASEPRI, r2
   41e38:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   41e3c:	e7ee      	b.n	41e1c <pm_system_resume+0x4c>
   41e3e:	bf00      	nop
   41e40:	2001ad6c 	.word	0x2001ad6c
   41e44:	2001a8e4 	.word	0x2001a8e4
   41e48:	2001a8e8 	.word	0x2001a8e8
   41e4c:	00047adf 	.word	0x00047adf

00041e50 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   41e50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   41e54:	4b39      	ldr	r3, [pc, #228]	; (41f3c <pm_system_suspend+0xec>)
{
   41e56:	4605      	mov	r5, r0
	uint8_t id = _current_cpu->id;
   41e58:	7d1c      	ldrb	r4, [r3, #20]
{
   41e5a:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   41e5c:	4620      	mov	r0, r4
   41e5e:	f7ff ff9f 	bl	41da0 <atomic_test_and_set_bit.constprop.0>
   41e62:	4e37      	ldr	r6, [pc, #220]	; (41f40 <pm_system_suspend+0xf0>)
   41e64:	b960      	cbnz	r0, 41e80 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   41e66:	270c      	movs	r7, #12
   41e68:	46e8      	mov	r8, sp
   41e6a:	fb07 6704 	mla	r7, r7, r4, r6
   41e6e:	462a      	mov	r2, r5
   41e70:	4621      	mov	r1, r4
   41e72:	4640      	mov	r0, r8
   41e74:	f006 f95e 	bl	48134 <pm_policy_next_state>
   41e78:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
   41e7c:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   41e80:	230c      	movs	r3, #12
   41e82:	4363      	muls	r3, r4
   41e84:	5cf0      	ldrb	r0, [r6, r3]
   41e86:	18f2      	adds	r2, r6, r3
   41e88:	0967      	lsrs	r7, r4, #5
   41e8a:	f004 081f 	and.w	r8, r4, #31
   41e8e:	2800      	cmp	r0, #0
   41e90:	d03b      	beq.n	41f0a <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   41e92:	1c6b      	adds	r3, r5, #1
   41e94:	d014      	beq.n	41ec0 <pm_system_suspend+0x70>
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
   41e96:	f240 30e7 	movw	r0, #999	; 0x3e7
   41e9a:	2100      	movs	r1, #0
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
		     k_us_to_ticks_ceil32(
   41e9c:	6893      	ldr	r3, [r2, #8]
   41e9e:	18c0      	adds	r0, r0, r3
   41ea0:	f141 0100 	adc.w	r1, r1, #0
		if (result32 && (t < BIT64(32))) {
   41ea4:	2901      	cmp	r1, #1
   41ea6:	bf08      	it	eq
   41ea8:	2800      	cmpeq	r0, #0
   41eaa:	d241      	bcs.n	41f30 <pm_system_suspend+0xe0>
			return ((uint32_t)t) / (from_hz / to_hz);
   41eac:	f203 30e7 	addw	r0, r3, #999	; 0x3e7
   41eb0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   41eb4:	fbb0 f0f3 	udiv	r0, r0, r3
		z_set_timeout_expiry(ticks -
   41eb8:	2101      	movs	r1, #1
   41eba:	1a28      	subs	r0, r5, r0
   41ebc:	f006 fe61 	bl	48b82 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   41ec0:	f004 fc62 	bl	46788 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   41ec4:	2001      	movs	r0, #1
   41ec6:	f7ff ff39 	bl	41d3c <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41eca:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41ecc:	4b1d      	ldr	r3, [pc, #116]	; (41f44 <pm_system_suspend+0xf4>)
   41ece:	fa02 f208 	lsl.w	r2, r2, r8
   41ed2:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   41ed6:	e8d3 1fef 	ldaex	r1, [r3]
   41eda:	4311      	orrs	r1, r2
   41edc:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41ee0:	2800      	cmp	r0, #0
   41ee2:	d1f8      	bne.n	41ed6 <pm_system_suspend+0x86>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   41ee4:	230c      	movs	r3, #12
   41ee6:	fb03 6404 	mla	r4, r3, r4, r6
   41eea:	ab05      	add	r3, sp, #20
   41eec:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   41ef0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   41ef4:	4a14      	ldr	r2, [pc, #80]	; (41f48 <pm_system_suspend+0xf8>)
   41ef6:	b11a      	cbz	r2, 41f00 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
   41ef8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41efc:	f005 fddc 	bl	47ab8 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   41f00:	f7ff ff66 	bl	41dd0 <pm_system_resume>
	k_sched_unlock();
   41f04:	f004 fe1a 	bl	46b3c <k_sched_unlock>
	bool ret = true;
   41f08:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   41f0a:	2301      	movs	r3, #1
   41f0c:	fa03 f808 	lsl.w	r8, r3, r8
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41f10:	ea6f 0808 	mvn.w	r8, r8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41f14:	4b0d      	ldr	r3, [pc, #52]	; (41f4c <pm_system_suspend+0xfc>)
   41f16:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   41f1a:	e8d7 3fef 	ldaex	r3, [r7]
   41f1e:	ea03 0308 	and.w	r3, r3, r8
   41f22:	e8c7 3fe2 	stlex	r2, r3, [r7]
   41f26:	2a00      	cmp	r2, #0
   41f28:	d1f7      	bne.n	41f1a <pm_system_suspend+0xca>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   41f2a:	b008      	add	sp, #32
   41f2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else {
			return t / ((uint64_t)from_hz / to_hz);
   41f30:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   41f34:	2300      	movs	r3, #0
   41f36:	f7fe f905 	bl	40144 <__aeabi_uldivmod>
   41f3a:	e7bd      	b.n	41eb8 <pm_system_suspend+0x68>
   41f3c:	2001ad6c 	.word	0x2001ad6c
   41f40:	2001a8e8 	.word	0x2001a8e8
   41f44:	2001a8e4 	.word	0x2001a8e4
   41f48:	00047ab9 	.word	0x00047ab9
   41f4c:	2001a8f4 	.word	0x2001a8f4

00041f50 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   41f50:	4901      	ldr	r1, [pc, #4]	; (41f58 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   41f52:	2210      	movs	r2, #16
	str	r2, [r1]
   41f54:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   41f56:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   41f58:	e000ed10 	.word	0xe000ed10

00041f5c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   41f5c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   41f5e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   41f60:	f380 8811 	msr	BASEPRI, r0
	isb
   41f64:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   41f68:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   41f6c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   41f6e:	b662      	cpsie	i
	isb
   41f70:	f3bf 8f6f 	isb	sy

	bx	lr
   41f74:	4770      	bx	lr
   41f76:	bf00      	nop

00041f78 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   41f78:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   41f7a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   41f7c:	f381 8811 	msr	BASEPRI, r1

	wfe
   41f80:	bf20      	wfe

	msr	BASEPRI, r0
   41f82:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   41f86:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   41f88:	4770      	bx	lr
   41f8a:	bf00      	nop

00041f8c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   41f8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   41f8e:	4606      	mov	r6, r0

	if (esf != NULL) {
   41f90:	460c      	mov	r4, r1
   41f92:	b301      	cbz	r1, 41fd6 <z_arm_fatal_error+0x4a>
   41f94:	4b13      	ldr	r3, [pc, #76]	; (41fe4 <z_arm_fatal_error+0x58>)
   41f96:	4d14      	ldr	r5, [pc, #80]	; (41fe8 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   41f98:	4814      	ldr	r0, [pc, #80]	; (41fec <z_arm_fatal_error+0x60>)
   41f9a:	1aed      	subs	r5, r5, r3
   41f9c:	08ed      	lsrs	r5, r5, #3
   41f9e:	01ad      	lsls	r5, r5, #6
   41fa0:	f045 0501 	orr.w	r5, r5, #1
   41fa4:	f8ad 5000 	strh.w	r5, [sp]
   41fa8:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   41fac:	6809      	ldr	r1, [r1, #0]
   41fae:	f005 fe1e 	bl	47bee <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   41fb2:	f8ad 5000 	strh.w	r5, [sp]
   41fb6:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   41fba:	68e1      	ldr	r1, [r4, #12]
   41fbc:	480c      	ldr	r0, [pc, #48]	; (41ff0 <z_arm_fatal_error+0x64>)
   41fbe:	f005 fe16 	bl	47bee <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   41fc2:	462a      	mov	r2, r5
   41fc4:	69e1      	ldr	r1, [r4, #28]
   41fc6:	480b      	ldr	r0, [pc, #44]	; (41ff4 <z_arm_fatal_error+0x68>)
   41fc8:	f005 fde4 	bl	47b94 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   41fcc:	462a      	mov	r2, r5
   41fce:	69a1      	ldr	r1, [r4, #24]
   41fd0:	4809      	ldr	r0, [pc, #36]	; (41ff8 <z_arm_fatal_error+0x6c>)
   41fd2:	f005 fddf 	bl	47b94 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   41fd6:	4621      	mov	r1, r4
   41fd8:	4630      	mov	r0, r6
}
   41fda:	b002      	add	sp, #8
   41fdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
   41fe0:	f004 b836 	b.w	46050 <z_fatal_error>
   41fe4:	00048f58 	.word	0x00048f58
   41fe8:	00048f90 	.word	0x00048f90
   41fec:	00049567 	.word	0x00049567
   41ff0:	00049596 	.word	0x00049596
   41ff4:	000495c5 	.word	0x000495c5
   41ff8:	000495d4 	.word	0x000495d4

00041ffc <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   41ffc:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   41ffe:	2b00      	cmp	r3, #0
   42000:	db08      	blt.n	42014 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42002:	2201      	movs	r2, #1
   42004:	f000 001f 	and.w	r0, r0, #31
   42008:	fa02 f000 	lsl.w	r0, r2, r0
   4200c:	4a02      	ldr	r2, [pc, #8]	; (42018 <arch_irq_enable+0x1c>)
   4200e:	095b      	lsrs	r3, r3, #5
   42010:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   42014:	4770      	bx	lr
   42016:	bf00      	nop
   42018:	e000e100 	.word	0xe000e100

0004201c <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   4201c:	4b05      	ldr	r3, [pc, #20]	; (42034 <arch_irq_is_enabled+0x18>)
   4201e:	0942      	lsrs	r2, r0, #5
   42020:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   42024:	2301      	movs	r3, #1
   42026:	f000 001f 	and.w	r0, r0, #31
   4202a:	fa03 f000 	lsl.w	r0, r3, r0
}
   4202e:	4010      	ands	r0, r2
   42030:	4770      	bx	lr
   42032:	bf00      	nop
   42034:	e000e100 	.word	0xe000e100

00042038 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   42038:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   4203a:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   4203c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42040:	bfac      	ite	ge
   42042:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42046:	4b06      	ldrlt	r3, [pc, #24]	; (42060 <z_arm_irq_priority_set+0x28>)
   42048:	ea4f 1141 	mov.w	r1, r1, lsl #5
   4204c:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   4204e:	bfab      	itete	ge
   42050:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42054:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42058:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   4205c:	5419      	strblt	r1, [r3, r0]
}
   4205e:	4770      	bx	lr
   42060:	e000ed14 	.word	0xe000ed14

00042064 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   42064:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   42066:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   42068:	4b04      	ldr	r3, [pc, #16]	; (4207c <_arch_isr_direct_pm+0x18>)
   4206a:	699a      	ldr	r2, [r3, #24]
   4206c:	b11a      	cbz	r2, 42076 <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   4206e:	2200      	movs	r2, #0
   42070:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   42072:	f006 fc54 	bl	4891e <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   42076:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   42078:	bd08      	pop	{r3, pc}
   4207a:	bf00      	nop
   4207c:	2001ad6c 	.word	0x2001ad6c

00042080 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   42080:	bf30      	wfi
    b z_SysNmiOnReset
   42082:	f7ff bffd 	b.w	42080 <z_SysNmiOnReset>
   42086:	bf00      	nop

00042088 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   42088:	4a0b      	ldr	r2, [pc, #44]	; (420b8 <z_arm_prep_c+0x30>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   4208a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   4208c:	4b0b      	ldr	r3, [pc, #44]	; (420bc <z_arm_prep_c+0x34>)
   4208e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   42092:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   42094:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42098:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   4209c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   420a0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   420a4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   420a8:	f004 f878 	bl	4619c <z_bss_zero>
	z_data_copy();
   420ac:	f004 fe68 	bl	46d80 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   420b0:	f000 fb06 	bl	426c0 <z_arm_interrupt_init>
	z_cstart();
   420b4:	f004 f87c 	bl	461b0 <z_cstart>
   420b8:	00040000 	.word	0x00040000
   420bc:	e000ed00 	.word	0xe000ed00

000420c0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   420c0:	4a09      	ldr	r2, [pc, #36]	; (420e8 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   420c2:	490a      	ldr	r1, [pc, #40]	; (420ec <arch_swap+0x2c>)
	_current->arch.basepri = key;
   420c4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   420c6:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   420c8:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   420ca:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   420cc:	4908      	ldr	r1, [pc, #32]	; (420f0 <arch_swap+0x30>)
   420ce:	684b      	ldr	r3, [r1, #4]
   420d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   420d4:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   420d6:	2300      	movs	r3, #0
   420d8:	f383 8811 	msr	BASEPRI, r3
   420dc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   420e0:	6893      	ldr	r3, [r2, #8]
}
   420e2:	6f98      	ldr	r0, [r3, #120]	; 0x78
   420e4:	4770      	bx	lr
   420e6:	bf00      	nop
   420e8:	2001ad6c 	.word	0x2001ad6c
   420ec:	000491c0 	.word	0x000491c0
   420f0:	e000ed00 	.word	0xe000ed00

000420f4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   420f4:	4915      	ldr	r1, [pc, #84]	; (4214c <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   420f6:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   420f8:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   420fc:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   42100:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   42102:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   42106:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   4210a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   4210c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   42110:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   42114:	4f0e      	ldr	r7, [pc, #56]	; (42150 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   42116:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   4211a:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   4211c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   4211e:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   42120:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   42124:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   42126:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   42128:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   4212a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   4212e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   42132:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   42136:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   4213a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   4213e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   42140:	f006 f80c 	bl	4815c <configure_builtin_stack_guard>
    pop {r2, lr}
   42144:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   42148:	4770      	bx	lr
   4214a:	0000      	.short	0x0000
    ldr r1, =_kernel
   4214c:	2001ad6c 	.word	0x2001ad6c
    ldr v4, =_SCS_ICSR
   42150:	e000ed04 	.word	0xe000ed04

00042154 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   42154:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   42158:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   4215a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   4215e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   42162:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   42164:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   42168:	2902      	cmp	r1, #2
    beq _oops
   4216a:	d0ff      	beq.n	4216c <_oops>

0004216c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   4216c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   4216e:	f005 ffe6 	bl	4813e <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   42172:	bd01      	pop	{r0, pc}

00042174 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   42174:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   42178:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   4217a:	490c      	ldr	r1, [pc, #48]	; (421ac <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   4217c:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   42180:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   42182:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   42186:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   4218a:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   4218c:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   42190:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   42194:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   42198:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   4219c:	2300      	movs	r3, #0
   4219e:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   421a0:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   421a4:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   421a6:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   421a8:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   421aa:	4770      	bx	lr
   421ac:	00047657 	.word	0x00047657

000421b0 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   421b0:	4b08      	ldr	r3, [pc, #32]	; (421d4 <arch_switch_to_main_thread+0x24>)
   421b2:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   421b4:	6e43      	ldr	r3, [r0, #100]	; 0x64
   421b6:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   421ba:	4610      	mov	r0, r2
   421bc:	f381 8809 	msr	PSP, r1
   421c0:	2100      	movs	r1, #0
   421c2:	b663      	cpsie	if
   421c4:	f381 8811 	msr	BASEPRI, r1
   421c8:	f3bf 8f6f 	isb	sy
   421cc:	2200      	movs	r2, #0
   421ce:	2300      	movs	r3, #0
   421d0:	f005 fa41 	bl	47656 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   421d4:	2001ad6c 	.word	0x2001ad6c

000421d8 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   421d8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   421da:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   421dc:	4a0b      	ldr	r2, [pc, #44]	; (4220c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   421de:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   421e0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   421e2:	bf1e      	ittt	ne
	movne	r1, #0
   421e4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   421e6:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   421e8:	f006 fb99 	blne	4891e <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   421ec:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   421ee:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   421f2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   421f6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   421fa:	4905      	ldr	r1, [pc, #20]	; (42210 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   421fc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   421fe:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   42200:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   42202:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   42206:	4903      	ldr	r1, [pc, #12]	; (42214 <_isr_wrapper+0x3c>)
	bx r1
   42208:	4708      	bx	r1
   4220a:	0000      	.short	0x0000
	ldr r2, =_kernel
   4220c:	2001ad6c 	.word	0x2001ad6c
	ldr r1, =_sw_isr_table
   42210:	00048d50 	.word	0x00048d50
	ldr r1, =z_arm_int_exit
   42214:	00042219 	.word	0x00042219

00042218 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   42218:	4b04      	ldr	r3, [pc, #16]	; (4222c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   4221a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   4221c:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   4221e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   42220:	d003      	beq.n	4222a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   42222:	4903      	ldr	r1, [pc, #12]	; (42230 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   42224:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   42228:	600a      	str	r2, [r1, #0]

0004222a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   4222a:	4770      	bx	lr
	ldr r3, =_kernel
   4222c:	2001ad6c 	.word	0x2001ad6c
	ldr r1, =_SCS_ICSR
   42230:	e000ed04 	.word	0xe000ed04

00042234 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
   42234:	b570      	push	{r4, r5, r6, lr}
   42236:	4b28      	ldr	r3, [pc, #160]	; (422d8 <usage_fault.isra.0+0xa4>)
   42238:	4c28      	ldr	r4, [pc, #160]	; (422dc <usage_fault.isra.0+0xa8>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4223a:	4d29      	ldr	r5, [pc, #164]	; (422e0 <usage_fault.isra.0+0xac>)
   4223c:	1ae4      	subs	r4, r4, r3
   4223e:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
   42240:	01a4      	lsls	r4, r4, #6
   42242:	f044 0601 	orr.w	r6, r4, #1
   42246:	4631      	mov	r1, r6
   42248:	4826      	ldr	r0, [pc, #152]	; (422e4 <usage_fault.isra.0+0xb0>)
   4224a:	f005 fc96 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4224e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42250:	0193      	lsls	r3, r2, #6
   42252:	d503      	bpl.n	4225c <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
   42254:	4631      	mov	r1, r6
   42256:	4824      	ldr	r0, [pc, #144]	; (422e8 <usage_fault.isra.0+0xb4>)
   42258:	f005 fc8f 	bl	47b7a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   4225c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4225e:	01dd      	lsls	r5, r3, #7
   42260:	d504      	bpl.n	4226c <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
   42262:	4822      	ldr	r0, [pc, #136]	; (422ec <usage_fault.isra.0+0xb8>)
   42264:	f044 0101 	orr.w	r1, r4, #1
   42268:	f005 fc87 	bl	47b7a <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   4226c:	4d1c      	ldr	r5, [pc, #112]	; (422e0 <usage_fault.isra.0+0xac>)
   4226e:	6aae      	ldr	r6, [r5, #40]	; 0x28
   42270:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   42274:	d005      	beq.n	42282 <usage_fault.isra.0+0x4e>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   42276:	481e      	ldr	r0, [pc, #120]	; (422f0 <usage_fault.isra.0+0xbc>)
   42278:	f044 0101 	orr.w	r1, r4, #1
   4227c:	f005 fc7d 	bl	47b7a <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   42280:	2602      	movs	r6, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   42282:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42284:	0318      	lsls	r0, r3, #12
   42286:	d504      	bpl.n	42292 <usage_fault.isra.0+0x5e>
		PR_FAULT_INFO("  No coprocessor instructions");
   42288:	481a      	ldr	r0, [pc, #104]	; (422f4 <usage_fault.isra.0+0xc0>)
   4228a:	f044 0101 	orr.w	r1, r4, #1
   4228e:	f005 fc74 	bl	47b7a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   42292:	4d13      	ldr	r5, [pc, #76]	; (422e0 <usage_fault.isra.0+0xac>)
   42294:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42296:	0351      	lsls	r1, r2, #13
   42298:	d504      	bpl.n	422a4 <usage_fault.isra.0+0x70>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   4229a:	4817      	ldr	r0, [pc, #92]	; (422f8 <usage_fault.isra.0+0xc4>)
   4229c:	f044 0101 	orr.w	r1, r4, #1
   422a0:	f005 fc6b 	bl	47b7a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   422a4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422a6:	039a      	lsls	r2, r3, #14
   422a8:	d504      	bpl.n	422b4 <usage_fault.isra.0+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   422aa:	4814      	ldr	r0, [pc, #80]	; (422fc <usage_fault.isra.0+0xc8>)
   422ac:	f044 0101 	orr.w	r1, r4, #1
   422b0:	f005 fc63 	bl	47b7a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   422b4:	4d0a      	ldr	r5, [pc, #40]	; (422e0 <usage_fault.isra.0+0xac>)
   422b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   422b8:	03db      	lsls	r3, r3, #15
   422ba:	d504      	bpl.n	422c6 <usage_fault.isra.0+0x92>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   422bc:	4810      	ldr	r0, [pc, #64]	; (42300 <usage_fault.isra.0+0xcc>)
   422be:	f044 0101 	orr.w	r1, r4, #1
   422c2:	f005 fc5a 	bl	47b7a <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   422c6:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
   422c8:	4630      	mov	r0, r6
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   422ca:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   422ce:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   422d2:	62ab      	str	r3, [r5, #40]	; 0x28
}
   422d4:	bd70      	pop	{r4, r5, r6, pc}
   422d6:	bf00      	nop
   422d8:	00048f58 	.word	0x00048f58
   422dc:	00048f90 	.word	0x00048f90
   422e0:	e000ed00 	.word	0xe000ed00
   422e4:	00049602 	.word	0x00049602
   422e8:	0004961a 	.word	0x0004961a
   422ec:	0004962d 	.word	0x0004962d
   422f0:	00049647 	.word	0x00049647
   422f4:	00049671 	.word	0x00049671
   422f8:	0004968f 	.word	0x0004968f
   422fc:	000496b4 	.word	0x000496b4
   42300:	000496ce 	.word	0x000496ce

00042304 <mem_manage_fault.isra.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   42308:	4b28      	ldr	r3, [pc, #160]	; (423ac <mem_manage_fault.isra.0+0xa8>)
   4230a:	4c29      	ldr	r4, [pc, #164]	; (423b0 <mem_manage_fault.isra.0+0xac>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   4230c:	4d29      	ldr	r5, [pc, #164]	; (423b4 <mem_manage_fault.isra.0+0xb0>)
   4230e:	1ae4      	subs	r4, r4, r3
   42310:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
   42312:	01a4      	lsls	r4, r4, #6
   42314:	f044 0801 	orr.w	r8, r4, #1
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42318:	4607      	mov	r7, r0
   4231a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   4231c:	4826      	ldr	r0, [pc, #152]	; (423b8 <mem_manage_fault.isra.0+0xb4>)
   4231e:	4641      	mov	r1, r8
   42320:	f005 fc2b 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42324:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42326:	06d0      	lsls	r0, r2, #27
   42328:	d503      	bpl.n	42332 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
   4232a:	4641      	mov	r1, r8
   4232c:	4823      	ldr	r0, [pc, #140]	; (423bc <mem_manage_fault.isra.0+0xb8>)
   4232e:	f005 fc24 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   42332:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42334:	0719      	lsls	r1, r3, #28
   42336:	d504      	bpl.n	42342 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42338:	4821      	ldr	r0, [pc, #132]	; (423c0 <mem_manage_fault.isra.0+0xbc>)
   4233a:	f044 0101 	orr.w	r1, r4, #1
   4233e:	f005 fc1c 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   42342:	4d1c      	ldr	r5, [pc, #112]	; (423b4 <mem_manage_fault.isra.0+0xb0>)
   42344:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42346:	079a      	lsls	r2, r3, #30
   42348:	d512      	bpl.n	42370 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
   4234a:	f044 0801 	orr.w	r8, r4, #1
   4234e:	4641      	mov	r1, r8
   42350:	481c      	ldr	r0, [pc, #112]	; (423c4 <mem_manage_fault.isra.0+0xc0>)
   42352:	f005 fc12 	bl	47b7a <log_0>
		uint32_t temp = SCB->MMFAR;
   42356:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   42358:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4235a:	061b      	lsls	r3, r3, #24
   4235c:	d508      	bpl.n	42370 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   4235e:	4642      	mov	r2, r8
   42360:	4819      	ldr	r0, [pc, #100]	; (423c8 <mem_manage_fault.isra.0+0xc4>)
   42362:	f005 fc17 	bl	47b94 <log_1>
			if (from_hard_fault != 0) {
   42366:	b11f      	cbz	r7, 42370 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   42368:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4236a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   4236e:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   42370:	4d10      	ldr	r5, [pc, #64]	; (423b4 <mem_manage_fault.isra.0+0xb0>)
   42372:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42374:	07d0      	lsls	r0, r2, #31
   42376:	d504      	bpl.n	42382 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
   42378:	4814      	ldr	r0, [pc, #80]	; (423cc <mem_manage_fault.isra.0+0xc8>)
   4237a:	f044 0101 	orr.w	r1, r4, #1
   4237e:	f005 fbfc 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   42382:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42384:	0699      	lsls	r1, r3, #26
   42386:	d504      	bpl.n	42392 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
   42388:	4811      	ldr	r0, [pc, #68]	; (423d0 <mem_manage_fault.isra.0+0xcc>)
   4238a:	f044 0101 	orr.w	r1, r4, #1
   4238e:	f005 fbf4 	bl	47b7a <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   42392:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   42394:	4b07      	ldr	r3, [pc, #28]	; (423b4 <mem_manage_fault.isra.0+0xb0>)
   42396:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   42398:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   4239a:	bf58      	it	pl
   4239c:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   4239e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   423a0:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   423a4:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   423a6:	7030      	strb	r0, [r6, #0]
}
   423a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   423ac:	00048f58 	.word	0x00048f58
   423b0:	00048f90 	.word	0x00048f90
   423b4:	e000ed00 	.word	0xe000ed00
   423b8:	000496f9 	.word	0x000496f9
   423bc:	0004970f 	.word	0x0004970f
   423c0:	00049742 	.word	0x00049742
   423c4:	00049755 	.word	0x00049755
   423c8:	0004976d 	.word	0x0004976d
   423cc:	00049783 	.word	0x00049783
   423d0:	000497a2 	.word	0x000497a2

000423d4 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   423d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   423d8:	4b2a      	ldr	r3, [pc, #168]	; (42484 <bus_fault.isra.0+0xb0>)
   423da:	4c2b      	ldr	r4, [pc, #172]	; (42488 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   423dc:	4d2b      	ldr	r5, [pc, #172]	; (4248c <bus_fault.isra.0+0xb8>)
   423de:	1ae4      	subs	r4, r4, r3
   423e0:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
   423e2:	01a4      	lsls	r4, r4, #6
   423e4:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   423e8:	4607      	mov	r7, r0
   423ea:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   423ec:	4828      	ldr	r0, [pc, #160]	; (42490 <bus_fault.isra.0+0xbc>)
   423ee:	4641      	mov	r1, r8
   423f0:	f005 fbc3 	bl	47b7a <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   423f4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   423f6:	04d1      	lsls	r1, r2, #19
   423f8:	d503      	bpl.n	42402 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
   423fa:	4641      	mov	r1, r8
   423fc:	4825      	ldr	r0, [pc, #148]	; (42494 <bus_fault.isra.0+0xc0>)
   423fe:	f005 fbbc 	bl	47b7a <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   42402:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42404:	051a      	lsls	r2, r3, #20
   42406:	d504      	bpl.n	42412 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42408:	4823      	ldr	r0, [pc, #140]	; (42498 <bus_fault.isra.0+0xc4>)
   4240a:	f044 0101 	orr.w	r1, r4, #1
   4240e:	f005 fbb4 	bl	47b7a <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   42412:	4d1e      	ldr	r5, [pc, #120]	; (4248c <bus_fault.isra.0+0xb8>)
   42414:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42416:	059b      	lsls	r3, r3, #22
   42418:	d512      	bpl.n	42440 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
   4241a:	f044 0801 	orr.w	r8, r4, #1
   4241e:	4641      	mov	r1, r8
   42420:	481e      	ldr	r0, [pc, #120]	; (4249c <bus_fault.isra.0+0xc8>)
   42422:	f005 fbaa 	bl	47b7a <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   42426:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   42428:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4242a:	0418      	lsls	r0, r3, #16
   4242c:	d508      	bpl.n	42440 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   4242e:	4642      	mov	r2, r8
   42430:	481b      	ldr	r0, [pc, #108]	; (424a0 <bus_fault.isra.0+0xcc>)
   42432:	f005 fbaf 	bl	47b94 <log_1>
			if (from_hard_fault != 0) {
   42436:	b11f      	cbz	r7, 42440 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   42438:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4243a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   4243e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   42440:	4d12      	ldr	r5, [pc, #72]	; (4248c <bus_fault.isra.0+0xb8>)
   42442:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42444:	0559      	lsls	r1, r3, #21
   42446:	d504      	bpl.n	42452 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
   42448:	4816      	ldr	r0, [pc, #88]	; (424a4 <bus_fault.isra.0+0xd0>)
   4244a:	f044 0101 	orr.w	r1, r4, #1
   4244e:	f005 fb94 	bl	47b7a <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   42452:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42454:	05da      	lsls	r2, r3, #23
   42456:	d50d      	bpl.n	42474 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
   42458:	4813      	ldr	r0, [pc, #76]	; (424a8 <bus_fault.isra.0+0xd4>)
   4245a:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4245e:	f005 fb8c 	bl	47b7a <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   42462:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   42464:	4a09      	ldr	r2, [pc, #36]	; (4248c <bus_fault.isra.0+0xb8>)
   42466:	6a93      	ldr	r3, [r2, #40]	; 0x28
   42468:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   4246c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   4246e:	7030      	strb	r0, [r6, #0]
}
   42470:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   42474:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42476:	049b      	lsls	r3, r3, #18
   42478:	d5f3      	bpl.n	42462 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4247a:	480c      	ldr	r0, [pc, #48]	; (424ac <bus_fault.isra.0+0xd8>)
   4247c:	f044 0101 	orr.w	r1, r4, #1
   42480:	e7ed      	b.n	4245e <bus_fault.isra.0+0x8a>
   42482:	bf00      	nop
   42484:	00048f58 	.word	0x00048f58
   42488:	00048f90 	.word	0x00048f90
   4248c:	e000ed00 	.word	0xe000ed00
   42490:	000497d1 	.word	0x000497d1
   42494:	000497e7 	.word	0x000497e7
   42498:	00049742 	.word	0x00049742
   4249c:	000497f8 	.word	0x000497f8
   424a0:	00049811 	.word	0x00049811
   424a4:	00049826 	.word	0x00049826
   424a8:	00049841 	.word	0x00049841
   424ac:	000497a2 	.word	0x000497a2

000424b0 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   424b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   424b4:	4b68      	ldr	r3, [pc, #416]	; (42658 <z_arm_fault+0x1a8>)
{
   424b6:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   424b8:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   424bc:	4689      	mov	r9, r1
   424be:	4614      	mov	r4, r2
   424c0:	2700      	movs	r7, #0
   424c2:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   424c4:	f3c8 0608 	ubfx	r6, r8, #0, #9
   424c8:	f387 8811 	msr	BASEPRI, r7
   424cc:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   424d0:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   424d4:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   424d8:	d124      	bne.n	42524 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   424da:	07d0      	lsls	r0, r2, #31
   424dc:	d422      	bmi.n	42524 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   424de:	0651      	lsls	r1, r2, #25
   424e0:	d403      	bmi.n	424ea <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   424e2:	0722      	lsls	r2, r4, #28
   424e4:	d40e      	bmi.n	42504 <z_arm_fault+0x54>
			*nested_exc = true;
   424e6:	2701      	movs	r7, #1
   424e8:	e00e      	b.n	42508 <z_arm_fault+0x58>
   424ea:	495c      	ldr	r1, [pc, #368]	; (4265c <z_arm_fault+0x1ac>)
   424ec:	4b5c      	ldr	r3, [pc, #368]	; (42660 <z_arm_fault+0x1b0>)
		PR_FAULT_INFO("Exception occurred in Secure State");
   424ee:	485d      	ldr	r0, [pc, #372]	; (42664 <z_arm_fault+0x1b4>)
   424f0:	1a5b      	subs	r3, r3, r1
   424f2:	08db      	lsrs	r3, r3, #3
   424f4:	019b      	lsls	r3, r3, #6
   424f6:	f043 0101 	orr.w	r1, r3, #1
   424fa:	f005 fb3e 	bl	47b7a <log_0>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   424fe:	f014 0704 	ands.w	r7, r4, #4
   42502:	d001      	beq.n	42508 <z_arm_fault+0x58>
			ptr_esf = (z_arch_esf_t *)psp;
   42504:	464d      	mov	r5, r9
	*nested_exc = false;
   42506:	2700      	movs	r7, #0
	*recoverable = false;
   42508:	2300      	movs	r3, #0
   4250a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   4250e:	1ef3      	subs	r3, r6, #3
   42510:	2b09      	cmp	r3, #9
   42512:	f200 8088 	bhi.w	42626 <z_arm_fault+0x176>
   42516:	e8df f003 	tbb	[pc, r3]
   4251a:	7507      	.short	0x7507
   4251c:	86867279 	.word	0x86867279
   42520:	7d868686 	.word	0x7d868686
		return NULL;
   42524:	463d      	mov	r5, r7
   42526:	e7ef      	b.n	42508 <z_arm_fault+0x58>
	*recoverable = false;
   42528:	f04f 0800 	mov.w	r8, #0
   4252c:	4a4b      	ldr	r2, [pc, #300]	; (4265c <z_arm_fault+0x1ac>)
   4252e:	4e4c      	ldr	r6, [pc, #304]	; (42660 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** HARD FAULT *****");
   42530:	484d      	ldr	r0, [pc, #308]	; (42668 <z_arm_fault+0x1b8>)
   42532:	1ab6      	subs	r6, r6, r2
   42534:	08f6      	lsrs	r6, r6, #3
   42536:	01b6      	lsls	r6, r6, #6
   42538:	f046 0601 	orr.w	r6, r6, #1
   4253c:	4631      	mov	r1, r6
   4253e:	f005 fb1c 	bl	47b7a <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42542:	4b45      	ldr	r3, [pc, #276]	; (42658 <z_arm_fault+0x1a8>)
	*recoverable = false;
   42544:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42548:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   4254a:	f014 0402 	ands.w	r4, r4, #2
   4254e:	d005      	beq.n	4255c <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
   42550:	4631      	mov	r1, r6
   42552:	4846      	ldr	r0, [pc, #280]	; (4266c <z_arm_fault+0x1bc>)
	PR_FAULT_INFO(
   42554:	f005 fb11 	bl	47b7a <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   42558:	2400      	movs	r4, #0
}
   4255a:	e006      	b.n	4256a <z_arm_fault+0xba>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   4255c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   4255e:	2a00      	cmp	r2, #0
   42560:	da1d      	bge.n	4259e <z_arm_fault+0xee>
		PR_EXC("  Debug event");
   42562:	4631      	mov	r1, r6
   42564:	4842      	ldr	r0, [pc, #264]	; (42670 <z_arm_fault+0x1c0>)
   42566:	f005 fb08 	bl	47b7a <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   4256a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   4256e:	b99b      	cbnz	r3, 42598 <z_arm_fault+0xe8>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   42570:	2220      	movs	r2, #32
   42572:	4629      	mov	r1, r5
   42574:	a802      	add	r0, sp, #8
   42576:	f005 fe5d 	bl	48234 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   4257a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   4257c:	2f00      	cmp	r7, #0
   4257e:	d066      	beq.n	4264e <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   42580:	f3c3 0208 	ubfx	r2, r3, #0, #9
   42584:	b922      	cbnz	r2, 42590 <z_arm_fault+0xe0>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   42586:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   4258a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4258e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   42590:	4620      	mov	r0, r4
   42592:	a902      	add	r1, sp, #8
   42594:	f7ff fcfa 	bl	41f8c <z_arm_fatal_error>
}
   42598:	b00b      	add	sp, #44	; 0x2c
   4259a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   4259e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   425a0:	005b      	lsls	r3, r3, #1
   425a2:	d5e2      	bpl.n	4256a <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   425a4:	4631      	mov	r1, r6
   425a6:	4833      	ldr	r0, [pc, #204]	; (42674 <z_arm_fault+0x1c4>)
   425a8:	f005 fae7 	bl	47b7a <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
   425ac:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   425ae:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   425b2:	f64d 7302 	movw	r3, #57090	; 0xdf02
   425b6:	429a      	cmp	r2, r3
   425b8:	d00c      	beq.n	425d4 <z_arm_fault+0x124>
		} else if (SCB_MMFSR != 0) {
   425ba:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   425be:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   425c2:	781b      	ldrb	r3, [r3, #0]
   425c4:	b16b      	cbz	r3, 425e2 <z_arm_fault+0x132>
			reason = mem_manage_fault(esf, 1, recoverable);
   425c6:	2001      	movs	r0, #1
   425c8:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   425cc:	f7ff fe9a 	bl	42304 <mem_manage_fault.isra.0>
   425d0:	4604      	mov	r4, r0
		break;
   425d2:	e7ca      	b.n	4256a <z_arm_fault+0xba>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   425d4:	4632      	mov	r2, r6
   425d6:	6829      	ldr	r1, [r5, #0]
   425d8:	4827      	ldr	r0, [pc, #156]	; (42678 <z_arm_fault+0x1c8>)
   425da:	f005 fadb 	bl	47b94 <log_1>
			reason = esf->basic.r0;
   425de:	682c      	ldr	r4, [r5, #0]
   425e0:	e7c3      	b.n	4256a <z_arm_fault+0xba>
		} else if (SCB_BFSR != 0) {
   425e2:	4b26      	ldr	r3, [pc, #152]	; (4267c <z_arm_fault+0x1cc>)
   425e4:	781b      	ldrb	r3, [r3, #0]
   425e6:	b12b      	cbz	r3, 425f4 <z_arm_fault+0x144>
			reason = bus_fault(esf, 1, recoverable);
   425e8:	2001      	movs	r0, #1
   425ea:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   425ee:	f7ff fef1 	bl	423d4 <bus_fault.isra.0>
   425f2:	e7ed      	b.n	425d0 <z_arm_fault+0x120>
		} else if (SCB_UFSR != 0) {
   425f4:	4b22      	ldr	r3, [pc, #136]	; (42680 <z_arm_fault+0x1d0>)
   425f6:	881b      	ldrh	r3, [r3, #0]
   425f8:	b29b      	uxth	r3, r3
   425fa:	2b00      	cmp	r3, #0
   425fc:	d0b5      	beq.n	4256a <z_arm_fault+0xba>
		reason = usage_fault(esf);
   425fe:	f7ff fe19 	bl	42234 <usage_fault.isra.0>
   42602:	e7e5      	b.n	425d0 <z_arm_fault+0x120>
		reason = mem_manage_fault(esf, 0, recoverable);
   42604:	2000      	movs	r0, #0
   42606:	f10d 0107 	add.w	r1, sp, #7
   4260a:	e7df      	b.n	425cc <z_arm_fault+0x11c>
		reason = bus_fault(esf, 0, recoverable);
   4260c:	2000      	movs	r0, #0
   4260e:	f10d 0107 	add.w	r1, sp, #7
   42612:	e7ec      	b.n	425ee <z_arm_fault+0x13e>
   42614:	4912      	ldr	r1, [pc, #72]	; (42660 <z_arm_fault+0x1b0>)
   42616:	4b11      	ldr	r3, [pc, #68]	; (4265c <z_arm_fault+0x1ac>)
	PR_FAULT_INFO(
   42618:	481a      	ldr	r0, [pc, #104]	; (42684 <z_arm_fault+0x1d4>)
   4261a:	1ac9      	subs	r1, r1, r3
   4261c:	08c9      	lsrs	r1, r1, #3
   4261e:	0189      	lsls	r1, r1, #6
   42620:	f041 0101 	orr.w	r1, r1, #1
   42624:	e796      	b.n	42554 <z_arm_fault+0xa4>
   42626:	4a0d      	ldr	r2, [pc, #52]	; (4265c <z_arm_fault+0x1ac>)
   42628:	4b0d      	ldr	r3, [pc, #52]	; (42660 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** %s %d) *****",
   4262a:	4817      	ldr	r0, [pc, #92]	; (42688 <z_arm_fault+0x1d8>)
   4262c:	1a9b      	subs	r3, r3, r2
   4262e:	08db      	lsrs	r3, r3, #3
   42630:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   42634:	ea4f 1383 	mov.w	r3, r3, lsl #6
   42638:	4914      	ldr	r1, [pc, #80]	; (4268c <z_arm_fault+0x1dc>)
   4263a:	f043 0301 	orr.w	r3, r3, #1
   4263e:	bf18      	it	ne
   42640:	4601      	movne	r1, r0
   42642:	f1a6 0210 	sub.w	r2, r6, #16
   42646:	4812      	ldr	r0, [pc, #72]	; (42690 <z_arm_fault+0x1e0>)
   42648:	f005 fab8 	bl	47bbc <log_2>
   4264c:	e784      	b.n	42558 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4264e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   42652:	f023 0301 	bic.w	r3, r3, #1
   42656:	e79a      	b.n	4258e <z_arm_fault+0xde>
   42658:	e000ed00 	.word	0xe000ed00
   4265c:	00048f58 	.word	0x00048f58
   42660:	00048f90 	.word	0x00048f90
   42664:	00049859 	.word	0x00049859
   42668:	0004987c 	.word	0x0004987c
   4266c:	00049893 	.word	0x00049893
   42670:	000498b4 	.word	0x000498b4
   42674:	000498c2 	.word	0x000498c2
   42678:	000498e1 	.word	0x000498e1
   4267c:	e000ed29 	.word	0xe000ed29
   42680:	e000ed2a 	.word	0xe000ed2a
   42684:	000498fd 	.word	0x000498fd
   42688:	00049936 	.word	0x00049936
   4268c:	00049921 	.word	0x00049921
   42690:	0004994f 	.word	0x0004994f

00042694 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   42694:	4b04      	ldr	r3, [pc, #16]	; (426a8 <z_arm_fault_init+0x14>)
   42696:	695a      	ldr	r2, [r3, #20]
   42698:	f042 0210 	orr.w	r2, r2, #16
   4269c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   4269e:	695a      	ldr	r2, [r3, #20]
   426a0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   426a4:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   426a6:	4770      	bx	lr
   426a8:	e000ed00 	.word	0xe000ed00

000426ac <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   426ac:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   426b0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   426b4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   426b6:	4672      	mov	r2, lr
	bl z_arm_fault
   426b8:	f7ff fefa 	bl	424b0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   426bc:	bd01      	pop	{r0, pc}
   426be:	bf00      	nop

000426c0 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   426c0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   426c2:	2120      	movs	r1, #32
   426c4:	4803      	ldr	r0, [pc, #12]	; (426d4 <z_arm_interrupt_init+0x14>)
   426c6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   426c8:	3301      	adds	r3, #1
   426ca:	2b41      	cmp	r3, #65	; 0x41
   426cc:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   426d0:	d1f9      	bne.n	426c6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   426d2:	4770      	bx	lr
   426d4:	e000e100 	.word	0xe000e100

000426d8 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   426d8:	2000      	movs	r0, #0
    msr CONTROL, r0
   426da:	f380 8814 	msr	CONTROL, r0
    isb
   426de:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   426e2:	2000      	movs	r0, #0
    msr MSPLIM, r0
   426e4:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   426e8:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   426ec:	f006 fac2 	bl	48c74 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   426f0:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   426f2:	490e      	ldr	r1, [pc, #56]	; (4272c <__start+0x54>)
    str r0, [r1]
   426f4:	6008      	str	r0, [r1, #0]
    dsb
   426f6:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   426fa:	480d      	ldr	r0, [pc, #52]	; (42730 <__start+0x58>)
    msr msp, r0
   426fc:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   42700:	f000 f82a 	bl	42758 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   42704:	2020      	movs	r0, #32
    msr BASEPRI, r0
   42706:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   4270a:	480a      	ldr	r0, [pc, #40]	; (42734 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   4270c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   42710:	1840      	adds	r0, r0, r1
    msr PSP, r0
   42712:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   42716:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   4271a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   4271c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   4271e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   42722:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   42726:	f7ff fcaf 	bl	42088 <z_arm_prep_c>
   4272a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   4272c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42730:	200232b0 	.word	0x200232b0
    ldr r0, =z_interrupt_stacks
   42734:	200233f0 	.word	0x200233f0

00042738 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   42738:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   4273a:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   4273c:	4a05      	ldr	r2, [pc, #20]	; (42754 <z_arm_clear_arm_mpu_config+0x1c>)
   4273e:	6811      	ldr	r1, [r2, #0]
	int num_regions =
   42740:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
   42744:	428b      	cmp	r3, r1
   42746:	d100      	bne.n	4274a <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
   42748:	4770      	bx	lr
  mpu->RNR = rnr;
   4274a:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   4274c:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
   4274e:	3301      	adds	r3, #1
   42750:	e7f8      	b.n	42744 <z_arm_clear_arm_mpu_config+0xc>
   42752:	bf00      	nop
   42754:	e000ed90 	.word	0xe000ed90

00042758 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
   42758:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   4275a:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   4275c:	2400      	movs	r4, #0
   4275e:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   42762:	f7ff ffe9 	bl	42738 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   42766:	4a0e      	ldr	r2, [pc, #56]	; (427a0 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
   42768:	4623      	mov	r3, r4
   4276a:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
   4276c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   42770:	f103 0020 	add.w	r0, r3, #32
   42774:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   42776:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   42778:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   4277c:	d1f8      	bne.n	42770 <z_arm_init_arch_hw_at_boot+0x18>
   4277e:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   42780:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42784:	f103 0260 	add.w	r2, r3, #96	; 0x60
   42788:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   4278a:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   4278c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   42790:	d1f8      	bne.n	42784 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   42792:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   42794:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42798:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   4279c:	bd10      	pop	{r4, pc}
   4279e:	bf00      	nop
   427a0:	e000e100 	.word	0xe000e100

000427a4 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   427a4:	4b06      	ldr	r3, [pc, #24]	; (427c0 <z_impl_k_thread_abort+0x1c>)
   427a6:	689b      	ldr	r3, [r3, #8]
   427a8:	4283      	cmp	r3, r0
   427aa:	d107      	bne.n	427bc <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   427ac:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   427b0:	b123      	cbz	r3, 427bc <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   427b2:	4a04      	ldr	r2, [pc, #16]	; (427c4 <z_impl_k_thread_abort+0x20>)
   427b4:	6853      	ldr	r3, [r2, #4]
   427b6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   427ba:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   427bc:	f004 ba8e 	b.w	46cdc <z_thread_abort>
   427c0:	2001ad6c 	.word	0x2001ad6c
   427c4:	e000ed00 	.word	0xe000ed00

000427c8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   427c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   427ca:	4c09      	ldr	r4, [pc, #36]	; (427f0 <z_arm_configure_static_mpu_regions+0x28>)
   427cc:	4a09      	ldr	r2, [pc, #36]	; (427f4 <z_arm_configure_static_mpu_regions+0x2c>)
   427ce:	4623      	mov	r3, r4
   427d0:	2101      	movs	r1, #1
   427d2:	4809      	ldr	r0, [pc, #36]	; (427f8 <z_arm_configure_static_mpu_regions+0x30>)
   427d4:	f000 f912 	bl	429fc <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   427d8:	2300      	movs	r3, #0
   427da:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   427dc:	4b07      	ldr	r3, [pc, #28]	; (427fc <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   427de:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   427e0:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   427e2:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   427e4:	9301      	str	r3, [sp, #4]
   427e6:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   427e8:	f000 f912 	bl	42a10 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   427ec:	b004      	add	sp, #16
   427ee:	bd10      	pop	{r4, pc}
   427f0:	20040000 	.word	0x20040000
   427f4:	2001a500 	.word	0x2001a500
   427f8:	00049078 	.word	0x00049078
   427fc:	2001a658 	.word	0x2001a658

00042800 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   42800:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42802:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   42804:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42806:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   4280a:	f004 031f 	and.w	r3, r4, #31
   4280e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42810:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42812:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42814:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   42818:	4904      	ldr	r1, [pc, #16]	; (4282c <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   4281a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   4281e:	f043 0301 	orr.w	r3, r3, #1
   42822:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   42824:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   42826:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   42828:	bd10      	pop	{r4, pc}
   4282a:	bf00      	nop
   4282c:	e000ed90 	.word	0xe000ed90

00042830 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   42830:	280f      	cmp	r0, #15
{
   42832:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
   42834:	d90d      	bls.n	42852 <region_allocate_and_init+0x22>
   42836:	4b08      	ldr	r3, [pc, #32]	; (42858 <region_allocate_and_init+0x28>)
   42838:	4a08      	ldr	r2, [pc, #32]	; (4285c <region_allocate_and_init+0x2c>)

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   4283a:	4601      	mov	r1, r0
   4283c:	1ad2      	subs	r2, r2, r3
   4283e:	08d2      	lsrs	r2, r2, #3
   42840:	0192      	lsls	r2, r2, #6
   42842:	4807      	ldr	r0, [pc, #28]	; (42860 <region_allocate_and_init+0x30>)
   42844:	f042 0201 	orr.w	r2, r2, #1
   42848:	f005 f9a4 	bl	47b94 <log_1>
		return -EINVAL;
   4284c:	f06f 0015 	mvn.w	r0, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   42850:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   42852:	f7ff ffd5 	bl	42800 <region_init>
	return index;
   42856:	e7fb      	b.n	42850 <region_allocate_and_init+0x20>
   42858:	00048f58 	.word	0x00048f58
   4285c:	00048f80 	.word	0x00048f80
   42860:	00049966 	.word	0x00049966

00042864 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42864:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42868:	4689      	mov	r9, r1
   4286a:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   4286c:	4606      	mov	r6, r0
   4286e:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
   42872:	4d54      	ldr	r5, [pc, #336]	; (429c4 <mpu_configure_regions_and_partition.constprop.0+0x160>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42874:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   42876:	45c8      	cmp	r8, r9
   42878:	da33      	bge.n	428e2 <mpu_configure_regions_and_partition.constprop.0+0x7e>
		if (regions[i].size == 0U) {
   4287a:	f8d6 a004 	ldr.w	sl, [r6, #4]
   4287e:	f1ba 0f00 	cmp.w	sl, #0
   42882:	d04d      	beq.n	42920 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		&&
   42884:	f1ba 0f1f 	cmp.w	sl, #31
   42888:	d91e      	bls.n	428c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		&&
   4288a:	f01a 0f1f 	tst.w	sl, #31
   4288e:	d11b      	bne.n	428c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		((part->start &
   42890:	f8d6 b000 	ldr.w	fp, [r6]
		&&
   42894:	f01b 0f1f 	tst.w	fp, #31
   42898:	d116      	bne.n	428c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   4289a:	4658      	mov	r0, fp
   4289c:	f005 fc64 	bl	48168 <arm_cmse_mpu_region_get>
   428a0:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   428a2:	eb0a 000b 	add.w	r0, sl, fp
   428a6:	3801      	subs	r0, #1
   428a8:	f005 fc5e 	bl	48168 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   428ac:	4287      	cmp	r7, r0
   428ae:	d01c      	beq.n	428ea <mpu_configure_regions_and_partition.constprop.0+0x86>
	return -EINVAL;
   428b0:	f06f 0715 	mvn.w	r7, #21
   428b4:	4a44      	ldr	r2, [pc, #272]	; (429c8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   428b6:	4b45      	ldr	r3, [pc, #276]	; (429cc <mpu_configure_regions_and_partition.constprop.0+0x168>)
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   428b8:	4639      	mov	r1, r7
   428ba:	1ad2      	subs	r2, r2, r3
   428bc:	08d2      	lsrs	r2, r2, #3
   428be:	0192      	lsls	r2, r2, #6
   428c0:	4843      	ldr	r0, [pc, #268]	; (429d0 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
   428c2:	f042 0201 	orr.w	r2, r2, #1
   428c6:	e008      	b.n	428da <mpu_configure_regions_and_partition.constprop.0+0x76>
			LOG_ERR("Partition %u: sanity check failed.", i);
   428c8:	4641      	mov	r1, r8
   428ca:	4a3f      	ldr	r2, [pc, #252]	; (429c8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   428cc:	4b3f      	ldr	r3, [pc, #252]	; (429cc <mpu_configure_regions_and_partition.constprop.0+0x168>)
   428ce:	4841      	ldr	r0, [pc, #260]	; (429d4 <mpu_configure_regions_and_partition.constprop.0+0x170>)
   428d0:	1ad2      	subs	r2, r2, r3
   428d2:	08d2      	lsrs	r2, r2, #3
   428d4:	0192      	lsls	r2, r2, #6
   428d6:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
   428da:	f005 f95b 	bl	47b94 <log_1>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   428de:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   428e2:	4620      	mov	r0, r4
   428e4:	b005      	add	sp, #20
   428e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   428ea:	f117 0f16 	cmn.w	r7, #22
   428ee:	d0e1      	beq.n	428b4 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
   428f0:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   428f2:	42bb      	cmp	r3, r7
   428f4:	dbde      	blt.n	428b4 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
   428f6:	60af      	str	r7, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   428f8:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   428fa:	60af      	str	r7, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   428fc:	692b      	ldr	r3, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   428fe:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42902:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42906:	e9d6 3200 	ldrd	r3, r2, [r6]
   4290a:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   4290c:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   4290e:	f102 3aff 	add.w	sl, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   42912:	d11a      	bne.n	4294a <mpu_configure_regions_and_partition.constprop.0+0xe6>
   42914:	45d3      	cmp	fp, sl
   42916:	d107      	bne.n	42928 <mpu_configure_regions_and_partition.constprop.0+0xc4>
			mpu_configure_region(u_reg_index, &regions[i]);
   42918:	4631      	mov	r1, r6
   4291a:	b2f8      	uxtb	r0, r7
   4291c:	f005 fc2d 	bl	4817a <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   42920:	f108 0801 	add.w	r8, r8, #1
   42924:	360c      	adds	r6, #12
   42926:	e7a6      	b.n	42876 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   42928:	4631      	mov	r1, r6
	MPU->RNR = index;
   4292a:	60af      	str	r7, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   4292c:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   4292e:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42932:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   42936:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42938:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   4293a:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   4293c:	f005 fc1d 	bl	4817a <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42940:	f110 0f16 	cmn.w	r0, #22
   42944:	d0cb      	beq.n	428de <mpu_configure_regions_and_partition.constprop.0+0x7a>
			reg_index++;
   42946:	1c44      	adds	r4, r0, #1
   42948:	e7ea      	b.n	42920 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		} else if (reg_last == u_reg_last) {
   4294a:	3b01      	subs	r3, #1
   4294c:	45d3      	cmp	fp, sl
   4294e:	b2e0      	uxtb	r0, r4
   42950:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   42954:	60af      	str	r7, [r5, #8]
		} else if (reg_last == u_reg_last) {
   42956:	d106      	bne.n	42966 <mpu_configure_regions_and_partition.constprop.0+0x102>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42958:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   4295a:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   4295c:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42960:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42962:	612b      	str	r3, [r5, #16]
			reg_index =
   42964:	e7ea      	b.n	4293c <mpu_configure_regions_and_partition.constprop.0+0xd8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42966:	6929      	ldr	r1, [r5, #16]
   42968:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   4296c:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   4296e:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42970:	4631      	mov	r1, r6
   42972:	f005 fc02 	bl	4817a <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42976:	f110 0f16 	cmn.w	r0, #22
   4297a:	d0b0      	beq.n	428de <mpu_configure_regions_and_partition.constprop.0+0x7a>
	MPU->RNR = index;
   4297c:	60af      	str	r7, [r5, #8]
	attr->rbar = MPU->RBAR &
   4297e:	68ea      	ldr	r2, [r5, #12]
   42980:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   42984:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
	attr->rbar = MPU->RBAR &
   42988:	f362 0304 	bfi	r3, r2, #0, #5
   4298c:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42990:	692b      	ldr	r3, [r5, #16]
   42992:	f89d 2008 	ldrb.w	r2, [sp, #8]
   42996:	085b      	lsrs	r3, r3, #1
   42998:	f363 1247 	bfi	r2, r3, #5, #3
   4299c:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   429a0:	e9d6 3200 	ldrd	r3, r2, [r6]
   429a4:	4413      	add	r3, r2
   429a6:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   429a8:	f023 031f 	bic.w	r3, r3, #31
   429ac:	445b      	add	r3, fp
   429ae:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
   429b2:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   429b4:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   429b8:	4669      	mov	r1, sp
   429ba:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   429bc:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   429be:	f7ff ff37 	bl	42830 <region_allocate_and_init>
   429c2:	e7bd      	b.n	42940 <mpu_configure_regions_and_partition.constprop.0+0xdc>
   429c4:	e000ed90 	.word	0xe000ed90
   429c8:	00048f80 	.word	0x00048f80
   429cc:	00048f58 	.word	0x00048f58
   429d0:	000499af 	.word	0x000499af
   429d4:	0004998c 	.word	0x0004998c

000429d8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   429d8:	2205      	movs	r2, #5
   429da:	4b03      	ldr	r3, [pc, #12]	; (429e8 <arm_core_mpu_enable+0x10>)
   429dc:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   429de:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   429e2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   429e6:	4770      	bx	lr
   429e8:	e000ed90 	.word	0xe000ed90

000429ec <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   429ec:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   429f0:	2200      	movs	r2, #0
   429f2:	4b01      	ldr	r3, [pc, #4]	; (429f8 <arm_core_mpu_disable+0xc>)
   429f4:	605a      	str	r2, [r3, #4]
}
   429f6:	4770      	bx	lr
   429f8:	e000ed90 	.word	0xe000ed90

000429fc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   429fc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   429fe:	4c03      	ldr	r4, [pc, #12]	; (42a0c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   42a00:	7822      	ldrb	r2, [r4, #0]
   42a02:	f7ff ff2f 	bl	42864 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   42a06:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   42a08:	bd10      	pop	{r4, pc}
   42a0a:	bf00      	nop
   42a0c:	2001ae69 	.word	0x2001ae69

00042a10 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   42a10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42a14:	4d26      	ldr	r5, [pc, #152]	; (42ab0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   42a16:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42a18:	4606      	mov	r6, r0
   42a1a:	f04f 0800 	mov.w	r8, #0
   42a1e:	46ab      	mov	fp, r5
	MPU->RNR = index;
   42a20:	4f24      	ldr	r7, [pc, #144]	; (42ab4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42a22:	45d0      	cmp	r8, sl
   42a24:	da1b      	bge.n	42a5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   42a26:	f8d6 9004 	ldr.w	r9, [r6, #4]
   42a2a:	f1b9 0f00 	cmp.w	r9, #0
   42a2e:	d039      	beq.n	42aa4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   42a30:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42a32:	4608      	mov	r0, r1
   42a34:	9101      	str	r1, [sp, #4]
   42a36:	f005 fb97 	bl	48168 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42a3a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42a3c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42a3e:	eb09 0001 	add.w	r0, r9, r1
   42a42:	3801      	subs	r0, #1
   42a44:	f005 fb90 	bl	48168 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   42a48:	4284      	cmp	r4, r0
   42a4a:	f04f 0214 	mov.w	r2, #20
   42a4e:	4b1a      	ldr	r3, [pc, #104]	; (42ab8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   42a50:	d008      	beq.n	42a64 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   42a52:	f06f 0315 	mvn.w	r3, #21
   42a56:	fb02 f808 	mul.w	r8, r2, r8
   42a5a:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   42a5e:	b003      	add	sp, #12
   42a60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   42a64:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   42a68:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   42a6a:	d0f8      	beq.n	42a5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   42a6c:	7819      	ldrb	r1, [r3, #0]
   42a6e:	42a1      	cmp	r1, r4
   42a70:	ddf5      	ble.n	42a5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   42a72:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   42a76:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   42a78:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   42a7a:	68fc      	ldr	r4, [r7, #12]
   42a7c:	f100 0108 	add.w	r1, r0, #8
   42a80:	7b00      	ldrb	r0, [r0, #12]
   42a82:	f364 0004 	bfi	r0, r4, #0, #5
   42a86:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42a88:	6938      	ldr	r0, [r7, #16]
   42a8a:	790c      	ldrb	r4, [r1, #4]
   42a8c:	0840      	lsrs	r0, r0, #1
   42a8e:	f360 1447 	bfi	r4, r0, #5, #3
   42a92:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   42a94:	68f9      	ldr	r1, [r7, #12]
   42a96:	f021 011f 	bic.w	r1, r1, #31
   42a9a:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   42a9c:	6939      	ldr	r1, [r7, #16]
   42a9e:	f021 011f 	bic.w	r1, r1, #31
   42aa2:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42aa4:	f108 0801 	add.w	r8, r8, #1
   42aa8:	3514      	adds	r5, #20
   42aaa:	360c      	adds	r6, #12
   42aac:	e7b9      	b.n	42a22 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   42aae:	bf00      	nop
   42ab0:	2001a8f8 	.word	0x2001a8f8
   42ab4:	e000ed90 	.word	0xe000ed90
   42ab8:	2001ae69 	.word	0x2001ae69

00042abc <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   42abc:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   42abe:	4c0e      	ldr	r4, [pc, #56]	; (42af8 <z_arm_mpu_init+0x3c>)
   42ac0:	6825      	ldr	r5, [r4, #0]
   42ac2:	2d10      	cmp	r5, #16
   42ac4:	d814      	bhi.n	42af0 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   42ac6:	f7ff ff91 	bl	429ec <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42aca:	2000      	movs	r0, #0
	MPU->MAIR0 =
   42acc:	4b0b      	ldr	r3, [pc, #44]	; (42afc <z_arm_mpu_init+0x40>)
   42ace:	4a0c      	ldr	r2, [pc, #48]	; (42b00 <z_arm_mpu_init+0x44>)
   42ad0:	631a      	str	r2, [r3, #48]	; 0x30
   42ad2:	4285      	cmp	r5, r0
   42ad4:	d105      	bne.n	42ae2 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   42ad6:	4b0b      	ldr	r3, [pc, #44]	; (42b04 <z_arm_mpu_init+0x48>)
   42ad8:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   42ada:	f7ff ff7d 	bl	429d8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   42ade:	2000      	movs	r0, #0
}
   42ae0:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   42ae2:	6861      	ldr	r1, [r4, #4]
   42ae4:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   42ae8:	f7ff fe8a 	bl	42800 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42aec:	3001      	adds	r0, #1
   42aee:	e7f0      	b.n	42ad2 <z_arm_mpu_init+0x16>
		return -1;
   42af0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42af4:	e7f4      	b.n	42ae0 <z_arm_mpu_init+0x24>
   42af6:	bf00      	nop
   42af8:	00049084 	.word	0x00049084
   42afc:	e000ed90 	.word	0xe000ed90
   42b00:	0044ffaa 	.word	0x0044ffaa
   42b04:	2001ae69 	.word	0x2001ae69

00042b08 <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   42b08:	b508      	push	{r3, lr}
   42b0a:	4908      	ldr	r1, [pc, #32]	; (42b2c <malloc+0x24>)
   42b0c:	4b08      	ldr	r3, [pc, #32]	; (42b30 <malloc+0x28>)
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
   42b0e:	4809      	ldr	r0, [pc, #36]	; (42b34 <malloc+0x2c>)
   42b10:	1ac9      	subs	r1, r1, r3
   42b12:	08c9      	lsrs	r1, r1, #3
   42b14:	0189      	lsls	r1, r1, #6
   42b16:	f041 0101 	orr.w	r1, r1, #1
   42b1a:	f005 f82e 	bl	47b7a <log_0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   42b1e:	f003 fa91 	bl	46044 <z_impl_z_errno>
	errno = ENOMEM;
   42b22:	230c      	movs	r3, #12
   42b24:	6003      	str	r3, [r0, #0]

	return NULL;
}
   42b26:	2000      	movs	r0, #0
   42b28:	bd08      	pop	{r3, pc}
   42b2a:	bf00      	nop
   42b2c:	00048f90 	.word	0x00048f90
   42b30:	00048f58 	.word	0x00048f58
   42b34:	000499d2 	.word	0x000499d2

00042b38 <_exit>:

#include <stdlib.h>
#include <zephyr.h>

void _exit(int status)
{
   42b38:	b508      	push	{r3, lr}
	printk("exit\n");
   42b3a:	4802      	ldr	r0, [pc, #8]	; (42b44 <_exit+0xc>)
   42b3c:	f004 fcc6 	bl	474cc <printk>
	while (1) {
   42b40:	e7fe      	b.n	42b40 <_exit+0x8>
   42b42:	bf00      	nop
   42b44:	000499fd 	.word	0x000499fd

00042b48 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   42b48:	4b01      	ldr	r3, [pc, #4]	; (42b50 <__stdout_hook_install+0x8>)
   42b4a:	6018      	str	r0, [r3, #0]
}
   42b4c:	4770      	bx	lr
   42b4e:	bf00      	nop
   42b50:	2001a508 	.word	0x2001a508

00042b54 <onoff_stop>:
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42b54:	b570      	push	{r4, r5, r6, lr}
   42b56:	4604      	mov	r4, r0
	err = set_off_state(&subdata->flags, ctx);
   42b58:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   42b5a:	480d      	ldr	r0, [pc, #52]	; (42b90 <onoff_stop+0x3c>)
{
   42b5c:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
   42b5e:	1a23      	subs	r3, r4, r0
   42b60:	109a      	asrs	r2, r3, #2
   42b62:	4b0c      	ldr	r3, [pc, #48]	; (42b94 <onoff_stop+0x40>)
	err = set_off_state(&subdata->flags, ctx);
   42b64:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   42b66:	4353      	muls	r3, r2
   42b68:	b2db      	uxtb	r3, r3
	err = set_off_state(&subdata->flags, ctx);
   42b6a:	435d      	muls	r5, r3
   42b6c:	f105 0340 	add.w	r3, r5, #64	; 0x40
   42b70:	4418      	add	r0, r3
   42b72:	f005 fb7f 	bl	48274 <set_off_state>
	if (err < 0) {
   42b76:	1e01      	subs	r1, r0, #0
   42b78:	db04      	blt.n	42b84 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   42b7a:	4b07      	ldr	r3, [pc, #28]	; (42b98 <onoff_stop+0x44>)
   42b7c:	442b      	add	r3, r5
   42b7e:	685b      	ldr	r3, [r3, #4]
   42b80:	4798      	blx	r3
	return 0;
   42b82:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   42b84:	4620      	mov	r0, r4
   42b86:	4633      	mov	r3, r6
}
   42b88:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   42b8c:	4718      	bx	r3
   42b8e:	bf00      	nop
   42b90:	2001a91c 	.word	0x2001a91c
   42b94:	b6db6db7 	.word	0xb6db6db7
   42b98:	000490c4 	.word	0x000490c4

00042b9c <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42b9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   42ba0:	4c0f      	ldr	r4, [pc, #60]	; (42be0 <onoff_start+0x44>)
   42ba2:	4d10      	ldr	r5, [pc, #64]	; (42be4 <onoff_start+0x48>)
   42ba4:	1b03      	subs	r3, r0, r4
   42ba6:	109b      	asrs	r3, r3, #2
   42ba8:	435d      	muls	r5, r3
   42baa:	b2eb      	uxtb	r3, r5
	err = set_starting_state(&subdata->flags, ctx);
   42bac:	250c      	movs	r5, #12
   42bae:	435d      	muls	r5, r3
{
   42bb0:	4607      	mov	r7, r0
	err = set_starting_state(&subdata->flags, ctx);
   42bb2:	f105 0040 	add.w	r0, r5, #64	; 0x40
{
   42bb6:	460e      	mov	r6, r1
	err = set_starting_state(&subdata->flags, ctx);
   42bb8:	4420      	add	r0, r4
   42bba:	2140      	movs	r1, #64	; 0x40
   42bbc:	f005 fb73 	bl	482a6 <set_starting_state>
	if (err < 0) {
   42bc0:	1e01      	subs	r1, r0, #0
   42bc2:	db08      	blt.n	42bd6 <onoff_start+0x3a>
	subdata->cb = cb;
   42bc4:	4b08      	ldr	r3, [pc, #32]	; (42be8 <onoff_start+0x4c>)
   42bc6:	442c      	add	r4, r5
	subdata->user_data = user_data;
   42bc8:	e9c4 360e 	strd	r3, r6, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   42bcc:	4b07      	ldr	r3, [pc, #28]	; (42bec <onoff_start+0x50>)
   42bce:	595b      	ldr	r3, [r3, r5]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   42bd0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   42bd4:	4718      	bx	r3
		notify(mgr, err);
   42bd6:	4638      	mov	r0, r7
   42bd8:	4633      	mov	r3, r6
}
   42bda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   42bde:	4718      	bx	r3
   42be0:	2001a91c 	.word	0x2001a91c
   42be4:	b6db6db7 	.word	0xb6db6db7
   42be8:	00048309 	.word	0x00048309
   42bec:	000490c4 	.word	0x000490c4

00042bf0 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   42bf0:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42bf2:	2200      	movs	r2, #0
   42bf4:	2101      	movs	r1, #1
{
   42bf6:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42bf8:	2005      	movs	r0, #5
   42bfa:	f7ff fa1d 	bl	42038 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   42bfe:	2005      	movs	r0, #5
   42c00:	f7ff f9fc 	bl	41ffc <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   42c04:	480f      	ldr	r0, [pc, #60]	; (42c44 <clk_init+0x54>)
   42c06:	f001 f8ef 	bl	43de8 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   42c0a:	4b0f      	ldr	r3, [pc, #60]	; (42c48 <clk_init+0x58>)
   42c0c:	4298      	cmp	r0, r3
   42c0e:	d115      	bne.n	42c3c <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   42c10:	f005 fcb4 	bl	4857c <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   42c14:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   42c16:	490d      	ldr	r1, [pc, #52]	; (42c4c <clk_init+0x5c>)
   42c18:	4630      	mov	r0, r6
   42c1a:	f004 fcc0 	bl	4759e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   42c1e:	2800      	cmp	r0, #0
   42c20:	db0b      	blt.n	42c3a <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42c22:	2501      	movs	r5, #1
   42c24:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   42c26:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   42c28:	4908      	ldr	r1, [pc, #32]	; (42c4c <clk_init+0x5c>)
   42c2a:	f104 001c 	add.w	r0, r4, #28
   42c2e:	f004 fcb6 	bl	4759e <onoff_manager_init>
		if (err < 0) {
   42c32:	2800      	cmp	r0, #0
   42c34:	db01      	blt.n	42c3a <clk_init+0x4a>
	}

	return 0;
   42c36:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42c38:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   42c3a:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   42c3c:	f06f 0004 	mvn.w	r0, #4
   42c40:	e7fb      	b.n	42c3a <clk_init+0x4a>
   42c42:	bf00      	nop
   42c44:	00042c85 	.word	0x00042c85
   42c48:	0bad0000 	.word	0x0bad0000
   42c4c:	000490dc 	.word	0x000490dc

00042c50 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   42c50:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   42c52:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   42c54:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   42c56:	434b      	muls	r3, r1
   42c58:	4808      	ldr	r0, [pc, #32]	; (42c7c <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   42c5a:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   42c5c:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   42c5e:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   42c60:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42c64:	4418      	add	r0, r3
	sub_data->cb = NULL;
   42c66:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42c68:	f005 fb3b 	bl	482e2 <set_on_state>
	if (callback) {
   42c6c:	b12d      	cbz	r5, 42c7a <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   42c6e:	4632      	mov	r2, r6
   42c70:	462b      	mov	r3, r5
}
   42c72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   42c76:	4802      	ldr	r0, [pc, #8]	; (42c80 <clkstarted_handle.constprop.0+0x30>)
   42c78:	4718      	bx	r3
}
   42c7a:	bd70      	pop	{r4, r5, r6, pc}
   42c7c:	2001a91c 	.word	0x2001a91c
   42c80:	00048cf0 	.word	0x00048cf0

00042c84 <clock_event_handler>:
	switch (event) {
   42c84:	b110      	cbz	r0, 42c8c <clock_event_handler+0x8>
   42c86:	2801      	cmp	r0, #1
   42c88:	d004      	beq.n	42c94 <clock_event_handler+0x10>
   42c8a:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   42c8c:	4b03      	ldr	r3, [pc, #12]	; (42c9c <clock_event_handler+0x18>)
   42c8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   42c90:	075b      	lsls	r3, r3, #29
   42c92:	d101      	bne.n	42c98 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   42c94:	f7ff bfdc 	b.w	42c50 <clkstarted_handle.constprop.0>
}
   42c98:	4770      	bx	lr
   42c9a:	bf00      	nop
   42c9c:	2001a91c 	.word	0x2001a91c

00042ca0 <generic_hfclk_start>:
{
   42ca0:	b508      	push	{r3, lr}
	__asm__ volatile(
   42ca2:	f04f 0320 	mov.w	r3, #32
   42ca6:	f3ef 8111 	mrs	r1, BASEPRI
   42caa:	f383 8812 	msr	BASEPRI_MAX, r3
   42cae:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   42cb2:	4a11      	ldr	r2, [pc, #68]	; (42cf8 <generic_hfclk_start+0x58>)
   42cb4:	6813      	ldr	r3, [r2, #0]
   42cb6:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   42cba:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   42cbe:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   42cc0:	d00b      	beq.n	42cda <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   42cc2:	4a0e      	ldr	r2, [pc, #56]	; (42cfc <generic_hfclk_start+0x5c>)
   42cc4:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   42cc8:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   42ccc:	f013 0301 	ands.w	r3, r3, #1
   42cd0:	d003      	beq.n	42cda <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   42cd2:	480b      	ldr	r0, [pc, #44]	; (42d00 <generic_hfclk_start+0x60>)
   42cd4:	f005 fb05 	bl	482e2 <set_on_state>
			already_started = true;
   42cd8:	2301      	movs	r3, #1
	__asm__ volatile(
   42cda:	f381 8811 	msr	BASEPRI, r1
   42cde:	f3bf 8f6f 	isb	sy
	if (already_started) {
   42ce2:	b123      	cbz	r3, 42cee <generic_hfclk_start+0x4e>
}
   42ce4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   42ce8:	2000      	movs	r0, #0
   42cea:	f7ff bfb1 	b.w	42c50 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   42cee:	2001      	movs	r0, #1
}
   42cf0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   42cf4:	f001 b888 	b.w	43e08 <nrfx_clock_start>
   42cf8:	2001a96c 	.word	0x2001a96c
   42cfc:	40005000 	.word	0x40005000
   42d00:	2001a95c 	.word	0x2001a95c

00042d04 <generic_hfclk_stop>:
   42d04:	4b07      	ldr	r3, [pc, #28]	; (42d24 <generic_hfclk_stop+0x20>)
   42d06:	e8d3 2fef 	ldaex	r2, [r3]
   42d0a:	f022 0102 	bic.w	r1, r2, #2
   42d0e:	e8c3 1fe0 	stlex	r0, r1, [r3]
   42d12:	2800      	cmp	r0, #0
   42d14:	d1f7      	bne.n	42d06 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   42d16:	07d3      	lsls	r3, r2, #31
   42d18:	d402      	bmi.n	42d20 <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   42d1a:	2001      	movs	r0, #1
   42d1c:	f001 b8a6 	b.w	43e6c <nrfx_clock_stop>
}
   42d20:	4770      	bx	lr
   42d22:	bf00      	nop
   42d24:	2001a96c 	.word	0x2001a96c

00042d28 <api_blocking_start>:
{
   42d28:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42d2a:	2200      	movs	r2, #0
   42d2c:	2301      	movs	r3, #1
   42d2e:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42d32:	466b      	mov	r3, sp
   42d34:	4a08      	ldr	r2, [pc, #32]	; (42d58 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42d36:	f8cd d000 	str.w	sp, [sp]
   42d3a:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42d3e:	f005 fb09 	bl	48354 <api_start>
	if (err < 0) {
   42d42:	2800      	cmp	r0, #0
   42d44:	db05      	blt.n	42d52 <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   42d46:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   42d4a:	2300      	movs	r3, #0
   42d4c:	4668      	mov	r0, sp
   42d4e:	f003 fca5 	bl	4669c <z_impl_k_sem_take>
}
   42d52:	b005      	add	sp, #20
   42d54:	f85d fb04 	ldr.w	pc, [sp], #4
   42d58:	00048327 	.word	0x00048327

00042d5c <z_nrf_clock_control_lf_on>:
{
   42d5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   42d60:	2201      	movs	r2, #1
   42d62:	4607      	mov	r7, r0
   42d64:	4936      	ldr	r1, [pc, #216]	; (42e40 <z_nrf_clock_control_lf_on+0xe4>)
   42d66:	e8d1 3fef 	ldaex	r3, [r1]
   42d6a:	e8c1 2fe0 	stlex	r0, r2, [r1]
   42d6e:	2800      	cmp	r0, #0
   42d70:	d1f9      	bne.n	42d66 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   42d72:	b933      	cbnz	r3, 42d82 <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   42d74:	4933      	ldr	r1, [pc, #204]	; (42e44 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   42d76:	4834      	ldr	r0, [pc, #208]	; (42e48 <z_nrf_clock_control_lf_on+0xec>)
   42d78:	604b      	str	r3, [r1, #4]
   42d7a:	60cb      	str	r3, [r1, #12]
   42d7c:	608a      	str	r2, [r1, #8]
   42d7e:	f004 fc21 	bl	475c4 <onoff_request>
	switch (start_mode) {
   42d82:	1e7b      	subs	r3, r7, #1
   42d84:	2b01      	cmp	r3, #1
   42d86:	d82e      	bhi.n	42de6 <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   42d88:	2f01      	cmp	r7, #1
   42d8a:	d106      	bne.n	42d9a <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   42d8c:	4b2f      	ldr	r3, [pc, #188]	; (42e4c <z_nrf_clock_control_lf_on+0xf0>)
   42d8e:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   42d92:	f003 0303 	and.w	r3, r3, #3
   42d96:	2b02      	cmp	r3, #2
   42d98:	d025      	beq.n	42de6 <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   42d9a:	f005 fdb5 	bl	48908 <k_is_in_isr>
   42d9e:	4604      	mov	r4, r0
   42da0:	b918      	cbnz	r0, 42daa <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   42da2:	4b2b      	ldr	r3, [pc, #172]	; (42e50 <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   42da4:	781b      	ldrb	r3, [r3, #0]
   42da6:	2b00      	cmp	r3, #0
   42da8:	d144      	bne.n	42e34 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   42daa:	f04f 0320 	mov.w	r3, #32
   42dae:	f3ef 8611 	mrs	r6, BASEPRI
   42db2:	f383 8812 	msr	BASEPRI_MAX, r3
   42db6:	f3bf 8f6f 	isb	sy
   42dba:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42dbc:	4d23      	ldr	r5, [pc, #140]	; (42e4c <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42dbe:	f8df 809c 	ldr.w	r8, [pc, #156]	; 42e5c <z_nrf_clock_control_lf_on+0x100>
   42dc2:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42dc4:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   42dc8:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   42dcc:	03d2      	lsls	r2, r2, #15
   42dce:	d50c      	bpl.n	42dea <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   42dd0:	f003 0303 	and.w	r3, r3, #3
   42dd4:	2b02      	cmp	r3, #2
   42dd6:	d001      	beq.n	42ddc <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   42dd8:	2f01      	cmp	r7, #1
   42dda:	d106      	bne.n	42dea <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   42ddc:	b334      	cbz	r4, 42e2c <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   42dde:	f386 8811 	msr	BASEPRI, r6
   42de2:	f3bf 8f6f 	isb	sy
}
   42de6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   42dea:	b1d4      	cbz	r4, 42e22 <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   42dec:	4630      	mov	r0, r6
   42dee:	f7ff f8c3 	bl	41f78 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   42df2:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   42df6:	b2db      	uxtb	r3, r3
   42df8:	2b01      	cmp	r3, #1
   42dfa:	d1e3      	bne.n	42dc4 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42dfc:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   42e00:	2a00      	cmp	r2, #0
   42e02:	d0df      	beq.n	42dc4 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   42e04:	2200      	movs	r2, #0
   42e06:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   42e0a:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   42e0e:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42e10:	2120      	movs	r1, #32
   42e12:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   42e16:	4a0f      	ldr	r2, [pc, #60]	; (42e54 <z_nrf_clock_control_lf_on+0xf8>)
   42e18:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42e1c:	4a0e      	ldr	r2, [pc, #56]	; (42e58 <z_nrf_clock_control_lf_on+0xfc>)
   42e1e:	6013      	str	r3, [r2, #0]
}
   42e20:	e7d0      	b.n	42dc4 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   42e22:	2100      	movs	r1, #0
   42e24:	2001      	movs	r0, #1
   42e26:	f003 ff3f 	bl	46ca8 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   42e2a:	e7e2      	b.n	42df2 <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   42e2c:	2302      	movs	r3, #2
   42e2e:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   42e32:	e7d8      	b.n	42de6 <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   42e34:	2202      	movs	r2, #2
   42e36:	4b05      	ldr	r3, [pc, #20]	; (42e4c <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   42e38:	4606      	mov	r6, r0
   42e3a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   42e3e:	e7bd      	b.n	42dbc <z_nrf_clock_control_lf_on+0x60>
   42e40:	2001a970 	.word	0x2001a970
   42e44:	2001a90c 	.word	0x2001a90c
   42e48:	2001a938 	.word	0x2001a938
   42e4c:	40005000 	.word	0x40005000
   42e50:	20020bab 	.word	0x20020bab
   42e54:	e000e100 	.word	0xe000e100
   42e58:	40005008 	.word	0x40005008
   42e5c:	40005104 	.word	0x40005104

00042e60 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   42e60:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   42e62:	4808      	ldr	r0, [pc, #32]	; (42e84 <uart_console_init+0x24>)
   42e64:	4b08      	ldr	r3, [pc, #32]	; (42e88 <uart_console_init+0x28>)
   42e66:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   42e68:	f005 fc8a 	bl	48780 <z_device_ready>
   42e6c:	b138      	cbz	r0, 42e7e <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   42e6e:	4807      	ldr	r0, [pc, #28]	; (42e8c <uart_console_init+0x2c>)
   42e70:	f7ff fe6a 	bl	42b48 <__stdout_hook_install>
	__printk_hook_install(console_out);
   42e74:	4805      	ldr	r0, [pc, #20]	; (42e8c <uart_console_init+0x2c>)
   42e76:	f7fd fca3 	bl	407c0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   42e7a:	2000      	movs	r0, #0
}
   42e7c:	bd08      	pop	{r3, pc}
		return -ENODEV;
   42e7e:	f06f 0012 	mvn.w	r0, #18
   42e82:	e7fb      	b.n	42e7c <uart_console_init+0x1c>
   42e84:	00048d38 	.word	0x00048d38
   42e88:	2001a974 	.word	0x2001a974
   42e8c:	00042e91 	.word	0x00042e91

00042e90 <console_out>:
	if ('\n' == c) {
   42e90:	280a      	cmp	r0, #10
{
   42e92:	b538      	push	{r3, r4, r5, lr}
   42e94:	4604      	mov	r4, r0
   42e96:	4d07      	ldr	r5, [pc, #28]	; (42eb4 <console_out+0x24>)
	if ('\n' == c) {
   42e98:	d104      	bne.n	42ea4 <console_out+0x14>
   42e9a:	6828      	ldr	r0, [r5, #0]
   42e9c:	6883      	ldr	r3, [r0, #8]
   42e9e:	210d      	movs	r1, #13
   42ea0:	685b      	ldr	r3, [r3, #4]
   42ea2:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   42ea4:	6828      	ldr	r0, [r5, #0]
   42ea6:	6883      	ldr	r3, [r0, #8]
   42ea8:	b2e1      	uxtb	r1, r4
   42eaa:	685b      	ldr	r3, [r3, #4]
   42eac:	4798      	blx	r3
}
   42eae:	4620      	mov	r0, r4
   42eb0:	bd38      	pop	{r3, r4, r5, pc}
   42eb2:	bf00      	nop
   42eb4:	2001a974 	.word	0x2001a974

00042eb8 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   42eb8:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42eba:	6840      	ldr	r0, [r0, #4]
   42ebc:	f001 051f 	and.w	r5, r1, #31
   42ec0:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   42ec2:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   42ec6:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   42eca:	b085      	sub	sp, #20
   42ecc:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   42ed0:	d104      	bne.n	42edc <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   42ed2:	4628      	mov	r0, r5
   42ed4:	f001 fa88 	bl	443e8 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   42ed8:	2000      	movs	r0, #0
   42eda:	e02c      	b.n	42f36 <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   42edc:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   42ee0:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   42ee4:	d129      	bne.n	42f3a <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   42ee6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42eea:	bf0c      	ite	eq
   42eec:	2304      	moveq	r3, #4
   42eee:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   42ef0:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   42ef4:	6883      	ldr	r3, [r0, #8]
   42ef6:	fa23 f101 	lsr.w	r1, r3, r1
   42efa:	07c9      	lsls	r1, r1, #31
   42efc:	d429      	bmi.n	42f52 <gpio_nrfx_pin_interrupt_configure+0x9a>
   42efe:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   42f02:	d126      	bne.n	42f52 <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42f04:	4a1b      	ldr	r2, [pc, #108]	; (42f74 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   42f06:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   42f0a:	3380      	adds	r3, #128	; 0x80
   42f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   42f10:	07db      	lsls	r3, r3, #31
   42f12:	d41e      	bmi.n	42f52 <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   42f14:	f10d 0407 	add.w	r4, sp, #7
   42f18:	4621      	mov	r1, r4
   42f1a:	4628      	mov	r0, r5
   42f1c:	f001 f9d4 	bl	442c8 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   42f20:	4b15      	ldr	r3, [pc, #84]	; (42f78 <gpio_nrfx_pin_interrupt_configure+0xc0>)
   42f22:	4298      	cmp	r0, r3
   42f24:	d114      	bne.n	42f50 <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   42f26:	4620      	mov	r0, r4
   42f28:	f001 fa18 	bl	4435c <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   42f2c:	4b13      	ldr	r3, [pc, #76]	; (42f7c <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42f2e:	4298      	cmp	r0, r3
   42f30:	d00e      	beq.n	42f50 <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   42f32:	f06f 000b 	mvn.w	r0, #11
}
   42f36:	b005      	add	sp, #20
   42f38:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   42f3a:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   42f3e:	d005      	beq.n	42f4c <gpio_nrfx_pin_interrupt_configure+0x94>
   42f40:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   42f44:	bf0c      	ite	eq
   42f46:	2302      	moveq	r3, #2
   42f48:	2301      	movne	r3, #1
   42f4a:	e7d1      	b.n	42ef0 <gpio_nrfx_pin_interrupt_configure+0x38>
   42f4c:	2303      	movs	r3, #3
   42f4e:	e7cf      	b.n	42ef0 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   42f50:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   42f52:	2300      	movs	r3, #0
   42f54:	4628      	mov	r0, r5
   42f56:	4619      	mov	r1, r3
   42f58:	aa02      	add	r2, sp, #8
   42f5a:	f001 f875 	bl	44048 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   42f5e:	4b07      	ldr	r3, [pc, #28]	; (42f7c <gpio_nrfx_pin_interrupt_configure+0xc4>)
   42f60:	4298      	cmp	r0, r3
   42f62:	d104      	bne.n	42f6e <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   42f64:	2101      	movs	r1, #1
   42f66:	4628      	mov	r0, r5
   42f68:	f001 f9fe 	bl	44368 <nrfx_gpiote_trigger_enable>
   42f6c:	e7b4      	b.n	42ed8 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   42f6e:	f06f 0004 	mvn.w	r0, #4
   42f72:	e7e0      	b.n	42f36 <gpio_nrfx_pin_interrupt_configure+0x7e>
   42f74:	40842500 	.word	0x40842500
   42f78:	0bad0004 	.word	0x0bad0004
   42f7c:	0bad0000 	.word	0x0bad0000

00042f80 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   42f80:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   42f82:	f001 f9db 	bl	4433c <nrfx_gpiote_is_init>
   42f86:	4604      	mov	r4, r0
   42f88:	b968      	cbnz	r0, 42fa6 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   42f8a:	f001 f9af 	bl	442ec <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   42f8e:	4b08      	ldr	r3, [pc, #32]	; (42fb0 <gpio_nrfx_init+0x30>)
   42f90:	4298      	cmp	r0, r3
   42f92:	d10a      	bne.n	42faa <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   42f94:	4621      	mov	r1, r4
   42f96:	4807      	ldr	r0, [pc, #28]	; (42fb4 <gpio_nrfx_init+0x34>)
   42f98:	f001 f990 	bl	442bc <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   42f9c:	4622      	mov	r2, r4
   42f9e:	2105      	movs	r1, #5
   42fa0:	2031      	movs	r0, #49	; 0x31
   42fa2:	f7ff f849 	bl	42038 <z_arm_irq_priority_set>
		return 0;
   42fa6:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   42fa8:	bd10      	pop	{r4, pc}
		return -EIO;
   42faa:	f06f 0004 	mvn.w	r0, #4
   42fae:	e7fb      	b.n	42fa8 <gpio_nrfx_init+0x28>
   42fb0:	0bad0000 	.word	0x0bad0000
   42fb4:	00042fb9 	.word	0x00042fb9

00042fb8 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42fb8:	0943      	lsrs	r3, r0, #5
{
   42fba:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   42fbc:	d117      	bne.n	42fee <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42fbe:	4b0c      	ldr	r3, [pc, #48]	; (42ff0 <nrfx_gpio_handler+0x38>)
   42fc0:	6859      	ldr	r1, [r3, #4]
   42fc2:	b1a1      	cbz	r1, 42fee <nrfx_gpio_handler+0x36>
   42fc4:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   42fc6:	2501      	movs	r5, #1
   42fc8:	2c00      	cmp	r4, #0
   42fca:	bf38      	it	cc
   42fcc:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   42fce:	4e09      	ldr	r6, [pc, #36]	; (42ff4 <nrfx_gpio_handler+0x3c>)
   42fd0:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   42fd2:	688a      	ldr	r2, [r1, #8]
   42fd4:	402a      	ands	r2, r5
   42fd6:	d002      	beq.n	42fde <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   42fd8:	4630      	mov	r0, r6
   42fda:	684b      	ldr	r3, [r1, #4]
   42fdc:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   42fde:	b134      	cbz	r4, 42fee <nrfx_gpio_handler+0x36>
	return node->next;
   42fe0:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   42fe2:	4621      	mov	r1, r4
   42fe4:	2b00      	cmp	r3, #0
   42fe6:	bf38      	it	cc
   42fe8:	2300      	movcc	r3, #0
   42fea:	461c      	mov	r4, r3
   42fec:	e7f1      	b.n	42fd2 <nrfx_gpio_handler+0x1a>
}
   42fee:	bd70      	pop	{r4, r5, r6, pc}
   42ff0:	2001a978 	.word	0x2001a978
   42ff4:	00048d08 	.word	0x00048d08

00042ff8 <gpio_nrfx_pin_configure>:
{
   42ff8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   42ffc:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   42ffe:	f001 051f 	and.w	r5, r1, #31
   43002:	7b3b      	ldrb	r3, [r7, #12]
{
   43004:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   43006:	4614      	mov	r4, r2
{
   43008:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   4300a:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   4300e:	b9ca      	cbnz	r2, 43044 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   43010:	a902      	add	r1, sp, #8
   43012:	4628      	mov	r0, r5
   43014:	f001 f958 	bl	442c8 <nrfx_gpiote_channel_get>
   43018:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   4301a:	4628      	mov	r0, r5
   4301c:	f001 fa06 	bl	4442c <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   43020:	4b47      	ldr	r3, [pc, #284]	; (43140 <gpio_nrfx_pin_configure+0x148>)
   43022:	4298      	cmp	r0, r3
   43024:	d004      	beq.n	43030 <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   43026:	f06f 0004 	mvn.w	r0, #4
}
   4302a:	b005      	add	sp, #20
   4302c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   43030:	4284      	cmp	r4, r0
   43032:	d105      	bne.n	43040 <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   43034:	f89d 0008 	ldrb.w	r0, [sp, #8]
   43038:	f001 f98a 	bl	44350 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   4303c:	42a0      	cmp	r0, r4
   4303e:	d1f2      	bne.n	43026 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   43040:	2000      	movs	r0, #0
   43042:	e7f2      	b.n	4302a <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   43044:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   43048:	f10d 0103 	add.w	r1, sp, #3
   4304c:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   4304e:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   43052:	f001 f939 	bl	442c8 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43056:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   43058:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   4305a:	4649      	mov	r1, r9
   4305c:	4628      	mov	r0, r5
   4305e:	aa02      	add	r2, sp, #8
   43060:	f000 fff2 	bl	44048 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   43064:	4b36      	ldr	r3, [pc, #216]	; (43140 <gpio_nrfx_pin_configure+0x148>)
   43066:	4298      	cmp	r0, r3
   43068:	d002      	beq.n	43070 <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   4306a:	f06f 0015 	mvn.w	r0, #21
   4306e:	e7dc      	b.n	4302a <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   43070:	4580      	cmp	r8, r0
   43072:	d103      	bne.n	4307c <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   43074:	f89d 0003 	ldrb.w	r0, [sp, #3]
   43078:	f001 f96a 	bl	44350 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   4307c:	05a3      	lsls	r3, r4, #22
   4307e:	d54c      	bpl.n	4311a <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43080:	4b30      	ldr	r3, [pc, #192]	; (43144 <gpio_nrfx_pin_configure+0x14c>)
   43082:	4a31      	ldr	r2, [pc, #196]	; (43148 <gpio_nrfx_pin_configure+0x150>)
   43084:	4023      	ands	r3, r4
   43086:	4293      	cmp	r3, r2
   43088:	d039      	beq.n	430fe <gpio_nrfx_pin_configure+0x106>
   4308a:	d80c      	bhi.n	430a6 <gpio_nrfx_pin_configure+0xae>
   4308c:	2b06      	cmp	r3, #6
   4308e:	d014      	beq.n	430ba <gpio_nrfx_pin_configure+0xc2>
   43090:	d804      	bhi.n	4309c <gpio_nrfx_pin_configure+0xa4>
   43092:	b193      	cbz	r3, 430ba <gpio_nrfx_pin_configure+0xc2>
   43094:	2b02      	cmp	r3, #2
   43096:	d1e8      	bne.n	4306a <gpio_nrfx_pin_configure+0x72>
   43098:	2304      	movs	r3, #4
   4309a:	e00e      	b.n	430ba <gpio_nrfx_pin_configure+0xc2>
   4309c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   430a0:	d1e3      	bne.n	4306a <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   430a2:	2301      	movs	r3, #1
   430a4:	e009      	b.n	430ba <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   430a6:	4a29      	ldr	r2, [pc, #164]	; (4314c <gpio_nrfx_pin_configure+0x154>)
   430a8:	4293      	cmp	r3, r2
   430aa:	d02a      	beq.n	43102 <gpio_nrfx_pin_configure+0x10a>
   430ac:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   430b0:	d029      	beq.n	43106 <gpio_nrfx_pin_configure+0x10e>
   430b2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   430b6:	d1d8      	bne.n	4306a <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   430b8:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   430ba:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   430be:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   430c2:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   430c6:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   430c8:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   430cc:	bf4c      	ite	mi
   430ce:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   430d0:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   430d4:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   430d6:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   430da:	d516      	bpl.n	4310a <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   430dc:	2101      	movs	r1, #1
   430de:	687b      	ldr	r3, [r7, #4]
   430e0:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   430e4:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   430e6:	2200      	movs	r2, #0
   430e8:	4628      	mov	r0, r5
   430ea:	a901      	add	r1, sp, #4
   430ec:	f001 f852 	bl	44194 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   430f0:	4b13      	ldr	r3, [pc, #76]	; (43140 <gpio_nrfx_pin_configure+0x148>)
   430f2:	4298      	cmp	r0, r3
   430f4:	bf14      	ite	ne
   430f6:	f06f 0015 	mvnne.w	r0, #21
   430fa:	2000      	moveq	r0, #0
   430fc:	e795      	b.n	4302a <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   430fe:	2307      	movs	r3, #7
   43100:	e7db      	b.n	430ba <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   43102:	2305      	movs	r3, #5
   43104:	e7d9      	b.n	430ba <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   43106:	2303      	movs	r3, #3
   43108:	e7d7      	b.n	430ba <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   4310a:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   4310c:	bf41      	itttt	mi
   4310e:	2101      	movmi	r1, #1
   43110:	687b      	ldrmi	r3, [r7, #4]
   43112:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   43116:	60de      	strmi	r6, [r3, #12]
}
   43118:	e7e5      	b.n	430e6 <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   4311a:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   4311c:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   43120:	bf4c      	ite	mi
   43122:	2403      	movmi	r4, #3
   43124:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43128:	461a      	mov	r2, r3
   4312a:	4628      	mov	r0, r5
   4312c:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   4312e:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43132:	f000 ff89 	bl	44048 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   43136:	4b02      	ldr	r3, [pc, #8]	; (43140 <gpio_nrfx_pin_configure+0x148>)
   43138:	4298      	cmp	r0, r3
   4313a:	d081      	beq.n	43040 <gpio_nrfx_pin_configure+0x48>
   4313c:	e795      	b.n	4306a <gpio_nrfx_pin_configure+0x72>
   4313e:	bf00      	nop
   43140:	0bad0000 	.word	0x0bad0000
   43144:	00f00006 	.word	0x00f00006
   43148:	00100006 	.word	0x00100006
   4314c:	00400002 	.word	0x00400002

00043150 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   43150:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   43152:	794b      	ldrb	r3, [r1, #5]
   43154:	2b01      	cmp	r3, #1
   43156:	d026      	beq.n	431a6 <uarte_nrfx_configure+0x56>
   43158:	2b03      	cmp	r3, #3
   4315a:	d121      	bne.n	431a0 <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   4315c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   4315e:	798b      	ldrb	r3, [r1, #6]
   43160:	2b03      	cmp	r3, #3
   43162:	d11d      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   43164:	79cc      	ldrb	r4, [r1, #7]
   43166:	b10c      	cbz	r4, 4316c <uarte_nrfx_configure+0x1c>
   43168:	2c01      	cmp	r4, #1
   4316a:	d119      	bne.n	431a0 <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   4316c:	790a      	ldrb	r2, [r1, #4]
   4316e:	b112      	cbz	r2, 43176 <uarte_nrfx_configure+0x26>
   43170:	2a02      	cmp	r2, #2
   43172:	d115      	bne.n	431a0 <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   43174:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   43176:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   43178:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   4317a:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   4317e:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   43180:	d065      	beq.n	4324e <uarte_nrfx_configure+0xfe>
   43182:	d82d      	bhi.n	431e0 <uarte_nrfx_configure+0x90>
   43184:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   43188:	d064      	beq.n	43254 <uarte_nrfx_configure+0x104>
   4318a:	d816      	bhi.n	431ba <uarte_nrfx_configure+0x6a>
   4318c:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   43190:	d062      	beq.n	43258 <uarte_nrfx_configure+0x108>
   43192:	d80a      	bhi.n	431aa <uarte_nrfx_configure+0x5a>
   43194:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   43198:	d061      	beq.n	4325e <uarte_nrfx_configure+0x10e>
   4319a:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   4319e:	d061      	beq.n	43264 <uarte_nrfx_configure+0x114>
   431a0:	f06f 0085 	mvn.w	r0, #133	; 0x85
   431a4:	e052      	b.n	4324c <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   431a6:	2600      	movs	r6, #0
   431a8:	e7d9      	b.n	4315e <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   431aa:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   431ae:	d05c      	beq.n	4326a <uarte_nrfx_configure+0x11a>
   431b0:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   431b4:	d1f4      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   431b6:	4b37      	ldr	r3, [pc, #220]	; (43294 <uarte_nrfx_configure+0x144>)
   431b8:	e03c      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431ba:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   431be:	d057      	beq.n	43270 <uarte_nrfx_configure+0x120>
   431c0:	d807      	bhi.n	431d2 <uarte_nrfx_configure+0x82>
   431c2:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   431c6:	d055      	beq.n	43274 <uarte_nrfx_configure+0x124>
   431c8:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   431cc:	d1e8      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   431ce:	4b32      	ldr	r3, [pc, #200]	; (43298 <uarte_nrfx_configure+0x148>)
   431d0:	e030      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431d2:	f647 2712 	movw	r7, #31250	; 0x7a12
   431d6:	42bb      	cmp	r3, r7
   431d8:	d1e2      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   431da:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   431de:	e029      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   431e0:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   431e4:	d048      	beq.n	43278 <uarte_nrfx_configure+0x128>
   431e6:	d813      	bhi.n	43210 <uarte_nrfx_configure+0xc0>
   431e8:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   431ec:	d047      	beq.n	4327e <uarte_nrfx_configure+0x12e>
   431ee:	d809      	bhi.n	43204 <uarte_nrfx_configure+0xb4>
   431f0:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   431f4:	42bb      	cmp	r3, r7
   431f6:	d044      	beq.n	43282 <uarte_nrfx_configure+0x132>
   431f8:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   431fc:	d1d0      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   431fe:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   43202:	e017      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43204:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   43208:	d1ca      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   4320a:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   4320e:	e011      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43210:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   43214:	d038      	beq.n	43288 <uarte_nrfx_configure+0x138>
   43216:	d808      	bhi.n	4322a <uarte_nrfx_configure+0xda>
   43218:	4f20      	ldr	r7, [pc, #128]	; (4329c <uarte_nrfx_configure+0x14c>)
   4321a:	42bb      	cmp	r3, r7
   4321c:	d037      	beq.n	4328e <uarte_nrfx_configure+0x13e>
   4321e:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   43222:	d1bd      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   43224:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   43228:	e004      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4322a:	4f1d      	ldr	r7, [pc, #116]	; (432a0 <uarte_nrfx_configure+0x150>)
   4322c:	42bb      	cmp	r3, r7
   4322e:	d1b7      	bne.n	431a0 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   43230:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   43234:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   43238:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   4323a:	4334      	orrs	r4, r6
   4323c:	4322      	orrs	r2, r4
   4323e:	3304      	adds	r3, #4
   43240:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   43242:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   43246:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   4324a:	2000      	movs	r0, #0
}
   4324c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   4324e:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   43252:	e7ef      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   43254:	4b13      	ldr	r3, [pc, #76]	; (432a4 <uarte_nrfx_configure+0x154>)
   43256:	e7ed      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   43258:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   4325c:	e7ea      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   4325e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   43262:	e7e7      	b.n	43234 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43264:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   43268:	e7e4      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   4326a:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   4326e:	e7e1      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   43270:	4b0d      	ldr	r3, [pc, #52]	; (432a8 <uarte_nrfx_configure+0x158>)
   43272:	e7df      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   43274:	4b0d      	ldr	r3, [pc, #52]	; (432ac <uarte_nrfx_configure+0x15c>)
   43276:	e7dd      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   43278:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   4327c:	e7da      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   4327e:	4b0c      	ldr	r3, [pc, #48]	; (432b0 <uarte_nrfx_configure+0x160>)
   43280:	e7d8      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   43282:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   43286:	e7d5      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   43288:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   4328c:	e7d2      	b.n	43234 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   4328e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   43292:	e7cf      	b.n	43234 <uarte_nrfx_configure+0xe4>
   43294:	0013b000 	.word	0x0013b000
   43298:	004ea000 	.word	0x004ea000
   4329c:	0003d090 	.word	0x0003d090
   432a0:	000f4240 	.word	0x000f4240
   432a4:	00275000 	.word	0x00275000
   432a8:	0075c000 	.word	0x0075c000
   432ac:	003af000 	.word	0x003af000
   432b0:	013a9000 	.word	0x013a9000

000432b4 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   432b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   432b6:	4605      	mov	r5, r0
   432b8:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   432ba:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   432bc:	f005 fb24 	bl	48908 <k_is_in_isr>
   432c0:	b910      	cbnz	r0, 432c8 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   432c2:	4b2c      	ldr	r3, [pc, #176]	; (43374 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   432c4:	781b      	ldrb	r3, [r3, #0]
   432c6:	b983      	cbnz	r3, 432ea <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   432c8:	f04f 0320 	mov.w	r3, #32
   432cc:	f3ef 8411 	mrs	r4, BASEPRI
   432d0:	f383 8812 	msr	BASEPRI_MAX, r3
   432d4:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   432d8:	4628      	mov	r0, r5
   432da:	f005 f8e9 	bl	484b0 <is_tx_ready>
   432de:	bb28      	cbnz	r0, 4332c <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   432e0:	f384 8811 	msr	BASEPRI, r4
   432e4:	f3bf 8f6f 	isb	sy
}
   432e8:	e7ee      	b.n	432c8 <uarte_nrfx_poll_out+0x14>
{
   432ea:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   432ec:	4628      	mov	r0, r5
   432ee:	f005 f8df 	bl	484b0 <is_tx_ready>
   432f2:	b970      	cbnz	r0, 43312 <uarte_nrfx_poll_out+0x5e>
   432f4:	2001      	movs	r0, #1
   432f6:	f005 f93f 	bl	48578 <nrfx_busy_wait>
   432fa:	3c01      	subs	r4, #1
   432fc:	d1f6      	bne.n	432ec <uarte_nrfx_poll_out+0x38>
   432fe:	2100      	movs	r1, #0
   43300:	2001      	movs	r0, #1
   43302:	f003 fcd1 	bl	46ca8 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   43306:	e7f0      	b.n	432ea <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43308:	f384 8811 	msr	BASEPRI, r4
   4330c:	f3bf 8f6f 	isb	sy
}
   43310:	e7f5      	b.n	432fe <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   43312:	f04f 0320 	mov.w	r3, #32
   43316:	f3ef 8411 	mrs	r4, BASEPRI
   4331a:	f383 8812 	msr	BASEPRI_MAX, r3
   4331e:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   43322:	4628      	mov	r0, r5
   43324:	f005 f8c4 	bl	484b0 <is_tx_ready>
   43328:	2800      	cmp	r0, #0
   4332a:	d0ed      	beq.n	43308 <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   4332c:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   4332e:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   43332:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   43334:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43336:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   4333a:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4333e:	2200      	movs	r2, #0
   43340:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   43344:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   43348:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   4334c:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   43350:	684a      	ldr	r2, [r1, #4]
   43352:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43354:	bf41      	itttt	mi
   43356:	2208      	movmi	r2, #8
   43358:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   4335c:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   43360:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43364:	2201      	movs	r2, #1
   43366:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   43368:	f384 8811 	msr	BASEPRI, r4
   4336c:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   43370:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   43372:	bf00      	nop
   43374:	20020bab 	.word	0x20020bab

00043378 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   43378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4337c:	4606      	mov	r6, r0
   4337e:	2101      	movs	r1, #1
   43380:	2200      	movs	r2, #0
   43382:	2008      	movs	r0, #8
   43384:	f7fe fe58 	bl	42038 <z_arm_irq_priority_set>
   43388:	2008      	movs	r0, #8
   4338a:	f7fe fe37 	bl	41ffc <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   4338e:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   43390:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   43392:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   43394:	683c      	ldr	r4, [r7, #0]
   43396:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   4339a:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   4339c:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4339e:	68d8      	ldr	r0, [r3, #12]
   433a0:	1c41      	adds	r1, r0, #1
   433a2:	d00b      	beq.n	433bc <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   433a4:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   433a6:	f8df c154 	ldr.w	ip, [pc, #340]	; 434fc <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   433aa:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   433ae:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   433b0:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   433b4:	2103      	movs	r1, #3
   433b6:	3280      	adds	r2, #128	; 0x80
   433b8:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   433bc:	6919      	ldr	r1, [r3, #16]
   433be:	1c4a      	adds	r2, r1, #1
   433c0:	d00d      	beq.n	433de <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   433c2:	7f1a      	ldrb	r2, [r3, #28]
   433c4:	f8df c134 	ldr.w	ip, [pc, #308]	; 434fc <uarte_0_init+0x184>
   433c8:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   433ca:	bf14      	ite	ne
   433cc:	f04f 0e0c 	movne.w	lr, #12
   433d0:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   433d4:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   433d8:	3280      	adds	r2, #128	; 0x80
   433da:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   433de:	f8d3 c014 	ldr.w	ip, [r3, #20]
   433e2:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   433e6:	d00e      	beq.n	43406 <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   433e8:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   433ec:	f8df 810c 	ldr.w	r8, [pc, #268]	; 434fc <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   433f0:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   433f4:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   433f8:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   433fc:	f04f 0e03 	mov.w	lr, #3
   43400:	3280      	adds	r2, #128	; 0x80
   43402:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43406:	f8d3 e018 	ldr.w	lr, [r3, #24]
   4340a:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
   4340e:	d00d      	beq.n	4342c <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   43410:	7f5a      	ldrb	r2, [r3, #29]
   43412:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 434fc <uarte_0_init+0x184>
   43416:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43418:	bf14      	ite	ne
   4341a:	f04f 090c 	movne.w	r9, #12
   4341e:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   43422:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   43426:	3280      	adds	r2, #128	; 0x80
   43428:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   4342c:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   4342e:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   43432:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   43436:	6931      	ldr	r1, [r6, #16]
   43438:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   4343a:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   4343e:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   43440:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   43444:	f7ff fe84 	bl	43150 <uarte_nrfx_configure>
	if (err) {
   43448:	4606      	mov	r6, r0
   4344a:	b9a8      	cbnz	r0, 43478 <uarte_0_init+0x100>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   4344c:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   4344e:	0799      	lsls	r1, r3, #30
   43450:	d522      	bpl.n	43498 <uarte_0_init+0x120>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   43452:	f105 0012 	add.w	r0, r5, #18
   43456:	f000 fd7d 	bl	43f54 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   4345a:	4b23      	ldr	r3, [pc, #140]	; (434e8 <uarte_0_init+0x170>)
   4345c:	4298      	cmp	r0, r3
   4345e:	d00e      	beq.n	4347e <uarte_0_init+0x106>
   43460:	4b22      	ldr	r3, [pc, #136]	; (434ec <uarte_0_init+0x174>)
   43462:	4923      	ldr	r1, [pc, #140]	; (434f0 <uarte_0_init+0x178>)
		LOG_ERR("Failed to allocate PPI Channel");
   43464:	4823      	ldr	r0, [pc, #140]	; (434f4 <uarte_0_init+0x17c>)
   43466:	1ac9      	subs	r1, r1, r3
   43468:	08c9      	lsrs	r1, r1, #3
   4346a:	0189      	lsls	r1, r1, #6
   4346c:	f041 0101 	orr.w	r1, r1, #1
   43470:	f004 fb83 	bl	47b7a <log_0>
		return -EIO;
   43474:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   43478:	4630      	mov	r0, r6
   4347a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   4347e:	7cab      	ldrb	r3, [r5, #18]
   43480:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   43484:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   43488:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   4348c:	2301      	movs	r3, #1
   4348e:	7caa      	ldrb	r2, [r5, #18]
   43490:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   43492:	4a19      	ldr	r2, [pc, #100]	; (434f8 <uarte_0_init+0x180>)
   43494:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43498:	2308      	movs	r3, #8
   4349a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   4349e:	7a3b      	ldrb	r3, [r7, #8]
   434a0:	b95b      	cbnz	r3, 434ba <uarte_0_init+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   434a2:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   434a6:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   434aa:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   434ae:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   434b2:	2301      	movs	r3, #1
   434b4:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   434b8:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   434ba:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   434bc:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   434be:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   434c0:	bf5c      	itt	pl
   434c2:	f44f 7280 	movpl.w	r2, #256	; 0x100
   434c6:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   434ca:	06db      	lsls	r3, r3, #27
   434cc:	bf44      	itt	mi
   434ce:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   434d2:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   434d6:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   434d8:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   434dc:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   434e0:	2301      	movs	r3, #1
   434e2:	60a3      	str	r3, [r4, #8]
   434e4:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   434e6:	e7c7      	b.n	43478 <uarte_0_init+0x100>
   434e8:	0bad0000 	.word	0x0bad0000
   434ec:	00048f58 	.word	0x00048f58
   434f0:	00048fa8 	.word	0x00048fa8
   434f4:	00049a39 	.word	0x00049a39
   434f8:	40017000 	.word	0x40017000
   434fc:	40842500 	.word	0x40842500

00043500 <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   43500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43502:	4e20      	ldr	r6, [pc, #128]	; (43584 <sys_clock_timeout_handler+0x84>)
	return absolute_time & COUNTER_MAX;
   43504:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43508:	e9d6 ce00 	ldrd	ip, lr, [r6]
   4350c:	ebb2 020c 	subs.w	r2, r2, ip

	last_count += dticks * CYC_PER_TICK;
   43510:	f022 011f 	bic.w	r1, r2, #31
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43514:	eb63 030e 	sbc.w	r3, r3, lr
{
   43518:	4604      	mov	r4, r0
	last_count += dticks * CYC_PER_TICK;
   4351a:	eb11 010c 	adds.w	r1, r1, ip
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4351e:	ea4f 1052 	mov.w	r0, r2, lsr #5
	last_count += dticks * CYC_PER_TICK;
   43522:	eb43 070e 	adc.w	r7, r3, lr
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43526:	ea40 60c3 	orr.w	r0, r0, r3, lsl #27
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   4352a:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   4352e:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
	last_count += dticks * CYC_PER_TICK;
   43532:	e9c6 1700 	strd	r1, r7, [r6]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   43536:	f04f 0600 	mov.w	r6, #0
	if (in_anchor_range(cc_value)) {
   4353a:	d20a      	bcs.n	43552 <sys_clock_timeout_handler+0x52>
		return true;
   4353c:	2601      	movs	r6, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   4353e:	4b12      	ldr	r3, [pc, #72]	; (43588 <sys_clock_timeout_handler+0x88>)
   43540:	6819      	ldr	r1, [r3, #0]
   43542:	060a      	lsls	r2, r1, #24
   43544:	0a0b      	lsrs	r3, r1, #8
   43546:	1952      	adds	r2, r2, r5
   43548:	4910      	ldr	r1, [pc, #64]	; (4358c <sys_clock_timeout_handler+0x8c>)
   4354a:	f143 0300 	adc.w	r3, r3, #0
   4354e:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   43552:	f003 fd07 	bl	46f64 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   43556:	00a3      	lsls	r3, r4, #2
   43558:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   4355c:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   43560:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   43564:	42aa      	cmp	r2, r5
   43566:	d10b      	bne.n	43580 <sys_clock_timeout_handler+0x80>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   43568:	b91e      	cbnz	r6, 43572 <sys_clock_timeout_handler+0x72>
    p_reg->CC[ch] = cc_val;
   4356a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   4356e:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43572:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   43576:	4b06      	ldr	r3, [pc, #24]	; (43590 <sys_clock_timeout_handler+0x90>)
   43578:	fa00 f404 	lsl.w	r4, r0, r4
   4357c:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   43580:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   43582:	bf00      	nop
   43584:	2001a728 	.word	0x2001a728
   43588:	2001a98c 	.word	0x2001a98c
   4358c:	2001a710 	.word	0x2001a710
   43590:	40015000 	.word	0x40015000

00043594 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43594:	2301      	movs	r3, #1
   43596:	4083      	lsls	r3, r0
{
   43598:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   4359a:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   4359c:	4a0c      	ldr	r2, [pc, #48]	; (435d0 <compare_int_lock+0x3c>)
   4359e:	e8d2 1fef 	ldaex	r1, [r2]
   435a2:	ea01 0c04 	and.w	ip, r1, r4
   435a6:	e8c2 cfee 	stlex	lr, ip, [r2]
   435aa:	f1be 0f00 	cmp.w	lr, #0
   435ae:	d1f6      	bne.n	4359e <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   435b0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   435b4:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   435b8:	4a06      	ldr	r2, [pc, #24]	; (435d4 <compare_int_lock+0x40>)
   435ba:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   435be:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   435c2:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   435c6:	420b      	tst	r3, r1
}
   435c8:	bf14      	ite	ne
   435ca:	2001      	movne	r0, #1
   435cc:	2000      	moveq	r0, #0
   435ce:	bd10      	pop	{r4, pc}
   435d0:	2001a988 	.word	0x2001a988
   435d4:	40015000 	.word	0x40015000

000435d8 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   435d8:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   435da:	4a0e      	ldr	r2, [pc, #56]	; (43614 <compare_int_unlock.part.0+0x3c>)
   435dc:	4083      	lsls	r3, r0
   435de:	e8d2 1fef 	ldaex	r1, [r2]
   435e2:	4319      	orrs	r1, r3
   435e4:	e8c2 1fec 	stlex	ip, r1, [r2]
   435e8:	f1bc 0f00 	cmp.w	ip, #0
   435ec:	d1f7      	bne.n	435de <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   435ee:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   435f2:	4a09      	ldr	r2, [pc, #36]	; (43618 <compare_int_unlock.part.0+0x40>)
   435f4:	4083      	lsls	r3, r0
   435f6:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   435fa:	4b08      	ldr	r3, [pc, #32]	; (4361c <compare_int_unlock.part.0+0x44>)
   435fc:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   43600:	fa23 f000 	lsr.w	r0, r3, r0
   43604:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43606:	bf42      	ittt	mi
   43608:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   4360c:	4b04      	ldrmi	r3, [pc, #16]	; (43620 <compare_int_unlock.part.0+0x48>)
   4360e:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   43612:	4770      	bx	lr
   43614:	2001a988 	.word	0x2001a988
   43618:	40015000 	.word	0x40015000
   4361c:	2001a984 	.word	0x2001a984
   43620:	e000e100 	.word	0xe000e100

00043624 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   43624:	4b0d      	ldr	r3, [pc, #52]	; (4365c <z_nrf_rtc_timer_read+0x38>)
   43626:	681b      	ldr	r3, [r3, #0]
   43628:	0a19      	lsrs	r1, r3, #8
   4362a:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   4362c:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   43630:	4b0b      	ldr	r3, [pc, #44]	; (43660 <z_nrf_rtc_timer_read+0x3c>)
   43632:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   43636:	18c0      	adds	r0, r0, r3
   43638:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   4363c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   43640:	d20a      	bcs.n	43658 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   43642:	4b08      	ldr	r3, [pc, #32]	; (43664 <z_nrf_rtc_timer_read+0x40>)
   43644:	e9d3 2300 	ldrd	r2, r3, [r3]
   43648:	4299      	cmp	r1, r3
   4364a:	bf08      	it	eq
   4364c:	4290      	cmpeq	r0, r2
   4364e:	d203      	bcs.n	43658 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   43650:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   43654:	f141 0100 	adc.w	r1, r1, #0
}
   43658:	4770      	bx	lr
   4365a:	bf00      	nop
   4365c:	2001a98c 	.word	0x2001a98c
   43660:	40015000 	.word	0x40015000
   43664:	2001a710 	.word	0x2001a710

00043668 <compare_set>:
{
   43668:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4366c:	4616      	mov	r6, r2
   4366e:	461f      	mov	r7, r3
   43670:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   43672:	f7ff ff8f 	bl	43594 <compare_int_lock>
   43676:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   43678:	f7ff ffd4 	bl	43624 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   4367c:	42b9      	cmp	r1, r7
   4367e:	bf08      	it	eq
   43680:	42b0      	cmpeq	r0, r6
   43682:	d27b      	bcs.n	4377c <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   43684:	2300      	movs	r3, #0
   43686:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   4368a:	ebb6 0800 	subs.w	r8, r6, r0
   4368e:	eb67 0901 	sbc.w	r9, r7, r1
   43692:	454b      	cmp	r3, r9
   43694:	bf08      	it	eq
   43696:	4542      	cmpeq	r2, r8
   43698:	d37d      	bcc.n	43796 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   4369a:	4b40      	ldr	r3, [pc, #256]	; (4379c <compare_set+0x134>)
   4369c:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   436a0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   436a4:	429f      	cmp	r7, r3
   436a6:	bf08      	it	eq
   436a8:	4296      	cmpeq	r6, r2
   436aa:	d051      	beq.n	43750 <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   436ac:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   436b0:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   436b4:	4614      	mov	r4, r2
   436b6:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   436ba:	f105 0850 	add.w	r8, r5, #80	; 0x50
   436be:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   436c2:	ea4f 0888 	mov.w	r8, r8, lsl #2
   436c6:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   436ca:	fa1f f888 	uxth.w	r8, r8
   436ce:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   436d2:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   436d6:	4b32      	ldr	r3, [pc, #200]	; (437a0 <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   436d8:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   436dc:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   436e0:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   436e4:	eba0 000a 	sub.w	r0, r0, sl
   436e8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   436ec:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   436f0:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   436f2:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   436f6:	d105      	bne.n	43704 <compare_set+0x9c>
   436f8:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   436fa:	2013      	movs	r0, #19
   436fc:	f005 fa61 	bl	48bc2 <z_impl_k_busy_wait>
   43700:	4b27      	ldr	r3, [pc, #156]	; (437a0 <compare_set+0x138>)
   43702:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   43704:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   43708:	eba4 000c 	sub.w	r0, r4, ip
   4370c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43710:	2100      	movs	r1, #0
			cc_val = now + 2;
   43712:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43716:	bf88      	it	hi
   43718:	4664      	movhi	r4, ip
   4371a:	f8c8 1000 	str.w	r1, [r8]
   4371e:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43722:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   43726:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   4372a:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   4372e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   43732:	4582      	cmp	sl, r0
   43734:	d006      	beq.n	43744 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   43736:	1a20      	subs	r0, r4, r0
   43738:	3802      	subs	r0, #2
   4373a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   4373e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43742:	d819      	bhi.n	43778 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   43744:	1aa4      	subs	r4, r4, r2
   43746:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   4374a:	1932      	adds	r2, r6, r4
   4374c:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   43750:	4c12      	ldr	r4, [pc, #72]	; (4379c <compare_set+0x134>)
   43752:	0129      	lsls	r1, r5, #4
   43754:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   43758:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   4375c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   4375e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   43760:	5062      	str	r2, [r4, r1]
	return ret;
   43762:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   43764:	6043      	str	r3, [r0, #4]
	if (key) {
   43766:	9b00      	ldr	r3, [sp, #0]
   43768:	b113      	cbz	r3, 43770 <compare_set+0x108>
   4376a:	4628      	mov	r0, r5
   4376c:	f7ff ff34 	bl	435d8 <compare_int_unlock.part.0>
}
   43770:	4620      	mov	r0, r4
   43772:	b003      	add	sp, #12
   43774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43778:	4620      	mov	r0, r4
   4377a:	e7b1      	b.n	436e0 <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   4377c:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4377e:	4a09      	ldr	r2, [pc, #36]	; (437a4 <compare_set+0x13c>)
   43780:	40ab      	lsls	r3, r5
   43782:	e8d2 1fef 	ldaex	r1, [r2]
   43786:	4319      	orrs	r1, r3
   43788:	e8c2 1fe0 	stlex	r0, r1, [r2]
   4378c:	2800      	cmp	r0, #0
   4378e:	d1f8      	bne.n	43782 <compare_set+0x11a>
   43790:	4632      	mov	r2, r6
   43792:	463b      	mov	r3, r7
   43794:	e7dc      	b.n	43750 <compare_set+0xe8>
			return -EINVAL;
   43796:	f06f 0415 	mvn.w	r4, #21
   4379a:	e7e4      	b.n	43766 <compare_set+0xfe>
   4379c:	2001a718 	.word	0x2001a718
   437a0:	40015000 	.word	0x40015000
   437a4:	2001a984 	.word	0x2001a984

000437a8 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   437a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   437aa:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   437ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   437b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   437b4:	4d16      	ldr	r5, [pc, #88]	; (43810 <sys_clock_driver_init+0x68>)
   437b6:	4b17      	ldr	r3, [pc, #92]	; (43814 <sys_clock_driver_init+0x6c>)
   437b8:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   437bc:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   437c0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   437c4:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   437c6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   437ca:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   437ce:	4b12      	ldr	r3, [pc, #72]	; (43818 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   437d0:	2101      	movs	r1, #1
   437d2:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   437d6:	2015      	movs	r0, #21
   437d8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   437dc:	4622      	mov	r2, r4
   437de:	f7fe fc2b 	bl	42038 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   437e2:	2015      	movs	r0, #21
   437e4:	f7fe fc0a 	bl	41ffc <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   437e8:	2301      	movs	r3, #1
   437ea:	4a0c      	ldr	r2, [pc, #48]	; (4381c <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   437ec:	4620      	mov	r0, r4
   437ee:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   437f0:	4a0b      	ldr	r2, [pc, #44]	; (43820 <sys_clock_driver_init+0x78>)
   437f2:	602b      	str	r3, [r5, #0]
   437f4:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   437f6:	4b0b      	ldr	r3, [pc, #44]	; (43824 <sys_clock_driver_init+0x7c>)
   437f8:	4a0b      	ldr	r2, [pc, #44]	; (43828 <sys_clock_driver_init+0x80>)
   437fa:	9300      	str	r3, [sp, #0]
   437fc:	9401      	str	r4, [sp, #4]
   437fe:	2300      	movs	r3, #0
   43800:	f7ff ff32 	bl	43668 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   43804:	4630      	mov	r0, r6
   43806:	f7ff faa9 	bl	42d5c <z_nrf_clock_control_lf_on>

	return 0;
}
   4380a:	4620      	mov	r0, r4
   4380c:	b002      	add	sp, #8
   4380e:	bd70      	pop	{r4, r5, r6, pc}
   43810:	40015000 	.word	0x40015000
   43814:	2001a718 	.word	0x2001a718
   43818:	e000e100 	.word	0xe000e100
   4381c:	40015008 	.word	0x40015008
   43820:	2001a988 	.word	0x2001a988
   43824:	00043501 	.word	0x00043501
   43828:	007fffff 	.word	0x007fffff

0004382c <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   4382c:	4b33      	ldr	r3, [pc, #204]	; (438fc <rtc_nrf_isr+0xd0>)
{
   4382e:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   43832:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   43836:	079a      	lsls	r2, r3, #30
   43838:	d509      	bpl.n	4384e <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4383a:	4b31      	ldr	r3, [pc, #196]	; (43900 <rtc_nrf_isr+0xd4>)
   4383c:	681a      	ldr	r2, [r3, #0]
   4383e:	b132      	cbz	r2, 4384e <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43840:	2200      	movs	r2, #0
   43842:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   43844:	4a2f      	ldr	r2, [pc, #188]	; (43904 <rtc_nrf_isr+0xd8>)
   43846:	681b      	ldr	r3, [r3, #0]
   43848:	6813      	ldr	r3, [r2, #0]
   4384a:	3301      	adds	r3, #1
   4384c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   4384e:	f04f 0320 	mov.w	r3, #32
   43852:	f3ef 8211 	mrs	r2, BASEPRI
   43856:	f383 8812 	msr	BASEPRI_MAX, r3
   4385a:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   4385e:	4b27      	ldr	r3, [pc, #156]	; (438fc <rtc_nrf_isr+0xd0>)
   43860:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   43864:	03db      	lsls	r3, r3, #15
   43866:	d50e      	bpl.n	43886 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43868:	4b27      	ldr	r3, [pc, #156]	; (43908 <rtc_nrf_isr+0xdc>)
   4386a:	e8d3 1fef 	ldaex	r1, [r3]
   4386e:	f021 0001 	bic.w	r0, r1, #1
   43872:	e8c3 0fe4 	stlex	r4, r0, [r3]
   43876:	2c00      	cmp	r4, #0
   43878:	d1f7      	bne.n	4386a <rtc_nrf_isr+0x3e>
   4387a:	4b24      	ldr	r3, [pc, #144]	; (4390c <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   4387c:	2900      	cmp	r1, #0
   4387e:	d136      	bne.n	438ee <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   43880:	6819      	ldr	r1, [r3, #0]
		if (result) {
   43882:	2900      	cmp	r1, #0
   43884:	d133      	bne.n	438ee <rtc_nrf_isr+0xc2>
{
   43886:	2300      	movs	r3, #0
	__asm__ volatile(
   43888:	f382 8811 	msr	BASEPRI, r2
   4388c:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   43890:	b353      	cbz	r3, 438e8 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   43892:	f7ff fec7 	bl	43624 <z_nrf_rtc_timer_read>
   43896:	4604      	mov	r4, r0
	__asm__ volatile(
   43898:	f04f 0320 	mov.w	r3, #32
   4389c:	f3ef 8011 	mrs	r0, BASEPRI
   438a0:	f383 8812 	msr	BASEPRI_MAX, r3
   438a4:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   438a8:	4b19      	ldr	r3, [pc, #100]	; (43910 <rtc_nrf_isr+0xe4>)
   438aa:	2200      	movs	r2, #0
   438ac:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   438b0:	4549      	cmp	r1, r9
   438b2:	bf08      	it	eq
   438b4:	4544      	cmpeq	r4, r8
   438b6:	d31f      	bcc.n	438f8 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   438b8:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   438bc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   438c0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   438c4:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   438c6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   438ca:	e9c3 4502 	strd	r4, r5, [r3, #8]
   438ce:	4b0b      	ldr	r3, [pc, #44]	; (438fc <rtc_nrf_isr+0xd0>)
   438d0:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   438d4:	f380 8811 	msr	BASEPRI, r0
   438d8:	f3bf 8f6f 	isb	sy
		if (handler) {
   438dc:	b121      	cbz	r1, 438e8 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   438de:	4642      	mov	r2, r8
   438e0:	464b      	mov	r3, r9
   438e2:	2000      	movs	r0, #0
   438e4:	9600      	str	r6, [sp, #0]
   438e6:	4788      	blx	r1
}
   438e8:	b002      	add	sp, #8
   438ea:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   438ee:	2100      	movs	r1, #0
   438f0:	6019      	str	r1, [r3, #0]
   438f2:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   438f4:	2301      	movs	r3, #1
}
   438f6:	e7c7      	b.n	43888 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   438f8:	4611      	mov	r1, r2
   438fa:	e7eb      	b.n	438d4 <rtc_nrf_isr+0xa8>
   438fc:	40015000 	.word	0x40015000
   43900:	40015104 	.word	0x40015104
   43904:	2001a98c 	.word	0x2001a98c
   43908:	2001a984 	.word	0x2001a984
   4390c:	40015140 	.word	0x40015140
   43910:	2001a718 	.word	0x2001a718

00043914 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43914:	4b15      	ldr	r3, [pc, #84]	; (4396c <sys_clock_set_timeout+0x58>)
{
   43916:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43918:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   4391c:	bf08      	it	eq
   4391e:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43920:	1e46      	subs	r6, r0, #1
   43922:	2e00      	cmp	r6, #0
   43924:	dd20      	ble.n	43968 <sys_clock_set_timeout+0x54>
   43926:	429e      	cmp	r6, r3
   43928:	bfa8      	it	ge
   4392a:	461e      	movge	r6, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   4392c:	f7ff fe7a 	bl	43624 <z_nrf_rtc_timer_read>
   43930:	4b0f      	ldr	r3, [pc, #60]	; (43970 <sys_clock_set_timeout+0x5c>)
   43932:	e9d3 4500 	ldrd	r4, r5, [r3]
   43936:	1b00      	subs	r0, r0, r4
		ticks = 0;
   43938:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   4393c:	bf28      	it	cs
   4393e:	2600      	movcs	r6, #0
	cyc += (CYC_PER_TICK - 1);
   43940:	3020      	adds	r0, #32
   43942:	eb00 1246 	add.w	r2, r0, r6, lsl #5
	uint64_t target_time = cyc + last_count;
   43946:	480b      	ldr	r0, [pc, #44]	; (43974 <sys_clock_set_timeout+0x60>)
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
   43948:	f022 021f 	bic.w	r2, r2, #31
	uint64_t target_time = cyc + last_count;
   4394c:	4282      	cmp	r2, r0
   4394e:	bf28      	it	cs
   43950:	4602      	movcs	r2, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   43952:	2000      	movs	r0, #0
   43954:	4b08      	ldr	r3, [pc, #32]	; (43978 <sys_clock_set_timeout+0x64>)
   43956:	18a2      	adds	r2, r4, r2
   43958:	9300      	str	r3, [sp, #0]
   4395a:	9001      	str	r0, [sp, #4]
   4395c:	f145 0300 	adc.w	r3, r5, #0
   43960:	f7ff fe82 	bl	43668 <compare_set>
}
   43964:	b002      	add	sp, #8
   43966:	bd70      	pop	{r4, r5, r6, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43968:	2600      	movs	r6, #0
   4396a:	e7df      	b.n	4392c <sys_clock_set_timeout+0x18>
   4396c:	0003ffff 	.word	0x0003ffff
   43970:	2001a728 	.word	0x2001a728
   43974:	007fffe0 	.word	0x007fffe0
   43978:	00043501 	.word	0x00043501

0004397c <sys_clock_elapsed>:
{
   4397c:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   4397e:	f7ff fe51 	bl	43624 <z_nrf_rtc_timer_read>
   43982:	4a05      	ldr	r2, [pc, #20]	; (43998 <sys_clock_elapsed+0x1c>)
   43984:	e9d2 3200 	ldrd	r3, r2, [r2]
   43988:	1ac0      	subs	r0, r0, r3
   4398a:	eb61 0102 	sbc.w	r1, r1, r2
   4398e:	0940      	lsrs	r0, r0, #5
}
   43990:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
   43994:	bd08      	pop	{r3, pc}
   43996:	bf00      	nop
   43998:	2001a728 	.word	0x2001a728

0004399c <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   4399c:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   4399e:	4d19      	ldr	r5, [pc, #100]	; (43a04 <_nrf_modem_lib_init+0x68>)
   439a0:	4c19      	ldr	r4, [pc, #100]	; (43a08 <_nrf_modem_lib_init+0x6c>)
   439a2:	782b      	ldrb	r3, [r5, #0]
   439a4:	b933      	cbnz	r3, 439b4 <_nrf_modem_lib_init+0x18>
	list->tail = NULL;
   439a6:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   439aa:	4818      	ldr	r0, [pc, #96]	; (43a0c <_nrf_modem_lib_init+0x70>)
   439ac:	f004 ffbe 	bl	4892c <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   439b0:	2301      	movs	r3, #1
   439b2:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   439b4:	2200      	movs	r2, #0
   439b6:	202a      	movs	r0, #42	; 0x2a
   439b8:	4611      	mov	r1, r2
   439ba:	f7fe fb3d 	bl	42038 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   439be:	2100      	movs	r1, #0
   439c0:	4813      	ldr	r0, [pc, #76]	; (43a10 <_nrf_modem_lib_init+0x74>)
   439c2:	f002 f965 	bl	45c90 <nrf_modem_init>
   439c6:	4b13      	ldr	r3, [pc, #76]	; (43a14 <_nrf_modem_lib_init+0x78>)
   439c8:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   439ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   439ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   439d2:	480e      	ldr	r0, [pc, #56]	; (43a0c <_nrf_modem_lib_init+0x70>)
   439d4:	f002 fd7e 	bl	464d4 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   439d8:	6820      	ldr	r0, [r4, #0]
   439da:	b170      	cbz	r0, 439fa <_nrf_modem_lib_init+0x5e>
	return node->next;
   439dc:	6804      	ldr	r4, [r0, #0]
   439de:	2c00      	cmp	r4, #0
   439e0:	bf38      	it	cc
   439e2:	2400      	movcc	r4, #0
	z_impl_k_sem_give(sem);
   439e4:	3004      	adds	r0, #4
   439e6:	f002 fe39 	bl	4665c <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   439ea:	b134      	cbz	r4, 439fa <_nrf_modem_lib_init+0x5e>
   439ec:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   439ee:	4620      	mov	r0, r4
   439f0:	2b00      	cmp	r3, #0
   439f2:	bf38      	it	cc
   439f4:	2300      	movcc	r3, #0
   439f6:	461c      	mov	r4, r3
   439f8:	e7f4      	b.n	439e4 <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   439fa:	4804      	ldr	r0, [pc, #16]	; (43a0c <_nrf_modem_lib_init+0x70>)
   439fc:	f002 fde8 	bl	465d0 <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   43a00:	2000      	movs	r0, #0
   43a02:	bd38      	pop	{r3, r4, r5, pc}
   43a04:	2001ae6a 	.word	0x2001ae6a
   43a08:	2001a994 	.word	0x2001a994
   43a0c:	2001a99c 	.word	0x2001a99c
   43a10:	00049158 	.word	0x00049158
   43a14:	2001a990 	.word	0x2001a990

00043a18 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   43a18:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   43a1a:	4c0d      	ldr	r4, [pc, #52]	; (43a50 <thread_monitor_entry_get+0x38>)
{
   43a1c:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   43a1e:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   43a20:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   43a22:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   43a24:	4b0b      	ldr	r3, [pc, #44]	; (43a54 <thread_monitor_entry_get+0x3c>)
   43a26:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   43a28:	6801      	ldr	r1, [r0, #0]
   43a2a:	4291      	cmp	r1, r2
   43a2c:	d00e      	beq.n	43a4c <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   43a2e:	b151      	cbz	r1, 43a46 <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   43a30:	6841      	ldr	r1, [r0, #4]
   43a32:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   43a34:	42b1      	cmp	r1, r6
   43a36:	bfc4      	itt	gt
   43a38:	4604      	movgt	r4, r0
   43a3a:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   43a3c:	3d01      	subs	r5, #1
   43a3e:	f100 0008 	add.w	r0, r0, #8
   43a42:	d1f1      	bne.n	43a28 <thread_monitor_entry_get+0x10>
   43a44:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   43a46:	3b01      	subs	r3, #1
	new_entry->id = id;
   43a48:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   43a4a:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   43a4c:	bd70      	pop	{r4, r5, r6, pc}
   43a4e:	bf00      	nop
   43a50:	2001aa08 	.word	0x2001aa08
   43a54:	2001a9e4 	.word	0x2001a9e4

00043a58 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43a58:	4668      	mov	r0, sp
   43a5a:	f020 0107 	bic.w	r1, r0, #7
   43a5e:	468d      	mov	sp, r1
   43a60:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   43a62:	4b0f      	ldr	r3, [pc, #60]	; (43aa0 <rpc_proxy_irq_handler+0x48>)
   43a64:	e8d3 2fef 	ldaex	r2, [r3]
   43a68:	3201      	adds	r2, #1
   43a6a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   43a6e:	2900      	cmp	r1, #0
   43a70:	d1f8      	bne.n	43a64 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   43a72:	f001 f951 	bl	44d18 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   43a76:	4b0b      	ldr	r3, [pc, #44]	; (43aa4 <rpc_proxy_irq_handler+0x4c>)
   43a78:	681c      	ldr	r4, [r3, #0]
   43a7a:	2c00      	cmp	r4, #0
   43a7c:	bf38      	it	cc
   43a7e:	2400      	movcc	r4, #0
   43a80:	b12c      	cbz	r4, 43a8e <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   43a82:	1d20      	adds	r0, r4, #4
   43a84:	f002 fdea 	bl	4665c <z_impl_k_sem_give>
   43a88:	6824      	ldr	r4, [r4, #0]
   43a8a:	2c00      	cmp	r4, #0
   43a8c:	d1f8      	bne.n	43a80 <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   43a8e:	f7fe fae9 	bl	42064 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   43a92:	f7fe fbc1 	bl	42218 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43a96:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   43a9a:	4685      	mov	sp, r0
   43a9c:	4770      	bx	lr
   43a9e:	bf00      	nop
   43aa0:	2001a9e4 	.word	0x2001a9e4
   43aa4:	2001aa00 	.word	0x2001aa00

00043aa8 <nrf_modem_os_timedwait>:
{
   43aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43aac:	4688      	mov	r8, r1
   43aae:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   43ab0:	f005 f885 	bl	48bbe <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   43ab4:	f8d8 3000 	ldr.w	r3, [r8]
   43ab8:	4604      	mov	r4, r0
   43aba:	2b00      	cmp	r3, #0
   43abc:	460d      	mov	r5, r1
   43abe:	d103      	bne.n	43ac8 <nrf_modem_os_timedwait+0x20>
	z_impl_k_yield();
   43ac0:	f003 f864 	bl	46b8c <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   43ac4:	2074      	movs	r0, #116	; 0x74
   43ac6:	e077      	b.n	43bb8 <nrf_modem_os_timedwait+0x110>
		*timeout = SYS_FOREVER_MS;
   43ac8:	bfbc      	itt	lt
   43aca:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   43ace:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   43ad2:	2201      	movs	r2, #1
   43ad4:	2100      	movs	r1, #0
   43ad6:	a802      	add	r0, sp, #8
   43ad8:	f004 ff2f 	bl	4893a <z_impl_k_sem_init>
   43adc:	f10d 0904 	add.w	r9, sp, #4
	__asm__ volatile(
   43ae0:	f04f 0320 	mov.w	r3, #32
   43ae4:	f3ef 8b11 	mrs	fp, BASEPRI
   43ae8:	f383 8812 	msr	BASEPRI_MAX, r3
   43aec:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   43af0:	f003 f8ee 	bl	46cd0 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43af4:	f7ff ff90 	bl	43a18 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   43af8:	4938      	ldr	r1, [pc, #224]	; (43bdc <nrf_modem_os_timedwait+0x134>)
   43afa:	6843      	ldr	r3, [r0, #4]
   43afc:	680a      	ldr	r2, [r1, #0]
   43afe:	468a      	mov	sl, r1
   43b00:	4293      	cmp	r3, r2
   43b02:	f04f 0300 	mov.w	r3, #0
   43b06:	d108      	bne.n	43b1a <nrf_modem_os_timedwait+0x72>
	parent->next = child;
   43b08:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   43b0a:	4b35      	ldr	r3, [pc, #212]	; (43be0 <nrf_modem_os_timedwait+0x138>)
   43b0c:	685a      	ldr	r2, [r3, #4]
   43b0e:	2a00      	cmp	r2, #0
   43b10:	d155      	bne.n	43bbe <nrf_modem_os_timedwait+0x116>
	list->head = node;
   43b12:	e9c3 9900 	strd	r9, r9, [r3]
		allow_to_sleep = true;
   43b16:	2301      	movs	r3, #1
}
   43b18:	e000      	b.n	43b1c <nrf_modem_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   43b1a:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   43b1c:	f38b 8811 	msr	BASEPRI, fp
   43b20:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   43b24:	2b00      	cmp	r3, #0
   43b26:	d046      	beq.n	43bb6 <nrf_modem_os_timedwait+0x10e>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   43b28:	f8d8 2000 	ldr.w	r2, [r8]
   43b2c:	1c53      	adds	r3, r2, #1
   43b2e:	bf19      	ittee	ne
   43b30:	ea22 72e2 	bicne.w	r2, r2, r2, asr #31
   43b34:	17d3      	asrne	r3, r2, #31
   43b36:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   43b3a:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
	return z_impl_k_sem_take(sem, timeout);
   43b3e:	a802      	add	r0, sp, #8
   43b40:	f002 fdac 	bl	4669c <z_impl_k_sem_take>
	__asm__ volatile(
   43b44:	f04f 0320 	mov.w	r3, #32
   43b48:	f3ef 8b11 	mrs	fp, BASEPRI
   43b4c:	f383 8812 	msr	BASEPRI_MAX, r3
   43b50:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43b54:	2000      	movs	r0, #0
   43b56:	4b22      	ldr	r3, [pc, #136]	; (43be0 <nrf_modem_os_timedwait+0x138>)
   43b58:	681a      	ldr	r2, [r3, #0]
   43b5a:	b152      	cbz	r2, 43b72 <nrf_modem_os_timedwait+0xca>
   43b5c:	454a      	cmp	r2, r9
   43b5e:	d139      	bne.n	43bd4 <nrf_modem_os_timedwait+0x12c>
Z_GENLIST_REMOVE(slist, snode)
   43b60:	9901      	ldr	r1, [sp, #4]
   43b62:	bb88      	cbnz	r0, 43bc8 <nrf_modem_os_timedwait+0x120>
   43b64:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   43b66:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   43b68:	4290      	cmp	r0, r2
   43b6a:	d100      	bne.n	43b6e <nrf_modem_os_timedwait+0xc6>
	list->tail = node;
   43b6c:	6059      	str	r1, [r3, #4]
	parent->next = child;
   43b6e:	2300      	movs	r3, #0
   43b70:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   43b72:	f003 f8ad 	bl	46cd0 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43b76:	f7ff ff4f 	bl	43a18 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   43b7a:	f8da 3000 	ldr.w	r3, [sl]
   43b7e:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   43b80:	f38b 8811 	msr	BASEPRI, fp
   43b84:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   43b88:	f8d8 9000 	ldr.w	r9, [r8]
   43b8c:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   43b90:	d011      	beq.n	43bb6 <nrf_modem_os_timedwait+0x10e>
	return z_impl_k_uptime_ticks();
   43b92:	f005 f814 	bl	48bbe <z_impl_k_uptime_ticks>
	remaining = *timeout - k_uptime_delta(&start);
   43b96:	eb14 0409 	adds.w	r4, r4, r9
   43b9a:	eb45 75e9 	adc.w	r5, r5, r9, asr #31
   43b9e:	1a26      	subs	r6, r4, r0
   43ba0:	eb65 0701 	sbc.w	r7, r5, r1
	*timeout = remaining > 0 ? remaining : 0;
   43ba4:	2e00      	cmp	r6, #0
   43ba6:	f177 0300 	sbcs.w	r3, r7, #0
   43baa:	bfb8      	it	lt
   43bac:	2600      	movlt	r6, #0
   43bae:	f8c8 6000 	str.w	r6, [r8]
	if (*timeout == 0) {
   43bb2:	2e00      	cmp	r6, #0
   43bb4:	d086      	beq.n	43ac4 <nrf_modem_os_timedwait+0x1c>
	return 0;
   43bb6:	2000      	movs	r0, #0
}
   43bb8:	b007      	add	sp, #28
   43bba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43bbe:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   43bc2:	f8c3 9004 	str.w	r9, [r3, #4]
   43bc6:	e7a6      	b.n	43b16 <nrf_modem_os_timedwait+0x6e>
	parent->next = child;
   43bc8:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   43bca:	6859      	ldr	r1, [r3, #4]
   43bcc:	4291      	cmp	r1, r2
	list->tail = node;
   43bce:	bf08      	it	eq
   43bd0:	6058      	streq	r0, [r3, #4]
}
   43bd2:	e7cc      	b.n	43b6e <nrf_modem_os_timedwait+0xc6>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43bd4:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43bd6:	6812      	ldr	r2, [r2, #0]
   43bd8:	e7bf      	b.n	43b5a <nrf_modem_os_timedwait+0xb2>
   43bda:	bf00      	nop
   43bdc:	2001a9e4 	.word	0x2001a9e4
   43be0:	2001aa00 	.word	0x2001aa00

00043be4 <nrf_modem_os_sem_init>:
{
   43be4:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   43be6:	6804      	ldr	r4, [r0, #0]
   43be8:	4b09      	ldr	r3, [pc, #36]	; (43c10 <nrf_modem_os_sem_init+0x2c>)
   43bea:	b12c      	cbz	r4, 43bf8 <nrf_modem_os_sem_init+0x14>
   43bec:	429c      	cmp	r4, r3
   43bee:	d303      	bcc.n	43bf8 <nrf_modem_os_sem_init+0x14>
   43bf0:	f103 0530 	add.w	r5, r3, #48	; 0x30
   43bf4:	42ac      	cmp	r4, r5
   43bf6:	d306      	bcc.n	43c06 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   43bf8:	4d06      	ldr	r5, [pc, #24]	; (43c14 <nrf_modem_os_sem_init+0x30>)
   43bfa:	782c      	ldrb	r4, [r5, #0]
   43bfc:	1c66      	adds	r6, r4, #1
   43bfe:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   43c02:	702e      	strb	r6, [r5, #0]
   43c04:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   43c06:	6800      	ldr	r0, [r0, #0]
}
   43c08:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   43c0a:	f004 be96 	b.w	4893a <z_impl_k_sem_init>
   43c0e:	bf00      	nop
   43c10:	2001a9b4 	.word	0x2001a9b4
   43c14:	2001ae6b 	.word	0x2001ae6b

00043c18 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c18:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43c1c:	4b01      	ldr	r3, [pc, #4]	; (43c24 <nrf_modem_os_application_irq_set+0xc>)
   43c1e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43c22:	4770      	bx	lr
   43c24:	e000e100 	.word	0xe000e100

00043c28 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c28:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43c2c:	4b01      	ldr	r3, [pc, #4]	; (43c34 <nrf_modem_os_application_irq_clear+0xc>)
   43c2e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43c32:	4770      	bx	lr
   43c34:	e000e100 	.word	0xe000e100

00043c38 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c38:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43c3c:	4b01      	ldr	r3, [pc, #4]	; (43c44 <nrf_modem_os_trace_irq_set+0xc>)
   43c3e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43c42:	4770      	bx	lr
   43c44:	e000e100 	.word	0xe000e100

00043c48 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c48:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43c4c:	4b01      	ldr	r3, [pc, #4]	; (43c54 <nrf_modem_os_trace_irq_clear+0xc>)
   43c4e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43c52:	4770      	bx	lr
   43c54:	e000e100 	.word	0xe000e100

00043c58 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   43c58:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   43c5a:	2200      	movs	r2, #0
   43c5c:	2300      	movs	r3, #0
   43c5e:	4801      	ldr	r0, [pc, #4]	; (43c64 <nrf_modem_os_alloc+0xc>)
   43c60:	f004 bde7 	b.w	48832 <k_heap_alloc>
   43c64:	2001a608 	.word	0x2001a608

00043c68 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   43c68:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   43c6a:	4801      	ldr	r0, [pc, #4]	; (43c70 <nrf_modem_os_free+0x8>)
   43c6c:	f004 bdeb 	b.w	48846 <k_heap_free>
   43c70:	2001a608 	.word	0x2001a608

00043c74 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   43c74:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   43c76:	2200      	movs	r2, #0
   43c78:	2300      	movs	r3, #0
   43c7a:	4801      	ldr	r0, [pc, #4]	; (43c80 <nrf_modem_os_shm_tx_alloc+0xc>)
   43c7c:	f004 bdd9 	b.w	48832 <k_heap_alloc>
   43c80:	2001a9ec 	.word	0x2001a9ec

00043c84 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   43c84:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   43c86:	4801      	ldr	r0, [pc, #4]	; (43c8c <nrf_modem_os_shm_tx_free+0x8>)
   43c88:	f004 bddd 	b.w	48846 <k_heap_free>
   43c8c:	2001a9ec 	.word	0x2001a9ec

00043c90 <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   43c90:	b510      	push	{r4, lr}
	list->head = NULL;
   43c92:	2400      	movs	r4, #0
   43c94:	4b0e      	ldr	r3, [pc, #56]	; (43cd0 <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   43c96:	e9c3 4400 	strd	r4, r4, [r3]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43c9a:	4b0e      	ldr	r3, [pc, #56]	; (43cd4 <nrf_modem_os_init+0x44>)
   43c9c:	e8d3 2fef 	ldaex	r2, [r3]
   43ca0:	e8c3 4fe1 	stlex	r1, r4, [r3]
   43ca4:	2900      	cmp	r1, #0
   43ca6:	d1f9      	bne.n	43c9c <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   43ca8:	f004 fc54 	bl	48554 <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   43cac:	4621      	mov	r1, r4
   43cae:	2204      	movs	r2, #4
   43cb0:	4809      	ldr	r0, [pc, #36]	; (43cd8 <nrf_modem_os_init+0x48>)
   43cb2:	f004 faca 	bl	4824a <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   43cb6:	4621      	mov	r1, r4
   43cb8:	2204      	movs	r2, #4
   43cba:	4808      	ldr	r0, [pc, #32]	; (43cdc <nrf_modem_os_init+0x4c>)
   43cbc:	f004 fac5 	bl	4824a <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   43cc0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   43cc4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   43cc8:	4905      	ldr	r1, [pc, #20]	; (43ce0 <nrf_modem_os_init+0x50>)
   43cca:	4806      	ldr	r0, [pc, #24]	; (43ce4 <nrf_modem_os_init+0x54>)
   43ccc:	f004 bd62 	b.w	48794 <k_heap_init>
   43cd0:	2001aa00 	.word	0x2001aa00
   43cd4:	2001a9e4 	.word	0x2001a9e4
   43cd8:	2001a9b0 	.word	0x2001a9b0
   43cdc:	2001a9e8 	.word	0x2001a9e8
   43ce0:	200164e8 	.word	0x200164e8
   43ce4:	2001a9ec 	.word	0x2001a9ec

00043ce8 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   43ce8:	b508      	push	{r3, lr}
	z_impl_log_panic();
   43cea:	f7fd fc97 	bl	4161c <z_impl_log_panic>
   43cee:	4b06      	ldr	r3, [pc, #24]	; (43d08 <k_sys_fatal_error_handler+0x20>)
   43cf0:	4906      	ldr	r1, [pc, #24]	; (43d0c <k_sys_fatal_error_handler+0x24>)
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   43cf2:	4807      	ldr	r0, [pc, #28]	; (43d10 <k_sys_fatal_error_handler+0x28>)
   43cf4:	1ac9      	subs	r1, r1, r3
   43cf6:	08c9      	lsrs	r1, r1, #3
   43cf8:	0189      	lsls	r1, r1, #6
   43cfa:	f041 0101 	orr.w	r1, r1, #1
   43cfe:	f003 ff3c 	bl	47b7a <log_0>
		sys_arch_reboot(0);
   43d02:	2000      	movs	r0, #0
   43d04:	f004 fc35 	bl	48572 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   43d08:	00048f58 	.word	0x00048f58
   43d0c:	00048f68 	.word	0x00048f68
   43d10:	00049a8b 	.word	0x00049a8b

00043d14 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   43d14:	b5f0      	push	{r4, r5, r6, r7, lr}
   43d16:	4604      	mov	r4, r0
   43d18:	b0a3      	sub	sp, #140	; 0x8c
   43d1a:	460d      	mov	r5, r1
   43d1c:	4616      	mov	r6, r2
   43d1e:	461f      	mov	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   43d20:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43d24:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43d28:	480b      	ldr	r0, [pc, #44]	; (43d58 <tfm_ns_interface_dispatch+0x44>)
   43d2a:	f002 fbd3 	bl	464d4 <z_impl_k_mutex_lock>
	int32_t result;

	/* TF-M request protected by NS lock */
	if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   43d2e:	b988      	cbnz	r0, 43d54 <tfm_ns_interface_dispatch+0x40>
#endif

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   43d30:	4668      	mov	r0, sp
   43d32:	f004 fa17 	bl	48164 <z_arm_save_fp_context>
#endif

	result = fn(arg0, arg1, arg2, arg3);
   43d36:	463a      	mov	r2, r7
   43d38:	4631      	mov	r1, r6
   43d3a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   43d3c:	4628      	mov	r0, r5
   43d3e:	47a0      	blx	r4
   43d40:	4604      	mov	r4, r0

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	z_arm_restore_fp_context(&context_buffer);
   43d42:	4668      	mov	r0, sp
   43d44:	f004 fa0f 	bl	48166 <z_arm_restore_fp_context>
	return z_impl_k_mutex_unlock(mutex);
   43d48:	4803      	ldr	r0, [pc, #12]	; (43d58 <tfm_ns_interface_dispatch+0x44>)
   43d4a:	f002 fc41 	bl	465d0 <z_impl_k_mutex_unlock>
#endif

	k_mutex_unlock(&tfm_mutex);

	return result;
}
   43d4e:	4620      	mov	r0, r4
   43d50:	b023      	add	sp, #140	; 0x8c
   43d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (int32_t)TFM_ERROR_GENERIC;
   43d54:	241f      	movs	r4, #31
   43d56:	e7fa      	b.n	43d4e <tfm_ns_interface_dispatch+0x3a>
   43d58:	2001a630 	.word	0x2001a630

00043d5c <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   43d5c:	4b01      	ldr	r3, [pc, #4]	; (43d64 <SystemInit+0x8>)
   43d5e:	4a02      	ldr	r2, [pc, #8]	; (43d68 <SystemInit+0xc>)
   43d60:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   43d62:	4770      	bx	lr
   43d64:	2001a520 	.word	0x2001a520
   43d68:	03d09000 	.word	0x03d09000

00043d6c <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   43d6c:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   43d6e:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   43d70:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   43d72:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   43d76:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   43d78:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   43d7c:	d010      	beq.n	43da0 <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   43d7e:	fa05 f204 	lsl.w	r2, r5, r4
   43d82:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   43d86:	e8d0 6fef 	ldaex	r6, [r0]
   43d8a:	429e      	cmp	r6, r3
   43d8c:	d104      	bne.n	43d98 <nrfx_flag32_alloc+0x2c>
   43d8e:	e8c0 2fec 	stlex	ip, r2, [r0]
   43d92:	f1bc 0f00 	cmp.w	ip, #0
   43d96:	d1f6      	bne.n	43d86 <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43d98:	d1ea      	bne.n	43d70 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   43d9a:	4802      	ldr	r0, [pc, #8]	; (43da4 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   43d9c:	700c      	strb	r4, [r1, #0]
}
   43d9e:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   43da0:	4801      	ldr	r0, [pc, #4]	; (43da8 <nrfx_flag32_alloc+0x3c>)
   43da2:	e7fc      	b.n	43d9e <nrfx_flag32_alloc+0x32>
   43da4:	0bad0000 	.word	0x0bad0000
   43da8:	0bad0002 	.word	0x0bad0002

00043dac <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   43dac:	6803      	ldr	r3, [r0, #0]
{
   43dae:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   43db0:	40cb      	lsrs	r3, r1
   43db2:	07db      	lsls	r3, r3, #31
   43db4:	d411      	bmi.n	43dda <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   43db6:	2301      	movs	r3, #1
   43db8:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   43dbc:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   43dbe:	ea41 0203 	orr.w	r2, r1, r3
   43dc2:	e8d0 4fef 	ldaex	r4, [r0]
   43dc6:	429c      	cmp	r4, r3
   43dc8:	d104      	bne.n	43dd4 <nrfx_flag32_free+0x28>
   43dca:	e8c0 2fec 	stlex	ip, r2, [r0]
   43dce:	f1bc 0f00 	cmp.w	ip, #0
   43dd2:	d1f6      	bne.n	43dc2 <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43dd4:	d1f2      	bne.n	43dbc <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   43dd6:	4802      	ldr	r0, [pc, #8]	; (43de0 <nrfx_flag32_free+0x34>)
}
   43dd8:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   43dda:	4802      	ldr	r0, [pc, #8]	; (43de4 <nrfx_flag32_free+0x38>)
   43ddc:	e7fc      	b.n	43dd8 <nrfx_flag32_free+0x2c>
   43dde:	bf00      	nop
   43de0:	0bad0000 	.word	0x0bad0000
   43de4:	0bad0004 	.word	0x0bad0004

00043de8 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   43de8:	4b04      	ldr	r3, [pc, #16]	; (43dfc <nrfx_clock_init+0x14>)
   43dea:	791a      	ldrb	r2, [r3, #4]
   43dec:	b922      	cbnz	r2, 43df8 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   43dee:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   43df0:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   43df2:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   43df4:	4802      	ldr	r0, [pc, #8]	; (43e00 <nrfx_clock_init+0x18>)
   43df6:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   43df8:	4802      	ldr	r0, [pc, #8]	; (43e04 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   43dfa:	4770      	bx	lr
   43dfc:	2001aa58 	.word	0x2001aa58
   43e00:	0bad0000 	.word	0x0bad0000
   43e04:	0bad000c 	.word	0x0bad000c

00043e08 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43e08:	b110      	cbz	r0, 43e10 <nrfx_clock_start+0x8>
   43e0a:	2801      	cmp	r0, #1
   43e0c:	d01e      	beq.n	43e4c <nrfx_clock_start+0x44>
   43e0e:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43e10:	4b13      	ldr	r3, [pc, #76]	; (43e60 <nrfx_clock_start+0x58>)
   43e12:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43e16:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   43e1a:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   43e1e:	4619      	mov	r1, r3
   43e20:	d010      	beq.n	43e44 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   43e22:	f002 0203 	and.w	r2, r2, #3
   43e26:	2a02      	cmp	r2, #2
   43e28:	d10c      	bne.n	43e44 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43e2a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e2e:	2200      	movs	r2, #0
   43e30:	4b0c      	ldr	r3, [pc, #48]	; (43e64 <nrfx_clock_start+0x5c>)
   43e32:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   43e34:	2202      	movs	r2, #2
   43e36:	681b      	ldr	r3, [r3, #0]
   43e38:	4b09      	ldr	r3, [pc, #36]	; (43e60 <nrfx_clock_start+0x58>)
   43e3a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e3e:	2201      	movs	r2, #1
   43e40:	609a      	str	r2, [r3, #8]
}
   43e42:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   43e44:	2301      	movs	r3, #1
   43e46:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   43e4a:	e7f0      	b.n	43e2e <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e4c:	2200      	movs	r2, #0
   43e4e:	4b06      	ldr	r3, [pc, #24]	; (43e68 <nrfx_clock_start+0x60>)
   43e50:	601a      	str	r2, [r3, #0]
   43e52:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   43e54:	4b02      	ldr	r3, [pc, #8]	; (43e60 <nrfx_clock_start+0x58>)
   43e56:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e5a:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   43e5c:	4770      	bx	lr
   43e5e:	bf00      	nop
   43e60:	40005000 	.word	0x40005000
   43e64:	40005104 	.word	0x40005104
   43e68:	40005100 	.word	0x40005100

00043e6c <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   43e6c:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43e6e:	b110      	cbz	r0, 43e76 <nrfx_clock_stop+0xa>
   43e70:	2801      	cmp	r0, #1
   43e72:	d016      	beq.n	43ea2 <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   43e74:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   43e76:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e78:	2101      	movs	r1, #1
   43e7a:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   43e7e:	4c16      	ldr	r4, [pc, #88]	; (43ed8 <nrfx_clock_stop+0x6c>)
   43e80:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43e84:	4a15      	ldr	r2, [pc, #84]	; (43edc <nrfx_clock_stop+0x70>)
   43e86:	6010      	str	r0, [r2, #0]
   43e88:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43e8a:	4a15      	ldr	r2, [pc, #84]	; (43ee0 <nrfx_clock_stop+0x74>)
   43e8c:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43e8e:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   43e92:	03db      	lsls	r3, r3, #15
   43e94:	d5ee      	bpl.n	43e74 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   43e96:	2001      	movs	r0, #1
   43e98:	f004 fb6e 	bl	48578 <nrfx_busy_wait>
   43e9c:	3d01      	subs	r5, #1
   43e9e:	d1f6      	bne.n	43e8e <nrfx_clock_stop+0x22>
   43ea0:	e7e8      	b.n	43e74 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ea2:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43ea4:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ea8:	4b0e      	ldr	r3, [pc, #56]	; (43ee4 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   43eaa:	4c0b      	ldr	r4, [pc, #44]	; (43ed8 <nrfx_clock_stop+0x6c>)
   43eac:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43eb0:	601a      	str	r2, [r3, #0]
   43eb2:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43eb4:	4b0c      	ldr	r3, [pc, #48]	; (43ee8 <nrfx_clock_stop+0x7c>)
   43eb6:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43eb8:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43ebc:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43ec0:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43ec4:	03d2      	lsls	r2, r2, #15
   43ec6:	d5d5      	bpl.n	43e74 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   43ec8:	2b00      	cmp	r3, #0
   43eca:	d0d3      	beq.n	43e74 <nrfx_clock_stop+0x8>
   43ecc:	2001      	movs	r0, #1
   43ece:	f004 fb53 	bl	48578 <nrfx_busy_wait>
   43ed2:	3d01      	subs	r5, #1
   43ed4:	d1f0      	bne.n	43eb8 <nrfx_clock_stop+0x4c>
   43ed6:	e7cd      	b.n	43e74 <nrfx_clock_stop+0x8>
   43ed8:	40005000 	.word	0x40005000
   43edc:	40005104 	.word	0x40005104
   43ee0:	4000500c 	.word	0x4000500c
   43ee4:	40005100 	.word	0x40005100
   43ee8:	40005004 	.word	0x40005004

00043eec <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43eec:	4b15      	ldr	r3, [pc, #84]	; (43f44 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   43eee:	b510      	push	{r4, lr}
   43ef0:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   43ef2:	b14a      	cbz	r2, 43f08 <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ef4:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   43ef6:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ef8:	6018      	str	r0, [r3, #0]
   43efa:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   43efc:	4b12      	ldr	r3, [pc, #72]	; (43f48 <nrfx_power_clock_irq_handler+0x5c>)
   43efe:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   43f02:	4b12      	ldr	r3, [pc, #72]	; (43f4c <nrfx_power_clock_irq_handler+0x60>)
   43f04:	681b      	ldr	r3, [r3, #0]
   43f06:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   43f08:	4b11      	ldr	r3, [pc, #68]	; (43f50 <nrfx_power_clock_irq_handler+0x64>)
   43f0a:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   43f0c:	b182      	cbz	r2, 43f30 <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43f0e:	2200      	movs	r2, #0
   43f10:	601a      	str	r2, [r3, #0]
   43f12:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43f14:	4b0c      	ldr	r3, [pc, #48]	; (43f48 <nrfx_power_clock_irq_handler+0x5c>)
   43f16:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43f1a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   43f1e:	f002 0203 	and.w	r2, r2, #3
   43f22:	2a01      	cmp	r2, #1
   43f24:	f04f 0102 	mov.w	r1, #2
   43f28:	d103      	bne.n	43f32 <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43f2a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43f2e:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   43f30:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   43f32:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43f36:	4b05      	ldr	r3, [pc, #20]	; (43f4c <nrfx_power_clock_irq_handler+0x60>)
   43f38:	2001      	movs	r0, #1
}
   43f3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   43f3e:	681b      	ldr	r3, [r3, #0]
   43f40:	4718      	bx	r3
   43f42:	bf00      	nop
   43f44:	40005100 	.word	0x40005100
   43f48:	40005000 	.word	0x40005000
   43f4c:	2001aa58 	.word	0x2001aa58
   43f50:	40005104 	.word	0x40005104

00043f54 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   43f54:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   43f56:	4801      	ldr	r0, [pc, #4]	; (43f5c <nrfx_dppi_channel_alloc+0x8>)
   43f58:	f7ff bf08 	b.w	43d6c <nrfx_flag32_alloc>
   43f5c:	2001a524 	.word	0x2001a524

00043f60 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   43f60:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f62:	4c0d      	ldr	r4, [pc, #52]	; (43f98 <call_handler+0x38>)
   43f64:	f100 0308 	add.w	r3, r0, #8
   43f68:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   43f6c:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f6e:	05da      	lsls	r2, r3, #23
{
   43f70:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f72:	d507      	bpl.n	43f84 <call_handler+0x24>
   43f74:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   43f78:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   43f7c:	6852      	ldr	r2, [r2, #4]
   43f7e:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   43f82:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   43f84:	68a3      	ldr	r3, [r4, #8]
   43f86:	b12b      	cbz	r3, 43f94 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43f88:	4631      	mov	r1, r6
   43f8a:	4628      	mov	r0, r5
   43f8c:	68e2      	ldr	r2, [r4, #12]
    }
}
   43f8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   43f92:	4718      	bx	r3
}
   43f94:	bd70      	pop	{r4, r5, r6, pc}
   43f96:	bf00      	nop
   43f98:	2001a528 	.word	0x2001a528

00043f9c <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43f9c:	4b12      	ldr	r3, [pc, #72]	; (43fe8 <release_handler+0x4c>)
   43f9e:	3008      	adds	r0, #8
   43fa0:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   43fa4:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   43fa6:	05d1      	lsls	r1, r2, #23
   43fa8:	d51b      	bpl.n	43fe2 <release_handler+0x46>
   43faa:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   43fae:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   43fb2:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43fb6:	2000      	movs	r0, #0
   43fb8:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   43fbc:	f834 2b02 	ldrh.w	r2, [r4], #2
   43fc0:	f412 7f80 	tst.w	r2, #256	; 0x100
   43fc4:	d003      	beq.n	43fce <release_handler+0x32>
   43fc6:	f3c2 2243 	ubfx	r2, r2, #9, #4
   43fca:	4291      	cmp	r1, r2
   43fcc:	d009      	beq.n	43fe2 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   43fce:	3001      	adds	r0, #1
   43fd0:	2820      	cmp	r0, #32
   43fd2:	d1f3      	bne.n	43fbc <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   43fd4:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43fd6:	4805      	ldr	r0, [pc, #20]	; (43fec <release_handler+0x50>)
}
   43fd8:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   43fda:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   43fde:	f7ff bee5 	b.w	43dac <nrfx_flag32_free>
}
   43fe2:	bc10      	pop	{r4}
   43fe4:	4770      	bx	lr
   43fe6:	bf00      	nop
   43fe8:	2001a528 	.word	0x2001a528
   43fec:	2001a57c 	.word	0x2001a57c

00043ff0 <pin_handler_trigger_uninit>:
{
   43ff0:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   43ff2:	4c0c      	ldr	r4, [pc, #48]	; (44024 <pin_handler_trigger_uninit+0x34>)
   43ff4:	f100 0508 	add.w	r5, r0, #8
   43ff8:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   43ffc:	069a      	lsls	r2, r3, #26
   43ffe:	d50a      	bpl.n	44016 <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   44000:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   44002:	0b5b      	lsrs	r3, r3, #13
   44004:	009b      	lsls	r3, r3, #2
   44006:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   4400a:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   4400e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   44012:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   44016:	f7ff ffc1 	bl	43f9c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   4401a:	2300      	movs	r3, #0
   4401c:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   44020:	bd38      	pop	{r3, r4, r5, pc}
   44022:	bf00      	nop
   44024:	2001a528 	.word	0x2001a528

00044028 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   44028:	f000 021f 	and.w	r2, r0, #31
   4402c:	4805      	ldr	r0, [pc, #20]	; (44044 <nrf_gpio_cfg_sense_set+0x1c>)
   4402e:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44032:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   44036:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4403a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   4403e:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   44042:	4770      	bx	lr
   44044:	40842500 	.word	0x40842500

00044048 <nrfx_gpiote_input_configure>:
{
   44048:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4404a:	4604      	mov	r4, r0
    if (p_input_config)
   4404c:	b1f9      	cbz	r1, 4408e <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4404e:	4f4c      	ldr	r7, [pc, #304]	; (44180 <nrfx_gpiote_input_configure+0x138>)
   44050:	f100 0c08 	add.w	ip, r0, #8
   44054:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   44058:	f000 0522 	and.w	r5, r0, #34	; 0x22
   4405c:	2d22      	cmp	r5, #34	; 0x22
   4405e:	d102      	bne.n	44066 <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   44060:	4848      	ldr	r0, [pc, #288]	; (44184 <nrfx_gpiote_input_configure+0x13c>)
}
   44062:	b003      	add	sp, #12
   44064:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44066:	4d48      	ldr	r5, [pc, #288]	; (44188 <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   44068:	f004 061f 	and.w	r6, r4, #31
   4406c:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44070:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   44074:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   44076:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   4407a:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4407e:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   44082:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   44086:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   4408a:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   4408e:	b192      	cbz	r2, 440b6 <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44090:	483b      	ldr	r0, [pc, #236]	; (44180 <nrfx_gpiote_input_configure+0x138>)
   44092:	f104 0608 	add.w	r6, r4, #8
   44096:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   4409a:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   4409c:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   4409e:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   440a0:	d50c      	bpl.n	440bc <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   440a2:	2a00      	cmp	r2, #0
   440a4:	d1dc      	bne.n	44060 <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   440a6:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   440aa:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   440ae:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   440b2:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   440b6:	bbd3      	cbnz	r3, 4412e <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   440b8:	4834      	ldr	r0, [pc, #208]	; (4418c <nrfx_gpiote_input_configure+0x144>)
   440ba:	e7d2      	b.n	44062 <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   440bc:	f021 0120 	bic.w	r1, r1, #32
   440c0:	04c9      	lsls	r1, r1, #19
   440c2:	0cc9      	lsrs	r1, r1, #19
   440c4:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   440c8:	2a00      	cmp	r2, #0
   440ca:	d0ec      	beq.n	440a6 <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   440cc:	2d03      	cmp	r5, #3
   440ce:	d8c7      	bhi.n	44060 <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   440d0:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   440d4:	4662      	mov	r2, ip
   440d6:	0092      	lsls	r2, r2, #2
   440d8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   440dc:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   440e0:	b925      	cbnz	r5, 440ec <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   440e2:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   440e6:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   440ea:	e7dc      	b.n	440a6 <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   440ec:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   440f0:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   440f4:	f027 0703 	bic.w	r7, r7, #3
   440f8:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   440fc:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44100:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   44104:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   44108:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   4410c:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44110:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44114:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   44118:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   4411c:	ea47 070e 	orr.w	r7, r7, lr
   44120:	f041 0120 	orr.w	r1, r1, #32
   44124:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   44128:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   4412c:	e7bb      	b.n	440a6 <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   4412e:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   44130:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   44134:	f7ff ff32 	bl	43f9c <release_handler>
    if (!handler)
   44138:	2e00      	cmp	r6, #0
   4413a:	d0bd      	beq.n	440b8 <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   4413c:	4d10      	ldr	r5, [pc, #64]	; (44180 <nrfx_gpiote_input_configure+0x138>)
   4413e:	682b      	ldr	r3, [r5, #0]
   44140:	429e      	cmp	r6, r3
   44142:	d104      	bne.n	4414e <nrfx_gpiote_input_configure+0x106>
   44144:	686b      	ldr	r3, [r5, #4]
   44146:	429f      	cmp	r7, r3
   44148:	d101      	bne.n	4414e <nrfx_gpiote_input_configure+0x106>
   4414a:	2200      	movs	r2, #0
   4414c:	e009      	b.n	44162 <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   4414e:	4810      	ldr	r0, [pc, #64]	; (44190 <nrfx_gpiote_input_configure+0x148>)
   44150:	f10d 0107 	add.w	r1, sp, #7
   44154:	f7ff fe0a 	bl	43d6c <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   44158:	4b0c      	ldr	r3, [pc, #48]	; (4418c <nrfx_gpiote_input_configure+0x144>)
   4415a:	4298      	cmp	r0, r3
   4415c:	d181      	bne.n	44062 <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   4415e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   44162:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44166:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   44168:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   4416a:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   4416e:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44172:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   44176:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   4417a:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   4417e:	e79b      	b.n	440b8 <nrfx_gpiote_input_configure+0x70>
   44180:	2001a528 	.word	0x2001a528
   44184:	0bad0004 	.word	0x0bad0004
   44188:	40842500 	.word	0x40842500
   4418c:	0bad0000 	.word	0x0bad0000
   44190:	2001a57c 	.word	0x2001a57c

00044194 <nrfx_gpiote_output_configure>:
{
   44194:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   44198:	2900      	cmp	r1, #0
   4419a:	d044      	beq.n	44226 <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4419c:	4e43      	ldr	r6, [pc, #268]	; (442ac <nrfx_gpiote_output_configure+0x118>)
   4419e:	f100 0c08 	add.w	ip, r0, #8
   441a2:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   441a6:	07ab      	lsls	r3, r5, #30
   441a8:	d404      	bmi.n	441b4 <nrfx_gpiote_output_configure+0x20>
   441aa:	06af      	lsls	r7, r5, #26
   441ac:	d502      	bpl.n	441b4 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   441ae:	4840      	ldr	r0, [pc, #256]	; (442b0 <nrfx_gpiote_output_configure+0x11c>)
}
   441b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   441b4:	f015 0f1c 	tst.w	r5, #28
   441b8:	d002      	beq.n	441c0 <nrfx_gpiote_output_configure+0x2c>
   441ba:	784b      	ldrb	r3, [r1, #1]
   441bc:	2b01      	cmp	r3, #1
   441be:	d0f6      	beq.n	441ae <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   441c0:	4b3c      	ldr	r3, [pc, #240]	; (442b4 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   441c2:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   441c6:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   441ca:	bf14      	ite	ne
   441cc:	2402      	movne	r4, #2
   441ce:	2400      	moveq	r4, #0
   441d0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   441d4:	1c8b      	adds	r3, r1, #2
   441d6:	bf14      	ite	ne
   441d8:	f04f 090c 	movne.w	r9, #12
   441dc:	f04f 0900 	moveq.w	r9, #0
   441e0:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   441e4:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   441e8:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   441ec:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   441f0:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   441f4:	f1be 0f00 	cmp.w	lr, #0
   441f8:	d003      	beq.n	44202 <nrfx_gpiote_output_configure+0x6e>
   441fa:	f891 e001 	ldrb.w	lr, [r1, #1]
   441fe:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   44202:	b10b      	cbz	r3, 44208 <nrfx_gpiote_output_configure+0x74>
   44204:	788c      	ldrb	r4, [r1, #2]
   44206:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   44208:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   4420a:	f045 0503 	orr.w	r5, r5, #3
   4420e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   44212:	ea43 0308 	orr.w	r3, r3, r8
   44216:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4421a:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   4421e:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   44222:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   44226:	b90a      	cbnz	r2, 4422c <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   44228:	4823      	ldr	r0, [pc, #140]	; (442b8 <nrfx_gpiote_output_configure+0x124>)
   4422a:	e7c1      	b.n	441b0 <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4422c:	4d1f      	ldr	r5, [pc, #124]	; (442ac <nrfx_gpiote_output_configure+0x118>)
   4422e:	f100 0608 	add.w	r6, r0, #8
   44232:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   44236:	07a3      	lsls	r3, r4, #30
   44238:	d5b9      	bpl.n	441ae <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   4423a:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   4423c:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   4423e:	f024 0420 	bic.w	r4, r4, #32
   44242:	00b9      	lsls	r1, r7, #2
   44244:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   44248:	04e4      	lsls	r4, r4, #19
   4424a:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   4424e:	0ce4      	lsrs	r4, r4, #19
   44250:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44254:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   44258:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   4425c:	f892 c001 	ldrb.w	ip, [r2, #1]
   44260:	f1bc 0f00 	cmp.w	ip, #0
   44264:	d0e0      	beq.n	44228 <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   44266:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   4426a:	7892      	ldrb	r2, [r2, #2]
   4426c:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   44270:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   44274:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44278:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   4427c:	0203      	lsls	r3, r0, #8
   4427e:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   44282:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44286:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   4428a:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   4428e:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44290:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   44292:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44296:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4429a:	4313      	orrs	r3, r2
   4429c:	f044 0420 	orr.w	r4, r4, #32
   442a0:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   442a4:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   442a8:	e7be      	b.n	44228 <nrfx_gpiote_output_configure+0x94>
   442aa:	bf00      	nop
   442ac:	2001a528 	.word	0x2001a528
   442b0:	0bad0004 	.word	0x0bad0004
   442b4:	40842500 	.word	0x40842500
   442b8:	0bad0000 	.word	0x0bad0000

000442bc <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   442bc:	4b01      	ldr	r3, [pc, #4]	; (442c4 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   442be:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   442c2:	4770      	bx	lr
   442c4:	2001a528 	.word	0x2001a528

000442c8 <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   442c8:	4b05      	ldr	r3, [pc, #20]	; (442e0 <nrfx_gpiote_channel_get+0x18>)
   442ca:	3008      	adds	r0, #8
   442cc:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   442d0:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   442d2:	bf43      	ittte	mi
   442d4:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   442d6:	4803      	ldrmi	r0, [pc, #12]	; (442e4 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   442d8:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   442da:	4803      	ldrpl	r0, [pc, #12]	; (442e8 <nrfx_gpiote_channel_get+0x20>)
}
   442dc:	4770      	bx	lr
   442de:	bf00      	nop
   442e0:	2001a528 	.word	0x2001a528
   442e4:	0bad0000 	.word	0x0bad0000
   442e8:	0bad0004 	.word	0x0bad0004

000442ec <nrfx_gpiote_init>:
{
   442ec:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   442ee:	4c0e      	ldr	r4, [pc, #56]	; (44328 <nrfx_gpiote_init+0x3c>)
   442f0:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   442f4:	b9b5      	cbnz	r5, 44324 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   442f6:	2240      	movs	r2, #64	; 0x40
   442f8:	4629      	mov	r1, r5
   442fa:	f104 0010 	add.w	r0, r4, #16
   442fe:	f003 ffa4 	bl	4824a <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   44302:	2031      	movs	r0, #49	; 0x31
   44304:	f7fd fe7a 	bl	41ffc <arch_irq_enable>
    p_reg->INTENSET = mask;
   44308:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   4430c:	4b07      	ldr	r3, [pc, #28]	; (4432c <nrfx_gpiote_init+0x40>)
    return err_code;
   4430e:	4808      	ldr	r0, [pc, #32]	; (44330 <nrfx_gpiote_init+0x44>)
   44310:	601d      	str	r5, [r3, #0]
   44312:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   44314:	4b07      	ldr	r3, [pc, #28]	; (44334 <nrfx_gpiote_init+0x48>)
   44316:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   4431a:	2301      	movs	r3, #1
   4431c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   44320:	6563      	str	r3, [r4, #84]	; 0x54
}
   44322:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   44324:	4804      	ldr	r0, [pc, #16]	; (44338 <nrfx_gpiote_init+0x4c>)
   44326:	e7fc      	b.n	44322 <nrfx_gpiote_init+0x36>
   44328:	2001a528 	.word	0x2001a528
   4432c:	4003117c 	.word	0x4003117c
   44330:	0bad0000 	.word	0x0bad0000
   44334:	40031000 	.word	0x40031000
   44338:	0bad0005 	.word	0x0bad0005

0004433c <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   4433c:	4b03      	ldr	r3, [pc, #12]	; (4434c <nrfx_gpiote_is_init+0x10>)
   4433e:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   44342:	3800      	subs	r0, #0
   44344:	bf18      	it	ne
   44346:	2001      	movne	r0, #1
   44348:	4770      	bx	lr
   4434a:	bf00      	nop
   4434c:	2001a528 	.word	0x2001a528

00044350 <nrfx_gpiote_channel_free>:
{
   44350:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   44352:	4801      	ldr	r0, [pc, #4]	; (44358 <nrfx_gpiote_channel_free+0x8>)
   44354:	f7ff bd2a 	b.w	43dac <nrfx_flag32_free>
   44358:	2001a578 	.word	0x2001a578

0004435c <nrfx_gpiote_channel_alloc>:
{
   4435c:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   4435e:	4801      	ldr	r0, [pc, #4]	; (44364 <nrfx_gpiote_channel_alloc+0x8>)
   44360:	f7ff bd04 	b.w	43d6c <nrfx_flag32_alloc>
   44364:	2001a578 	.word	0x2001a578

00044368 <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44368:	4b1b      	ldr	r3, [pc, #108]	; (443d8 <nrfx_gpiote_trigger_enable+0x70>)
   4436a:	f100 0208 	add.w	r2, r0, #8
   4436e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   44372:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   44374:	069a      	lsls	r2, r3, #26
   44376:	d51a      	bpl.n	443ae <nrfx_gpiote_trigger_enable+0x46>
   44378:	f013 0402 	ands.w	r4, r3, #2
   4437c:	d117      	bne.n	443ae <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   4437e:	4817      	ldr	r0, [pc, #92]	; (443dc <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44380:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   44382:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44384:	5084      	str	r4, [r0, r2]
   44386:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   44388:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   4438c:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   44390:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   44394:	f040 0001 	orr.w	r0, r0, #1
   44398:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   4439c:	b129      	cbz	r1, 443aa <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   4439e:	2201      	movs	r2, #1
   443a0:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   443a4:	4a0e      	ldr	r2, [pc, #56]	; (443e0 <nrfx_gpiote_trigger_enable+0x78>)
   443a6:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   443aa:	bc10      	pop	{r4}
   443ac:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   443ae:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   443b2:	2b04      	cmp	r3, #4
   443b4:	d00c      	beq.n	443d0 <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   443b6:	2b05      	cmp	r3, #5
   443b8:	d00c      	beq.n	443d4 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   443ba:	4b0a      	ldr	r3, [pc, #40]	; (443e4 <nrfx_gpiote_trigger_enable+0x7c>)
   443bc:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   443be:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   443c2:	40d9      	lsrs	r1, r3
   443c4:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   443c8:	3102      	adds	r1, #2
}
   443ca:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   443cc:	f7ff be2c 	b.w	44028 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   443d0:	2103      	movs	r1, #3
   443d2:	e7fa      	b.n	443ca <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   443d4:	2102      	movs	r1, #2
   443d6:	e7f8      	b.n	443ca <nrfx_gpiote_trigger_enable+0x62>
   443d8:	2001a528 	.word	0x2001a528
   443dc:	40031100 	.word	0x40031100
   443e0:	40031000 	.word	0x40031000
   443e4:	40842500 	.word	0x40842500

000443e8 <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   443e8:	4b0e      	ldr	r3, [pc, #56]	; (44424 <nrfx_gpiote_trigger_disable+0x3c>)
   443ea:	f100 0208 	add.w	r2, r0, #8
   443ee:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   443f2:	0699      	lsls	r1, r3, #26
   443f4:	d513      	bpl.n	4441e <nrfx_gpiote_trigger_disable+0x36>
   443f6:	079a      	lsls	r2, r3, #30
   443f8:	d411      	bmi.n	4441e <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   443fa:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   443fc:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   443fe:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   44400:	4909      	ldr	r1, [pc, #36]	; (44428 <nrfx_gpiote_trigger_disable+0x40>)
   44402:	009b      	lsls	r3, r3, #2
   44404:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44408:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   4440c:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   44410:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   44414:	f022 0203 	bic.w	r2, r2, #3
   44418:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   4441c:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   4441e:	2100      	movs	r1, #0
   44420:	f7ff be02 	b.w	44028 <nrf_gpio_cfg_sense_set>
   44424:	2001a528 	.word	0x2001a528
   44428:	40031000 	.word	0x40031000

0004442c <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   4442c:	4b0c      	ldr	r3, [pc, #48]	; (44460 <nrfx_gpiote_pin_uninit+0x34>)
   4442e:	f100 0208 	add.w	r2, r0, #8
   44432:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   44436:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   44438:	07db      	lsls	r3, r3, #31
{
   4443a:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   4443c:	d50d      	bpl.n	4445a <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   4443e:	f7ff ffd3 	bl	443e8 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   44442:	4620      	mov	r0, r4
   44444:	f7ff fdd4 	bl	43ff0 <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   44448:	2202      	movs	r2, #2
   4444a:	4b06      	ldr	r3, [pc, #24]	; (44464 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   4444c:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   44450:	3480      	adds	r4, #128	; 0x80
   44452:	4805      	ldr	r0, [pc, #20]	; (44468 <nrfx_gpiote_pin_uninit+0x3c>)
   44454:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   44458:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   4445a:	4804      	ldr	r0, [pc, #16]	; (4446c <nrfx_gpiote_pin_uninit+0x40>)
   4445c:	e7fc      	b.n	44458 <nrfx_gpiote_pin_uninit+0x2c>
   4445e:	bf00      	nop
   44460:	2001a528 	.word	0x2001a528
   44464:	40842500 	.word	0x40842500
   44468:	0bad0000 	.word	0x0bad0000
   4446c:	0bad0004 	.word	0x0bad0004

00044470 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   44470:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   44474:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   44476:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44478:	4634      	mov	r4, r6
{
   4447a:	4b4b      	ldr	r3, [pc, #300]	; (445a8 <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   4447c:	484b      	ldr	r0, [pc, #300]	; (445ac <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   4447e:	494c      	ldr	r1, [pc, #304]	; (445b0 <nrfx_gpiote_irq_handler+0x140>)
{
   44480:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   44482:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   44484:	b135      	cbz	r5, 44494 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   44486:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   4448a:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   4448c:	bf1e      	ittt	ne
   4448e:	601c      	strne	r4, [r3, #0]
   44490:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   44492:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   44494:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44496:	428b      	cmp	r3, r1
        mask <<= 1;
   44498:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   4449c:	d1f1      	bne.n	44482 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4449e:	4f45      	ldr	r7, [pc, #276]	; (445b4 <nrfx_gpiote_irq_handler+0x144>)
   444a0:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   444a2:	b183      	cbz	r3, 444c6 <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   444a4:	4d44      	ldr	r5, [pc, #272]	; (445b8 <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   444a6:	f10d 080c 	add.w	r8, sp, #12
   444aa:	6a2b      	ldr	r3, [r5, #32]
   444ac:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   444ae:	622b      	str	r3, [r5, #32]
   444b0:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   444b4:	9803      	ldr	r0, [sp, #12]
   444b6:	b940      	cbnz	r0, 444ca <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   444b8:	6038      	str	r0, [r7, #0]
   444ba:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   444bc:	6a2b      	ldr	r3, [r5, #32]
   444be:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   444c0:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   444c2:	2b00      	cmp	r3, #0
   444c4:	d1f4      	bne.n	444b0 <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   444c6:	2401      	movs	r4, #1
   444c8:	e069      	b.n	4459e <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   444ca:	fa90 faa0 	rbit	sl, r0
   444ce:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   444d2:	4a3a      	ldr	r2, [pc, #232]	; (445bc <nrfx_gpiote_irq_handler+0x14c>)
   444d4:	f10a 0308 	add.w	r3, sl, #8
   444d8:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   444dc:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   444e0:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   444e4:	fa09 f403 	lsl.w	r4, r9, r3
   444e8:	f818 300c 	ldrb.w	r3, [r8, ip]
   444ec:	f3c1 0282 	ubfx	r2, r1, #2, #3
   444f0:	ea23 0304 	bic.w	r3, r3, r4
   444f4:	f808 300c 	strb.w	r3, [r8, ip]
   444f8:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   444fc:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   44500:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   44502:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   44504:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   44508:	d518      	bpl.n	4453c <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   4450a:	4611      	mov	r1, r2
   4450c:	4650      	mov	r0, sl
   4450e:	9301      	str	r3, [sp, #4]
   44510:	f7ff fd26 	bl	43f60 <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44514:	9b01      	ldr	r3, [sp, #4]
   44516:	b2e4      	uxtb	r4, r4
   44518:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   4451c:	f3c3 4301 	ubfx	r3, r3, #16, #2
   44520:	429c      	cmp	r4, r3
   44522:	d107      	bne.n	44534 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   44524:	2100      	movs	r1, #0
   44526:	4650      	mov	r0, sl
   44528:	f7ff fd7e 	bl	44028 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   4452c:	4621      	mov	r1, r4
   4452e:	4650      	mov	r0, sl
   44530:	f7ff fd7a 	bl	44028 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   44534:	fa09 f00a 	lsl.w	r0, r9, sl
   44538:	6228      	str	r0, [r5, #32]
}
   4453a:	e7bb      	b.n	444b4 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   4453c:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   4453e:	bf0c      	ite	eq
   44540:	2103      	moveq	r1, #3
   44542:	2102      	movne	r1, #2
   44544:	4650      	mov	r0, sl
   44546:	9201      	str	r2, [sp, #4]
   44548:	f7ff fd6e 	bl	44028 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   4454c:	9a01      	ldr	r2, [sp, #4]
   4454e:	2a03      	cmp	r2, #3
   44550:	d004      	beq.n	4455c <nrfx_gpiote_irq_handler+0xec>
   44552:	2c02      	cmp	r4, #2
   44554:	d107      	bne.n	44566 <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   44556:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   4455a:	d1eb      	bne.n	44534 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   4455c:	4659      	mov	r1, fp
   4455e:	4650      	mov	r0, sl
   44560:	f7ff fcfe 	bl	43f60 <call_handler>
   44564:	e7e6      	b.n	44534 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   44566:	2c03      	cmp	r4, #3
   44568:	d1e4      	bne.n	44534 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   4456a:	f1bb 0f02 	cmp.w	fp, #2
   4456e:	e7f4      	b.n	4455a <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   44570:	fa96 f3a6 	rbit	r3, r6
   44574:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   44578:	fa04 f203 	lsl.w	r2, r4, r3
   4457c:	009b      	lsls	r3, r3, #2
   4457e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44582:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   44586:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   4458a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   4458e:	f3c0 2004 	ubfx	r0, r0, #8, #5
   44592:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   44596:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   4459a:	f7ff fce1 	bl	43f60 <call_handler>
    while (mask)
   4459e:	2e00      	cmp	r6, #0
   445a0:	d1e6      	bne.n	44570 <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   445a2:	b005      	add	sp, #20
   445a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   445a8:	40031100 	.word	0x40031100
   445ac:	40031000 	.word	0x40031000
   445b0:	40031120 	.word	0x40031120
   445b4:	4003117c 	.word	0x4003117c
   445b8:	40842500 	.word	0x40842500
   445bc:	2001a528 	.word	0x2001a528

000445c0 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   445c0:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   445c2:	4c08      	ldr	r4, [pc, #32]	; (445e4 <nrfx_ipc_init+0x24>)
{
   445c4:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   445c6:	7923      	ldrb	r3, [r4, #4]
{
   445c8:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   445ca:	b943      	cbnz	r3, 445de <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   445cc:	202a      	movs	r0, #42	; 0x2a
   445ce:	f7fd fd15 	bl	41ffc <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   445d2:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   445d4:	4804      	ldr	r0, [pc, #16]	; (445e8 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   445d6:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   445d8:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   445da:	60a5      	str	r5, [r4, #8]
}
   445dc:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   445de:	4803      	ldr	r0, [pc, #12]	; (445ec <nrfx_ipc_init+0x2c>)
   445e0:	e7fc      	b.n	445dc <nrfx_ipc_init+0x1c>
   445e2:	bf00      	nop
   445e4:	2001aa60 	.word	0x2001aa60
   445e8:	0bad0000 	.word	0x0bad0000
   445ec:	0bad000c 	.word	0x0bad000c

000445f0 <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   445f0:	2300      	movs	r3, #0
{
   445f2:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   445f4:	4a0d      	ldr	r2, [pc, #52]	; (4462c <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   445f6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   445fa:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   445fe:	3301      	adds	r3, #1
   44600:	2b08      	cmp	r3, #8
   44602:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   44606:	d1f6      	bne.n	445f6 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   44608:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   4460a:	4a08      	ldr	r2, [pc, #32]	; (4462c <nrfx_ipc_config_load+0x3c>)
   4460c:	f100 0120 	add.w	r1, r0, #32
   44610:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   44614:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44618:	3301      	adds	r3, #1
   4461a:	2b08      	cmp	r3, #8
   4461c:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   44620:	d1f6      	bne.n	44610 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   44622:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   44624:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44628:	bd30      	pop	{r4, r5, pc}
   4462a:	bf00      	nop
   4462c:	4002a000 	.word	0x4002a000

00044630 <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   44630:	2300      	movs	r3, #0
   44632:	4a14      	ldr	r2, [pc, #80]	; (44684 <nrfx_ipc_uninit+0x54>)
   44634:	4914      	ldr	r1, [pc, #80]	; (44688 <nrfx_ipc_uninit+0x58>)
   44636:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   4463a:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   4463e:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   44642:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   44646:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   4464a:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   4464e:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   44652:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   44656:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   4465a:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   4465e:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   44662:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   44666:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   4466a:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   4466e:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   44672:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   44676:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4467a:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   4467e:	4a03      	ldr	r2, [pc, #12]	; (4468c <nrfx_ipc_uninit+0x5c>)
   44680:	7113      	strb	r3, [r2, #4]
}
   44682:	4770      	bx	lr
   44684:	4002a004 	.word	0x4002a004
   44688:	4002a000 	.word	0x4002a000
   4468c:	2001aa60 	.word	0x2001aa60

00044690 <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   44690:	4b0c      	ldr	r3, [pc, #48]	; (446c4 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   44692:	b430      	push	{r4, r5}
   44694:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   44698:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   4469a:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4469c:	2500      	movs	r5, #0
    while (bitmask)
   4469e:	b923      	cbnz	r3, 446aa <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   446a0:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   446a2:	4b09      	ldr	r3, [pc, #36]	; (446c8 <nrfx_ipc_irq_handler+0x38>)
   446a4:	681a      	ldr	r2, [r3, #0]
   446a6:	6899      	ldr	r1, [r3, #8]
   446a8:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   446aa:	fa93 f2a3 	rbit	r2, r3
   446ae:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   446b2:	fa04 f102 	lsl.w	r1, r4, r2
   446b6:	ea23 0301 	bic.w	r3, r3, r1
   446ba:	4904      	ldr	r1, [pc, #16]	; (446cc <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   446bc:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   446be:	508d      	str	r5, [r1, r2]
}
   446c0:	e7ed      	b.n	4469e <nrfx_ipc_irq_handler+0xe>
   446c2:	bf00      	nop
   446c4:	4002a000 	.word	0x4002a000
   446c8:	2001aa60 	.word	0x2001aa60
   446cc:	4002a100 	.word	0x4002a100

000446d0 <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   446d0:	2303      	movs	r3, #3
static void _DoInit(void) {
   446d2:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   446d4:	4c10      	ldr	r4, [pc, #64]	; (44718 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   446d6:	4a11      	ldr	r2, [pc, #68]	; (4471c <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   446d8:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   446da:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   446dc:	4b10      	ldr	r3, [pc, #64]	; (44720 <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   446de:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   446e0:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   446e2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
   446e6:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   446e8:	2300      	movs	r3, #0
   446ea:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   446ec:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   446ee:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   446f0:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   446f2:	4a0c      	ldr	r2, [pc, #48]	; (44724 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   446f4:	490c      	ldr	r1, [pc, #48]	; (44728 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
   446f6:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   446f8:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
   446fa:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   446fc:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   446fe:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   44700:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   44702:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   44704:	f003 fd69 	bl	481da <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   44708:	4620      	mov	r0, r4
   4470a:	4908      	ldr	r1, [pc, #32]	; (4472c <_DoInit+0x5c>)
   4470c:	f003 fd65 	bl	481da <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   44710:	2320      	movs	r3, #32
   44712:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   44714:	bd10      	pop	{r4, pc}
   44716:	bf00      	nop
   44718:	2001aa6c 	.word	0x2001aa6c
   4471c:	00049aa8 	.word	0x00049aa8
   44720:	2001ae7c 	.word	0x2001ae7c
   44724:	2001ae6c 	.word	0x2001ae6c
   44728:	00049ab1 	.word	0x00049ab1
   4472c:	00049ab5 	.word	0x00049ab5

00044730 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44730:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   44734:	f04f 0b18 	mov.w	fp, #24
   44738:	4f22      	ldr	r7, [pc, #136]	; (447c4 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   4473a:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   4473c:	fb0b 7200 	mla	r2, fp, r0, r7
   44740:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   44742:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44744:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   44746:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44748:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   4474a:	d834      	bhi.n	447b6 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   4474c:	f8d2 a020 	ldr.w	sl, [r2, #32]
   44750:	ebaa 0905 	sub.w	r9, sl, r5
   44754:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
   44758:	4294      	cmp	r4, r2
   4475a:	d811      	bhi.n	44780 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   4475c:	f04f 0918 	mov.w	r9, #24
   44760:	fb06 9309 	mla	r3, r6, r9, r9
   44764:	443b      	add	r3, r7
   44766:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   44768:	4622      	mov	r2, r4
   4476a:	4641      	mov	r1, r8
   4476c:	4428      	add	r0, r5
   4476e:	f003 fd61 	bl	48234 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   44772:	fb09 7606 	mla	r6, r9, r6, r7
   44776:	442c      	add	r4, r5
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
   44778:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   4477a:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   4477c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   44780:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   44782:	429c      	cmp	r4, r3
   44784:	d81b      	bhi.n	447be <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   44786:	fb00 bb0b 	mla	fp, r0, fp, fp
   4478a:	44bb      	add	fp, r7
   4478c:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   44790:	464a      	mov	r2, r9
   44792:	4428      	add	r0, r5
   44794:	442c      	add	r4, r5
   44796:	f003 fd4d 	bl	48234 <memcpy>
      if (NumBytes) {
   4479a:	ebb4 040a 	subs.w	r4, r4, sl
   4479e:	d006      	beq.n	447ae <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   447a0:	4622      	mov	r2, r4
   447a2:	f8db 0004 	ldr.w	r0, [fp, #4]
   447a6:	eb08 0109 	add.w	r1, r8, r9
   447aa:	f003 fd43 	bl	48234 <memcpy>
      pRing->WrOff = NumBytes;
   447ae:	2018      	movs	r0, #24
   447b0:	fb00 7606 	mla	r6, r0, r6, r7
   447b4:	e7e0      	b.n	44778 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   447b6:	3b01      	subs	r3, #1
   447b8:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   447ba:	42a3      	cmp	r3, r4
   447bc:	d2ce      	bcs.n	4475c <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   447be:	2000      	movs	r0, #0
   447c0:	e7dc      	b.n	4477c <SEGGER_RTT_WriteSkipNoLock+0x4c>
   447c2:	bf00      	nop
   447c4:	2001aa6c 	.word	0x2001aa6c

000447c8 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   447c8:	2218      	movs	r2, #24
   447ca:	4b03      	ldr	r3, [pc, #12]	; (447d8 <SEGGER_RTT_HasDataUp+0x10>)
   447cc:	fb02 3300 	mla	r3, r2, r0, r3
   447d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   447d2:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   447d4:	1a80      	subs	r0, r0, r2
   447d6:	4770      	bx	lr
   447d8:	2001aa6c 	.word	0x2001aa6c

000447dc <rpc_handle_data_message>:
   447dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   447e0:	4680      	mov	r8, r0
   447e2:	4604      	mov	r4, r0
   447e4:	2700      	movs	r7, #0
   447e6:	f858 6b08 	ldr.w	r6, [r8], #8
   447ea:	4d0c      	ldr	r5, [pc, #48]	; (4481c <rpc_handle_data_message+0x40>)
   447ec:	b2f6      	uxtb	r6, r6
   447ee:	782b      	ldrb	r3, [r5, #0]
   447f0:	42b3      	cmp	r3, r6
   447f2:	d00a      	beq.n	4480a <rpc_handle_data_message+0x2e>
   447f4:	3701      	adds	r7, #1
   447f6:	2f04      	cmp	r7, #4
   447f8:	f105 050c 	add.w	r5, r5, #12
   447fc:	d1f7      	bne.n	447ee <rpc_handle_data_message+0x12>
   447fe:	68a0      	ldr	r0, [r4, #8]
   44800:	b150      	cbz	r0, 44818 <rpc_handle_data_message+0x3c>
   44802:	f003 ff0f 	bl	48624 <rpc_transport_peer_data_free>
   44806:	2000      	movs	r0, #0
   44808:	e006      	b.n	44818 <rpc_handle_data_message+0x3c>
   4480a:	6821      	ldr	r1, [r4, #0]
   4480c:	4640      	mov	r0, r8
   4480e:	686b      	ldr	r3, [r5, #4]
   44810:	0c09      	lsrs	r1, r1, #16
   44812:	4798      	blx	r3
   44814:	2802      	cmp	r0, #2
   44816:	d0ed      	beq.n	447f4 <rpc_handle_data_message+0x18>
   44818:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4481c:	0004917c 	.word	0x0004917c

00044820 <trace_write>:
   44820:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44824:	4f53      	ldr	r7, [pc, #332]	; (44974 <trace_write+0x154>)
   44826:	4605      	mov	r5, r0
   44828:	2100      	movs	r1, #0
   4482a:	6838      	ldr	r0, [r7, #0]
   4482c:	f003 fe80 	bl	48530 <nrf_modem_os_sem_take>
   44830:	4604      	mov	r4, r0
   44832:	2800      	cmp	r0, #0
   44834:	d14c      	bne.n	448d0 <trace_write+0xb0>
   44836:	782b      	ldrb	r3, [r5, #0]
   44838:	f8d5 8008 	ldr.w	r8, [r5, #8]
   4483c:	2b62      	cmp	r3, #98	; 0x62
   4483e:	d043      	beq.n	448c8 <trace_write+0xa8>
   44840:	2b63      	cmp	r3, #99	; 0x63
   44842:	d043      	beq.n	448cc <trace_write+0xac>
   44844:	2b61      	cmp	r3, #97	; 0x61
   44846:	d102      	bne.n	4484e <trace_write+0x2e>
   44848:	4b4b      	ldr	r3, [pc, #300]	; (44978 <trace_write+0x158>)
   4484a:	881c      	ldrh	r4, [r3, #0]
   4484c:	b2a4      	uxth	r4, r4
   4484e:	6838      	ldr	r0, [r7, #0]
   44850:	f003 fe6c 	bl	4852c <nrf_modem_os_sem_give>
   44854:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   44858:	6929      	ldr	r1, [r5, #16]
   4485a:	eba8 080a 	sub.w	r8, r8, sl
   4485e:	eba1 030a 	sub.w	r3, r1, sl
   44862:	b29b      	uxth	r3, r3
   44864:	fa14 f488 	uxtah	r4, r4, r8
   44868:	fbb4 f2f3 	udiv	r2, r4, r3
   4486c:	fb03 4412 	mls	r4, r3, r2, r4
   44870:	686a      	ldr	r2, [r5, #4]
   44872:	eba2 020a 	sub.w	r2, r2, sl
   44876:	fa13 f282 	uxtah	r2, r3, r2
   4487a:	1b12      	subs	r2, r2, r4
   4487c:	fb92 f0f3 	sdiv	r0, r2, r3
   44880:	fb03 2210 	mls	r2, r3, r0, r2
   44884:	fa1f f982 	uxth.w	r9, r2
   44888:	fa14 f282 	uxtah	r2, r4, r2
   4488c:	4293      	cmp	r3, r2
   4488e:	44a2      	add	sl, r4
   44890:	da22      	bge.n	448d8 <trace_write+0xb8>
   44892:	eba1 030a 	sub.w	r3, r1, sl
   44896:	b29b      	uxth	r3, r3
   44898:	eba9 0403 	sub.w	r4, r9, r3
   4489c:	4699      	mov	r9, r3
   4489e:	b2a4      	uxth	r4, r4
   448a0:	f1b9 0f00 	cmp.w	r9, #0
   448a4:	d064      	beq.n	44970 <trace_write+0x150>
   448a6:	2005      	movs	r0, #5
   448a8:	f7ff f9d6 	bl	43c58 <nrf_modem_os_alloc>
   448ac:	4680      	mov	r8, r0
   448ae:	2800      	cmp	r0, #0
   448b0:	d05e      	beq.n	44970 <trace_write+0x150>
   448b2:	b19c      	cbz	r4, 448dc <trace_write+0xbc>
   448b4:	2005      	movs	r0, #5
   448b6:	f7ff f9cf 	bl	43c58 <nrf_modem_os_alloc>
   448ba:	4606      	mov	r6, r0
   448bc:	b970      	cbnz	r0, 448dc <trace_write+0xbc>
   448be:	4640      	mov	r0, r8
   448c0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   448c4:	f7ff b9d0 	b.w	43c68 <nrf_modem_os_free>
   448c8:	4b2c      	ldr	r3, [pc, #176]	; (4497c <trace_write+0x15c>)
   448ca:	e7be      	b.n	4484a <trace_write+0x2a>
   448cc:	4b2c      	ldr	r3, [pc, #176]	; (44980 <trace_write+0x160>)
   448ce:	e7bc      	b.n	4484a <trace_write+0x2a>
   448d0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   448d4:	f7ff b9b0 	b.w	43c38 <nrf_modem_os_trace_irq_set>
   448d8:	2400      	movs	r4, #0
   448da:	e7e1      	b.n	448a0 <trace_write+0x80>
   448dc:	2100      	movs	r1, #0
   448de:	6838      	ldr	r0, [r7, #0]
   448e0:	f003 fe26 	bl	48530 <nrf_modem_os_sem_take>
   448e4:	b140      	cbz	r0, 448f8 <trace_write+0xd8>
   448e6:	f7ff f9a7 	bl	43c38 <nrf_modem_os_trace_irq_set>
   448ea:	4640      	mov	r0, r8
   448ec:	f7ff f9bc 	bl	43c68 <nrf_modem_os_free>
   448f0:	2c00      	cmp	r4, #0
   448f2:	d03d      	beq.n	44970 <trace_write+0x150>
   448f4:	4630      	mov	r0, r6
   448f6:	e7e3      	b.n	448c0 <trace_write+0xa0>
   448f8:	782b      	ldrb	r3, [r5, #0]
   448fa:	2b62      	cmp	r3, #98	; 0x62
   448fc:	d034      	beq.n	44968 <trace_write+0x148>
   448fe:	2b63      	cmp	r3, #99	; 0x63
   44900:	d034      	beq.n	4496c <trace_write+0x14c>
   44902:	2b61      	cmp	r3, #97	; 0x61
   44904:	d107      	bne.n	44916 <trace_write+0xf6>
   44906:	4a1c      	ldr	r2, [pc, #112]	; (44978 <trace_write+0x158>)
   44908:	8813      	ldrh	r3, [r2, #0]
   4490a:	eb04 0109 	add.w	r1, r4, r9
   4490e:	fa11 f383 	uxtah	r3, r1, r3
   44912:	b29b      	uxth	r3, r3
   44914:	8013      	strh	r3, [r2, #0]
   44916:	6838      	ldr	r0, [r7, #0]
   44918:	f06f 0b10 	mvn.w	fp, #16
   4491c:	f06f 0741 	mvn.w	r7, #65	; 0x41
   44920:	f003 fe04 	bl	4852c <nrf_modem_os_sem_give>
   44924:	f888 b000 	strb.w	fp, [r8]
   44928:	f888 7001 	strb.w	r7, [r8, #1]
   4492c:	782b      	ldrb	r3, [r5, #0]
   4492e:	2105      	movs	r1, #5
   44930:	4640      	mov	r0, r8
   44932:	f888 3004 	strb.w	r3, [r8, #4]
   44936:	f8a8 9002 	strh.w	r9, [r8, #2]
   4493a:	f003 fe16 	bl	4856a <nrf_modem_os_trace_put>
   4493e:	4649      	mov	r1, r9
   44940:	4650      	mov	r0, sl
   44942:	f003 fe12 	bl	4856a <nrf_modem_os_trace_put>
   44946:	b19c      	cbz	r4, 44970 <trace_write+0x150>
   44948:	f886 b000 	strb.w	fp, [r6]
   4494c:	7077      	strb	r7, [r6, #1]
   4494e:	782b      	ldrb	r3, [r5, #0]
   44950:	2105      	movs	r1, #5
   44952:	4630      	mov	r0, r6
   44954:	7133      	strb	r3, [r6, #4]
   44956:	8074      	strh	r4, [r6, #2]
   44958:	f003 fe07 	bl	4856a <nrf_modem_os_trace_put>
   4495c:	4621      	mov	r1, r4
   4495e:	68e8      	ldr	r0, [r5, #12]
   44960:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44964:	f003 be01 	b.w	4856a <nrf_modem_os_trace_put>
   44968:	4a04      	ldr	r2, [pc, #16]	; (4497c <trace_write+0x15c>)
   4496a:	e7cd      	b.n	44908 <trace_write+0xe8>
   4496c:	4a04      	ldr	r2, [pc, #16]	; (44980 <trace_write+0x160>)
   4496e:	e7cb      	b.n	44908 <trace_write+0xe8>
   44970:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44974:	2001ab24 	.word	0x2001ab24
   44978:	2001ada8 	.word	0x2001ada8
   4497c:	2001ada4 	.word	0x2001ada4
   44980:	2001ada6 	.word	0x2001ada6

00044984 <ipc_trace_init>:
   44984:	2300      	movs	r3, #0
   44986:	4a08      	ldr	r2, [pc, #32]	; (449a8 <ipc_trace_init+0x24>)
   44988:	b510      	push	{r4, lr}
   4498a:	8013      	strh	r3, [r2, #0]
   4498c:	4a07      	ldr	r2, [pc, #28]	; (449ac <ipc_trace_init+0x28>)
   4498e:	4604      	mov	r4, r0
   44990:	8013      	strh	r3, [r2, #0]
   44992:	4a07      	ldr	r2, [pc, #28]	; (449b0 <ipc_trace_init+0x2c>)
   44994:	4807      	ldr	r0, [pc, #28]	; (449b4 <ipc_trace_init+0x30>)
   44996:	8013      	strh	r3, [r2, #0]
   44998:	2201      	movs	r2, #1
   4499a:	4611      	mov	r1, r2
   4499c:	f7ff f922 	bl	43be4 <nrf_modem_os_sem_init>
   449a0:	4b05      	ldr	r3, [pc, #20]	; (449b8 <ipc_trace_init+0x34>)
   449a2:	601c      	str	r4, [r3, #0]
   449a4:	bd10      	pop	{r4, pc}
   449a6:	bf00      	nop
   449a8:	2001ada8 	.word	0x2001ada8
   449ac:	2001ada4 	.word	0x2001ada4
   449b0:	2001ada6 	.word	0x2001ada6
   449b4:	2001ab24 	.word	0x2001ab24
   449b8:	2001ab20 	.word	0x2001ab20

000449bc <nrf_modem_trace_irq_handler>:
   449bc:	b508      	push	{r3, lr}
   449be:	4b10      	ldr	r3, [pc, #64]	; (44a00 <nrf_modem_trace_irq_handler+0x44>)
   449c0:	781b      	ldrb	r3, [r3, #0]
   449c2:	b90b      	cbnz	r3, 449c8 <nrf_modem_trace_irq_handler+0xc>
   449c4:	f7ff f940 	bl	43c48 <nrf_modem_os_trace_irq_clear>
   449c8:	4b0e      	ldr	r3, [pc, #56]	; (44a04 <nrf_modem_trace_irq_handler+0x48>)
   449ca:	6818      	ldr	r0, [r3, #0]
   449cc:	6842      	ldr	r2, [r0, #4]
   449ce:	6883      	ldr	r3, [r0, #8]
   449d0:	429a      	cmp	r2, r3
   449d2:	d001      	beq.n	449d8 <nrf_modem_trace_irq_handler+0x1c>
   449d4:	f7ff ff24 	bl	44820 <trace_write>
   449d8:	4b0b      	ldr	r3, [pc, #44]	; (44a08 <nrf_modem_trace_irq_handler+0x4c>)
   449da:	6818      	ldr	r0, [r3, #0]
   449dc:	6882      	ldr	r2, [r0, #8]
   449de:	6843      	ldr	r3, [r0, #4]
   449e0:	429a      	cmp	r2, r3
   449e2:	d001      	beq.n	449e8 <nrf_modem_trace_irq_handler+0x2c>
   449e4:	f7ff ff1c 	bl	44820 <trace_write>
   449e8:	4b08      	ldr	r3, [pc, #32]	; (44a0c <nrf_modem_trace_irq_handler+0x50>)
   449ea:	6818      	ldr	r0, [r3, #0]
   449ec:	6882      	ldr	r2, [r0, #8]
   449ee:	6843      	ldr	r3, [r0, #4]
   449f0:	429a      	cmp	r2, r3
   449f2:	d003      	beq.n	449fc <nrf_modem_trace_irq_handler+0x40>
   449f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   449f8:	f7ff bf12 	b.w	44820 <trace_write>
   449fc:	bd08      	pop	{r3, pc}
   449fe:	bf00      	nop
   44a00:	2001ea7c 	.word	0x2001ea7c
   44a04:	2001ab1c 	.word	0x2001ab1c
   44a08:	2001ab14 	.word	0x2001ab14
   44a0c:	2001ab18 	.word	0x2001ab18

00044a10 <ipc_trace_handle>:
   44a10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44a14:	4b43      	ldr	r3, [pc, #268]	; (44b24 <ipc_trace_handle+0x114>)
   44a16:	681b      	ldr	r3, [r3, #0]
   44a18:	6919      	ldr	r1, [r3, #16]
   44a1a:	f8d3 a014 	ldr.w	sl, [r3, #20]
   44a1e:	7c1a      	ldrb	r2, [r3, #16]
   44a20:	2200      	movs	r2, #0
   44a22:	741a      	strb	r2, [r3, #16]
   44a24:	7c58      	ldrb	r0, [r3, #17]
   44a26:	745a      	strb	r2, [r3, #17]
   44a28:	7c98      	ldrb	r0, [r3, #18]
   44a2a:	749a      	strb	r2, [r3, #18]
   44a2c:	7cd8      	ldrb	r0, [r3, #19]
   44a2e:	74da      	strb	r2, [r3, #19]
   44a30:	7d18      	ldrb	r0, [r3, #20]
   44a32:	751a      	strb	r2, [r3, #20]
   44a34:	7d58      	ldrb	r0, [r3, #21]
   44a36:	755a      	strb	r2, [r3, #21]
   44a38:	7d98      	ldrb	r0, [r3, #22]
   44a3a:	759a      	strb	r2, [r3, #22]
   44a3c:	7dd8      	ldrb	r0, [r3, #23]
   44a3e:	75da      	strb	r2, [r3, #23]
   44a40:	2900      	cmp	r1, #0
   44a42:	d033      	beq.n	44aac <ipc_trace_handle+0x9c>
   44a44:	3901      	subs	r1, #1
   44a46:	2903      	cmp	r1, #3
   44a48:	d830      	bhi.n	44aac <ipc_trace_handle+0x9c>
   44a4a:	e8df f001 	tbb	[pc, r1]
   44a4e:	6502      	.short	0x6502
   44a50:	534c      	.short	0x534c
   44a52:	4a35      	ldr	r2, [pc, #212]	; (44b28 <ipc_trace_handle+0x118>)
   44a54:	7811      	ldrb	r1, [r2, #0]
   44a56:	b109      	cbz	r1, 44a5c <ipc_trace_handle+0x4c>
   44a58:	2100      	movs	r1, #0
   44a5a:	7011      	strb	r1, [r2, #0]
   44a5c:	2200      	movs	r2, #0
   44a5e:	4691      	mov	r9, r2
   44a60:	4617      	mov	r7, r2
   44a62:	4614      	mov	r4, r2
   44a64:	4d31      	ldr	r5, [pc, #196]	; (44b2c <ipc_trace_handle+0x11c>)
   44a66:	4932      	ldr	r1, [pc, #200]	; (44b30 <ipc_trace_handle+0x120>)
   44a68:	4832      	ldr	r0, [pc, #200]	; (44b34 <ipc_trace_handle+0x124>)
   44a6a:	f8d5 e000 	ldr.w	lr, [r5]
   44a6e:	f8d1 8000 	ldr.w	r8, [r1]
   44a72:	6806      	ldr	r6, [r0, #0]
   44a74:	f8da b008 	ldr.w	fp, [sl, #8]
   44a78:	9501      	str	r5, [sp, #4]
   44a7a:	45a3      	cmp	fp, r4
   44a7c:	d119      	bne.n	44ab2 <ipc_trace_handle+0xa2>
   44a7e:	b107      	cbz	r7, 44a82 <ipc_trace_handle+0x72>
   44a80:	6006      	str	r6, [r0, #0]
   44a82:	f1b9 0f00 	cmp.w	r9, #0
   44a86:	d001      	beq.n	44a8c <ipc_trace_handle+0x7c>
   44a88:	f8c1 8000 	str.w	r8, [r1]
   44a8c:	b112      	cbz	r2, 44a94 <ipc_trace_handle+0x84>
   44a8e:	9a01      	ldr	r2, [sp, #4]
   44a90:	f8c2 e000 	str.w	lr, [r2]
   44a94:	7a1a      	ldrb	r2, [r3, #8]
   44a96:	2101      	movs	r1, #1
   44a98:	2200      	movs	r2, #0
   44a9a:	7219      	strb	r1, [r3, #8]
   44a9c:	7a59      	ldrb	r1, [r3, #9]
   44a9e:	725a      	strb	r2, [r3, #9]
   44aa0:	7a99      	ldrb	r1, [r3, #10]
   44aa2:	729a      	strb	r2, [r3, #10]
   44aa4:	7ada      	ldrb	r2, [r3, #11]
   44aa6:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   44aaa:	72da      	strb	r2, [r3, #11]
   44aac:	b003      	add	sp, #12
   44aae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44ab2:	1ca5      	adds	r5, r4, #2
   44ab4:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   44ab8:	686d      	ldr	r5, [r5, #4]
   44aba:	f895 c000 	ldrb.w	ip, [r5]
   44abe:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   44ac2:	d009      	beq.n	44ad8 <ipc_trace_handle+0xc8>
   44ac4:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   44ac8:	d00a      	beq.n	44ae0 <ipc_trace_handle+0xd0>
   44aca:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   44ace:	bf04      	itt	eq
   44ad0:	462e      	moveq	r6, r5
   44ad2:	2701      	moveq	r7, #1
   44ad4:	3401      	adds	r4, #1
   44ad6:	e7d0      	b.n	44a7a <ipc_trace_handle+0x6a>
   44ad8:	46a8      	mov	r8, r5
   44ada:	f04f 0901 	mov.w	r9, #1
   44ade:	e7f9      	b.n	44ad4 <ipc_trace_handle+0xc4>
   44ae0:	46ae      	mov	lr, r5
   44ae2:	2201      	movs	r2, #1
   44ae4:	e7f6      	b.n	44ad4 <ipc_trace_handle+0xc4>
   44ae6:	2101      	movs	r1, #1
   44ae8:	4a0f      	ldr	r2, [pc, #60]	; (44b28 <ipc_trace_handle+0x118>)
   44aea:	7011      	strb	r1, [r2, #0]
   44aec:	7a1a      	ldrb	r2, [r3, #8]
   44aee:	2103      	movs	r1, #3
   44af0:	2200      	movs	r2, #0
   44af2:	e7d2      	b.n	44a9a <ipc_trace_handle+0x8a>
   44af4:	7a19      	ldrb	r1, [r3, #8]
   44af6:	2104      	movs	r1, #4
   44af8:	7219      	strb	r1, [r3, #8]
   44afa:	7a59      	ldrb	r1, [r3, #9]
   44afc:	725a      	strb	r2, [r3, #9]
   44afe:	7a99      	ldrb	r1, [r3, #10]
   44b00:	729a      	strb	r2, [r3, #10]
   44b02:	7ad9      	ldrb	r1, [r3, #11]
   44b04:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   44b08:	72d9      	strb	r1, [r3, #11]
   44b0a:	4b07      	ldr	r3, [pc, #28]	; (44b28 <ipc_trace_handle+0x118>)
   44b0c:	701a      	strb	r2, [r3, #0]
   44b0e:	b003      	add	sp, #12
   44b10:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44b14:	f7ff bf52 	b.w	449bc <nrf_modem_trace_irq_handler>
   44b18:	b003      	add	sp, #12
   44b1a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44b1e:	f7ff b88b 	b.w	43c38 <nrf_modem_os_trace_irq_set>
   44b22:	bf00      	nop
   44b24:	2001ab20 	.word	0x2001ab20
   44b28:	2001ea7c 	.word	0x2001ea7c
   44b2c:	2001ab18 	.word	0x2001ab18
   44b30:	2001ab14 	.word	0x2001ab14
   44b34:	2001ab1c 	.word	0x2001ab1c

00044b38 <rpc_trace_coredump_in_progress>:
   44b38:	4b01      	ldr	r3, [pc, #4]	; (44b40 <rpc_trace_coredump_in_progress+0x8>)
   44b3a:	7818      	ldrb	r0, [r3, #0]
   44b3c:	4770      	bx	lr
   44b3e:	bf00      	nop
   44b40:	2001ea7c 	.word	0x2001ea7c

00044b44 <handle_modem_rpc_msg>:
   44b44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44b48:	4606      	mov	r6, r0
   44b4a:	460f      	mov	r7, r1
   44b4c:	2500      	movs	r5, #0
   44b4e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 44bc4 <handle_modem_rpc_msg+0x80>
   44b52:	6833      	ldr	r3, [r6, #0]
   44b54:	42ab      	cmp	r3, r5
   44b56:	d801      	bhi.n	44b5c <handle_modem_rpc_msg+0x18>
   44b58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44b5c:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   44b60:	68a3      	ldr	r3, [r4, #8]
   44b62:	b1fb      	cbz	r3, 44ba4 <handle_modem_rpc_msg+0x60>
   44b64:	6863      	ldr	r3, [r4, #4]
   44b66:	b2db      	uxtb	r3, r3
   44b68:	2b01      	cmp	r3, #1
   44b6a:	d11b      	bne.n	44ba4 <handle_modem_rpc_msg+0x60>
   44b6c:	6862      	ldr	r2, [r4, #4]
   44b6e:	f8b8 3000 	ldrh.w	r3, [r8]
   44b72:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   44b76:	d115      	bne.n	44ba4 <handle_modem_rpc_msg+0x60>
   44b78:	2f02      	cmp	r7, #2
   44b7a:	68a0      	ldr	r0, [r4, #8]
   44b7c:	d114      	bne.n	44ba8 <handle_modem_rpc_msg+0x64>
   44b7e:	f7ff fe2d 	bl	447dc <rpc_handle_data_message>
   44b82:	2802      	cmp	r0, #2
   44b84:	d00e      	beq.n	44ba4 <handle_modem_rpc_msg+0x60>
   44b86:	2801      	cmp	r0, #1
   44b88:	d113      	bne.n	44bb2 <handle_modem_rpc_msg+0x6e>
   44b8a:	6863      	ldr	r3, [r4, #4]
   44b8c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44b90:	f043 0302 	orr.w	r3, r3, #2
   44b94:	6063      	str	r3, [r4, #4]
   44b96:	f8b8 3000 	ldrh.w	r3, [r8]
   44b9a:	3301      	adds	r3, #1
   44b9c:	f8a8 3000 	strh.w	r3, [r8]
   44ba0:	f7ff f83a 	bl	43c18 <nrf_modem_os_application_irq_set>
   44ba4:	3501      	adds	r5, #1
   44ba6:	e7d4      	b.n	44b52 <handle_modem_rpc_msg+0xe>
   44ba8:	6801      	ldr	r1, [r0, #0]
   44baa:	0c09      	lsrs	r1, r1, #16
   44bac:	f003 fcf8 	bl	485a0 <rpc_handle_ctrl_message>
   44bb0:	e7e7      	b.n	44b82 <handle_modem_rpc_msg+0x3e>
   44bb2:	2800      	cmp	r0, #0
   44bb4:	d1ef      	bne.n	44b96 <handle_modem_rpc_msg+0x52>
   44bb6:	6863      	ldr	r3, [r4, #4]
   44bb8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44bbc:	f043 0303 	orr.w	r3, r3, #3
   44bc0:	e7e8      	b.n	44b94 <handle_modem_rpc_msg+0x50>
   44bc2:	bf00      	nop
   44bc4:	2001adaa 	.word	0x2001adaa

00044bc8 <rpc_transport_ipc_msg_alloc>:
   44bc8:	b570      	push	{r4, r5, r6, lr}
   44bca:	4616      	mov	r6, r2
   44bcc:	2400      	movs	r4, #0
   44bce:	6803      	ldr	r3, [r0, #0]
   44bd0:	42a3      	cmp	r3, r4
   44bd2:	d101      	bne.n	44bd8 <rpc_transport_ipc_msg_alloc+0x10>
   44bd4:	2300      	movs	r3, #0
   44bd6:	e01c      	b.n	44c12 <rpc_transport_ipc_msg_alloc+0x4a>
   44bd8:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   44bdc:	6855      	ldr	r5, [r2, #4]
   44bde:	b2ed      	uxtb	r5, r5
   44be0:	2d03      	cmp	r5, #3
   44be2:	d118      	bne.n	44c16 <rpc_transport_ipc_msg_alloc+0x4e>
   44be4:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   44be8:	6093      	str	r3, [r2, #8]
   44bea:	6851      	ldr	r1, [r2, #4]
   44bec:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   44bf0:	6051      	str	r1, [r2, #4]
   44bf2:	490c      	ldr	r1, [pc, #48]	; (44c24 <rpc_transport_ipc_msg_alloc+0x5c>)
   44bf4:	8808      	ldrh	r0, [r1, #0]
   44bf6:	1c44      	adds	r4, r0, #1
   44bf8:	800c      	strh	r4, [r1, #0]
   44bfa:	6851      	ldr	r1, [r2, #4]
   44bfc:	b289      	uxth	r1, r1
   44bfe:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   44c02:	6051      	str	r1, [r2, #4]
   44c04:	4618      	mov	r0, r3
   44c06:	2240      	movs	r2, #64	; 0x40
   44c08:	2100      	movs	r1, #0
   44c0a:	f003 fb1e 	bl	4824a <memset>
   44c0e:	4603      	mov	r3, r0
   44c10:	6046      	str	r6, [r0, #4]
   44c12:	4618      	mov	r0, r3
   44c14:	bd70      	pop	{r4, r5, r6, pc}
   44c16:	b915      	cbnz	r5, 44c1e <rpc_transport_ipc_msg_alloc+0x56>
   44c18:	6895      	ldr	r5, [r2, #8]
   44c1a:	2d00      	cmp	r5, #0
   44c1c:	d0e2      	beq.n	44be4 <rpc_transport_ipc_msg_alloc+0x1c>
   44c1e:	3401      	adds	r4, #1
   44c20:	e7d6      	b.n	44bd0 <rpc_transport_ipc_msg_alloc+0x8>
   44c22:	bf00      	nop
   44c24:	2001adac 	.word	0x2001adac

00044c28 <rpc_transport_ipc_data_msg_send>:
   44c28:	b508      	push	{r3, lr}
   44c2a:	4b0b      	ldr	r3, [pc, #44]	; (44c58 <rpc_transport_ipc_data_msg_send+0x30>)
   44c2c:	681b      	ldr	r3, [r3, #0]
   44c2e:	1ac0      	subs	r0, r0, r3
   44c30:	4b0a      	ldr	r3, [pc, #40]	; (44c5c <rpc_transport_ipc_data_msg_send+0x34>)
   44c32:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44c36:	681b      	ldr	r3, [r3, #0]
   44c38:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44c3c:	6843      	ldr	r3, [r0, #4]
   44c3e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44c42:	f043 0301 	orr.w	r3, r3, #1
   44c46:	6043      	str	r3, [r0, #4]
   44c48:	2003      	movs	r0, #3
   44c4a:	f003 fc6b 	bl	48524 <nrf_modem_os_busywait>
   44c4e:	2201      	movs	r2, #1
   44c50:	4b03      	ldr	r3, [pc, #12]	; (44c60 <rpc_transport_ipc_data_msg_send+0x38>)
   44c52:	601a      	str	r2, [r3, #0]
   44c54:	bd08      	pop	{r3, pc}
   44c56:	bf00      	nop
   44c58:	2001ab40 	.word	0x2001ab40
   44c5c:	2001ab44 	.word	0x2001ab44
   44c60:	4002a00c 	.word	0x4002a00c

00044c64 <rpc_transport_ipc_ctrl_msg_send>:
   44c64:	b508      	push	{r3, lr}
   44c66:	4b0b      	ldr	r3, [pc, #44]	; (44c94 <rpc_transport_ipc_ctrl_msg_send+0x30>)
   44c68:	681b      	ldr	r3, [r3, #0]
   44c6a:	1ac0      	subs	r0, r0, r3
   44c6c:	4b0a      	ldr	r3, [pc, #40]	; (44c98 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   44c6e:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44c72:	681b      	ldr	r3, [r3, #0]
   44c74:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44c78:	6843      	ldr	r3, [r0, #4]
   44c7a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44c7e:	f043 0301 	orr.w	r3, r3, #1
   44c82:	6043      	str	r3, [r0, #4]
   44c84:	2003      	movs	r0, #3
   44c86:	f003 fc4d 	bl	48524 <nrf_modem_os_busywait>
   44c8a:	2201      	movs	r2, #1
   44c8c:	4b03      	ldr	r3, [pc, #12]	; (44c9c <rpc_transport_ipc_ctrl_msg_send+0x38>)
   44c8e:	601a      	str	r2, [r3, #0]
   44c90:	bd08      	pop	{r3, pc}
   44c92:	bf00      	nop
   44c94:	2001ab38 	.word	0x2001ab38
   44c98:	2001ab3c 	.word	0x2001ab3c
   44c9c:	4002a004 	.word	0x4002a004

00044ca0 <rpc_transport_ipc_data_msg_alloc>:
   44ca0:	4b05      	ldr	r3, [pc, #20]	; (44cb8 <rpc_transport_ipc_data_msg_alloc+0x18>)
   44ca2:	781b      	ldrb	r3, [r3, #0]
   44ca4:	b933      	cbnz	r3, 44cb4 <rpc_transport_ipc_data_msg_alloc+0x14>
   44ca6:	4b05      	ldr	r3, [pc, #20]	; (44cbc <rpc_transport_ipc_data_msg_alloc+0x1c>)
   44ca8:	2202      	movs	r2, #2
   44caa:	6819      	ldr	r1, [r3, #0]
   44cac:	4b04      	ldr	r3, [pc, #16]	; (44cc0 <rpc_transport_ipc_data_msg_alloc+0x20>)
   44cae:	6818      	ldr	r0, [r3, #0]
   44cb0:	f7ff bf8a 	b.w	44bc8 <rpc_transport_ipc_msg_alloc>
   44cb4:	2000      	movs	r0, #0
   44cb6:	4770      	bx	lr
   44cb8:	2001ea7e 	.word	0x2001ea7e
   44cbc:	2001ab40 	.word	0x2001ab40
   44cc0:	2001ab44 	.word	0x2001ab44

00044cc4 <rpc_transport_ipc_ctrl_msg_alloc>:
   44cc4:	230a      	movs	r3, #10
   44cc6:	b537      	push	{r0, r1, r2, r4, r5, lr}
   44cc8:	4c0c      	ldr	r4, [pc, #48]	; (44cfc <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   44cca:	4d0d      	ldr	r5, [pc, #52]	; (44d00 <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   44ccc:	9301      	str	r3, [sp, #4]
   44cce:	2201      	movs	r2, #1
   44cd0:	6821      	ldr	r1, [r4, #0]
   44cd2:	6828      	ldr	r0, [r5, #0]
   44cd4:	f7ff ff78 	bl	44bc8 <rpc_transport_ipc_msg_alloc>
   44cd8:	b968      	cbnz	r0, 44cf6 <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   44cda:	f003 fc25 	bl	48528 <nrf_modem_os_is_in_isr>
   44cde:	b918      	cbnz	r0, 44ce8 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   44ce0:	a901      	add	r1, sp, #4
   44ce2:	f7fe fee1 	bl	43aa8 <nrf_modem_os_timedwait>
   44ce6:	e7f2      	b.n	44cce <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44ce8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   44cec:	9b01      	ldr	r3, [sp, #4]
   44cee:	4358      	muls	r0, r3
   44cf0:	f003 fc18 	bl	48524 <nrf_modem_os_busywait>
   44cf4:	e7eb      	b.n	44cce <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44cf6:	b003      	add	sp, #12
   44cf8:	bd30      	pop	{r4, r5, pc}
   44cfa:	bf00      	nop
   44cfc:	2001ab38 	.word	0x2001ab38
   44d00:	2001ab3c 	.word	0x2001ab3c

00044d04 <rpc_transport_ipc_data_alloc>:
   44d04:	4b03      	ldr	r3, [pc, #12]	; (44d14 <rpc_transport_ipc_data_alloc+0x10>)
   44d06:	781b      	ldrb	r3, [r3, #0]
   44d08:	b90b      	cbnz	r3, 44d0e <rpc_transport_ipc_data_alloc+0xa>
   44d0a:	f7fe bfb3 	b.w	43c74 <nrf_modem_os_shm_tx_alloc>
   44d0e:	2000      	movs	r0, #0
   44d10:	4770      	bx	lr
   44d12:	bf00      	nop
   44d14:	2001ea7e 	.word	0x2001ea7e

00044d18 <nrf_modem_application_irq_handler>:
   44d18:	b510      	push	{r4, lr}
   44d1a:	4c06      	ldr	r4, [pc, #24]	; (44d34 <nrf_modem_application_irq_handler+0x1c>)
   44d1c:	f7fe ff84 	bl	43c28 <nrf_modem_os_application_irq_clear>
   44d20:	6820      	ldr	r0, [r4, #0]
   44d22:	2101      	movs	r1, #1
   44d24:	f7ff ff0e 	bl	44b44 <handle_modem_rpc_msg>
   44d28:	6860      	ldr	r0, [r4, #4]
   44d2a:	2102      	movs	r1, #2
   44d2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   44d30:	f7ff bf08 	b.w	44b44 <handle_modem_rpc_msg>
   44d34:	2001ab2c 	.word	0x2001ab2c

00044d38 <rpc_transport_ipc_msg_free>:
   44d38:	2300      	movs	r3, #0
   44d3a:	4911      	ldr	r1, [pc, #68]	; (44d80 <rpc_transport_ipc_msg_free+0x48>)
   44d3c:	b530      	push	{r4, r5, lr}
   44d3e:	680a      	ldr	r2, [r1, #0]
   44d40:	6814      	ldr	r4, [r2, #0]
   44d42:	42a3      	cmp	r3, r4
   44d44:	d10b      	bne.n	44d5e <rpc_transport_ipc_msg_free+0x26>
   44d46:	2300      	movs	r3, #0
   44d48:	684a      	ldr	r2, [r1, #4]
   44d4a:	6811      	ldr	r1, [r2, #0]
   44d4c:	428b      	cmp	r3, r1
   44d4e:	d015      	beq.n	44d7c <rpc_transport_ipc_msg_free+0x44>
   44d50:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   44d54:	68a4      	ldr	r4, [r4, #8]
   44d56:	42a0      	cmp	r0, r4
   44d58:	d008      	beq.n	44d6c <rpc_transport_ipc_msg_free+0x34>
   44d5a:	3301      	adds	r3, #1
   44d5c:	e7f6      	b.n	44d4c <rpc_transport_ipc_msg_free+0x14>
   44d5e:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   44d62:	68ad      	ldr	r5, [r5, #8]
   44d64:	42a8      	cmp	r0, r5
   44d66:	d001      	beq.n	44d6c <rpc_transport_ipc_msg_free+0x34>
   44d68:	3301      	adds	r3, #1
   44d6a:	e7ea      	b.n	44d42 <rpc_transport_ipc_msg_free+0xa>
   44d6c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   44d70:	685a      	ldr	r2, [r3, #4]
   44d72:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   44d76:	f042 0203 	orr.w	r2, r2, #3
   44d7a:	605a      	str	r2, [r3, #4]
   44d7c:	bd30      	pop	{r4, r5, pc}
   44d7e:	bf00      	nop
   44d80:	2001ab2c 	.word	0x2001ab2c

00044d84 <rpc_transport_ipc_init>:
   44d84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44d88:	2200      	movs	r2, #0
   44d8a:	b095      	sub	sp, #84	; 0x54
   44d8c:	4605      	mov	r5, r0
   44d8e:	494d      	ldr	r1, [pc, #308]	; (44ec4 <rpc_transport_ipc_init+0x140>)
   44d90:	7900      	ldrb	r0, [r0, #4]
   44d92:	f7ff fc15 	bl	445c0 <nrfx_ipc_init>
   44d96:	2238      	movs	r2, #56	; 0x38
   44d98:	2100      	movs	r1, #0
   44d9a:	a803      	add	r0, sp, #12
   44d9c:	f003 fa55 	bl	4824a <memset>
   44da0:	2302      	movs	r3, #2
   44da2:	9304      	str	r3, [sp, #16]
   44da4:	2308      	movs	r3, #8
   44da6:	9306      	str	r3, [sp, #24]
   44da8:	2320      	movs	r3, #32
   44daa:	9308      	str	r3, [sp, #32]
   44dac:	2301      	movs	r3, #1
   44dae:	930b      	str	r3, [sp, #44]	; 0x2c
   44db0:	2304      	movs	r3, #4
   44db2:	930d      	str	r3, [sp, #52]	; 0x34
   44db4:	2310      	movs	r3, #16
   44db6:	f04f 0c40 	mov.w	ip, #64	; 0x40
   44dba:	930f      	str	r3, [sp, #60]	; 0x3c
   44dbc:	2380      	movs	r3, #128	; 0x80
   44dbe:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   44dc2:	23d5      	movs	r3, #213	; 0xd5
   44dc4:	a803      	add	r0, sp, #12
   44dc6:	9313      	str	r3, [sp, #76]	; 0x4c
   44dc8:	f7ff fc12 	bl	445f0 <nrfx_ipc_config_load>
   44dcc:	682b      	ldr	r3, [r5, #0]
   44dce:	2100      	movs	r1, #0
   44dd0:	685a      	ldr	r2, [r3, #4]
   44dd2:	6818      	ldr	r0, [r3, #0]
   44dd4:	f003 fa39 	bl	4824a <memset>
   44dd8:	682a      	ldr	r2, [r5, #0]
   44dda:	6814      	ldr	r4, [r2, #0]
   44ddc:	69d3      	ldr	r3, [r2, #28]
   44dde:	f104 0660 	add.w	r6, r4, #96	; 0x60
   44de2:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   44de6:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   44dea:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   44dee:	f104 0920 	add.w	r9, r4, #32
   44df2:	2b00      	cmp	r3, #0
   44df4:	d060      	beq.n	44eb8 <rpc_transport_ipc_init+0x134>
   44df6:	f104 0840 	add.w	r8, r4, #64	; 0x40
   44dfa:	4933      	ldr	r1, [pc, #204]	; (44ec8 <rpc_transport_ipc_init+0x144>)
   44dfc:	f8c1 9000 	str.w	r9, [r1]
   44e00:	b13b      	cbz	r3, 44e12 <rpc_transport_ipc_init+0x8e>
   44e02:	6992      	ldr	r2, [r2, #24]
   44e04:	4640      	mov	r0, r8
   44e06:	f8c8 2004 	str.w	r2, [r8, #4]
   44e0a:	f8c8 3000 	str.w	r3, [r8]
   44e0e:	f7ff fdb9 	bl	44984 <ipc_trace_init>
   44e12:	6828      	ldr	r0, [r5, #0]
   44e14:	2300      	movs	r3, #0
   44e16:	6902      	ldr	r2, [r0, #16]
   44e18:	2101      	movs	r1, #1
   44e1a:	6062      	str	r2, [r4, #4]
   44e1c:	6942      	ldr	r2, [r0, #20]
   44e1e:	70a1      	strb	r1, [r4, #2]
   44e20:	60a2      	str	r2, [r4, #8]
   44e22:	4a2a      	ldr	r2, [pc, #168]	; (44ecc <rpc_transport_ipc_init+0x148>)
   44e24:	7023      	strb	r3, [r4, #0]
   44e26:	6017      	str	r7, [r2, #0]
   44e28:	4a29      	ldr	r2, [pc, #164]	; (44ed0 <rpc_transport_ipc_init+0x14c>)
   44e2a:	7063      	strb	r3, [r4, #1]
   44e2c:	6016      	str	r6, [r2, #0]
   44e2e:	2208      	movs	r2, #8
   44e30:	70e3      	strb	r3, [r4, #3]
   44e32:	60e6      	str	r6, [r4, #12]
   44e34:	6127      	str	r7, [r4, #16]
   44e36:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   44e3a:	f8c4 9014 	str.w	r9, [r4, #20]
   44e3e:	f8c4 8018 	str.w	r8, [r4, #24]
   44e42:	707b      	strb	r3, [r7, #1]
   44e44:	70bb      	strb	r3, [r7, #2]
   44e46:	70fb      	strb	r3, [r7, #3]
   44e48:	2714      	movs	r7, #20
   44e4a:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   44e4e:	4a21      	ldr	r2, [pc, #132]	; (44ed4 <rpc_transport_ipc_init+0x150>)
   44e50:	4d21      	ldr	r5, [pc, #132]	; (44ed8 <rpc_transport_ipc_init+0x154>)
   44e52:	f8c2 b000 	str.w	fp, [r2]
   44e56:	4a21      	ldr	r2, [pc, #132]	; (44edc <rpc_transport_ipc_init+0x158>)
   44e58:	7073      	strb	r3, [r6, #1]
   44e5a:	f8c2 a000 	str.w	sl, [r2]
   44e5e:	4a20      	ldr	r2, [pc, #128]	; (44ee0 <rpc_transport_ipc_init+0x15c>)
   44e60:	70b3      	strb	r3, [r6, #2]
   44e62:	70f3      	strb	r3, [r6, #3]
   44e64:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   44e68:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   44e6c:	4c1d      	ldr	r4, [pc, #116]	; (44ee4 <rpc_transport_ipc_init+0x160>)
   44e6e:	7029      	strb	r1, [r5, #0]
   44e70:	491d      	ldr	r1, [pc, #116]	; (44ee8 <rpc_transport_ipc_init+0x164>)
   44e72:	6023      	str	r3, [r4, #0]
   44e74:	9302      	str	r3, [sp, #8]
   44e76:	600b      	str	r3, [r1, #0]
   44e78:	680b      	ldr	r3, [r1, #0]
   44e7a:	4e1c      	ldr	r6, [pc, #112]	; (44eec <rpc_transport_ipc_init+0x168>)
   44e7c:	9302      	str	r3, [sp, #8]
   44e7e:	9b02      	ldr	r3, [sp, #8]
   44e80:	2000      	movs	r0, #0
   44e82:	a901      	add	r1, sp, #4
   44e84:	9701      	str	r7, [sp, #4]
   44e86:	f7fe fe0f 	bl	43aa8 <nrf_modem_os_timedwait>
   44e8a:	9b01      	ldr	r3, [sp, #4]
   44e8c:	3b14      	subs	r3, #20
   44e8e:	441e      	add	r6, r3
   44e90:	782b      	ldrb	r3, [r5, #0]
   44e92:	2b01      	cmp	r3, #1
   44e94:	d104      	bne.n	44ea0 <rpc_transport_ipc_init+0x11c>
   44e96:	2e00      	cmp	r6, #0
   44e98:	d1f2      	bne.n	44e80 <rpc_transport_ipc_init+0xfc>
   44e9a:	f06f 0373 	mvn.w	r3, #115	; 0x73
   44e9e:	6023      	str	r3, [r4, #0]
   44ea0:	6824      	ldr	r4, [r4, #0]
   44ea2:	b95c      	cbnz	r4, 44ebc <rpc_transport_ipc_init+0x138>
   44ea4:	4b12      	ldr	r3, [pc, #72]	; (44ef0 <rpc_transport_ipc_init+0x16c>)
   44ea6:	701c      	strb	r4, [r3, #0]
   44ea8:	4b12      	ldr	r3, [pc, #72]	; (44ef4 <rpc_transport_ipc_init+0x170>)
   44eaa:	801c      	strh	r4, [r3, #0]
   44eac:	4b12      	ldr	r3, [pc, #72]	; (44ef8 <rpc_transport_ipc_init+0x174>)
   44eae:	801c      	strh	r4, [r3, #0]
   44eb0:	4620      	mov	r0, r4
   44eb2:	b015      	add	sp, #84	; 0x54
   44eb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44eb8:	4698      	mov	r8, r3
   44eba:	e79e      	b.n	44dfa <rpc_transport_ipc_init+0x76>
   44ebc:	f7ff fbb8 	bl	44630 <nrfx_ipc_uninit>
   44ec0:	e7f6      	b.n	44eb0 <rpc_transport_ipc_init+0x12c>
   44ec2:	bf00      	nop
   44ec4:	00044efd 	.word	0x00044efd
   44ec8:	2001ab34 	.word	0x2001ab34
   44ecc:	2001ab44 	.word	0x2001ab44
   44ed0:	2001ab3c 	.word	0x2001ab3c
   44ed4:	2001ab40 	.word	0x2001ab40
   44ed8:	2001ea7d 	.word	0x2001ea7d
   44edc:	2001ab38 	.word	0x2001ab38
   44ee0:	4002a000 	.word	0x4002a000
   44ee4:	2001ab28 	.word	0x2001ab28
   44ee8:	40005610 	.word	0x40005610
   44eec:	000249f0 	.word	0x000249f0
   44ef0:	2001ea7e 	.word	0x2001ea7e
   44ef4:	2001adac 	.word	0x2001adac
   44ef8:	2001adaa 	.word	0x2001adaa

00044efc <ipc_irq_handler>:
   44efc:	b570      	push	{r4, r5, r6, lr}
   44efe:	4604      	mov	r4, r0
   44f00:	0620      	lsls	r0, r4, #24
   44f02:	d50c      	bpl.n	44f1e <ipc_irq_handler+0x22>
   44f04:	f7ff fd84 	bl	44a10 <ipc_trace_handle>
   44f08:	f7ff fe16 	bl	44b38 <rpc_trace_coredump_in_progress>
   44f0c:	b138      	cbz	r0, 44f1e <ipc_irq_handler+0x22>
   44f0e:	22e0      	movs	r2, #224	; 0xe0
   44f10:	4b3e      	ldr	r3, [pc, #248]	; (4500c <ipc_irq_handler+0x110>)
   44f12:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   44f16:	f44f 6280 	mov.w	r2, #1024	; 0x400
   44f1a:	605a      	str	r2, [r3, #4]
   44f1c:	bd70      	pop	{r4, r5, r6, pc}
   44f1e:	07e1      	lsls	r1, r4, #31
   44f20:	d548      	bpl.n	44fb4 <ipc_irq_handler+0xb8>
   44f22:	f248 0202 	movw	r2, #32770	; 0x8002
   44f26:	4b3a      	ldr	r3, [pc, #232]	; (45010 <ipc_irq_handler+0x114>)
   44f28:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   44f2c:	4293      	cmp	r3, r2
   44f2e:	d035      	beq.n	44f9c <ipc_irq_handler+0xa0>
   44f30:	d81b      	bhi.n	44f6a <ipc_irq_handler+0x6e>
   44f32:	f243 0232 	movw	r2, #12338	; 0x3032
   44f36:	4293      	cmp	r3, r2
   44f38:	d036      	beq.n	44fa8 <ipc_irq_handler+0xac>
   44f3a:	d80b      	bhi.n	44f54 <ipc_irq_handler+0x58>
   44f3c:	3b01      	subs	r3, #1
   44f3e:	2b01      	cmp	r3, #1
   44f40:	d8ec      	bhi.n	44f1c <ipc_irq_handler+0x20>
   44f42:	2203      	movs	r2, #3
   44f44:	200e      	movs	r0, #14
   44f46:	4b33      	ldr	r3, [pc, #204]	; (45014 <ipc_irq_handler+0x118>)
   44f48:	701a      	strb	r2, [r3, #0]
   44f4a:	4b33      	ldr	r3, [pc, #204]	; (45018 <ipc_irq_handler+0x11c>)
   44f4c:	6018      	str	r0, [r3, #0]
   44f4e:	f003 fbf5 	bl	4873c <rpc_transport_ipc_fault_handler>
   44f52:	e7e3      	b.n	44f1c <ipc_irq_handler+0x20>
   44f54:	f248 0201 	movw	r2, #32769	; 0x8001
   44f58:	4293      	cmp	r3, r2
   44f5a:	d1df      	bne.n	44f1c <ipc_irq_handler+0x20>
   44f5c:	2203      	movs	r2, #3
   44f5e:	4b2d      	ldr	r3, [pc, #180]	; (45014 <ipc_irq_handler+0x118>)
   44f60:	701a      	strb	r2, [r3, #0]
   44f62:	2216      	movs	r2, #22
   44f64:	4b2c      	ldr	r3, [pc, #176]	; (45018 <ipc_irq_handler+0x11c>)
   44f66:	601a      	str	r2, [r3, #0]
   44f68:	e7d8      	b.n	44f1c <ipc_irq_handler+0x20>
   44f6a:	4a2c      	ldr	r2, [pc, #176]	; (4501c <ipc_irq_handler+0x120>)
   44f6c:	4293      	cmp	r3, r2
   44f6e:	d80c      	bhi.n	44f8a <ipc_irq_handler+0x8e>
   44f70:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   44f74:	d80c      	bhi.n	44f90 <ipc_irq_handler+0x94>
   44f76:	f248 0203 	movw	r2, #32771	; 0x8003
   44f7a:	4293      	cmp	r3, r2
   44f7c:	d1ce      	bne.n	44f1c <ipc_irq_handler+0x20>
   44f7e:	2203      	movs	r2, #3
   44f80:	4b24      	ldr	r3, [pc, #144]	; (45014 <ipc_irq_handler+0x118>)
   44f82:	701a      	strb	r2, [r3, #0]
   44f84:	220c      	movs	r2, #12
   44f86:	4b24      	ldr	r3, [pc, #144]	; (45018 <ipc_irq_handler+0x11c>)
   44f88:	e7ed      	b.n	44f66 <ipc_irq_handler+0x6a>
   44f8a:	4a25      	ldr	r2, [pc, #148]	; (45020 <ipc_irq_handler+0x124>)
   44f8c:	4293      	cmp	r3, r2
   44f8e:	d1c5      	bne.n	44f1c <ipc_irq_handler+0x20>
   44f90:	2103      	movs	r1, #3
   44f92:	4a20      	ldr	r2, [pc, #128]	; (45014 <ipc_irq_handler+0x118>)
   44f94:	7011      	strb	r1, [r2, #0]
   44f96:	4a20      	ldr	r2, [pc, #128]	; (45018 <ipc_irq_handler+0x11c>)
   44f98:	6013      	str	r3, [r2, #0]
   44f9a:	e7bf      	b.n	44f1c <ipc_irq_handler+0x20>
   44f9c:	2203      	movs	r2, #3
   44f9e:	4b1d      	ldr	r3, [pc, #116]	; (45014 <ipc_irq_handler+0x118>)
   44fa0:	701a      	strb	r2, [r3, #0]
   44fa2:	225f      	movs	r2, #95	; 0x5f
   44fa4:	4b1c      	ldr	r3, [pc, #112]	; (45018 <ipc_irq_handler+0x11c>)
   44fa6:	e7de      	b.n	44f66 <ipc_irq_handler+0x6a>
   44fa8:	2203      	movs	r2, #3
   44faa:	4b1a      	ldr	r3, [pc, #104]	; (45014 <ipc_irq_handler+0x118>)
   44fac:	701a      	strb	r2, [r3, #0]
   44fae:	2205      	movs	r2, #5
   44fb0:	4b19      	ldr	r3, [pc, #100]	; (45018 <ipc_irq_handler+0x11c>)
   44fb2:	e7d8      	b.n	44f66 <ipc_irq_handler+0x6a>
   44fb4:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   44fb8:	d003      	beq.n	44fc2 <ipc_irq_handler+0xc6>
   44fba:	2202      	movs	r2, #2
   44fbc:	4b15      	ldr	r3, [pc, #84]	; (45014 <ipc_irq_handler+0x118>)
   44fbe:	701a      	strb	r2, [r3, #0]
   44fc0:	e7ac      	b.n	44f1c <ipc_irq_handler+0x20>
   44fc2:	0762      	lsls	r2, r4, #29
   44fc4:	d505      	bpl.n	44fd2 <ipc_irq_handler+0xd6>
   44fc6:	4b13      	ldr	r3, [pc, #76]	; (45014 <ipc_irq_handler+0x118>)
   44fc8:	781a      	ldrb	r2, [r3, #0]
   44fca:	461e      	mov	r6, r3
   44fcc:	b93a      	cbnz	r2, 44fde <ipc_irq_handler+0xe2>
   44fce:	f7fe fe23 	bl	43c18 <nrf_modem_os_application_irq_set>
   44fd2:	06e3      	lsls	r3, r4, #27
   44fd4:	d5a2      	bpl.n	44f1c <ipc_irq_handler+0x20>
   44fd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   44fda:	f7fe be1d 	b.w	43c18 <nrf_modem_os_application_irq_set>
   44fde:	2a01      	cmp	r2, #1
   44fe0:	d1f7      	bne.n	44fd2 <ipc_irq_handler+0xd6>
   44fe2:	4a10      	ldr	r2, [pc, #64]	; (45024 <ipc_irq_handler+0x128>)
   44fe4:	4810      	ldr	r0, [pc, #64]	; (45028 <ipc_irq_handler+0x12c>)
   44fe6:	6812      	ldr	r2, [r2, #0]
   44fe8:	6891      	ldr	r1, [r2, #8]
   44fea:	6041      	str	r1, [r0, #4]
   44fec:	6852      	ldr	r2, [r2, #4]
   44fee:	6002      	str	r2, [r0, #0]
   44ff0:	b121      	cbz	r1, 44ffc <ipc_irq_handler+0x100>
   44ff2:	b11a      	cbz	r2, 44ffc <ipc_irq_handler+0x100>
   44ff4:	6809      	ldr	r1, [r1, #0]
   44ff6:	b109      	cbz	r1, 44ffc <ipc_irq_handler+0x100>
   44ff8:	6812      	ldr	r2, [r2, #0]
   44ffa:	b92a      	cbnz	r2, 45008 <ipc_irq_handler+0x10c>
   44ffc:	2303      	movs	r3, #3
   44ffe:	2205      	movs	r2, #5
   45000:	7033      	strb	r3, [r6, #0]
   45002:	4b05      	ldr	r3, [pc, #20]	; (45018 <ipc_irq_handler+0x11c>)
   45004:	601a      	str	r2, [r3, #0]
   45006:	e7e4      	b.n	44fd2 <ipc_irq_handler+0xd6>
   45008:	701d      	strb	r5, [r3, #0]
   4500a:	e7e2      	b.n	44fd2 <ipc_irq_handler+0xd6>
   4500c:	e000e100 	.word	0xe000e100
   45010:	4002a000 	.word	0x4002a000
   45014:	2001ea7d 	.word	0x2001ea7d
   45018:	2001ab28 	.word	0x2001ab28
   4501c:	04400004 	.word	0x04400004
   45020:	05500001 	.word	0x05500001
   45024:	2001ab34 	.word	0x2001ab34
   45028:	2001ab2c 	.word	0x2001ab2c

0004502c <interface_init>:
   4502c:	b508      	push	{r3, lr}
   4502e:	f44f 72b0 	mov.w	r2, #352	; 0x160
   45032:	2100      	movs	r1, #0
   45034:	4802      	ldr	r0, [pc, #8]	; (45040 <interface_init+0x14>)
   45036:	f003 f908 	bl	4824a <memset>
   4503a:	2000      	movs	r0, #0
   4503c:	bd08      	pop	{r3, pc}
   4503e:	bf00      	nop
   45040:	2001ab48 	.word	0x2001ab48

00045044 <interface_socket_wait>:
   45044:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45048:	4615      	mov	r5, r2
   4504a:	222c      	movs	r2, #44	; 0x2c
   4504c:	4350      	muls	r0, r2
   4504e:	461e      	mov	r6, r3
   45050:	4b0e      	ldr	r3, [pc, #56]	; (4508c <interface_socket_wait+0x48>)
   45052:	460c      	mov	r4, r1
   45054:	181f      	adds	r7, r3, r0
   45056:	581b      	ldr	r3, [r3, r0]
   45058:	402b      	ands	r3, r5
   4505a:	428b      	cmp	r3, r1
   4505c:	d102      	bne.n	45064 <interface_socket_wait+0x20>
   4505e:	2000      	movs	r0, #0
   45060:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45064:	687b      	ldr	r3, [r7, #4]
   45066:	2b00      	cmp	r3, #0
   45068:	d1f9      	bne.n	4505e <interface_socket_wait+0x1a>
   4506a:	46b8      	mov	r8, r7
   4506c:	f8d8 3000 	ldr.w	r3, [r8]
   45070:	402b      	ands	r3, r5
   45072:	42a3      	cmp	r3, r4
   45074:	d0f3      	beq.n	4505e <interface_socket_wait+0x1a>
   45076:	f8d8 3004 	ldr.w	r3, [r8, #4]
   4507a:	2b00      	cmp	r3, #0
   4507c:	d1ef      	bne.n	4505e <interface_socket_wait+0x1a>
   4507e:	4631      	mov	r1, r6
   45080:	4638      	mov	r0, r7
   45082:	f7fe fd11 	bl	43aa8 <nrf_modem_os_timedwait>
   45086:	2800      	cmp	r0, #0
   45088:	d0f0      	beq.n	4506c <interface_socket_wait+0x28>
   4508a:	e7e9      	b.n	45060 <interface_socket_wait+0x1c>
   4508c:	2001ab48 	.word	0x2001ab48

00045090 <interface_sockets_aux_state_set>:
   45090:	4a0d      	ldr	r2, [pc, #52]	; (450c8 <interface_sockets_aux_state_set+0x38>)
   45092:	b570      	push	{r4, r5, r6, lr}
   45094:	2300      	movs	r3, #0
   45096:	4611      	mov	r1, r2
   45098:	252c      	movs	r5, #44	; 0x2c
   4509a:	fb05 f403 	mul.w	r4, r5, r3
   4509e:	590c      	ldr	r4, [r1, r4]
   450a0:	b15c      	cbz	r4, 450ba <interface_sockets_aux_state_set+0x2a>
   450a2:	68d4      	ldr	r4, [r2, #12]
   450a4:	f024 0608 	bic.w	r6, r4, #8
   450a8:	2e02      	cmp	r6, #2
   450aa:	d001      	beq.n	450b0 <interface_sockets_aux_state_set+0x20>
   450ac:	2c05      	cmp	r4, #5
   450ae:	d104      	bne.n	450ba <interface_sockets_aux_state_set+0x2a>
   450b0:	fb05 f603 	mul.w	r6, r5, r3
   450b4:	598c      	ldr	r4, [r1, r6]
   450b6:	4304      	orrs	r4, r0
   450b8:	518c      	str	r4, [r1, r6]
   450ba:	3301      	adds	r3, #1
   450bc:	2b08      	cmp	r3, #8
   450be:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   450c2:	d1ea      	bne.n	4509a <interface_sockets_aux_state_set+0xa>
   450c4:	bd70      	pop	{r4, r5, r6, pc}
   450c6:	bf00      	nop
   450c8:	2001ab48 	.word	0x2001ab48

000450cc <interface_sockets_aux_state_clear>:
   450cc:	4a0d      	ldr	r2, [pc, #52]	; (45104 <interface_sockets_aux_state_clear+0x38>)
   450ce:	b570      	push	{r4, r5, r6, lr}
   450d0:	2300      	movs	r3, #0
   450d2:	4611      	mov	r1, r2
   450d4:	252c      	movs	r5, #44	; 0x2c
   450d6:	43c0      	mvns	r0, r0
   450d8:	fb05 f403 	mul.w	r4, r5, r3
   450dc:	590c      	ldr	r4, [r1, r4]
   450de:	b15c      	cbz	r4, 450f8 <interface_sockets_aux_state_clear+0x2c>
   450e0:	68d4      	ldr	r4, [r2, #12]
   450e2:	f024 0608 	bic.w	r6, r4, #8
   450e6:	2e02      	cmp	r6, #2
   450e8:	d001      	beq.n	450ee <interface_sockets_aux_state_clear+0x22>
   450ea:	2c05      	cmp	r4, #5
   450ec:	d104      	bne.n	450f8 <interface_sockets_aux_state_clear+0x2c>
   450ee:	fb05 f603 	mul.w	r6, r5, r3
   450f2:	598c      	ldr	r4, [r1, r6]
   450f4:	4004      	ands	r4, r0
   450f6:	518c      	str	r4, [r1, r6]
   450f8:	3301      	adds	r3, #1
   450fa:	2b08      	cmp	r3, #8
   450fc:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   45100:	d1ea      	bne.n	450d8 <interface_sockets_aux_state_clear+0xc>
   45102:	bd70      	pop	{r4, r5, r6, pc}
   45104:	2001ab48 	.word	0x2001ab48

00045108 <interface_from_internal_id_search>:
   45108:	4b0a      	ldr	r3, [pc, #40]	; (45134 <interface_from_internal_id_search+0x2c>)
   4510a:	4602      	mov	r2, r0
   4510c:	b530      	push	{r4, r5, lr}
   4510e:	2000      	movs	r0, #0
   45110:	461c      	mov	r4, r3
   45112:	212c      	movs	r1, #44	; 0x2c
   45114:	fb01 f500 	mul.w	r5, r1, r0
   45118:	5965      	ldr	r5, [r4, r5]
   4511a:	b115      	cbz	r5, 45122 <interface_from_internal_id_search+0x1a>
   4511c:	699d      	ldr	r5, [r3, #24]
   4511e:	4295      	cmp	r5, r2
   45120:	d006      	beq.n	45130 <interface_from_internal_id_search+0x28>
   45122:	3001      	adds	r0, #1
   45124:	2808      	cmp	r0, #8
   45126:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   4512a:	d1f3      	bne.n	45114 <interface_from_internal_id_search+0xc>
   4512c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   45130:	bd30      	pop	{r4, r5, pc}
   45132:	bf00      	nop
   45134:	2001ab48 	.word	0x2001ab48

00045138 <interface_socket_from_handle_get>:
   45138:	2807      	cmp	r0, #7
   4513a:	d808      	bhi.n	4514e <interface_socket_from_handle_get+0x16>
   4513c:	232c      	movs	r3, #44	; 0x2c
   4513e:	4343      	muls	r3, r0
   45140:	4a04      	ldr	r2, [pc, #16]	; (45154 <interface_socket_from_handle_get+0x1c>)
   45142:	18d0      	adds	r0, r2, r3
   45144:	58d3      	ldr	r3, [r2, r3]
   45146:	2b00      	cmp	r3, #0
   45148:	bf08      	it	eq
   4514a:	2000      	moveq	r0, #0
   4514c:	4770      	bx	lr
   4514e:	2000      	movs	r0, #0
   45150:	4770      	bx	lr
   45152:	bf00      	nop
   45154:	2001ab48 	.word	0x2001ab48

00045158 <rpc_error_to_nrf_errno>:
   45158:	286a      	cmp	r0, #106	; 0x6a
   4515a:	bf9a      	itte	ls
   4515c:	4b01      	ldrls	r3, [pc, #4]	; (45164 <rpc_error_to_nrf_errno+0xc>)
   4515e:	5c18      	ldrbls	r0, [r3, r0]
   45160:	205f      	movhi	r0, #95	; 0x5f
   45162:	4770      	bx	lr
   45164:	00049ac1 	.word	0x00049ac1

00045168 <rpc_error_to_nrf_gai_errno>:
   45168:	2805      	cmp	r0, #5
   4516a:	d013      	beq.n	45194 <rpc_error_to_nrf_gai_errno+0x2c>
   4516c:	d807      	bhi.n	4517e <rpc_error_to_nrf_gai_errno+0x16>
   4516e:	b170      	cbz	r0, 4518e <rpc_error_to_nrf_gai_errno+0x26>
   45170:	4b0b      	ldr	r3, [pc, #44]	; (451a0 <rpc_error_to_nrf_gai_errno+0x38>)
   45172:	5c1b      	ldrb	r3, [r3, r0]
   45174:	4a0b      	ldr	r2, [pc, #44]	; (451a4 <rpc_error_to_nrf_gai_errno+0x3c>)
   45176:	f240 1015 	movw	r0, #277	; 0x115
   4517a:	6013      	str	r3, [r2, #0]
   4517c:	4770      	bx	lr
   4517e:	2806      	cmp	r0, #6
   45180:	d00b      	beq.n	4519a <rpc_error_to_nrf_gai_errno+0x32>
   45182:	280d      	cmp	r0, #13
   45184:	d009      	beq.n	4519a <rpc_error_to_nrf_gai_errno+0x32>
   45186:	286a      	cmp	r0, #106	; 0x6a
   45188:	d9f2      	bls.n	45170 <rpc_error_to_nrf_gai_errno+0x8>
   4518a:	235f      	movs	r3, #95	; 0x5f
   4518c:	e7f2      	b.n	45174 <rpc_error_to_nrf_gai_errno+0xc>
   4518e:	4b05      	ldr	r3, [pc, #20]	; (451a4 <rpc_error_to_nrf_gai_errno+0x3c>)
   45190:	6018      	str	r0, [r3, #0]
   45192:	4770      	bx	lr
   45194:	f44f 708a 	mov.w	r0, #276	; 0x114
   45198:	4770      	bx	lr
   4519a:	f240 1011 	movw	r0, #273	; 0x111
   4519e:	4770      	bx	lr
   451a0:	00049ac1 	.word	0x00049ac1
   451a4:	2001acb0 	.word	0x2001acb0

000451a8 <ip_interface_init>:
   451a8:	b510      	push	{r4, lr}
   451aa:	2400      	movs	r4, #0
   451ac:	4b06      	ldr	r3, [pc, #24]	; (451c8 <ip_interface_init+0x20>)
   451ae:	2220      	movs	r2, #32
   451b0:	601c      	str	r4, [r3, #0]
   451b2:	4b06      	ldr	r3, [pc, #24]	; (451cc <ip_interface_init+0x24>)
   451b4:	4621      	mov	r1, r4
   451b6:	4806      	ldr	r0, [pc, #24]	; (451d0 <ip_interface_init+0x28>)
   451b8:	601c      	str	r4, [r3, #0]
   451ba:	f003 f846 	bl	4824a <memset>
   451be:	2201      	movs	r2, #1
   451c0:	4b04      	ldr	r3, [pc, #16]	; (451d4 <ip_interface_init+0x2c>)
   451c2:	4620      	mov	r0, r4
   451c4:	701a      	strb	r2, [r3, #0]
   451c6:	bd10      	pop	{r4, pc}
   451c8:	2001acbc 	.word	0x2001acbc
   451cc:	2001acb8 	.word	0x2001acb8
   451d0:	2001acc0 	.word	0x2001acc0
   451d4:	2001ea80 	.word	0x2001ea80

000451d8 <rpc_ip_event_handler>:
   451d8:	f248 030f 	movw	r3, #32783	; 0x800f
   451dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   451e0:	4299      	cmp	r1, r3
   451e2:	4604      	mov	r4, r0
   451e4:	460e      	mov	r6, r1
   451e6:	b089      	sub	sp, #36	; 0x24
   451e8:	f000 80a4 	beq.w	45334 <rpc_ip_event_handler+0x15c>
   451ec:	f249 0304 	movw	r3, #36868	; 0x9004
   451f0:	4299      	cmp	r1, r3
   451f2:	f000 80ab 	beq.w	4534c <rpc_ip_event_handler+0x174>
   451f6:	f248 030d 	movw	r3, #32781	; 0x800d
   451fa:	4299      	cmp	r1, r3
   451fc:	f040 80b8 	bne.w	45370 <rpc_ip_event_handler+0x198>
   45200:	4bbc      	ldr	r3, [pc, #752]	; (454f4 <rpc_ip_event_handler+0x31c>)
   45202:	681a      	ldr	r2, [r3, #0]
   45204:	9303      	str	r3, [sp, #12]
   45206:	2a01      	cmp	r2, #1
   45208:	d12d      	bne.n	45266 <rpc_ip_event_handler+0x8e>
   4520a:	6940      	ldr	r0, [r0, #20]
   4520c:	2800      	cmp	r0, #0
   4520e:	f040 808c 	bne.w	4532a <rpc_ip_event_handler+0x152>
   45212:	f8d4 a018 	ldr.w	sl, [r4, #24]
   45216:	f8d4 8000 	ldr.w	r8, [r4]
   4521a:	ea4f 134a 	mov.w	r3, sl, lsl #5
   4521e:	4618      	mov	r0, r3
   45220:	9301      	str	r3, [sp, #4]
   45222:	f7fe fd19 	bl	43c58 <nrf_modem_os_alloc>
   45226:	4607      	mov	r7, r0
   45228:	b310      	cbz	r0, 45270 <rpc_ip_event_handler+0x98>
   4522a:	2024      	movs	r0, #36	; 0x24
   4522c:	fb00 f00a 	mul.w	r0, r0, sl
   45230:	f7fe fd12 	bl	43c58 <nrf_modem_os_alloc>
   45234:	4605      	mov	r5, r0
   45236:	b1e8      	cbz	r0, 45274 <rpc_ip_event_handler+0x9c>
   45238:	2604      	movs	r6, #4
   4523a:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   4523e:	f107 0920 	add.w	r9, r7, #32
   45242:	9302      	str	r3, [sp, #8]
   45244:	9b02      	ldr	r3, [sp, #8]
   45246:	42ab      	cmp	r3, r5
   45248:	d118      	bne.n	4527c <rpc_ip_event_handler+0xa4>
   4524a:	f1ba 0f00 	cmp.w	sl, #0
   4524e:	d005      	beq.n	4525c <rpc_ip_event_handler+0x84>
   45250:	9b01      	ldr	r3, [sp, #4]
   45252:	443b      	add	r3, r7
   45254:	4699      	mov	r9, r3
   45256:	2300      	movs	r3, #0
   45258:	f849 3c04 	str.w	r3, [r9, #-4]
   4525c:	4ba6      	ldr	r3, [pc, #664]	; (454f8 <rpc_ip_event_handler+0x320>)
   4525e:	601f      	str	r7, [r3, #0]
   45260:	2302      	movs	r3, #2
   45262:	9a03      	ldr	r2, [sp, #12]
   45264:	6013      	str	r3, [r2, #0]
   45266:	6820      	ldr	r0, [r4, #0]
   45268:	2800      	cmp	r0, #0
   4526a:	f040 81c7 	bne.w	455fc <rpc_ip_event_handler+0x424>
   4526e:	e1c7      	b.n	45600 <rpc_ip_event_handler+0x428>
   45270:	f7fe fcfa 	bl	43c68 <nrf_modem_os_free>
   45274:	220c      	movs	r2, #12
   45276:	4ba1      	ldr	r3, [pc, #644]	; (454fc <rpc_ip_event_handler+0x324>)
   45278:	601a      	str	r2, [r3, #0]
   4527a:	e7ef      	b.n	4525c <rpc_ip_event_handler+0x84>
   4527c:	f858 2006 	ldr.w	r2, [r8, r6]
   45280:	eb08 0106 	add.w	r1, r8, r6
   45284:	f849 2c20 	str.w	r2, [r9, #-32]
   45288:	eb08 0206 	add.w	r2, r8, r6
   4528c:	6852      	ldr	r2, [r2, #4]
   4528e:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   45292:	3a01      	subs	r2, #1
   45294:	2a04      	cmp	r2, #4
   45296:	bf8c      	ite	hi
   45298:	2200      	movhi	r2, #0
   4529a:	4b99      	ldrls	r3, [pc, #612]	; (45500 <rpc_ip_event_handler+0x328>)
   4529c:	f106 0614 	add.w	r6, r6, #20
   452a0:	bf98      	it	ls
   452a2:	569a      	ldrsbls	r2, [r3, r2]
   452a4:	4b97      	ldr	r3, [pc, #604]	; (45504 <rpc_ip_event_handler+0x32c>)
   452a6:	f849 2c1c 	str.w	r2, [r9, #-28]
   452aa:	681a      	ldr	r2, [r3, #0]
   452ac:	4b96      	ldr	r3, [pc, #600]	; (45508 <rpc_ip_event_handler+0x330>)
   452ae:	f849 2c18 	str.w	r2, [r9, #-24]
   452b2:	681a      	ldr	r2, [r3, #0]
   452b4:	f849 2c14 	str.w	r2, [r9, #-20]
   452b8:	8a0a      	ldrh	r2, [r1, #16]
   452ba:	4994      	ldr	r1, [pc, #592]	; (4550c <rpc_ip_event_handler+0x334>)
   452bc:	2a04      	cmp	r2, #4
   452be:	8808      	ldrh	r0, [r1, #0]
   452c0:	f849 2c10 	str.w	r2, [r9, #-16]
   452c4:	f849 5c0c 	str.w	r5, [r9, #-12]
   452c8:	eb08 0106 	add.w	r1, r8, r6
   452cc:	d121      	bne.n	45312 <rpc_ip_event_handler+0x13a>
   452ce:	2202      	movs	r2, #2
   452d0:	606a      	str	r2, [r5, #4]
   452d2:	2210      	movs	r2, #16
   452d4:	8128      	strh	r0, [r5, #8]
   452d6:	702a      	strb	r2, [r5, #0]
   452d8:	680a      	ldr	r2, [r1, #0]
   452da:	60ea      	str	r2, [r5, #12]
   452dc:	f859 2c10 	ldr.w	r2, [r9, #-16]
   452e0:	f10b 0001 	add.w	r0, fp, #1
   452e4:	4416      	add	r6, r2
   452e6:	f7fe fcb7 	bl	43c58 <nrf_modem_os_alloc>
   452ea:	f849 0c08 	str.w	r0, [r9, #-8]
   452ee:	b148      	cbz	r0, 45304 <rpc_ip_event_handler+0x12c>
   452f0:	465a      	mov	r2, fp
   452f2:	eb08 0106 	add.w	r1, r8, r6
   452f6:	f002 ff9d 	bl	48234 <memcpy>
   452fa:	2100      	movs	r1, #0
   452fc:	f859 2c08 	ldr.w	r2, [r9, #-8]
   45300:	f802 100b 	strb.w	r1, [r2, fp]
   45304:	f849 9c04 	str.w	r9, [r9, #-4]
   45308:	445e      	add	r6, fp
   4530a:	f109 0920 	add.w	r9, r9, #32
   4530e:	3508      	adds	r5, #8
   45310:	e798      	b.n	45244 <rpc_ip_event_handler+0x6c>
   45312:	230a      	movs	r3, #10
   45314:	f04f 0c24 	mov.w	ip, #36	; 0x24
   45318:	8128      	strh	r0, [r5, #8]
   4531a:	606b      	str	r3, [r5, #4]
   4531c:	f885 c000 	strb.w	ip, [r5]
   45320:	f105 0010 	add.w	r0, r5, #16
   45324:	f002 ff86 	bl	48234 <memcpy>
   45328:	e7d8      	b.n	452dc <rpc_ip_event_handler+0x104>
   4532a:	f7ff ff1d 	bl	45168 <rpc_error_to_nrf_gai_errno>
   4532e:	4b73      	ldr	r3, [pc, #460]	; (454fc <rpc_ip_event_handler+0x324>)
   45330:	6018      	str	r0, [r3, #0]
   45332:	e795      	b.n	45260 <rpc_ip_event_handler+0x88>
   45334:	6943      	ldr	r3, [r0, #20]
   45336:	2b6a      	cmp	r3, #106	; 0x6a
   45338:	bf8e      	itee	hi
   4533a:	235f      	movhi	r3, #95	; 0x5f
   4533c:	4a74      	ldrls	r2, [pc, #464]	; (45510 <rpc_ip_event_handler+0x338>)
   4533e:	5cd3      	ldrbls	r3, [r2, r3]
   45340:	4a74      	ldr	r2, [pc, #464]	; (45514 <rpc_ip_event_handler+0x33c>)
   45342:	6013      	str	r3, [r2, #0]
   45344:	4b74      	ldr	r3, [pc, #464]	; (45518 <rpc_ip_event_handler+0x340>)
   45346:	2201      	movs	r2, #1
   45348:	701a      	strb	r2, [r3, #0]
   4534a:	e159      	b.n	45600 <rpc_ip_event_handler+0x428>
   4534c:	6903      	ldr	r3, [r0, #16]
   4534e:	2b03      	cmp	r3, #3
   45350:	d807      	bhi.n	45362 <rpc_ip_event_handler+0x18a>
   45352:	e8df f003 	tbb	[pc, r3]
   45356:	0802      	.short	0x0802
   45358:	0802      	.short	0x0802
   4535a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   4535e:	f7ff fe97 	bl	45090 <interface_sockets_aux_state_set>
   45362:	4b6e      	ldr	r3, [pc, #440]	; (4551c <rpc_ip_event_handler+0x344>)
   45364:	e7ef      	b.n	45346 <rpc_ip_event_handler+0x16e>
   45366:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   4536a:	f7ff feaf 	bl	450cc <interface_sockets_aux_state_clear>
   4536e:	e7f8      	b.n	45362 <rpc_ip_event_handler+0x18a>
   45370:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   45374:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   45378:	68c0      	ldr	r0, [r0, #12]
   4537a:	d13b      	bne.n	453f4 <rpc_ip_event_handler+0x21c>
   4537c:	f7ff fec4 	bl	45108 <interface_from_internal_id_search>
   45380:	4607      	mov	r7, r0
   45382:	4638      	mov	r0, r7
   45384:	f7ff fed8 	bl	45138 <interface_socket_from_handle_get>
   45388:	4605      	mov	r5, r0
   4538a:	2800      	cmp	r0, #0
   4538c:	f43f af6b 	beq.w	45266 <rpc_ip_event_handler+0x8e>
   45390:	4601      	mov	r1, r0
   45392:	4633      	mov	r3, r6
   45394:	4622      	mov	r2, r4
   45396:	4638      	mov	r0, r7
   45398:	f000 f9f4 	bl	45784 <tls_rpc_ip_event_handler>
   4539c:	2800      	cmp	r0, #0
   4539e:	f000 812f 	beq.w	45600 <rpc_ip_event_handler+0x428>
   453a2:	f248 030c 	movw	r3, #32780	; 0x800c
   453a6:	429e      	cmp	r6, r3
   453a8:	d826      	bhi.n	453f8 <rpc_ip_event_handler+0x220>
   453aa:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   453ae:	f67f af5a 	bls.w	45266 <rpc_ip_event_handler+0x8e>
   453b2:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   453b6:	3e01      	subs	r6, #1
   453b8:	2e0b      	cmp	r6, #11
   453ba:	f63f af54 	bhi.w	45266 <rpc_ip_event_handler+0x8e>
   453be:	a301      	add	r3, pc, #4	; (adr r3, 453c4 <rpc_ip_event_handler+0x1ec>)
   453c0:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   453c4:	00045489 	.word	0x00045489
   453c8:	0004553d 	.word	0x0004553d
   453cc:	00045659 	.word	0x00045659
   453d0:	00045677 	.word	0x00045677
   453d4:	00045521 	.word	0x00045521
   453d8:	00045609 	.word	0x00045609
   453dc:	00045609 	.word	0x00045609
   453e0:	00045581 	.word	0x00045581
   453e4:	000454a3 	.word	0x000454a3
   453e8:	00045267 	.word	0x00045267
   453ec:	00045267 	.word	0x00045267
   453f0:	000455ab 	.word	0x000455ab
   453f4:	0c07      	lsrs	r7, r0, #16
   453f6:	e7c4      	b.n	45382 <rpc_ip_event_handler+0x1aa>
   453f8:	f249 0302 	movw	r3, #36866	; 0x9002
   453fc:	429e      	cmp	r6, r3
   453fe:	f000 80cc 	beq.w	4559a <rpc_ip_event_handler+0x3c2>
   45402:	f249 0303 	movw	r3, #36867	; 0x9003
   45406:	429e      	cmp	r6, r3
   45408:	d05b      	beq.n	454c2 <rpc_ip_event_handler+0x2ea>
   4540a:	f249 0301 	movw	r3, #36865	; 0x9001
   4540e:	429e      	cmp	r6, r3
   45410:	f47f af29 	bne.w	45266 <rpc_ip_event_handler+0x8e>
   45414:	682e      	ldr	r6, [r5, #0]
   45416:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   4541a:	f000 80ee 	beq.w	455fa <rpc_ip_event_handler+0x422>
   4541e:	68a3      	ldr	r3, [r4, #8]
   45420:	2b04      	cmp	r3, #4
   45422:	f240 80e7 	bls.w	455f4 <rpc_ip_event_handler+0x41c>
   45426:	8a63      	ldrh	r3, [r4, #18]
   45428:	2b00      	cmp	r3, #0
   4542a:	f000 80e4 	beq.w	455f6 <rpc_ip_event_handler+0x41e>
   4542e:	2b10      	cmp	r3, #16
   45430:	f040 80cc 	bne.w	455cc <rpc_ip_event_handler+0x3f4>
   45434:	2024      	movs	r0, #36	; 0x24
   45436:	f7fe fc0f 	bl	43c58 <nrf_modem_os_alloc>
   4543a:	b318      	cbz	r0, 45484 <rpc_ip_event_handler+0x2ac>
   4543c:	230a      	movs	r3, #10
   4543e:	6043      	str	r3, [r0, #4]
   45440:	2324      	movs	r3, #36	; 0x24
   45442:	7003      	strb	r3, [r0, #0]
   45444:	7c62      	ldrb	r2, [r4, #17]
   45446:	7c23      	ldrb	r3, [r4, #16]
   45448:	f104 0124 	add.w	r1, r4, #36	; 0x24
   4544c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   45450:	8103      	strh	r3, [r0, #8]
   45452:	f100 0210 	add.w	r2, r0, #16
   45456:	f104 0314 	add.w	r3, r4, #20
   4545a:	f853 6b04 	ldr.w	r6, [r3], #4
   4545e:	428b      	cmp	r3, r1
   45460:	f842 6b04 	str.w	r6, [r2], #4
   45464:	d1f9      	bne.n	4545a <rpc_ip_event_handler+0x282>
   45466:	2324      	movs	r3, #36	; 0x24
   45468:	6822      	ldr	r2, [r4, #0]
   4546a:	9307      	str	r3, [sp, #28]
   4546c:	9204      	str	r2, [sp, #16]
   4546e:	6862      	ldr	r2, [r4, #4]
   45470:	a904      	add	r1, sp, #16
   45472:	e9cd 2005 	strd	r2, r0, [sp, #20]
   45476:	69e8      	ldr	r0, [r5, #28]
   45478:	6803      	ldr	r3, [r0, #0]
   4547a:	685b      	ldr	r3, [r3, #4]
   4547c:	4798      	blx	r3
   4547e:	3001      	adds	r0, #1
   45480:	f040 808f 	bne.w	455a2 <rpc_ip_event_handler+0x3ca>
   45484:	2002      	movs	r0, #2
   45486:	e0bc      	b.n	45602 <rpc_ip_event_handler+0x42a>
   45488:	682b      	ldr	r3, [r5, #0]
   4548a:	2b01      	cmp	r3, #1
   4548c:	f040 80b8 	bne.w	45600 <rpc_ip_event_handler+0x428>
   45490:	6960      	ldr	r0, [r4, #20]
   45492:	2800      	cmp	r0, #0
   45494:	f040 80e9 	bne.w	4566a <rpc_ip_event_handler+0x492>
   45498:	2302      	movs	r3, #2
   4549a:	602b      	str	r3, [r5, #0]
   4549c:	69a3      	ldr	r3, [r4, #24]
   4549e:	61ab      	str	r3, [r5, #24]
   454a0:	e0af      	b.n	45602 <rpc_ip_event_handler+0x42a>
   454a2:	682b      	ldr	r3, [r5, #0]
   454a4:	b29b      	uxth	r3, r3
   454a6:	2b0d      	cmp	r3, #13
   454a8:	f040 80aa 	bne.w	45600 <rpc_ip_event_handler+0x428>
   454ac:	6960      	ldr	r0, [r4, #20]
   454ae:	2800      	cmp	r0, #0
   454b0:	f040 80db 	bne.w	4566a <rpc_ip_event_handler+0x492>
   454b4:	682b      	ldr	r3, [r5, #0]
   454b6:	0c1b      	lsrs	r3, r3, #16
   454b8:	041b      	lsls	r3, r3, #16
   454ba:	f043 030e 	orr.w	r3, r3, #14
   454be:	602b      	str	r3, [r5, #0]
   454c0:	e09f      	b.n	45602 <rpc_ip_event_handler+0x42a>
   454c2:	682b      	ldr	r3, [r5, #0]
   454c4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   454c8:	602b      	str	r3, [r5, #0]
   454ca:	682b      	ldr	r3, [r5, #0]
   454cc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   454d0:	602b      	str	r3, [r5, #0]
   454d2:	6923      	ldr	r3, [r4, #16]
   454d4:	2b6c      	cmp	r3, #108	; 0x6c
   454d6:	d107      	bne.n	454e8 <rpc_ip_event_handler+0x310>
   454d8:	682b      	ldr	r3, [r5, #0]
   454da:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   454de:	602b      	str	r3, [r5, #0]
   454e0:	2380      	movs	r3, #128	; 0x80
   454e2:	606b      	str	r3, [r5, #4]
   454e4:	60ab      	str	r3, [r5, #8]
   454e6:	e08b      	b.n	45600 <rpc_ip_event_handler+0x428>
   454e8:	2b6a      	cmp	r3, #106	; 0x6a
   454ea:	bf96      	itet	ls
   454ec:	4a08      	ldrls	r2, [pc, #32]	; (45510 <rpc_ip_event_handler+0x338>)
   454ee:	235f      	movhi	r3, #95	; 0x5f
   454f0:	5cd3      	ldrbls	r3, [r2, r3]
   454f2:	e7f6      	b.n	454e2 <rpc_ip_event_handler+0x30a>
   454f4:	2001acb8 	.word	0x2001acb8
   454f8:	2001acbc 	.word	0x2001acbc
   454fc:	2001acb4 	.word	0x2001acb4
   45500:	00049abc 	.word	0x00049abc
   45504:	2001acac 	.word	0x2001acac
   45508:	2001aca8 	.word	0x2001aca8
   4550c:	2001adae 	.word	0x2001adae
   45510:	00049ac1 	.word	0x00049ac1
   45514:	2001ace0 	.word	0x2001ace0
   45518:	2001ea81 	.word	0x2001ea81
   4551c:	2001ea7f 	.word	0x2001ea7f
   45520:	682b      	ldr	r3, [r5, #0]
   45522:	b29b      	uxth	r3, r3
   45524:	2b03      	cmp	r3, #3
   45526:	d16b      	bne.n	45600 <rpc_ip_event_handler+0x428>
   45528:	6960      	ldr	r0, [r4, #20]
   4552a:	2800      	cmp	r0, #0
   4552c:	f040 809d 	bne.w	4566a <rpc_ip_event_handler+0x492>
   45530:	682b      	ldr	r3, [r5, #0]
   45532:	0c1b      	lsrs	r3, r3, #16
   45534:	041b      	lsls	r3, r3, #16
   45536:	f043 0304 	orr.w	r3, r3, #4
   4553a:	e7c0      	b.n	454be <rpc_ip_event_handler+0x2e6>
   4553c:	682b      	ldr	r3, [r5, #0]
   4553e:	0099      	lsls	r1, r3, #2
   45540:	d55e      	bpl.n	45600 <rpc_ip_event_handler+0x428>
   45542:	682b      	ldr	r3, [r5, #0]
   45544:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45548:	602b      	str	r3, [r5, #0]
   4554a:	6960      	ldr	r0, [r4, #20]
   4554c:	b968      	cbnz	r0, 4556a <rpc_ip_event_handler+0x392>
   4554e:	682b      	ldr	r3, [r5, #0]
   45550:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   45554:	602b      	str	r3, [r5, #0]
   45556:	682b      	ldr	r3, [r5, #0]
   45558:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   4555c:	602b      	str	r3, [r5, #0]
   4555e:	682b      	ldr	r3, [r5, #0]
   45560:	0c1b      	lsrs	r3, r3, #16
   45562:	041b      	lsls	r3, r3, #16
   45564:	f043 0305 	orr.w	r3, r3, #5
   45568:	e7a9      	b.n	454be <rpc_ip_event_handler+0x2e6>
   4556a:	286a      	cmp	r0, #106	; 0x6a
   4556c:	bf8e      	itee	hi
   4556e:	235f      	movhi	r3, #95	; 0x5f
   45570:	4b4c      	ldrls	r3, [pc, #304]	; (456a4 <rpc_ip_event_handler+0x4cc>)
   45572:	5c1b      	ldrbls	r3, [r3, r0]
   45574:	606b      	str	r3, [r5, #4]
   45576:	682b      	ldr	r3, [r5, #0]
   45578:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   4557c:	602b      	str	r3, [r5, #0]
   4557e:	e03f      	b.n	45600 <rpc_ip_event_handler+0x428>
   45580:	682b      	ldr	r3, [r5, #0]
   45582:	b29b      	uxth	r3, r3
   45584:	2b06      	cmp	r3, #6
   45586:	d13b      	bne.n	45600 <rpc_ip_event_handler+0x428>
   45588:	6960      	ldr	r0, [r4, #20]
   4558a:	2800      	cmp	r0, #0
   4558c:	d16d      	bne.n	4566a <rpc_ip_event_handler+0x492>
   4558e:	682b      	ldr	r3, [r5, #0]
   45590:	0c1b      	lsrs	r3, r3, #16
   45592:	041b      	lsls	r3, r3, #16
   45594:	f043 0307 	orr.w	r3, r3, #7
   45598:	e791      	b.n	454be <rpc_ip_event_handler+0x2e6>
   4559a:	682b      	ldr	r3, [r5, #0]
   4559c:	b29b      	uxth	r3, r3
   4559e:	2b07      	cmp	r3, #7
   455a0:	d12e      	bne.n	45600 <rpc_ip_event_handler+0x428>
   455a2:	682b      	ldr	r3, [r5, #0]
   455a4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   455a8:	e7e8      	b.n	4557c <rpc_ip_event_handler+0x3a4>
   455aa:	682b      	ldr	r3, [r5, #0]
   455ac:	b29b      	uxth	r3, r3
   455ae:	2b08      	cmp	r3, #8
   455b0:	d126      	bne.n	45600 <rpc_ip_event_handler+0x428>
   455b2:	6963      	ldr	r3, [r4, #20]
   455b4:	2b00      	cmp	r3, #0
   455b6:	d16d      	bne.n	45694 <rpc_ip_event_handler+0x4bc>
   455b8:	4b3b      	ldr	r3, [pc, #236]	; (456a8 <rpc_ip_event_handler+0x4d0>)
   455ba:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   455be:	682b      	ldr	r3, [r5, #0]
   455c0:	0c1b      	lsrs	r3, r3, #16
   455c2:	041b      	lsls	r3, r3, #16
   455c4:	f043 0309 	orr.w	r3, r3, #9
   455c8:	602b      	str	r3, [r5, #0]
   455ca:	e032      	b.n	45632 <rpc_ip_event_handler+0x45a>
   455cc:	2b04      	cmp	r3, #4
   455ce:	d114      	bne.n	455fa <rpc_ip_event_handler+0x422>
   455d0:	2010      	movs	r0, #16
   455d2:	f7fe fb41 	bl	43c58 <nrf_modem_os_alloc>
   455d6:	2800      	cmp	r0, #0
   455d8:	f43f af54 	beq.w	45484 <rpc_ip_event_handler+0x2ac>
   455dc:	2302      	movs	r3, #2
   455de:	6043      	str	r3, [r0, #4]
   455e0:	2310      	movs	r3, #16
   455e2:	7003      	strb	r3, [r0, #0]
   455e4:	7c22      	ldrb	r2, [r4, #16]
   455e6:	7c61      	ldrb	r1, [r4, #17]
   455e8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   455ec:	8102      	strh	r2, [r0, #8]
   455ee:	6962      	ldr	r2, [r4, #20]
   455f0:	60c2      	str	r2, [r0, #12]
   455f2:	e739      	b.n	45468 <rpc_ip_event_handler+0x290>
   455f4:	2300      	movs	r3, #0
   455f6:	4618      	mov	r0, r3
   455f8:	e736      	b.n	45468 <rpc_ip_event_handler+0x290>
   455fa:	6820      	ldr	r0, [r4, #0]
   455fc:	f003 f83c 	bl	48678 <rpc_client_data_free>
   45600:	2000      	movs	r0, #0
   45602:	b009      	add	sp, #36	; 0x24
   45604:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45608:	4b27      	ldr	r3, [pc, #156]	; (456a8 <rpc_ip_event_handler+0x4d0>)
   4560a:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4560e:	6963      	ldr	r3, [r4, #20]
   45610:	b17b      	cbz	r3, 45632 <rpc_ip_event_handler+0x45a>
   45612:	2b6b      	cmp	r3, #107	; 0x6b
   45614:	d10f      	bne.n	45636 <rpc_ip_event_handler+0x45e>
   45616:	6928      	ldr	r0, [r5, #16]
   45618:	220c      	movs	r2, #12
   4561a:	2801      	cmp	r0, #1
   4561c:	682b      	ldr	r3, [r5, #0]
   4561e:	d104      	bne.n	4562a <rpc_ip_event_handler+0x452>
   45620:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   45624:	602b      	str	r3, [r5, #0]
   45626:	606a      	str	r2, [r5, #4]
   45628:	e7eb      	b.n	45602 <rpc_ip_event_handler+0x42a>
   4562a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   4562e:	602b      	str	r3, [r5, #0]
   45630:	606a      	str	r2, [r5, #4]
   45632:	2001      	movs	r0, #1
   45634:	e7e5      	b.n	45602 <rpc_ip_event_handler+0x42a>
   45636:	f023 0002 	bic.w	r0, r3, #2
   4563a:	2801      	cmp	r0, #1
   4563c:	d102      	bne.n	45644 <rpc_ip_event_handler+0x46c>
   4563e:	230c      	movs	r3, #12
   45640:	606b      	str	r3, [r5, #4]
   45642:	e7de      	b.n	45602 <rpc_ip_event_handler+0x42a>
   45644:	2b6a      	cmp	r3, #106	; 0x6a
   45646:	bf8e      	itee	hi
   45648:	235f      	movhi	r3, #95	; 0x5f
   4564a:	4a16      	ldrls	r2, [pc, #88]	; (456a4 <rpc_ip_event_handler+0x4cc>)
   4564c:	5cd3      	ldrbls	r3, [r2, r3]
   4564e:	606b      	str	r3, [r5, #4]
   45650:	682b      	ldr	r3, [r5, #0]
   45652:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45656:	e7b7      	b.n	455c8 <rpc_ip_event_handler+0x3f0>
   45658:	682b      	ldr	r3, [r5, #0]
   4565a:	025a      	lsls	r2, r3, #9
   4565c:	d5d0      	bpl.n	45600 <rpc_ip_event_handler+0x428>
   4565e:	6960      	ldr	r0, [r4, #20]
   45660:	b918      	cbnz	r0, 4566a <rpc_ip_event_handler+0x492>
   45662:	682b      	ldr	r3, [r5, #0]
   45664:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   45668:	e729      	b.n	454be <rpc_ip_event_handler+0x2e6>
   4566a:	286a      	cmp	r0, #106	; 0x6a
   4566c:	d817      	bhi.n	4569e <rpc_ip_event_handler+0x4c6>
   4566e:	4b0d      	ldr	r3, [pc, #52]	; (456a4 <rpc_ip_event_handler+0x4cc>)
   45670:	5c1b      	ldrb	r3, [r3, r0]
   45672:	606b      	str	r3, [r5, #4]
   45674:	e7c4      	b.n	45600 <rpc_ip_event_handler+0x428>
   45676:	682b      	ldr	r3, [r5, #0]
   45678:	01db      	lsls	r3, r3, #7
   4567a:	d5c1      	bpl.n	45600 <rpc_ip_event_handler+0x428>
   4567c:	6963      	ldr	r3, [r4, #20]
   4567e:	b94b      	cbnz	r3, 45694 <rpc_ip_event_handler+0x4bc>
   45680:	6820      	ldr	r0, [r4, #0]
   45682:	b118      	cbz	r0, 4568c <rpc_ip_event_handler+0x4b4>
   45684:	2001      	movs	r0, #1
   45686:	4b08      	ldr	r3, [pc, #32]	; (456a8 <rpc_ip_event_handler+0x4d0>)
   45688:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4568c:	682b      	ldr	r3, [r5, #0]
   4568e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   45692:	e714      	b.n	454be <rpc_ip_event_handler+0x2e6>
   45694:	2b6a      	cmp	r3, #106	; 0x6a
   45696:	d802      	bhi.n	4569e <rpc_ip_event_handler+0x4c6>
   45698:	4a02      	ldr	r2, [pc, #8]	; (456a4 <rpc_ip_event_handler+0x4cc>)
   4569a:	5cd3      	ldrb	r3, [r2, r3]
   4569c:	e7e9      	b.n	45672 <rpc_ip_event_handler+0x49a>
   4569e:	235f      	movs	r3, #95	; 0x5f
   456a0:	e7e7      	b.n	45672 <rpc_ip_event_handler+0x49a>
   456a2:	bf00      	nop
   456a4:	00049ac1 	.word	0x00049ac1
   456a8:	2001acc0 	.word	0x2001acc0

000456ac <hostname_free>:
   456ac:	b538      	push	{r3, r4, r5, lr}
   456ae:	4c07      	ldr	r4, [pc, #28]	; (456cc <hostname_free+0x20>)
   456b0:	4605      	mov	r5, r0
   456b2:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   456b6:	b138      	cbz	r0, 456c8 <hostname_free+0x1c>
   456b8:	f7fe fad6 	bl	43c68 <nrf_modem_os_free>
   456bc:	2300      	movs	r3, #0
   456be:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   456c2:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   456c6:	6063      	str	r3, [r4, #4]
   456c8:	bd38      	pop	{r3, r4, r5, pc}
   456ca:	bf00      	nop
   456cc:	2001ace4 	.word	0x2001ace4

000456d0 <secure_socket_attach_initiate>:
   456d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   456d4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   456d8:	f8df 8094 	ldr.w	r8, [pc, #148]	; 45770 <secure_socket_attach_initiate+0xa0>
   456dc:	9301      	str	r3, [sp, #4]
   456de:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   456e2:	460d      	mov	r5, r1
   456e4:	4616      	mov	r6, r2
   456e6:	f8d9 3004 	ldr.w	r3, [r9, #4]
   456ea:	f247 0281 	movw	r2, #28801	; 0x7081
   456ee:	6989      	ldr	r1, [r1, #24]
   456f0:	4607      	mov	r7, r0
   456f2:	f002 ffc3 	bl	4867c <ip_interface_request_create>
   456f6:	4604      	mov	r4, r0
   456f8:	b398      	cbz	r0, 45762 <secure_socket_attach_initiate+0x92>
   456fa:	f8d9 2004 	ldr.w	r2, [r9, #4]
   456fe:	b122      	cbz	r2, 4570a <secure_socket_attach_initiate+0x3a>
   45700:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   45704:	6800      	ldr	r0, [r0, #0]
   45706:	f002 fd95 	bl	48234 <memcpy>
   4570a:	2324      	movs	r3, #36	; 0x24
   4570c:	4a17      	ldr	r2, [pc, #92]	; (4576c <secure_socket_attach_initiate+0x9c>)
   4570e:	fb03 2307 	mla	r3, r3, r7, r2
   45712:	f104 0214 	add.w	r2, r4, #20
   45716:	f103 0124 	add.w	r1, r3, #36	; 0x24
   4571a:	f853 0b04 	ldr.w	r0, [r3], #4
   4571e:	428b      	cmp	r3, r1
   45720:	f842 0b04 	str.w	r0, [r2], #4
   45724:	d1f9      	bne.n	4571a <secure_socket_attach_initiate+0x4a>
   45726:	68a3      	ldr	r3, [r4, #8]
   45728:	4622      	mov	r2, r4
   4572a:	3324      	adds	r3, #36	; 0x24
   4572c:	60a3      	str	r3, [r4, #8]
   4572e:	682b      	ldr	r3, [r5, #0]
   45730:	f247 0181 	movw	r1, #28801	; 0x7081
   45734:	0c1b      	lsrs	r3, r3, #16
   45736:	041b      	lsls	r3, r3, #16
   45738:	f043 030a 	orr.w	r3, r3, #10
   4573c:	602b      	str	r3, [r5, #0]
   4573e:	2004      	movs	r0, #4
   45740:	f002 ff93 	bl	4866a <rpc_client_request_send>
   45744:	682b      	ldr	r3, [r5, #0]
   45746:	00db      	lsls	r3, r3, #3
   45748:	d40d      	bmi.n	45766 <secure_socket_attach_initiate+0x96>
   4574a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   4574e:	210b      	movs	r1, #11
   45750:	4638      	mov	r0, r7
   45752:	ab01      	add	r3, sp, #4
   45754:	f002 ffa5 	bl	486a2 <ip_interface_wait>
   45758:	b100      	cbz	r0, 4575c <secure_socket_attach_initiate+0x8c>
   4575a:	602e      	str	r6, [r5, #0]
   4575c:	b003      	add	sp, #12
   4575e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   45762:	200c      	movs	r0, #12
   45764:	e7fa      	b.n	4575c <secure_socket_attach_initiate+0x8c>
   45766:	2077      	movs	r0, #119	; 0x77
   45768:	e7f8      	b.n	4575c <secure_socket_attach_initiate+0x8c>
   4576a:	bf00      	nop
   4576c:	2001ea83 	.word	0x2001ea83
   45770:	2001ace4 	.word	0x2001ace4

00045774 <tls_interface_init>:
   45774:	2201      	movs	r2, #1
   45776:	4b02      	ldr	r3, [pc, #8]	; (45780 <tls_interface_init+0xc>)
   45778:	2000      	movs	r0, #0
   4577a:	701a      	strb	r2, [r3, #0]
   4577c:	4770      	bx	lr
   4577e:	bf00      	nop
   45780:	2001ea82 	.word	0x2001ea82

00045784 <tls_rpc_ip_event_handler>:
   45784:	b570      	push	{r4, r5, r6, lr}
   45786:	460c      	mov	r4, r1
   45788:	f248 0181 	movw	r1, #32897	; 0x8081
   4578c:	428b      	cmp	r3, r1
   4578e:	4606      	mov	r6, r0
   45790:	d035      	beq.n	457fe <tls_rpc_ip_event_handler+0x7a>
   45792:	f249 0182 	movw	r1, #36994	; 0x9082
   45796:	428b      	cmp	r3, r1
   45798:	d040      	beq.n	4581c <tls_rpc_ip_event_handler+0x98>
   4579a:	f248 0102 	movw	r1, #32770	; 0x8002
   4579e:	428b      	cmp	r3, r1
   457a0:	d161      	bne.n	45866 <tls_rpc_ip_event_handler+0xe2>
   457a2:	2c00      	cmp	r4, #0
   457a4:	d05f      	beq.n	45866 <tls_rpc_ip_event_handler+0xe2>
   457a6:	6963      	ldr	r3, [r4, #20]
   457a8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   457ac:	d002      	beq.n	457b4 <tls_rpc_ip_event_handler+0x30>
   457ae:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   457b2:	d158      	bne.n	45866 <tls_rpc_ip_event_handler+0xe2>
   457b4:	6823      	ldr	r3, [r4, #0]
   457b6:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   457ba:	6023      	str	r3, [r4, #0]
   457bc:	6955      	ldr	r5, [r2, #20]
   457be:	2d00      	cmp	r5, #0
   457c0:	d14d      	bne.n	4585e <tls_rpc_ip_event_handler+0xda>
   457c2:	6823      	ldr	r3, [r4, #0]
   457c4:	0c1b      	lsrs	r3, r3, #16
   457c6:	041b      	lsls	r3, r3, #16
   457c8:	f043 0305 	orr.w	r3, r3, #5
   457cc:	6023      	str	r3, [r4, #0]
   457ce:	6823      	ldr	r3, [r4, #0]
   457d0:	00db      	lsls	r3, r3, #3
   457d2:	d401      	bmi.n	457d8 <tls_rpc_ip_event_handler+0x54>
   457d4:	2000      	movs	r0, #0
   457d6:	e020      	b.n	4581a <tls_rpc_ip_event_handler+0x96>
   457d8:	2324      	movs	r3, #36	; 0x24
   457da:	4373      	muls	r3, r6
   457dc:	4a23      	ldr	r2, [pc, #140]	; (4586c <tls_rpc_ip_event_handler+0xe8>)
   457de:	5cd3      	ldrb	r3, [r2, r3]
   457e0:	2b02      	cmp	r3, #2
   457e2:	d1f7      	bne.n	457d4 <tls_rpc_ip_event_handler+0x50>
   457e4:	4621      	mov	r1, r4
   457e6:	4630      	mov	r0, r6
   457e8:	f002 ff6b 	bl	486c2 <secure_client_socket>
   457ec:	2800      	cmp	r0, #0
   457ee:	d0f1      	beq.n	457d4 <tls_rpc_ip_event_handler+0x50>
   457f0:	2877      	cmp	r0, #119	; 0x77
   457f2:	d0ef      	beq.n	457d4 <tls_rpc_ip_event_handler+0x50>
   457f4:	6060      	str	r0, [r4, #4]
   457f6:	6823      	ldr	r3, [r4, #0]
   457f8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   457fc:	e02d      	b.n	4585a <tls_rpc_ip_event_handler+0xd6>
   457fe:	2c00      	cmp	r4, #0
   45800:	d0e8      	beq.n	457d4 <tls_rpc_ip_event_handler+0x50>
   45802:	6823      	ldr	r3, [r4, #0]
   45804:	b29b      	uxth	r3, r3
   45806:	2b0a      	cmp	r3, #10
   45808:	d1e4      	bne.n	457d4 <tls_rpc_ip_event_handler+0x50>
   4580a:	6950      	ldr	r0, [r2, #20]
   4580c:	bb40      	cbnz	r0, 45860 <tls_rpc_ip_event_handler+0xdc>
   4580e:	6823      	ldr	r3, [r4, #0]
   45810:	0c1b      	lsrs	r3, r3, #16
   45812:	041b      	lsls	r3, r3, #16
   45814:	f043 030b 	orr.w	r3, r3, #11
   45818:	6023      	str	r3, [r4, #0]
   4581a:	bd70      	pop	{r4, r5, r6, pc}
   4581c:	2c00      	cmp	r4, #0
   4581e:	d0d9      	beq.n	457d4 <tls_rpc_ip_event_handler+0x50>
   45820:	6823      	ldr	r3, [r4, #0]
   45822:	b29b      	uxth	r3, r3
   45824:	2b0b      	cmp	r3, #11
   45826:	d1d5      	bne.n	457d4 <tls_rpc_ip_event_handler+0x50>
   45828:	6915      	ldr	r5, [r2, #16]
   4582a:	b9c5      	cbnz	r5, 4585e <tls_rpc_ip_event_handler+0xda>
   4582c:	6823      	ldr	r3, [r4, #0]
   4582e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   45832:	6023      	str	r3, [r4, #0]
   45834:	f7ff ff3a 	bl	456ac <hostname_free>
   45838:	6823      	ldr	r3, [r4, #0]
   4583a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   4583e:	6023      	str	r3, [r4, #0]
   45840:	6823      	ldr	r3, [r4, #0]
   45842:	0c1b      	lsrs	r3, r3, #16
   45844:	041b      	lsls	r3, r3, #16
   45846:	f043 030c 	orr.w	r3, r3, #12
   4584a:	6023      	str	r3, [r4, #0]
   4584c:	6823      	ldr	r3, [r4, #0]
   4584e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   45852:	6023      	str	r3, [r4, #0]
   45854:	6823      	ldr	r3, [r4, #0]
   45856:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   4585a:	6023      	str	r3, [r4, #0]
   4585c:	e7ba      	b.n	457d4 <tls_rpc_ip_event_handler+0x50>
   4585e:	4628      	mov	r0, r5
   45860:	f7ff fc7a 	bl	45158 <rpc_error_to_nrf_errno>
   45864:	e7c6      	b.n	457f4 <tls_rpc_ip_event_handler+0x70>
   45866:	2001      	movs	r0, #1
   45868:	e7d7      	b.n	4581a <tls_rpc_ip_event_handler+0x96>
   4586a:	bf00      	nop
   4586c:	2001ea83 	.word	0x2001ea83

00045870 <at_cmd_send>:
   45870:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45872:	4615      	mov	r5, r2
   45874:	f06f 0258 	mvn.w	r2, #88	; 0x58
   45878:	2300      	movs	r3, #0
   4587a:	7302      	strb	r2, [r0, #12]
   4587c:	2204      	movs	r2, #4
   4587e:	4c0d      	ldr	r4, [pc, #52]	; (458b4 <at_cmd_send+0x44>)
   45880:	7343      	strb	r3, [r0, #13]
   45882:	7383      	strb	r3, [r0, #14]
   45884:	73c3      	strb	r3, [r0, #15]
   45886:	7202      	strb	r2, [r0, #8]
   45888:	7243      	strb	r3, [r0, #9]
   4588a:	7283      	strb	r3, [r0, #10]
   4588c:	72c3      	strb	r3, [r0, #11]
   4588e:	4602      	mov	r2, r0
   45890:	b289      	uxth	r1, r1
   45892:	2003      	movs	r0, #3
   45894:	7023      	strb	r3, [r4, #0]
   45896:	f002 fee8 	bl	4866a <rpc_client_request_send>
   4589a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4589e:	9301      	str	r3, [sp, #4]
   458a0:	7823      	ldrb	r3, [r4, #0]
   458a2:	42ab      	cmp	r3, r5
   458a4:	d101      	bne.n	458aa <at_cmd_send+0x3a>
   458a6:	b003      	add	sp, #12
   458a8:	bd30      	pop	{r4, r5, pc}
   458aa:	a901      	add	r1, sp, #4
   458ac:	2000      	movs	r0, #0
   458ae:	f7fe f8fb 	bl	43aa8 <nrf_modem_os_timedwait>
   458b2:	e7f5      	b.n	458a0 <at_cmd_send+0x30>
   458b4:	2001eba3 	.word	0x2001eba3

000458b8 <nrf_modem_at_init>:
   458b8:	2201      	movs	r2, #1
   458ba:	b508      	push	{r3, lr}
   458bc:	4611      	mov	r1, r2
   458be:	4808      	ldr	r0, [pc, #32]	; (458e0 <nrf_modem_at_init+0x28>)
   458c0:	f7fe f990 	bl	43be4 <nrf_modem_os_sem_init>
   458c4:	2000      	movs	r0, #0
   458c6:	f002 feca 	bl	4865e <rpc_client_request_alloc>
   458ca:	b128      	cbz	r0, 458d8 <nrf_modem_at_init+0x20>
   458cc:	2201      	movs	r2, #1
   458ce:	2105      	movs	r1, #5
   458d0:	f7ff ffce 	bl	45870 <at_cmd_send>
   458d4:	2000      	movs	r0, #0
   458d6:	bd08      	pop	{r3, pc}
   458d8:	f06f 000b 	mvn.w	r0, #11
   458dc:	e7fb      	b.n	458d6 <nrf_modem_at_init+0x1e>
   458de:	bf00      	nop
   458e0:	2001ad24 	.word	0x2001ad24

000458e4 <rpc_at_event_handler>:
   458e4:	b570      	push	{r4, r5, r6, lr}
   458e6:	68c3      	ldr	r3, [r0, #12]
   458e8:	4605      	mov	r5, r0
   458ea:	2ba7      	cmp	r3, #167	; 0xa7
   458ec:	d003      	beq.n	458f6 <rpc_at_event_handler+0x12>
   458ee:	6828      	ldr	r0, [r5, #0]
   458f0:	f002 fec2 	bl	48678 <rpc_client_data_free>
   458f4:	e008      	b.n	45908 <rpc_at_event_handler+0x24>
   458f6:	2903      	cmp	r1, #3
   458f8:	d008      	beq.n	4590c <rpc_at_event_handler+0x28>
   458fa:	2904      	cmp	r1, #4
   458fc:	d019      	beq.n	45932 <rpc_at_event_handler+0x4e>
   458fe:	2902      	cmp	r1, #2
   45900:	d102      	bne.n	45908 <rpc_at_event_handler+0x24>
   45902:	2201      	movs	r2, #1
   45904:	4b0e      	ldr	r3, [pc, #56]	; (45940 <rpc_at_event_handler+0x5c>)
   45906:	701a      	strb	r2, [r3, #0]
   45908:	2000      	movs	r0, #0
   4590a:	e00a      	b.n	45922 <rpc_at_event_handler+0x3e>
   4590c:	4e0d      	ldr	r6, [pc, #52]	; (45944 <rpc_at_event_handler+0x60>)
   4590e:	6833      	ldr	r3, [r6, #0]
   45910:	b143      	cbz	r3, 45924 <rpc_at_event_handler+0x40>
   45912:	2400      	movs	r4, #0
   45914:	6800      	ldr	r0, [r0, #0]
   45916:	4798      	blx	r3
   45918:	6828      	ldr	r0, [r5, #0]
   4591a:	6034      	str	r4, [r6, #0]
   4591c:	f002 feac 	bl	48678 <rpc_client_data_free>
   45920:	b2e0      	uxtb	r0, r4
   45922:	bd70      	pop	{r4, r5, r6, pc}
   45924:	2202      	movs	r2, #2
   45926:	4b08      	ldr	r3, [pc, #32]	; (45948 <rpc_at_event_handler+0x64>)
   45928:	2401      	movs	r4, #1
   4592a:	6018      	str	r0, [r3, #0]
   4592c:	4b04      	ldr	r3, [pc, #16]	; (45940 <rpc_at_event_handler+0x5c>)
   4592e:	701a      	strb	r2, [r3, #0]
   45930:	e7f6      	b.n	45920 <rpc_at_event_handler+0x3c>
   45932:	4b06      	ldr	r3, [pc, #24]	; (4594c <rpc_at_event_handler+0x68>)
   45934:	681b      	ldr	r3, [r3, #0]
   45936:	2b00      	cmp	r3, #0
   45938:	d0d9      	beq.n	458ee <rpc_at_event_handler+0xa>
   4593a:	6800      	ldr	r0, [r0, #0]
   4593c:	4798      	blx	r3
   4593e:	e7d6      	b.n	458ee <rpc_at_event_handler+0xa>
   45940:	2001eba3 	.word	0x2001eba3
   45944:	2001ad30 	.word	0x2001ad30
   45948:	2001ad2c 	.word	0x2001ad2c
   4594c:	2001ad28 	.word	0x2001ad28

00045950 <rpc_dfu_event_handler>:
   45950:	b510      	push	{r4, lr}
   45952:	4604      	mov	r4, r0
   45954:	6800      	ldr	r0, [r0, #0]
   45956:	b108      	cbz	r0, 4595c <rpc_dfu_event_handler+0xc>
   45958:	f002 fe8e 	bl	48678 <rpc_client_data_free>
   4595c:	4b05      	ldr	r3, [pc, #20]	; (45974 <rpc_dfu_event_handler+0x24>)
   4595e:	68e2      	ldr	r2, [r4, #12]
   45960:	429a      	cmp	r2, r3
   45962:	bf05      	ittet	eq
   45964:	2001      	moveq	r0, #1
   45966:	4b04      	ldreq	r3, [pc, #16]	; (45978 <rpc_dfu_event_handler+0x28>)
   45968:	2000      	movne	r0, #0
   4596a:	7018      	strbeq	r0, [r3, #0]
   4596c:	bf04      	itt	eq
   4596e:	4b03      	ldreq	r3, [pc, #12]	; (4597c <rpc_dfu_event_handler+0x2c>)
   45970:	601c      	streq	r4, [r3, #0]
   45972:	bd10      	pop	{r4, pc}
   45974:	15abe11a 	.word	0x15abe11a
   45978:	2001eba4 	.word	0x2001eba4
   4597c:	2001ad34 	.word	0x2001ad34

00045980 <rpc_gnss_event_handler>:
   45980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45984:	6804      	ldr	r4, [r0, #0]
   45986:	4607      	mov	r7, r0
   45988:	460d      	mov	r5, r1
   4598a:	2c00      	cmp	r4, #0
   4598c:	f000 8086 	beq.w	45a9c <rpc_gnss_event_handler+0x11c>
   45990:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   45994:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   45998:	d142      	bne.n	45a20 <rpc_gnss_event_handler+0xa0>
   4599a:	4b5f      	ldr	r3, [pc, #380]	; (45b18 <rpc_gnss_event_handler+0x198>)
   4599c:	781a      	ldrb	r2, [r3, #0]
   4599e:	4698      	mov	r8, r3
   459a0:	2a01      	cmp	r2, #1
   459a2:	d131      	bne.n	45a08 <rpc_gnss_event_handler+0x88>
   459a4:	4a5d      	ldr	r2, [pc, #372]	; (45b1c <rpc_gnss_event_handler+0x19c>)
   459a6:	6821      	ldr	r1, [r4, #0]
   459a8:	8812      	ldrh	r2, [r2, #0]
   459aa:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   459ae:	d12b      	bne.n	45a08 <rpc_gnss_event_handler+0x88>
   459b0:	6862      	ldr	r2, [r4, #4]
   459b2:	bb6a      	cbnz	r2, 45a10 <rpc_gnss_event_handler+0x90>
   459b4:	4b5a      	ldr	r3, [pc, #360]	; (45b20 <rpc_gnss_event_handler+0x1a0>)
   459b6:	681e      	ldr	r6, [r3, #0]
   459b8:	b31e      	cbz	r6, 45a02 <rpc_gnss_event_handler+0x82>
   459ba:	f242 0309 	movw	r3, #8201	; 0x2009
   459be:	429d      	cmp	r5, r3
   459c0:	d11f      	bne.n	45a02 <rpc_gnss_event_handler+0x82>
   459c2:	4630      	mov	r0, r6
   459c4:	8923      	ldrh	r3, [r4, #8]
   459c6:	2280      	movs	r2, #128	; 0x80
   459c8:	f840 3b04 	str.w	r3, [r0], #4
   459cc:	f104 010a 	add.w	r1, r4, #10
   459d0:	f002 fc30 	bl	48234 <memcpy>
   459d4:	2280      	movs	r2, #128	; 0x80
   459d6:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   459da:	f106 0084 	add.w	r0, r6, #132	; 0x84
   459de:	f002 fc29 	bl	48234 <memcpy>
   459e2:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   459e6:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   459ea:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   459ee:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   459f2:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   459f6:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   459fa:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   459fe:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   45a02:	2300      	movs	r3, #0
   45a04:	f888 3000 	strb.w	r3, [r8]
   45a08:	6838      	ldr	r0, [r7, #0]
   45a0a:	f002 fe35 	bl	48678 <rpc_client_data_free>
   45a0e:	e045      	b.n	45a9c <rpc_gnss_event_handler+0x11c>
   45a10:	f647 71ff 	movw	r1, #32767	; 0x7fff
   45a14:	428a      	cmp	r2, r1
   45a16:	bf0c      	ite	eq
   45a18:	2203      	moveq	r2, #3
   45a1a:	2202      	movne	r2, #2
   45a1c:	701a      	strb	r2, [r3, #0]
   45a1e:	e7f3      	b.n	45a08 <rpc_gnss_event_handler+0x88>
   45a20:	4e40      	ldr	r6, [pc, #256]	; (45b24 <rpc_gnss_event_handler+0x1a4>)
   45a22:	6833      	ldr	r3, [r6, #0]
   45a24:	2b00      	cmp	r3, #0
   45a26:	d0ef      	beq.n	45a08 <rpc_gnss_event_handler+0x88>
   45a28:	f244 0204 	movw	r2, #16388	; 0x4004
   45a2c:	4291      	cmp	r1, r2
   45a2e:	d80b      	bhi.n	45a48 <rpc_gnss_event_handler+0xc8>
   45a30:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   45a34:	d9e8      	bls.n	45a08 <rpc_gnss_event_handler+0x88>
   45a36:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   45a3a:	3a02      	subs	r2, #2
   45a3c:	2a02      	cmp	r2, #2
   45a3e:	d80b      	bhi.n	45a58 <rpc_gnss_event_handler+0xd8>
   45a40:	e8df f002 	tbb	[pc, r2]
   45a44:	4f45      	.short	0x4f45
   45a46:	59          	.byte	0x59
   45a47:	00          	.byte	0x00
   45a48:	f244 1301 	movw	r3, #16641	; 0x4101
   45a4c:	4299      	cmp	r1, r3
   45a4e:	d003      	beq.n	45a58 <rpc_gnss_event_handler+0xd8>
   45a50:	f244 2301 	movw	r3, #16897	; 0x4201
   45a54:	4299      	cmp	r1, r3
   45a56:	d1d7      	bne.n	45a08 <rpc_gnss_event_handler+0x88>
   45a58:	4f33      	ldr	r7, [pc, #204]	; (45b28 <rpc_gnss_event_handler+0x1a8>)
   45a5a:	6838      	ldr	r0, [r7, #0]
   45a5c:	b108      	cbz	r0, 45a62 <rpc_gnss_event_handler+0xe2>
   45a5e:	f002 fe0b 	bl	48678 <rpc_client_data_free>
   45a62:	f244 2301 	movw	r3, #16897	; 0x4201
   45a66:	429d      	cmp	r5, r3
   45a68:	4b30      	ldr	r3, [pc, #192]	; (45b2c <rpc_gnss_event_handler+0x1ac>)
   45a6a:	d11a      	bne.n	45aa2 <rpc_gnss_event_handler+0x122>
   45a6c:	2202      	movs	r2, #2
   45a6e:	603c      	str	r4, [r7, #0]
   45a70:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   45a74:	701a      	strb	r2, [r3, #0]
   45a76:	07e3      	lsls	r3, r4, #31
   45a78:	d502      	bpl.n	45a80 <rpc_gnss_event_handler+0x100>
   45a7a:	2002      	movs	r0, #2
   45a7c:	6833      	ldr	r3, [r6, #0]
   45a7e:	4798      	blx	r3
   45a80:	4d2b      	ldr	r5, [pc, #172]	; (45b30 <rpc_gnss_event_handler+0x1b0>)
   45a82:	f014 0418 	ands.w	r4, r4, #24
   45a86:	6833      	ldr	r3, [r6, #0]
   45a88:	782a      	ldrb	r2, [r5, #0]
   45a8a:	d01a      	beq.n	45ac2 <rpc_gnss_event_handler+0x142>
   45a8c:	b91a      	cbnz	r2, 45a96 <rpc_gnss_event_handler+0x116>
   45a8e:	2005      	movs	r0, #5
   45a90:	4798      	blx	r3
   45a92:	2301      	movs	r3, #1
   45a94:	702b      	strb	r3, [r5, #0]
   45a96:	2001      	movs	r0, #1
   45a98:	6833      	ldr	r3, [r6, #0]
   45a9a:	4798      	blx	r3
   45a9c:	2000      	movs	r0, #0
   45a9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45aa2:	f244 1201 	movw	r2, #16641	; 0x4101
   45aa6:	4295      	cmp	r5, r2
   45aa8:	bf0b      	itete	eq
   45aaa:	2201      	moveq	r2, #1
   45aac:	2200      	movne	r2, #0
   45aae:	603c      	streq	r4, [r7, #0]
   45ab0:	603c      	strne	r4, [r7, #0]
   45ab2:	bf0b      	itete	eq
   45ab4:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   45ab8:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   45abc:	701a      	strbeq	r2, [r3, #0]
   45abe:	701a      	strbne	r2, [r3, #0]
   45ac0:	e7d9      	b.n	45a76 <rpc_gnss_event_handler+0xf6>
   45ac2:	2a00      	cmp	r2, #0
   45ac4:	d0e7      	beq.n	45a96 <rpc_gnss_event_handler+0x116>
   45ac6:	2006      	movs	r0, #6
   45ac8:	4798      	blx	r3
   45aca:	702c      	strb	r4, [r5, #0]
   45acc:	e7e3      	b.n	45a96 <rpc_gnss_event_handler+0x116>
   45ace:	4c19      	ldr	r4, [pc, #100]	; (45b34 <rpc_gnss_event_handler+0x1b4>)
   45ad0:	6820      	ldr	r0, [r4, #0]
   45ad2:	b108      	cbz	r0, 45ad8 <rpc_gnss_event_handler+0x158>
   45ad4:	f002 fdd0 	bl	48678 <rpc_client_data_free>
   45ad8:	683b      	ldr	r3, [r7, #0]
   45ada:	2003      	movs	r0, #3
   45adc:	6023      	str	r3, [r4, #0]
   45ade:	6833      	ldr	r3, [r6, #0]
   45ae0:	e7db      	b.n	45a9a <rpc_gnss_event_handler+0x11a>
   45ae2:	4c15      	ldr	r4, [pc, #84]	; (45b38 <rpc_gnss_event_handler+0x1b8>)
   45ae4:	6820      	ldr	r0, [r4, #0]
   45ae6:	b108      	cbz	r0, 45aec <rpc_gnss_event_handler+0x16c>
   45ae8:	f002 fdc6 	bl	48678 <rpc_client_data_free>
   45aec:	683b      	ldr	r3, [r7, #0]
   45aee:	2004      	movs	r0, #4
   45af0:	6023      	str	r3, [r4, #0]
   45af2:	6833      	ldr	r3, [r6, #0]
   45af4:	e7d1      	b.n	45a9a <rpc_gnss_event_handler+0x11a>
   45af6:	7822      	ldrb	r2, [r4, #0]
   45af8:	2a03      	cmp	r2, #3
   45afa:	d885      	bhi.n	45a08 <rpc_gnss_event_handler+0x88>
   45afc:	e8df f002 	tbb	[pc, r2]
   45b00:	09070502 	.word	0x09070502
   45b04:	2007      	movs	r0, #7
   45b06:	4798      	blx	r3
   45b08:	e77e      	b.n	45a08 <rpc_gnss_event_handler+0x88>
   45b0a:	2008      	movs	r0, #8
   45b0c:	e7fb      	b.n	45b06 <rpc_gnss_event_handler+0x186>
   45b0e:	2009      	movs	r0, #9
   45b10:	e7f9      	b.n	45b06 <rpc_gnss_event_handler+0x186>
   45b12:	200a      	movs	r0, #10
   45b14:	e7f7      	b.n	45b06 <rpc_gnss_event_handler+0x186>
   45b16:	bf00      	nop
   45b18:	2001eba7 	.word	0x2001eba7
   45b1c:	2001adb0 	.word	0x2001adb0
   45b20:	2001ad48 	.word	0x2001ad48
   45b24:	2001ad38 	.word	0x2001ad38
   45b28:	2001ad3c 	.word	0x2001ad3c
   45b2c:	2001eba6 	.word	0x2001eba6
   45b30:	2001eba5 	.word	0x2001eba5
   45b34:	2001ad44 	.word	0x2001ad44
   45b38:	2001ad40 	.word	0x2001ad40

00045b3c <full_dfu_ipc_irq_handler>:
   45b3c:	2301      	movs	r3, #1
   45b3e:	4a03      	ldr	r2, [pc, #12]	; (45b4c <full_dfu_ipc_irq_handler+0x10>)
   45b40:	6013      	str	r3, [r2, #0]
   45b42:	07c2      	lsls	r2, r0, #31
   45b44:	bf44      	itt	mi
   45b46:	4a02      	ldrmi	r2, [pc, #8]	; (45b50 <full_dfu_ipc_irq_handler+0x14>)
   45b48:	7013      	strbmi	r3, [r2, #0]
   45b4a:	4770      	bx	lr
   45b4c:	2001ad4c 	.word	0x2001ad4c
   45b50:	2001eba8 	.word	0x2001eba8

00045b54 <modem_ipc_wait_for_event>:
   45b54:	b538      	push	{r3, r4, r5, lr}
   45b56:	2300      	movs	r3, #0
   45b58:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   45b5c:	4c0b      	ldr	r4, [pc, #44]	; (45b8c <modem_ipc_wait_for_event+0x38>)
   45b5e:	6023      	str	r3, [r4, #0]
   45b60:	6823      	ldr	r3, [r4, #0]
   45b62:	b92b      	cbnz	r3, 45b70 <modem_ipc_wait_for_event+0x1c>
   45b64:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   45b68:	f002 fcdc 	bl	48524 <nrf_modem_os_busywait>
   45b6c:	3d01      	subs	r5, #1
   45b6e:	d1f7      	bne.n	45b60 <modem_ipc_wait_for_event+0xc>
   45b70:	6823      	ldr	r3, [r4, #0]
   45b72:	b913      	cbnz	r3, 45b7a <modem_ipc_wait_for_event+0x26>
   45b74:	f06f 0073 	mvn.w	r0, #115	; 0x73
   45b78:	e006      	b.n	45b88 <modem_ipc_wait_for_event+0x34>
   45b7a:	4b05      	ldr	r3, [pc, #20]	; (45b90 <modem_ipc_wait_for_event+0x3c>)
   45b7c:	781b      	ldrb	r3, [r3, #0]
   45b7e:	2b01      	cmp	r3, #1
   45b80:	bf14      	ite	ne
   45b82:	2000      	movne	r0, #0
   45b84:	f06f 0004 	mvneq.w	r0, #4
   45b88:	bd38      	pop	{r3, r4, r5, pc}
   45b8a:	bf00      	nop
   45b8c:	2001ad4c 	.word	0x2001ad4c
   45b90:	2001eba8 	.word	0x2001eba8

00045b94 <nrf_modem_full_dfu_setup>:
   45b94:	2200      	movs	r2, #0
   45b96:	2300      	movs	r3, #0
   45b98:	b5f0      	push	{r4, r5, r6, r7, lr}
   45b9a:	4d2b      	ldr	r5, [pc, #172]	; (45c48 <nrf_modem_full_dfu_setup+0xb4>)
   45b9c:	4e2b      	ldr	r6, [pc, #172]	; (45c4c <nrf_modem_full_dfu_setup+0xb8>)
   45b9e:	e9c5 2302 	strd	r2, r3, [r5, #8]
   45ba2:	e9c5 2304 	strd	r2, r3, [r5, #16]
   45ba6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   45baa:	4b29      	ldr	r3, [pc, #164]	; (45c50 <nrf_modem_full_dfu_setup+0xbc>)
   45bac:	2400      	movs	r4, #0
   45bae:	601a      	str	r2, [r3, #0]
   45bb0:	f100 031c 	add.w	r3, r0, #28
   45bb4:	6033      	str	r3, [r6, #0]
   45bb6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   45bba:	6043      	str	r3, [r0, #4]
   45bbc:	231c      	movs	r3, #28
   45bbe:	7203      	strb	r3, [r0, #8]
   45bc0:	2320      	movs	r3, #32
   45bc2:	2701      	movs	r7, #1
   45bc4:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   45bc8:	7243      	strb	r3, [r0, #9]
   45bca:	4b22      	ldr	r3, [pc, #136]	; (45c54 <nrf_modem_full_dfu_setup+0xc0>)
   45bcc:	7004      	strb	r4, [r0, #0]
   45bce:	7044      	strb	r4, [r0, #1]
   45bd0:	70c2      	strb	r2, [r0, #3]
   45bd2:	7284      	strb	r4, [r0, #10]
   45bd4:	72c4      	strb	r4, [r0, #11]
   45bd6:	7087      	strb	r7, [r0, #2]
   45bd8:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   45bdc:	702c      	strb	r4, [r5, #0]
   45bde:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   45be2:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   45be6:	4b1c      	ldr	r3, [pc, #112]	; (45c58 <nrf_modem_full_dfu_setup+0xc4>)
   45be8:	b093      	sub	sp, #76	; 0x4c
   45bea:	4622      	mov	r2, r4
   45bec:	4620      	mov	r0, r4
   45bee:	491b      	ldr	r1, [pc, #108]	; (45c5c <nrf_modem_full_dfu_setup+0xc8>)
   45bf0:	701c      	strb	r4, [r3, #0]
   45bf2:	f7fe fce5 	bl	445c0 <nrfx_ipc_init>
   45bf6:	4621      	mov	r1, r4
   45bf8:	2240      	movs	r2, #64	; 0x40
   45bfa:	a801      	add	r0, sp, #4
   45bfc:	f002 fb25 	bl	4824a <memset>
   45c00:	2302      	movs	r3, #2
   45c02:	9302      	str	r3, [sp, #8]
   45c04:	2304      	movs	r3, #4
   45c06:	930b      	str	r3, [sp, #44]	; 0x2c
   45c08:	2305      	movs	r3, #5
   45c0a:	a801      	add	r0, sp, #4
   45c0c:	9311      	str	r3, [sp, #68]	; 0x44
   45c0e:	9709      	str	r7, [sp, #36]	; 0x24
   45c10:	f7fe fcee 	bl	445f0 <nrfx_ipc_config_load>
   45c14:	4b12      	ldr	r3, [pc, #72]	; (45c60 <nrf_modem_full_dfu_setup+0xcc>)
   45c16:	9400      	str	r4, [sp, #0]
   45c18:	6836      	ldr	r6, [r6, #0]
   45c1a:	601c      	str	r4, [r3, #0]
   45c1c:	681b      	ldr	r3, [r3, #0]
   45c1e:	9300      	str	r3, [sp, #0]
   45c20:	9b00      	ldr	r3, [sp, #0]
   45c22:	f7ff ff97 	bl	45b54 <modem_ipc_wait_for_event>
   45c26:	4604      	mov	r4, r0
   45c28:	b130      	cbz	r0, 45c38 <nrf_modem_full_dfu_setup+0xa4>
   45c2a:	2303      	movs	r3, #3
   45c2c:	702b      	strb	r3, [r5, #0]
   45c2e:	f7fe fcff 	bl	44630 <nrfx_ipc_uninit>
   45c32:	4620      	mov	r0, r4
   45c34:	b013      	add	sp, #76	; 0x4c
   45c36:	bdf0      	pop	{r4, r5, r6, r7, pc}
   45c38:	6832      	ldr	r2, [r6, #0]
   45c3a:	4b0a      	ldr	r3, [pc, #40]	; (45c64 <nrf_modem_full_dfu_setup+0xd0>)
   45c3c:	429a      	cmp	r2, r3
   45c3e:	d0f8      	beq.n	45c32 <nrf_modem_full_dfu_setup+0x9e>
   45c40:	f06f 0404 	mvn.w	r4, #4
   45c44:	e7f3      	b.n	45c2e <nrf_modem_full_dfu_setup+0x9a>
   45c46:	bf00      	nop
   45c48:	2001a730 	.word	0x2001a730
   45c4c:	2001ad50 	.word	0x2001ad50
   45c50:	2001ad54 	.word	0x2001ad54
   45c54:	4002a000 	.word	0x4002a000
   45c58:	2001eba8 	.word	0x2001eba8
   45c5c:	00045b3d 	.word	0x00045b3d
   45c60:	40005610 	.word	0x40005610
   45c64:	a5000001 	.word	0xa5000001

00045c68 <modem_off>:
   45c68:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45c6a:	2501      	movs	r5, #1
   45c6c:	4c07      	ldr	r4, [pc, #28]	; (45c8c <modem_off+0x24>)
   45c6e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   45c72:	6065      	str	r5, [r4, #4]
   45c74:	f002 fc56 	bl	48524 <nrf_modem_os_busywait>
   45c78:	2300      	movs	r3, #0
   45c7a:	6063      	str	r3, [r4, #4]
   45c7c:	9301      	str	r3, [sp, #4]
   45c7e:	6025      	str	r5, [r4, #0]
   45c80:	6823      	ldr	r3, [r4, #0]
   45c82:	9301      	str	r3, [sp, #4]
   45c84:	9b01      	ldr	r3, [sp, #4]
   45c86:	b003      	add	sp, #12
   45c88:	bd30      	pop	{r4, r5, pc}
   45c8a:	bf00      	nop
   45c8c:	40005610 	.word	0x40005610

00045c90 <nrf_modem_init>:
   45c90:	b570      	push	{r4, r5, r6, lr}
   45c92:	460d      	mov	r5, r1
   45c94:	b300      	cbz	r0, 45cd8 <nrf_modem_init+0x48>
   45c96:	4e15      	ldr	r6, [pc, #84]	; (45cec <nrf_modem_init+0x5c>)
   45c98:	7832      	ldrb	r2, [r6, #0]
   45c9a:	bb02      	cbnz	r2, 45cde <nrf_modem_init+0x4e>
   45c9c:	2901      	cmp	r1, #1
   45c9e:	d113      	bne.n	45cc8 <nrf_modem_init+0x38>
   45ca0:	68c1      	ldr	r1, [r0, #12]
   45ca2:	6842      	ldr	r2, [r0, #4]
   45ca4:	440a      	add	r2, r1
   45ca6:	6941      	ldr	r1, [r0, #20]
   45ca8:	440a      	add	r2, r1
   45caa:	69c1      	ldr	r1, [r0, #28]
   45cac:	440a      	add	r2, r1
   45cae:	f242 011b 	movw	r1, #8219	; 0x201b
   45cb2:	428a      	cmp	r2, r1
   45cb4:	d916      	bls.n	45ce4 <nrf_modem_init+0x54>
   45cb6:	6800      	ldr	r0, [r0, #0]
   45cb8:	f7ff ff6c 	bl	45b94 <nrf_modem_full_dfu_setup>
   45cbc:	4604      	mov	r4, r0
   45cbe:	b130      	cbz	r0, 45cce <nrf_modem_init+0x3e>
   45cc0:	f7ff ffd2 	bl	45c68 <modem_off>
   45cc4:	4620      	mov	r0, r4
   45cc6:	bd70      	pop	{r4, r5, r6, pc}
   45cc8:	f002 fd3a 	bl	48740 <nrf_modem_platform_init>
   45ccc:	e7f6      	b.n	45cbc <nrf_modem_init+0x2c>
   45cce:	4b08      	ldr	r3, [pc, #32]	; (45cf0 <nrf_modem_init+0x60>)
   45cd0:	701d      	strb	r5, [r3, #0]
   45cd2:	2301      	movs	r3, #1
   45cd4:	7033      	strb	r3, [r6, #0]
   45cd6:	e7f5      	b.n	45cc4 <nrf_modem_init+0x34>
   45cd8:	f06f 040d 	mvn.w	r4, #13
   45cdc:	e7f2      	b.n	45cc4 <nrf_modem_init+0x34>
   45cde:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   45ce2:	e7ef      	b.n	45cc4 <nrf_modem_init+0x34>
   45ce4:	f06f 040b 	mvn.w	r4, #11
   45ce8:	e7ec      	b.n	45cc4 <nrf_modem_init+0x34>
   45cea:	bf00      	nop
   45cec:	2001eba9 	.word	0x2001eba9
   45cf0:	2001ebaa 	.word	0x2001ebaa

00045cf4 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
   45cf4:	4b02      	ldr	r3, [pc, #8]	; (45d00 <mbedtls_platform_set_calloc_free+0xc>)
   45cf6:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
   45cf8:	4b02      	ldr	r3, [pc, #8]	; (45d04 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
   45cfa:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
   45cfc:	6019      	str	r1, [r3, #0]
}
   45cfe:	4770      	bx	lr
   45d00:	2001a584 	.word	0x2001a584
   45d04:	2001a588 	.word	0x2001a588

00045d08 <_heap_init>:
 *
 * Not static in order to allow extern use.
 */
void _heap_init(void)
{
	mbedtls_memory_buffer_alloc_init(mbedtls_heap, sizeof(mbedtls_heap));
   45d08:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   45d0c:	4801      	ldr	r0, [pc, #4]	; (45d14 <_heap_init+0xc>)
   45d0e:	f000 b947 	b.w	45fa0 <mbedtls_memory_buffer_alloc_init>
   45d12:	bf00      	nop
   45d14:	2001ebab 	.word	0x2001ebab

00045d18 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
   45d18:	6801      	ldr	r1, [r0, #0]
   45d1a:	4a0e      	ldr	r2, [pc, #56]	; (45d54 <verify_header+0x3c>)
{
   45d1c:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
   45d1e:	4291      	cmp	r1, r2
   45d20:	d115      	bne.n	45d4e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
   45d22:	69c1      	ldr	r1, [r0, #28]
   45d24:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
   45d28:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
   45d2c:	4291      	cmp	r1, r2
   45d2e:	d10e      	bne.n	45d4e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
   45d30:	6882      	ldr	r2, [r0, #8]
   45d32:	2a01      	cmp	r2, #1
   45d34:	d80b      	bhi.n	45d4e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
   45d36:	68c2      	ldr	r2, [r0, #12]
   45d38:	b112      	cbz	r2, 45d40 <verify_header+0x28>
   45d3a:	6901      	ldr	r1, [r0, #16]
   45d3c:	428a      	cmp	r2, r1
   45d3e:	d006      	beq.n	45d4e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
   45d40:	6958      	ldr	r0, [r3, #20]
   45d42:	b128      	cbz	r0, 45d50 <verify_header+0x38>
   45d44:	699b      	ldr	r3, [r3, #24]
   45d46:	1a1b      	subs	r3, r3, r0
   45d48:	4258      	negs	r0, r3
   45d4a:	4158      	adcs	r0, r3
   45d4c:	4770      	bx	lr
        return( 1 );
   45d4e:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
   45d50:	4770      	bx	lr
   45d52:	bf00      	nop
   45d54:	ff00aa55 	.word	0xff00aa55

00045d58 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
   45d58:	4b0d      	ldr	r3, [pc, #52]	; (45d90 <verify_chain+0x38>)
{
   45d5a:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
   45d5c:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
   45d5e:	b1a6      	cbz	r6, 45d8a <verify_chain+0x32>
   45d60:	4630      	mov	r0, r6
   45d62:	f7ff ffd9 	bl	45d18 <verify_header>
   45d66:	4604      	mov	r4, r0
   45d68:	b978      	cbnz	r0, 45d8a <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
   45d6a:	68f3      	ldr	r3, [r6, #12]
   45d6c:	b96b      	cbnz	r3, 45d8a <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
   45d6e:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
   45d70:	b90d      	cbnz	r5, 45d76 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
   45d72:	4620      	mov	r0, r4
   45d74:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
   45d76:	4628      	mov	r0, r5
   45d78:	f7ff ffce 	bl	45d18 <verify_header>
   45d7c:	b928      	cbnz	r0, 45d8a <verify_chain+0x32>
        if( cur->prev != prv )
   45d7e:	68eb      	ldr	r3, [r5, #12]
   45d80:	42b3      	cmp	r3, r6
   45d82:	d102      	bne.n	45d8a <verify_chain+0x32>
        cur = cur->next;
   45d84:	462e      	mov	r6, r5
   45d86:	692d      	ldr	r5, [r5, #16]
   45d88:	e7f2      	b.n	45d70 <verify_chain+0x18>
        return( 1 );
   45d8a:	2401      	movs	r4, #1
   45d8c:	e7f1      	b.n	45d72 <verify_chain+0x1a>
   45d8e:	bf00      	nop
   45d90:	2001ad58 	.word	0x2001ad58

00045d94 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
   45d94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
   45d98:	4d3e      	ldr	r5, [pc, #248]	; (45e94 <buffer_alloc_calloc+0x100>)
   45d9a:	682c      	ldr	r4, [r5, #0]
   45d9c:	b1d4      	cbz	r4, 45dd4 <buffer_alloc_calloc+0x40>
   45d9e:	68ac      	ldr	r4, [r5, #8]
   45da0:	b1c4      	cbz	r4, 45dd4 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
   45da2:	2800      	cmp	r0, #0
   45da4:	d04b      	beq.n	45e3e <buffer_alloc_calloc+0xaa>
   45da6:	2900      	cmp	r1, #0
   45da8:	d049      	beq.n	45e3e <buffer_alloc_calloc+0xaa>
    original_len = len = n * size;
   45daa:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
   45dae:	fbb6 f0f0 	udiv	r0, r6, r0
   45db2:	4288      	cmp	r0, r1
   45db4:	d143      	bne.n	45e3e <buffer_alloc_calloc+0xaa>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45db6:	1d30      	adds	r0, r6, #4
   45db8:	d841      	bhi.n	45e3e <buffer_alloc_calloc+0xaa>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45dba:	07b1      	lsls	r1, r6, #30
   45dbc:	d00d      	beq.n	45dda <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45dbe:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45dc2:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
   45dc4:	68ec      	ldr	r4, [r5, #12]
   45dc6:	e003      	b.n	45dd0 <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
   45dc8:	6863      	ldr	r3, [r4, #4]
   45dca:	42bb      	cmp	r3, r7
   45dcc:	d239      	bcs.n	45e42 <buffer_alloc_calloc+0xae>
            break;

        cur = cur->next_free;
   45dce:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
   45dd0:	2c00      	cmp	r4, #0
   45dd2:	d1f9      	bne.n	45dc8 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
   45dd4:	4620      	mov	r0, r4
   45dd6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   45dda:	4637      	mov	r7, r6
   45ddc:	e7f2      	b.n	45dc4 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
   45dde:	60e8      	str	r0, [r5, #12]
   45de0:	e041      	b.n	45e66 <buffer_alloc_calloc+0xd2>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
   45de2:	f107 0c20 	add.w	ip, r7, #32
   45de6:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
   45dea:	3920      	subs	r1, #32
   45dec:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
   45dee:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
   45df0:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 45e98 <buffer_alloc_calloc+0x104>
    new->prev = cur;
   45df4:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
   45df8:	6921      	ldr	r1, [r4, #16]
   45dfa:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
   45dfc:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
   45e00:	f8df c098 	ldr.w	ip, [pc, #152]	; 45e9c <buffer_alloc_calloc+0x108>
   45e04:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
   45e08:	b101      	cbz	r1, 45e0c <buffer_alloc_calloc+0x78>
        new->next->prev = new;
   45e0a:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
   45e0c:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
   45e10:	b19a      	cbz	r2, 45e3a <buffer_alloc_calloc+0xa6>
        new->prev_free->next_free = new;
   45e12:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
   45e14:	699a      	ldr	r2, [r3, #24]
   45e16:	b102      	cbz	r2, 45e1a <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
   45e18:	6153      	str	r3, [r2, #20]
    cur->next = new;
   45e1a:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
   45e1c:	2300      	movs	r3, #0
    cur->alloc = 1;
   45e1e:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
   45e22:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45e26:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
   45e28:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45e2c:	07db      	lsls	r3, r3, #31
   45e2e:	d529      	bpl.n	45e84 <buffer_alloc_calloc+0xf0>
   45e30:	f7ff ff92 	bl	45d58 <verify_chain>
   45e34:	b330      	cbz	r0, 45e84 <buffer_alloc_calloc+0xf0>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void _exit(int status);
static inline void exit(int status)
{
	_exit(status);
   45e36:	4648      	mov	r0, r9
   45e38:	e022      	b.n	45e80 <buffer_alloc_calloc+0xec>
        heap.first_free = new;
   45e3a:	60eb      	str	r3, [r5, #12]
   45e3c:	e7ea      	b.n	45e14 <buffer_alloc_calloc+0x80>
        return( NULL );
   45e3e:	2400      	movs	r4, #0
   45e40:	e7c8      	b.n	45dd4 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
   45e42:	68a3      	ldr	r3, [r4, #8]
   45e44:	b113      	cbz	r3, 45e4c <buffer_alloc_calloc+0xb8>
   45e46:	2001      	movs	r0, #1
   45e48:	f7fc fe76 	bl	42b38 <_exit>
    if( cur->size - len < sizeof(memory_header) +
   45e4c:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
   45e50:	6861      	ldr	r1, [r4, #4]
   45e52:	f104 0820 	add.w	r8, r4, #32
   45e56:	1bc9      	subs	r1, r1, r7
   45e58:	2923      	cmp	r1, #35	; 0x23
   45e5a:	d8c2      	bhi.n	45de2 <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
   45e5c:	2301      	movs	r3, #1
   45e5e:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
   45e60:	2a00      	cmp	r2, #0
   45e62:	d0bc      	beq.n	45dde <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
   45e64:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
   45e66:	69a3      	ldr	r3, [r4, #24]
   45e68:	b103      	cbz	r3, 45e6c <buffer_alloc_calloc+0xd8>
            cur->next_free->prev_free = cur->prev_free;
   45e6a:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
   45e6c:	2300      	movs	r3, #0
        cur->next_free = NULL;
   45e6e:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45e72:	692b      	ldr	r3, [r5, #16]
   45e74:	07da      	lsls	r2, r3, #31
   45e76:	d505      	bpl.n	45e84 <buffer_alloc_calloc+0xf0>
   45e78:	f7ff ff6e 	bl	45d58 <verify_chain>
   45e7c:	b110      	cbz	r0, 45e84 <buffer_alloc_calloc+0xf0>
   45e7e:	2001      	movs	r0, #1
   45e80:	f7fc fe5a 	bl	42b38 <_exit>
    memset( ret, 0, original_len );
   45e84:	4632      	mov	r2, r6
   45e86:	2100      	movs	r1, #0
   45e88:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
   45e8a:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
   45e8c:	f002 f9dd 	bl	4824a <memset>
    return( ret );
   45e90:	e7a0      	b.n	45dd4 <buffer_alloc_calloc+0x40>
   45e92:	bf00      	nop
   45e94:	2001ad58 	.word	0x2001ad58
   45e98:	ff00aa55 	.word	0xff00aa55
   45e9c:	ee119966 	.word	0xee119966

00045ea0 <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
   45ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
   45ea2:	4605      	mov	r5, r0
   45ea4:	2800      	cmp	r0, #0
   45ea6:	d078      	beq.n	45f9a <buffer_alloc_free+0xfa>
   45ea8:	4e3c      	ldr	r6, [pc, #240]	; (45f9c <buffer_alloc_free+0xfc>)
   45eaa:	6833      	ldr	r3, [r6, #0]
   45eac:	2b00      	cmp	r3, #0
   45eae:	d074      	beq.n	45f9a <buffer_alloc_free+0xfa>
   45eb0:	68b2      	ldr	r2, [r6, #8]
   45eb2:	2a00      	cmp	r2, #0
   45eb4:	d071      	beq.n	45f9a <buffer_alloc_free+0xfa>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
   45eb6:	4283      	cmp	r3, r0
   45eb8:	d803      	bhi.n	45ec2 <buffer_alloc_free+0x22>
   45eba:	6872      	ldr	r2, [r6, #4]
   45ebc:	4413      	add	r3, r2
   45ebe:	4298      	cmp	r0, r3
   45ec0:	d302      	bcc.n	45ec8 <buffer_alloc_free+0x28>
   45ec2:	2001      	movs	r0, #1
   45ec4:	f7fc fe38 	bl	42b38 <_exit>
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
    }

    p -= sizeof(memory_header);
   45ec8:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
   45ecc:	4620      	mov	r0, r4
   45ece:	f7ff ff23 	bl	45d18 <verify_header>
   45ed2:	b110      	cbz	r0, 45eda <buffer_alloc_free+0x3a>
   45ed4:	2001      	movs	r0, #1
   45ed6:	f7fc fe2f 	bl	42b38 <_exit>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
   45eda:	f855 3c18 	ldr.w	r3, [r5, #-24]
   45ede:	2b01      	cmp	r3, #1
   45ee0:	d002      	beq.n	45ee8 <buffer_alloc_free+0x48>
   45ee2:	2001      	movs	r0, #1
   45ee4:	f7fc fe28 	bl	42b38 <_exit>
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
    }

    hdr->alloc = 0;
   45ee8:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45eea:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
   45eee:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   45ef2:	b1af      	cbz	r7, 45f20 <buffer_alloc_free+0x80>
   45ef4:	68ba      	ldr	r2, [r7, #8]
   45ef6:	b992      	cbnz	r2, 45f1e <buffer_alloc_free+0x7e>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
   45ef8:	f855 3c1c 	ldr.w	r3, [r5, #-28]
   45efc:	f103 0220 	add.w	r2, r3, #32
   45f00:	687b      	ldr	r3, [r7, #4]
   45f02:	4413      	add	r3, r2
   45f04:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
   45f06:	f855 3c10 	ldr.w	r3, [r5, #-16]
   45f0a:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
   45f0c:	b103      	cbz	r3, 45f10 <buffer_alloc_free+0x70>
            hdr->next->prev = hdr;
   45f0e:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45f10:	4620      	mov	r0, r4
   45f12:	2220      	movs	r2, #32
   45f14:	2100      	movs	r1, #0
   45f16:	f002 f998 	bl	4824a <memset>
   45f1a:	4623      	mov	r3, r4
   45f1c:	463c      	mov	r4, r7
    memory_header *hdr, *old = NULL;
   45f1e:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
   45f20:	6920      	ldr	r0, [r4, #16]
   45f22:	2800      	cmp	r0, #0
   45f24:	d031      	beq.n	45f8a <buffer_alloc_free+0xea>
   45f26:	6883      	ldr	r3, [r0, #8]
   45f28:	2b00      	cmp	r3, #0
   45f2a:	d12e      	bne.n	45f8a <buffer_alloc_free+0xea>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
   45f2c:	6863      	ldr	r3, [r4, #4]
   45f2e:	6842      	ldr	r2, [r0, #4]
   45f30:	3320      	adds	r3, #32
   45f32:	4413      	add	r3, r2
   45f34:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
   45f36:	6903      	ldr	r3, [r0, #16]
   45f38:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
   45f3c:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
   45f3e:	b9d2      	cbnz	r2, 45f76 <buffer_alloc_free+0xd6>
   45f40:	b9f9      	cbnz	r1, 45f82 <buffer_alloc_free+0xe2>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
   45f42:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
   45f44:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
   45f46:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
   45f48:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
   45f4a:	b1e2      	cbz	r2, 45f86 <buffer_alloc_free+0xe6>
            hdr->prev_free->next_free = hdr;
   45f4c:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
   45f4e:	69a2      	ldr	r2, [r4, #24]
   45f50:	b102      	cbz	r2, 45f54 <buffer_alloc_free+0xb4>
            hdr->next_free->prev_free = hdr;
   45f52:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
   45f54:	b103      	cbz	r3, 45f58 <buffer_alloc_free+0xb8>
            hdr->next->prev = hdr;
   45f56:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   45f58:	2220      	movs	r2, #32
   45f5a:	2100      	movs	r1, #0
   45f5c:	f002 f975 	bl	4824a <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
   45f60:	6933      	ldr	r3, [r6, #16]
   45f62:	079b      	lsls	r3, r3, #30
   45f64:	d519      	bpl.n	45f9a <buffer_alloc_free+0xfa>
   45f66:	f7ff fef7 	bl	45d58 <verify_chain>
   45f6a:	b1b0      	cbz	r0, 45f9a <buffer_alloc_free+0xfa>
        mbedtls_exit( 1 );
}
   45f6c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   45f70:	2001      	movs	r0, #1
   45f72:	f7fc bde1 	b.w	42b38 <_exit>
                hdr->prev_free->next_free = hdr->next_free;
   45f76:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
   45f78:	69a1      	ldr	r1, [r4, #24]
   45f7a:	2900      	cmp	r1, #0
   45f7c:	d0e1      	beq.n	45f42 <buffer_alloc_free+0xa2>
                hdr->next_free->prev_free = hdr->prev_free;
   45f7e:	614a      	str	r2, [r1, #20]
   45f80:	e7df      	b.n	45f42 <buffer_alloc_free+0xa2>
                heap.first_free = hdr->next_free;
   45f82:	60f1      	str	r1, [r6, #12]
   45f84:	e7f8      	b.n	45f78 <buffer_alloc_free+0xd8>
            heap.first_free = hdr;
   45f86:	60f4      	str	r4, [r6, #12]
   45f88:	e7e1      	b.n	45f4e <buffer_alloc_free+0xae>
    if( old == NULL )
   45f8a:	2f00      	cmp	r7, #0
   45f8c:	d1e8      	bne.n	45f60 <buffer_alloc_free+0xc0>
        hdr->next_free = heap.first_free;
   45f8e:	68f3      	ldr	r3, [r6, #12]
   45f90:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
   45f92:	b103      	cbz	r3, 45f96 <buffer_alloc_free+0xf6>
            heap.first_free->prev_free = hdr;
   45f94:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
   45f96:	60f4      	str	r4, [r6, #12]
   45f98:	e7e2      	b.n	45f60 <buffer_alloc_free+0xc0>
}
   45f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   45f9c:	2001ad58 	.word	0x2001ad58

00045fa0 <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
   45fa0:	b538      	push	{r3, r4, r5, lr}
   45fa2:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45fa4:	2214      	movs	r2, #20
   45fa6:	2100      	movs	r1, #0
{
   45fa8:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   45faa:	4812      	ldr	r0, [pc, #72]	; (45ff4 <mbedtls_memory_buffer_alloc_init+0x54>)
   45fac:	f002 f94d 	bl	4824a <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
   45fb0:	4911      	ldr	r1, [pc, #68]	; (45ff8 <mbedtls_memory_buffer_alloc_init+0x58>)
   45fb2:	4812      	ldr	r0, [pc, #72]	; (45ffc <mbedtls_memory_buffer_alloc_init+0x5c>)
   45fb4:	f7ff fe9e 	bl	45cf4 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45fb8:	2d23      	cmp	r5, #35	; 0x23
   45fba:	d91a      	bls.n	45ff2 <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45fbc:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45fc0:	bf1f      	itttt	ne
   45fc2:	3d04      	subne	r5, #4
   45fc4:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45fc6:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   45fca:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
   45fcc:	462a      	mov	r2, r5
   45fce:	2100      	movs	r1, #0
   45fd0:	4620      	mov	r0, r4
   45fd2:	f002 f93a 	bl	4824a <memset>

    heap.buf = buf;
   45fd6:	4b07      	ldr	r3, [pc, #28]	; (45ff4 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
   45fd8:	4a09      	ldr	r2, [pc, #36]	; (46000 <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
   45fda:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
   45fde:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
   45fe0:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
   45fe2:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
   45fe6:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
   45fe8:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
   45fec:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
   45fee:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
   45ff0:	60dc      	str	r4, [r3, #12]
}
   45ff2:	bd38      	pop	{r3, r4, r5, pc}
   45ff4:	2001ad58 	.word	0x2001ad58
   45ff8:	00045ea1 	.word	0x00045ea1
   45ffc:	00045d95 	.word	0x00045d95
   46000:	ff00aa55 	.word	0xff00aa55

00046004 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   46004:	4b0e      	ldr	r3, [pc, #56]	; (46040 <z_sys_init_run_level+0x3c>)
{
   46006:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   46008:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   4600c:	3001      	adds	r0, #1
   4600e:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   46012:	42a6      	cmp	r6, r4
   46014:	d800      	bhi.n	46018 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   46016:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   46018:	e9d4 3500 	ldrd	r3, r5, [r4]
   4601c:	4628      	mov	r0, r5
   4601e:	4798      	blx	r3
		if (dev != NULL) {
   46020:	b165      	cbz	r5, 4603c <z_sys_init_run_level+0x38>
			if (rc != 0) {
   46022:	68eb      	ldr	r3, [r5, #12]
   46024:	b130      	cbz	r0, 46034 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   46026:	2800      	cmp	r0, #0
   46028:	bfb8      	it	lt
   4602a:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   4602c:	28ff      	cmp	r0, #255	; 0xff
   4602e:	bfa8      	it	ge
   46030:	20ff      	movge	r0, #255	; 0xff
   46032:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   46034:	785a      	ldrb	r2, [r3, #1]
   46036:	f042 0201 	orr.w	r2, r2, #1
   4603a:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   4603c:	3408      	adds	r4, #8
   4603e:	e7e8      	b.n	46012 <z_sys_init_run_level+0xe>
   46040:	000491ac 	.word	0x000491ac

00046044 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   46044:	4b01      	ldr	r3, [pc, #4]	; (4604c <z_impl_z_errno+0x8>)
   46046:	6898      	ldr	r0, [r3, #8]
}
   46048:	3060      	adds	r0, #96	; 0x60
   4604a:	4770      	bx	lr
   4604c:	2001ad6c 	.word	0x2001ad6c

00046050 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   46050:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46054:	4606      	mov	r6, r0
   46056:	460f      	mov	r7, r1
	__asm__ volatile(
   46058:	f04f 0320 	mov.w	r3, #32
   4605c:	f3ef 8811 	mrs	r8, BASEPRI
   46060:	f383 8812 	msr	BASEPRI_MAX, r3
   46064:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   46068:	f000 fe32 	bl	46cd0 <z_impl_z_current_get>
   4606c:	4c21      	ldr	r4, [pc, #132]	; (460f4 <z_fatal_error+0xa4>)
   4606e:	4b22      	ldr	r3, [pc, #136]	; (460f8 <z_fatal_error+0xa8>)
   46070:	2e04      	cmp	r6, #4
   46072:	eba4 0403 	sub.w	r4, r4, r3
   46076:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   4607a:	bf98      	it	ls
   4607c:	4a1f      	ldrls	r2, [pc, #124]	; (460fc <z_fatal_error+0xac>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4607e:	ea4f 1484 	mov.w	r4, r4, lsl #6
   46082:	f044 0301 	orr.w	r3, r4, #1
   46086:	4605      	mov	r5, r0
	switch (reason) {
   46088:	bf94      	ite	ls
   4608a:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4608e:	4a1c      	ldrhi	r2, [pc, #112]	; (46100 <z_fatal_error+0xb0>)
   46090:	f8ad 3000 	strh.w	r3, [sp]
   46094:	4631      	mov	r1, r6
   46096:	2300      	movs	r3, #0
   46098:	481a      	ldr	r0, [pc, #104]	; (46104 <z_fatal_error+0xb4>)
   4609a:	f001 fda8 	bl	47bee <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   4609e:	b147      	cbz	r7, 460b2 <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   460a0:	69fb      	ldr	r3, [r7, #28]
   460a2:	f3c3 0308 	ubfx	r3, r3, #0, #9
   460a6:	b123      	cbz	r3, 460b2 <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
   460a8:	4817      	ldr	r0, [pc, #92]	; (46108 <z_fatal_error+0xb8>)
   460aa:	f044 0101 	orr.w	r1, r4, #1
   460ae:	f001 fd64 	bl	47b7a <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   460b2:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   460b6:	b12d      	cbz	r5, 460c4 <z_fatal_error+0x74>
   460b8:	4628      	mov	r0, r5
   460ba:	f002 fc2e 	bl	4891a <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   460be:	b108      	cbz	r0, 460c4 <z_fatal_error+0x74>
   460c0:	7803      	ldrb	r3, [r0, #0]
   460c2:	b903      	cbnz	r3, 460c6 <z_fatal_error+0x76>
		thread_name = "unknown";
   460c4:	4811      	ldr	r0, [pc, #68]	; (4610c <z_fatal_error+0xbc>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
   460c6:	f7fb f94b 	bl	41360 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
   460ca:	4623      	mov	r3, r4
   460cc:	4602      	mov	r2, r0
   460ce:	4629      	mov	r1, r5
   460d0:	480f      	ldr	r0, [pc, #60]	; (46110 <z_fatal_error+0xc0>)
   460d2:	f001 fd73 	bl	47bbc <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   460d6:	4639      	mov	r1, r7
   460d8:	4630      	mov	r0, r6
   460da:	f7fd fe05 	bl	43ce8 <k_sys_fatal_error_handler>
	__asm__ volatile(
   460de:	f388 8811 	msr	BASEPRI, r8
   460e2:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   460e6:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   460e8:	b002      	add	sp, #8
   460ea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   460ee:	f7fc bb59 	b.w	427a4 <z_impl_k_thread_abort>
   460f2:	bf00      	nop
   460f4:	00048f90 	.word	0x00048f90
   460f8:	00048f58 	.word	0x00048f58
   460fc:	000491c4 	.word	0x000491c4
   46100:	00049b2c 	.word	0x00049b2c
   46104:	00049b42 	.word	0x00049b42
   46108:	00049b6a 	.word	0x00049b6a
   4610c:	00049b3a 	.word	0x00049b3a
   46110:	00049b8b 	.word	0x00049b8b

00046114 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   46114:	2300      	movs	r3, #0
   46116:	2201      	movs	r2, #1
{
   46118:	b510      	push	{r4, lr}
   4611a:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   4611c:	e9cd 2304 	strd	r2, r3, [sp, #16]
   46120:	220f      	movs	r2, #15
   46122:	9301      	str	r3, [sp, #4]
   46124:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   46128:	2318      	movs	r3, #24
   4612a:	4a0b      	ldr	r2, [pc, #44]	; (46158 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   4612c:	4c0b      	ldr	r4, [pc, #44]	; (4615c <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   4612e:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   46132:	f44f 72a0 	mov.w	r2, #320	; 0x140
   46136:	490a      	ldr	r1, [pc, #40]	; (46160 <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   46138:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   4613c:	fb02 1100 	mla	r1, r2, r0, r1
   46140:	9300      	str	r3, [sp, #0]
   46142:	4620      	mov	r0, r4
   46144:	4b07      	ldr	r3, [pc, #28]	; (46164 <init_idle_thread+0x50>)
   46146:	f000 f90b 	bl	46360 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   4614a:	7b63      	ldrb	r3, [r4, #13]
   4614c:	f023 0304 	bic.w	r3, r3, #4
   46150:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   46152:	b006      	add	sp, #24
   46154:	bd10      	pop	{r4, pc}
   46156:	bf00      	nop
   46158:	2001ad6c 	.word	0x2001ad6c
   4615c:	2001a748 	.word	0x2001a748
   46160:	200232b0 	.word	0x200232b0
   46164:	000464a9 	.word	0x000464a9

00046168 <bg_thread_main>:
	z_sys_post_kernel = true;
   46168:	2201      	movs	r2, #1
{
   4616a:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   4616c:	4b09      	ldr	r3, [pc, #36]	; (46194 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   4616e:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   46170:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   46172:	f7ff ff47 	bl	46004 <z_sys_init_run_level>
	boot_banner();
   46176:	f001 f81d 	bl	471b4 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   4617a:	2003      	movs	r0, #3
   4617c:	f7ff ff42 	bl	46004 <z_sys_init_run_level>
	z_init_static_threads();
   46180:	f000 f94a 	bl	46418 <z_init_static_threads>
	main();
   46184:	f7fa fad8 	bl	40738 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   46188:	4a03      	ldr	r2, [pc, #12]	; (46198 <bg_thread_main+0x30>)
   4618a:	7b13      	ldrb	r3, [r2, #12]
   4618c:	f023 0301 	bic.w	r3, r3, #1
   46190:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   46192:	bd08      	pop	{r3, pc}
   46194:	20020bab 	.word	0x20020bab
   46198:	2001a7c8 	.word	0x2001a7c8

0004619c <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   4619c:	4802      	ldr	r0, [pc, #8]	; (461a8 <z_bss_zero+0xc>)
   4619e:	4a03      	ldr	r2, [pc, #12]	; (461ac <z_bss_zero+0x10>)
   461a0:	2100      	movs	r1, #0
   461a2:	1a12      	subs	r2, r2, r0
   461a4:	f002 b851 	b.w	4824a <memset>
   461a8:	2001a658 	.word	0x2001a658
   461ac:	20020bac 	.word	0x20020bac

000461b0 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   461b0:	b580      	push	{r7, lr}
   461b2:	b0a6      	sub	sp, #152	; 0x98
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   461b4:	f7fb f824 	bl	41200 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   461b8:	4b2f      	ldr	r3, [pc, #188]	; (46278 <z_cstart+0xc8>)
	uint32_t msp =
   461ba:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   461be:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   461c2:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   461c6:	2400      	movs	r4, #0
   461c8:	23e0      	movs	r3, #224	; 0xe0
   461ca:	4d2c      	ldr	r5, [pc, #176]	; (4627c <z_cstart+0xcc>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   461cc:	4e2c      	ldr	r6, [pc, #176]	; (46280 <z_cstart+0xd0>)
   461ce:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   461d2:	77ec      	strb	r4, [r5, #31]
   461d4:	762c      	strb	r4, [r5, #24]
   461d6:	766c      	strb	r4, [r5, #25]
   461d8:	76ac      	strb	r4, [r5, #26]
   461da:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   461de:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   461e0:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 46294 <z_cstart+0xe4>
   461e4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   461e8:	626b      	str	r3, [r5, #36]	; 0x24
   461ea:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   461ee:	f7fc fa51 	bl	42694 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   461f2:	f7fb fead 	bl	41f50 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   461f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   461fa:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   461fc:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   461fe:	f7fc fc5d 	bl	42abc <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   46202:	f7fc fae1 	bl	427c8 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   46206:	f240 1301 	movw	r3, #257	; 0x101
   4620a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   4620e:	ab06      	add	r3, sp, #24
   46210:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   46212:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   46216:	f002 fab2 	bl	4877e <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   4621a:	4620      	mov	r0, r4
   4621c:	f7ff fef2 	bl	46004 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   46220:	2001      	movs	r0, #1
   46222:	f7ff feef 	bl	46004 <z_sys_init_run_level>
	z_sched_init();
   46226:	f000 fca5 	bl	46b74 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4622a:	4b16      	ldr	r3, [pc, #88]	; (46284 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   4622c:	4d16      	ldr	r5, [pc, #88]	; (46288 <z_cstart+0xd8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4622e:	9305      	str	r3, [sp, #20]
   46230:	2301      	movs	r3, #1
   46232:	4916      	ldr	r1, [pc, #88]	; (4628c <z_cstart+0xdc>)
   46234:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   46238:	e9cd 4303 	strd	r4, r3, [sp, #12]
   4623c:	4628      	mov	r0, r5
   4623e:	464b      	mov	r3, r9
   46240:	e9cd 4401 	strd	r4, r4, [sp, #4]
   46244:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   46246:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46248:	f000 f88a 	bl	46360 <z_setup_new_thread>
   4624c:	4607      	mov	r7, r0
   4624e:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   46250:	4628      	mov	r0, r5
   46252:	f022 0204 	bic.w	r2, r2, #4
   46256:	736a      	strb	r2, [r5, #13]
   46258:	f002 fbd1 	bl	489fe <z_ready_thread>
		init_idle_thread(i);
   4625c:	4620      	mov	r0, r4
   4625e:	f7ff ff59 	bl	46114 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   46262:	4b0b      	ldr	r3, [pc, #44]	; (46290 <z_cstart+0xe0>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46264:	464a      	mov	r2, r9
   46266:	4639      	mov	r1, r7
   46268:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   4626a:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   4626c:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   4626e:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46272:	f7fb ff9d 	bl	421b0 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   46276:	bf00      	nop
   46278:	200233f0 	.word	0x200233f0
   4627c:	e000ed00 	.word	0xe000ed00
   46280:	2001ad6c 	.word	0x2001ad6c
   46284:	00049bed 	.word	0x00049bed
   46288:	2001a7c8 	.word	0x2001a7c8
   4628c:	200212b0 	.word	0x200212b0
   46290:	2001a748 	.word	0x2001a748
   46294:	00046169 	.word	0x00046169

00046298 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   46298:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   4629a:	4c06      	ldr	r4, [pc, #24]	; (462b4 <statics_init+0x1c>)
   4629c:	4d06      	ldr	r5, [pc, #24]	; (462b8 <statics_init+0x20>)
   4629e:	42ac      	cmp	r4, r5
   462a0:	d301      	bcc.n	462a6 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   462a2:	2000      	movs	r0, #0
   462a4:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   462a6:	4620      	mov	r0, r4
   462a8:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   462ac:	f002 fa72 	bl	48794 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   462b0:	3414      	adds	r4, #20
   462b2:	e7f4      	b.n	4629e <statics_init+0x6>
   462b4:	2001a608 	.word	0x2001a608
   462b8:	2001a61c 	.word	0x2001a61c

000462bc <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   462bc:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   462be:	4b0e      	ldr	r3, [pc, #56]	; (462f8 <init_mem_slab_module+0x3c>)
   462c0:	4c0e      	ldr	r4, [pc, #56]	; (462fc <init_mem_slab_module+0x40>)
   462c2:	42a3      	cmp	r3, r4
   462c4:	d301      	bcc.n	462ca <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   462c6:	2000      	movs	r0, #0
	return rc;
}
   462c8:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   462ca:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   462ce:	ea41 0200 	orr.w	r2, r1, r0
   462d2:	f012 0203 	ands.w	r2, r2, #3
   462d6:	d10b      	bne.n	462f0 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   462d8:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   462da:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   462dc:	42aa      	cmp	r2, r5
   462de:	d101      	bne.n	462e4 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   462e0:	331c      	adds	r3, #28
   462e2:	e7ee      	b.n	462c2 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   462e4:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   462e6:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   462e8:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   462ea:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   462ec:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   462ee:	e7f5      	b.n	462dc <init_mem_slab_module+0x20>
		return -EINVAL;
   462f0:	f06f 0015 	mvn.w	r0, #21
	return rc;
   462f4:	e7e8      	b.n	462c8 <init_mem_slab_module+0xc>
   462f6:	bf00      	nop
   462f8:	2001a608 	.word	0x2001a608
   462fc:	2001a608 	.word	0x2001a608

00046300 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   46300:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   46302:	460c      	mov	r4, r1
   46304:	4616      	mov	r6, r2
   46306:	461f      	mov	r7, r3
	__asm__ volatile(
   46308:	f04f 0320 	mov.w	r3, #32
   4630c:	f3ef 8111 	mrs	r1, BASEPRI
   46310:	f383 8812 	msr	BASEPRI_MAX, r3
   46314:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   46318:	6943      	ldr	r3, [r0, #20]
   4631a:	b15b      	cbz	r3, 46334 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   4631c:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   4631e:	681b      	ldr	r3, [r3, #0]
   46320:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   46322:	6983      	ldr	r3, [r0, #24]
   46324:	3301      	adds	r3, #1
   46326:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   46328:	2000      	movs	r0, #0
	__asm__ volatile(
   4632a:	f381 8811 	msr	BASEPRI, r1
   4632e:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   46332:	e011      	b.n	46358 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   46334:	ea56 0207 	orrs.w	r2, r6, r7
   46338:	d103      	bne.n	46342 <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   4633a:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   4633e:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   46340:	e7f3      	b.n	4632a <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   46342:	4602      	mov	r2, r0
   46344:	e9cd 6700 	strd	r6, r7, [sp]
   46348:	3008      	adds	r0, #8
   4634a:	f000 fb65 	bl	46a18 <z_pend_curr>
		if (result == 0) {
   4634e:	b918      	cbnz	r0, 46358 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   46350:	4b02      	ldr	r3, [pc, #8]	; (4635c <k_mem_slab_alloc+0x5c>)
   46352:	689b      	ldr	r3, [r3, #8]
   46354:	695b      	ldr	r3, [r3, #20]
   46356:	6023      	str	r3, [r4, #0]
}
   46358:	b002      	add	sp, #8
   4635a:	bdd0      	pop	{r4, r6, r7, pc}
   4635c:	2001ad6c 	.word	0x2001ad6c

00046360 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   46360:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   46364:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   46366:	f100 0558 	add.w	r5, r0, #88	; 0x58
   4636a:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   4636c:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   4636e:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   46372:	2500      	movs	r5, #0
{
   46374:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   46376:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   46378:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   4637a:	e9c0 5506 	strd	r5, r5, [r0, #24]
   4637e:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46380:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46382:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46384:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   46388:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   4638c:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   4638e:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   46390:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46392:	9202      	str	r2, [sp, #8]
   46394:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   46396:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   4639a:	9201      	str	r2, [sp, #4]
   4639c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   4639e:	9200      	str	r2, [sp, #0]
   463a0:	4642      	mov	r2, r8
   463a2:	f7fb fee7 	bl	42174 <arch_new_thread>
	if (!_current) {
   463a6:	4b05      	ldr	r3, [pc, #20]	; (463bc <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   463a8:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   463aa:	689b      	ldr	r3, [r3, #8]
   463ac:	b103      	cbz	r3, 463b0 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   463ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   463b0:	4640      	mov	r0, r8
   463b2:	6723      	str	r3, [r4, #112]	; 0x70
   463b4:	b004      	add	sp, #16
   463b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   463ba:	bf00      	nop
   463bc:	2001ad6c 	.word	0x2001ad6c

000463c0 <z_impl_k_thread_create>:
{
   463c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   463c2:	2500      	movs	r5, #0
{
   463c4:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   463c6:	9505      	str	r5, [sp, #20]
   463c8:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   463ca:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   463ce:	9504      	str	r5, [sp, #16]
   463d0:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   463d2:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   463d4:	9503      	str	r5, [sp, #12]
   463d6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   463d8:	9502      	str	r5, [sp, #8]
   463da:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   463dc:	9501      	str	r5, [sp, #4]
   463de:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   463e0:	9500      	str	r5, [sp, #0]
   463e2:	f7ff ffbd 	bl	46360 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   463e6:	1c7b      	adds	r3, r7, #1
   463e8:	bf08      	it	eq
   463ea:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   463ee:	d005      	beq.n	463fc <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   463f0:	ea56 0307 	orrs.w	r3, r6, r7
   463f4:	d105      	bne.n	46402 <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   463f6:	4620      	mov	r0, r4
   463f8:	f000 fab2 	bl	46960 <z_sched_start>
}
   463fc:	4620      	mov	r0, r4
   463fe:	b007      	add	sp, #28
   46400:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46402:	4632      	mov	r2, r6
   46404:	463b      	mov	r3, r7
   46406:	4903      	ldr	r1, [pc, #12]	; (46414 <z_impl_k_thread_create+0x54>)
   46408:	f104 0018 	add.w	r0, r4, #24
   4640c:	f000 fd22 	bl	46e54 <z_add_timeout>
   46410:	e7f4      	b.n	463fc <z_impl_k_thread_create+0x3c>
   46412:	bf00      	nop
   46414:	00048a1f 	.word	0x00048a1f

00046418 <z_init_static_threads>:
{
   46418:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   4641a:	4e20      	ldr	r6, [pc, #128]	; (4649c <z_init_static_threads+0x84>)
   4641c:	4d20      	ldr	r5, [pc, #128]	; (464a0 <z_init_static_threads+0x88>)
   4641e:	4637      	mov	r7, r6
{
   46420:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   46422:	42b5      	cmp	r5, r6
   46424:	f105 0430 	add.w	r4, r5, #48	; 0x30
   46428:	d30a      	bcc.n	46440 <z_init_static_threads+0x28>
	k_sched_lock();
   4642a:	f000 f9ad 	bl	46788 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   4642e:	4c1c      	ldr	r4, [pc, #112]	; (464a0 <z_init_static_threads+0x88>)
   46430:	4d1c      	ldr	r5, [pc, #112]	; (464a4 <z_init_static_threads+0x8c>)
   46432:	42bc      	cmp	r4, r7
   46434:	d321      	bcc.n	4647a <z_init_static_threads+0x62>
}
   46436:	b007      	add	sp, #28
   46438:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   4643c:	f000 bb7e 	b.w	46b3c <k_sched_unlock>
		z_setup_new_thread(
   46440:	f854 3c04 	ldr.w	r3, [r4, #-4]
   46444:	9305      	str	r3, [sp, #20]
   46446:	f854 3c10 	ldr.w	r3, [r4, #-16]
   4644a:	9304      	str	r3, [sp, #16]
   4644c:	f854 3c14 	ldr.w	r3, [r4, #-20]
   46450:	9303      	str	r3, [sp, #12]
   46452:	f854 3c18 	ldr.w	r3, [r4, #-24]
   46456:	9302      	str	r3, [sp, #8]
   46458:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   4645c:	9301      	str	r3, [sp, #4]
   4645e:	f854 3c20 	ldr.w	r3, [r4, #-32]
   46462:	9300      	str	r3, [sp, #0]
   46464:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   46468:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   4646c:	f7ff ff78 	bl	46360 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   46470:	f854 3c30 	ldr.w	r3, [r4, #-48]
   46474:	655d      	str	r5, [r3, #84]	; 0x54
   46476:	4625      	mov	r5, r4
   46478:	e7d3      	b.n	46422 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   4647a:	6a62      	ldr	r2, [r4, #36]	; 0x24
   4647c:	1c53      	adds	r3, r2, #1
   4647e:	d004      	beq.n	4648a <z_init_static_threads+0x72>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46480:	2a00      	cmp	r2, #0
			schedule_new_thread(thread_data->init_thread,
   46482:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46484:	dc03      	bgt.n	4648e <z_init_static_threads+0x76>
	z_sched_start(thread);
   46486:	f000 fa6b 	bl	46960 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   4648a:	3430      	adds	r4, #48	; 0x30
   4648c:	e7d1      	b.n	46432 <z_init_static_threads+0x1a>
   4648e:	4629      	mov	r1, r5
   46490:	17d3      	asrs	r3, r2, #31
   46492:	3018      	adds	r0, #24
   46494:	f000 fcde 	bl	46e54 <z_add_timeout>
   46498:	e7f7      	b.n	4648a <z_init_static_threads+0x72>
   4649a:	bf00      	nop
   4649c:	2001a608 	.word	0x2001a608
   464a0:	2001a608 	.word	0x2001a608
   464a4:	00048a1f 	.word	0x00048a1f

000464a8 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   464a8:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   464aa:	4c09      	ldr	r4, [pc, #36]	; (464d0 <idle+0x28>)
	__asm__ volatile(
   464ac:	f04f 0220 	mov.w	r2, #32
   464b0:	f3ef 8311 	mrs	r3, BASEPRI
   464b4:	f382 8812 	msr	BASEPRI_MAX, r2
   464b8:	f3bf 8f6f 	isb	sy
   464bc:	f002 fb51 	bl	48b62 <z_get_next_timeout_expiry>
   464c0:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   464c2:	f7fb fcc5 	bl	41e50 <pm_system_suspend>
   464c6:	2800      	cmp	r0, #0
   464c8:	d1f0      	bne.n	464ac <idle+0x4>
	arch_cpu_idle();
   464ca:	f7fb fd47 	bl	41f5c <arch_cpu_idle>
}
   464ce:	e7ed      	b.n	464ac <idle+0x4>
   464d0:	2001ad6c 	.word	0x2001ad6c

000464d4 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   464d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   464d8:	4604      	mov	r4, r0
   464da:	4616      	mov	r6, r2
   464dc:	461f      	mov	r7, r3
   464de:	f04f 0320 	mov.w	r3, #32
   464e2:	f3ef 8811 	mrs	r8, BASEPRI
   464e6:	f383 8812 	msr	BASEPRI_MAX, r3
   464ea:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   464ee:	68c3      	ldr	r3, [r0, #12]
   464f0:	4a35      	ldr	r2, [pc, #212]	; (465c8 <z_impl_k_mutex_lock+0xf4>)
   464f2:	b16b      	cbz	r3, 46510 <z_impl_k_mutex_lock+0x3c>
   464f4:	6880      	ldr	r0, [r0, #8]
   464f6:	6891      	ldr	r1, [r2, #8]
   464f8:	4288      	cmp	r0, r1
   464fa:	d019      	beq.n	46530 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   464fc:	ea56 0307 	orrs.w	r3, r6, r7
   46500:	d118      	bne.n	46534 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   46502:	f388 8811 	msr	BASEPRI, r8
   46506:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   4650a:	f06f 000f 	mvn.w	r0, #15
   4650e:	e00c      	b.n	4652a <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   46510:	6891      	ldr	r1, [r2, #8]
   46512:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   46516:	3301      	adds	r3, #1
   46518:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   4651a:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   4651c:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   4651e:	60a3      	str	r3, [r4, #8]
   46520:	f388 8811 	msr	BASEPRI, r8
   46524:	f3bf 8f6f 	isb	sy
		return 0;
   46528:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   4652a:	b002      	add	sp, #8
   4652c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   46530:	6921      	ldr	r1, [r4, #16]
   46532:	e7f0      	b.n	46516 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   46534:	f991 100e 	ldrsb.w	r1, [r1, #14]
   46538:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   4653c:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   46540:	4299      	cmp	r1, r3
   46542:	bfa8      	it	ge
   46544:	4619      	movge	r1, r3
   46546:	4291      	cmp	r1, r2
   46548:	bfb8      	it	lt
   4654a:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   4654c:	428b      	cmp	r3, r1
   4654e:	dd2f      	ble.n	465b0 <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   46550:	f000 fa76 	bl	46a40 <z_set_prio>
   46554:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   46556:	4622      	mov	r2, r4
   46558:	4641      	mov	r1, r8
   4655a:	e9cd 6700 	strd	r6, r7, [sp]
   4655e:	481b      	ldr	r0, [pc, #108]	; (465cc <z_impl_k_mutex_lock+0xf8>)
   46560:	f000 fa5a 	bl	46a18 <z_pend_curr>
	if (got_mutex == 0) {
   46564:	2800      	cmp	r0, #0
   46566:	d0e0      	beq.n	4652a <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   46568:	f04f 0320 	mov.w	r3, #32
   4656c:	f3ef 8611 	mrs	r6, BASEPRI
   46570:	f383 8812 	msr	BASEPRI_MAX, r3
   46574:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   46578:	6823      	ldr	r3, [r4, #0]
   4657a:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4657c:	429c      	cmp	r4, r3
   4657e:	d00a      	beq.n	46596 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   46580:	b14b      	cbz	r3, 46596 <z_impl_k_mutex_lock+0xc2>
   46582:	f993 300e 	ldrsb.w	r3, [r3, #14]
   46586:	4299      	cmp	r1, r3
   46588:	bfa8      	it	ge
   4658a:	4619      	movge	r1, r3
   4658c:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   46590:	4299      	cmp	r1, r3
   46592:	bfb8      	it	lt
   46594:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46596:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   46598:	f990 300e 	ldrsb.w	r3, [r0, #14]
   4659c:	4299      	cmp	r1, r3
   4659e:	d109      	bne.n	465b4 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   465a0:	b16d      	cbz	r5, 465be <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   465a2:	4631      	mov	r1, r6
   465a4:	4809      	ldr	r0, [pc, #36]	; (465cc <z_impl_k_mutex_lock+0xf8>)
   465a6:	f000 f8dd 	bl	46764 <z_reschedule>
	return -EAGAIN;
   465aa:	f06f 000a 	mvn.w	r0, #10
   465ae:	e7bc      	b.n	4652a <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   465b0:	2500      	movs	r5, #0
   465b2:	e7d0      	b.n	46556 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   465b4:	f000 fa44 	bl	46a40 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   465b8:	2800      	cmp	r0, #0
   465ba:	d1f2      	bne.n	465a2 <z_impl_k_mutex_lock+0xce>
   465bc:	e7f0      	b.n	465a0 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   465be:	f386 8811 	msr	BASEPRI, r6
   465c2:	f3bf 8f6f 	isb	sy
   465c6:	e7f0      	b.n	465aa <z_impl_k_mutex_lock+0xd6>
   465c8:	2001ad6c 	.word	0x2001ad6c
   465cc:	20020bac 	.word	0x20020bac

000465d0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   465d0:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   465d2:	6883      	ldr	r3, [r0, #8]
{
   465d4:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   465d6:	2b00      	cmp	r3, #0
   465d8:	d036      	beq.n	46648 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   465da:	4a1e      	ldr	r2, [pc, #120]	; (46654 <z_impl_k_mutex_unlock+0x84>)
   465dc:	6892      	ldr	r2, [r2, #8]
   465de:	4293      	cmp	r3, r2
   465e0:	d135      	bne.n	4664e <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   465e2:	7bda      	ldrb	r2, [r3, #15]
   465e4:	3a01      	subs	r2, #1
   465e6:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   465e8:	68c3      	ldr	r3, [r0, #12]
   465ea:	2b01      	cmp	r3, #1
   465ec:	d905      	bls.n	465fa <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   465ee:	3b01      	subs	r3, #1
   465f0:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   465f2:	f000 faa3 	bl	46b3c <k_sched_unlock>

	return 0;
   465f6:	2000      	movs	r0, #0
}
   465f8:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   465fa:	f04f 0320 	mov.w	r3, #32
   465fe:	f3ef 8511 	mrs	r5, BASEPRI
   46602:	f383 8812 	msr	BASEPRI_MAX, r3
   46606:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   4660a:	6901      	ldr	r1, [r0, #16]
   4660c:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   4660e:	f990 300e 	ldrsb.w	r3, [r0, #14]
   46612:	4299      	cmp	r1, r3
   46614:	d001      	beq.n	4661a <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   46616:	f000 fa13 	bl	46a40 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   4661a:	4620      	mov	r0, r4
   4661c:	f002 fa63 	bl	48ae6 <z_unpend_first_thread>
	mutex->owner = new_owner;
   46620:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   46622:	b158      	cbz	r0, 4663c <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   46624:	f990 200e 	ldrsb.w	r2, [r0, #14]
   46628:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   4662a:	2200      	movs	r2, #0
   4662c:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   4662e:	f002 f9e6 	bl	489fe <z_ready_thread>
		z_reschedule(&lock, key);
   46632:	4629      	mov	r1, r5
   46634:	4808      	ldr	r0, [pc, #32]	; (46658 <z_impl_k_mutex_unlock+0x88>)
   46636:	f000 f895 	bl	46764 <z_reschedule>
   4663a:	e7da      	b.n	465f2 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   4663c:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4663e:	f385 8811 	msr	BASEPRI, r5
   46642:	f3bf 8f6f 	isb	sy
   46646:	e7d4      	b.n	465f2 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   46648:	f06f 0015 	mvn.w	r0, #21
   4664c:	e7d4      	b.n	465f8 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   4664e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   46652:	e7d1      	b.n	465f8 <z_impl_k_mutex_unlock+0x28>
   46654:	2001ad6c 	.word	0x2001ad6c
   46658:	20020bac 	.word	0x20020bac

0004665c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   4665c:	b538      	push	{r3, r4, r5, lr}
   4665e:	4604      	mov	r4, r0
	__asm__ volatile(
   46660:	f04f 0320 	mov.w	r3, #32
   46664:	f3ef 8511 	mrs	r5, BASEPRI
   46668:	f383 8812 	msr	BASEPRI_MAX, r3
   4666c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   46670:	f002 fa39 	bl	48ae6 <z_unpend_first_thread>

	if (thread != NULL) {
   46674:	b148      	cbz	r0, 4668a <z_impl_k_sem_give+0x2e>
   46676:	2200      	movs	r2, #0
   46678:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   4667a:	f002 f9c0 	bl	489fe <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   4667e:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   46680:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   46684:	4804      	ldr	r0, [pc, #16]	; (46698 <z_impl_k_sem_give+0x3c>)
   46686:	f000 b86d 	b.w	46764 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   4668a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   4668e:	429a      	cmp	r2, r3
   46690:	bf18      	it	ne
   46692:	3301      	addne	r3, #1
   46694:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   46696:	e7f2      	b.n	4667e <z_impl_k_sem_give+0x22>
   46698:	20020bac 	.word	0x20020bac

0004669c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   4669c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4669e:	4614      	mov	r4, r2
   466a0:	461d      	mov	r5, r3
   466a2:	f04f 0320 	mov.w	r3, #32
   466a6:	f3ef 8111 	mrs	r1, BASEPRI
   466aa:	f383 8812 	msr	BASEPRI_MAX, r3
   466ae:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   466b2:	6883      	ldr	r3, [r0, #8]
   466b4:	b143      	cbz	r3, 466c8 <z_impl_k_sem_take+0x2c>
		sem->count--;
   466b6:	3b01      	subs	r3, #1
   466b8:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   466ba:	f381 8811 	msr	BASEPRI, r1
   466be:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   466c2:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   466c4:	b003      	add	sp, #12
   466c6:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   466c8:	ea54 0305 	orrs.w	r3, r4, r5
   466cc:	d106      	bne.n	466dc <z_impl_k_sem_take+0x40>
   466ce:	f381 8811 	msr	BASEPRI, r1
   466d2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   466d6:	f06f 000f 	mvn.w	r0, #15
   466da:	e7f3      	b.n	466c4 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   466dc:	4602      	mov	r2, r0
   466de:	e9cd 4500 	strd	r4, r5, [sp]
   466e2:	4802      	ldr	r0, [pc, #8]	; (466ec <z_impl_k_sem_take+0x50>)
   466e4:	f000 f998 	bl	46a18 <z_pend_curr>
	return ret;
   466e8:	e7ec      	b.n	466c4 <z_impl_k_sem_take+0x28>
   466ea:	bf00      	nop
   466ec:	20020bac 	.word	0x20020bac

000466f0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   466f0:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   466f2:	4c08      	ldr	r4, [pc, #32]	; (46714 <z_reset_time_slice+0x24>)
   466f4:	6823      	ldr	r3, [r4, #0]
   466f6:	b15b      	cbz	r3, 46710 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   466f8:	f7fd f940 	bl	4397c <sys_clock_elapsed>
   466fc:	4603      	mov	r3, r0
   466fe:	6820      	ldr	r0, [r4, #0]
   46700:	4a05      	ldr	r2, [pc, #20]	; (46718 <z_reset_time_slice+0x28>)
   46702:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   46704:	2100      	movs	r1, #0
	}
}
   46706:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   4670a:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   4670c:	f002 ba39 	b.w	48b82 <z_set_timeout_expiry>
}
   46710:	bd10      	pop	{r4, pc}
   46712:	bf00      	nop
   46714:	2001ad9c 	.word	0x2001ad9c
   46718:	2001ad6c 	.word	0x2001ad6c

0004671c <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   4671c:	b510      	push	{r4, lr}
	__asm__ volatile(
   4671e:	f04f 0320 	mov.w	r3, #32
   46722:	f3ef 8411 	mrs	r4, BASEPRI
   46726:	f383 8812 	msr	BASEPRI_MAX, r3
   4672a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   4672e:	2200      	movs	r2, #0
   46730:	4b09      	ldr	r3, [pc, #36]	; (46758 <k_sched_time_slice_set+0x3c>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   46732:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
   46734:	611a      	str	r2, [r3, #16]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   46736:	4b09      	ldr	r3, [pc, #36]	; (4675c <k_sched_time_slice_set+0x40>)
   46738:	dc09      	bgt.n	4674e <k_sched_time_slice_set+0x32>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   4673a:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   4673c:	4b08      	ldr	r3, [pc, #32]	; (46760 <k_sched_time_slice_set+0x44>)
   4673e:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
   46740:	f7ff ffd6 	bl	466f0 <z_reset_time_slice>
	__asm__ volatile(
   46744:	f384 8811 	msr	BASEPRI, r4
   46748:	f3bf 8f6f 	isb	sy
	}
}
   4674c:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
   4674e:	2802      	cmp	r0, #2
   46750:	bfb8      	it	lt
   46752:	2002      	movlt	r0, #2
   46754:	e7f1      	b.n	4673a <k_sched_time_slice_set+0x1e>
   46756:	bf00      	nop
   46758:	2001ad6c 	.word	0x2001ad6c
   4675c:	2001ad9c 	.word	0x2001ad9c
   46760:	2001ad98 	.word	0x2001ad98

00046764 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   46764:	b949      	cbnz	r1, 4677a <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   46766:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   4676a:	b930      	cbnz	r0, 4677a <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   4676c:	4b05      	ldr	r3, [pc, #20]	; (46784 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   4676e:	69da      	ldr	r2, [r3, #28]
   46770:	689b      	ldr	r3, [r3, #8]
   46772:	429a      	cmp	r2, r3
   46774:	d001      	beq.n	4677a <z_reschedule+0x16>
	ret = arch_swap(key);
   46776:	f7fb bca3 	b.w	420c0 <arch_swap>
   4677a:	f381 8811 	msr	BASEPRI, r1
   4677e:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   46782:	4770      	bx	lr
   46784:	2001ad6c 	.word	0x2001ad6c

00046788 <k_sched_lock>:
	__asm__ volatile(
   46788:	f04f 0320 	mov.w	r3, #32
   4678c:	f3ef 8111 	mrs	r1, BASEPRI
   46790:	f383 8812 	msr	BASEPRI_MAX, r3
   46794:	f3bf 8f6f 	isb	sy
   46798:	4b04      	ldr	r3, [pc, #16]	; (467ac <k_sched_lock+0x24>)
   4679a:	689a      	ldr	r2, [r3, #8]
   4679c:	7bd3      	ldrb	r3, [r2, #15]
   4679e:	3b01      	subs	r3, #1
   467a0:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   467a2:	f381 8811 	msr	BASEPRI, r1
   467a6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   467aa:	4770      	bx	lr
   467ac:	2001ad6c 	.word	0x2001ad6c

000467b0 <update_cache>:
{
   467b0:	b538      	push	{r3, r4, r5, lr}
   467b2:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   467b4:	480c      	ldr	r0, [pc, #48]	; (467e8 <update_cache+0x38>)
   467b6:	f002 f918 	bl	489ea <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   467ba:	4d0c      	ldr	r5, [pc, #48]	; (467ec <update_cache+0x3c>)
   467bc:	4604      	mov	r4, r0
   467be:	b900      	cbnz	r0, 467c2 <update_cache+0x12>
   467c0:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   467c2:	68ab      	ldr	r3, [r5, #8]
   467c4:	b94a      	cbnz	r2, 467da <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   467c6:	7b5a      	ldrb	r2, [r3, #13]
   467c8:	06d2      	lsls	r2, r2, #27
   467ca:	d106      	bne.n	467da <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   467cc:	69a2      	ldr	r2, [r4, #24]
   467ce:	b922      	cbnz	r2, 467da <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   467d0:	89da      	ldrh	r2, [r3, #14]
   467d2:	2a7f      	cmp	r2, #127	; 0x7f
   467d4:	d901      	bls.n	467da <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   467d6:	61eb      	str	r3, [r5, #28]
}
   467d8:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   467da:	429c      	cmp	r4, r3
   467dc:	d001      	beq.n	467e2 <update_cache+0x32>
			z_reset_time_slice();
   467de:	f7ff ff87 	bl	466f0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   467e2:	61ec      	str	r4, [r5, #28]
}
   467e4:	e7f8      	b.n	467d8 <update_cache+0x28>
   467e6:	bf00      	nop
   467e8:	2001ad8c 	.word	0x2001ad8c
   467ec:	2001ad6c 	.word	0x2001ad6c

000467f0 <move_thread_to_end_of_prio_q>:
{
   467f0:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   467f2:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   467f6:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   467f8:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   467fa:	7b43      	ldrb	r3, [r0, #13]
   467fc:	da04      	bge.n	46808 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   467fe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46802:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   46804:	f002 f8a5 	bl	48952 <sys_dlist_remove>
	return list->head == list;
   46808:	4a17      	ldr	r2, [pc, #92]	; (46868 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   4680a:	7b4b      	ldrb	r3, [r1, #13]
   4680c:	4610      	mov	r0, r2
   4680e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46812:	734b      	strb	r3, [r1, #13]
   46814:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46818:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4681a:	4283      	cmp	r3, r0
   4681c:	bf08      	it	eq
   4681e:	2300      	moveq	r3, #0
   46820:	2b00      	cmp	r3, #0
   46822:	bf38      	it	cc
   46824:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46826:	b1cb      	cbz	r3, 4685c <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   46828:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   4682c:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   46830:	42a6      	cmp	r6, r4
   46832:	d00f      	beq.n	46854 <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   46834:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46836:	2c00      	cmp	r4, #0
   46838:	dd0c      	ble.n	46854 <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   4683a:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   4683c:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   46840:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   46842:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   46844:	6890      	ldr	r0, [r2, #8]
}
   46846:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   4684a:	1a43      	subs	r3, r0, r1
   4684c:	4258      	negs	r0, r3
   4684e:	4158      	adcs	r0, r3
   46850:	f7ff bfae 	b.w	467b0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46854:	42ab      	cmp	r3, r5
   46856:	d001      	beq.n	4685c <move_thread_to_end_of_prio_q+0x6c>
   46858:	681b      	ldr	r3, [r3, #0]
   4685a:	e7e4      	b.n	46826 <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   4685c:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   46860:	6029      	str	r1, [r5, #0]
	list->tail = node;
   46862:	6251      	str	r1, [r2, #36]	; 0x24
}
   46864:	e7ee      	b.n	46844 <move_thread_to_end_of_prio_q+0x54>
   46866:	bf00      	nop
   46868:	2001ad6c 	.word	0x2001ad6c

0004686c <z_time_slice>:
{
   4686c:	4601      	mov	r1, r0
   4686e:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   46870:	f04f 0320 	mov.w	r3, #32
   46874:	f3ef 8411 	mrs	r4, BASEPRI
   46878:	f383 8812 	msr	BASEPRI_MAX, r3
   4687c:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   46880:	4b16      	ldr	r3, [pc, #88]	; (468dc <z_time_slice+0x70>)
   46882:	4a17      	ldr	r2, [pc, #92]	; (468e0 <z_time_slice+0x74>)
   46884:	6898      	ldr	r0, [r3, #8]
   46886:	6815      	ldr	r5, [r2, #0]
   46888:	42a8      	cmp	r0, r5
   4688a:	461d      	mov	r5, r3
   4688c:	d106      	bne.n	4689c <z_time_slice+0x30>
			z_reset_time_slice();
   4688e:	f7ff ff2f 	bl	466f0 <z_reset_time_slice>
	__asm__ volatile(
   46892:	f384 8811 	msr	BASEPRI, r4
   46896:	f3bf 8f6f 	isb	sy
}
   4689a:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   4689c:	2600      	movs	r6, #0
   4689e:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   468a0:	4a10      	ldr	r2, [pc, #64]	; (468e4 <z_time_slice+0x78>)
   468a2:	6812      	ldr	r2, [r2, #0]
   468a4:	b1ba      	cbz	r2, 468d6 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   468a6:	89c2      	ldrh	r2, [r0, #14]
   468a8:	2a7f      	cmp	r2, #127	; 0x7f
   468aa:	d814      	bhi.n	468d6 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   468ac:	7b42      	ldrb	r2, [r0, #13]
   468ae:	06d2      	lsls	r2, r2, #27
   468b0:	d111      	bne.n	468d6 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   468b2:	4a0d      	ldr	r2, [pc, #52]	; (468e8 <z_time_slice+0x7c>)
   468b4:	f990 600e 	ldrsb.w	r6, [r0, #14]
   468b8:	6812      	ldr	r2, [r2, #0]
   468ba:	4296      	cmp	r6, r2
   468bc:	db0b      	blt.n	468d6 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   468be:	4a0b      	ldr	r2, [pc, #44]	; (468ec <z_time_slice+0x80>)
   468c0:	4290      	cmp	r0, r2
   468c2:	d008      	beq.n	468d6 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   468c4:	691a      	ldr	r2, [r3, #16]
   468c6:	428a      	cmp	r2, r1
   468c8:	dc02      	bgt.n	468d0 <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   468ca:	f7ff ff91 	bl	467f0 <move_thread_to_end_of_prio_q>
   468ce:	e7de      	b.n	4688e <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   468d0:	1a52      	subs	r2, r2, r1
   468d2:	611a      	str	r2, [r3, #16]
   468d4:	e7dd      	b.n	46892 <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   468d6:	2300      	movs	r3, #0
   468d8:	612b      	str	r3, [r5, #16]
   468da:	e7da      	b.n	46892 <z_time_slice+0x26>
   468dc:	2001ad6c 	.word	0x2001ad6c
   468e0:	2001ad94 	.word	0x2001ad94
   468e4:	2001ad9c 	.word	0x2001ad9c
   468e8:	2001ad98 	.word	0x2001ad98
   468ec:	2001a748 	.word	0x2001a748

000468f0 <ready_thread>:
{
   468f0:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   468f2:	f990 300d 	ldrsb.w	r3, [r0, #13]
   468f6:	7b42      	ldrb	r2, [r0, #13]
   468f8:	2b00      	cmp	r3, #0
   468fa:	db2d      	blt.n	46958 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   468fc:	06d3      	lsls	r3, r2, #27
   468fe:	d12b      	bne.n	46958 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   46900:	6983      	ldr	r3, [r0, #24]
   46902:	bb4b      	cbnz	r3, 46958 <ready_thread+0x68>
	return list->head == list;
   46904:	4915      	ldr	r1, [pc, #84]	; (4695c <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46906:	f062 027f 	orn	r2, r2, #127	; 0x7f
   4690a:	7342      	strb	r2, [r0, #13]
   4690c:	460a      	mov	r2, r1
   4690e:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46912:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46914:	4294      	cmp	r4, r2
   46916:	bf18      	it	ne
   46918:	4623      	movne	r3, r4
   4691a:	2b00      	cmp	r3, #0
   4691c:	bf38      	it	cc
   4691e:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46920:	b1ab      	cbz	r3, 4694e <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   46922:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   46926:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   4692a:	42a6      	cmp	r6, r4
   4692c:	d00b      	beq.n	46946 <ready_thread+0x56>
		return b2 - b1;
   4692e:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46930:	2c00      	cmp	r4, #0
   46932:	dd08      	ble.n	46946 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   46934:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46936:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   4693a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   4693c:	6058      	str	r0, [r3, #4]
		update_cache(0);
   4693e:	2000      	movs	r0, #0
}
   46940:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   46942:	f7ff bf35 	b.w	467b0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46946:	42ab      	cmp	r3, r5
   46948:	d001      	beq.n	4694e <ready_thread+0x5e>
   4694a:	681b      	ldr	r3, [r3, #0]
   4694c:	e7e8      	b.n	46920 <ready_thread+0x30>
	node->prev = tail;
   4694e:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   46952:	6028      	str	r0, [r5, #0]
	list->tail = node;
   46954:	6248      	str	r0, [r1, #36]	; 0x24
}
   46956:	e7f2      	b.n	4693e <ready_thread+0x4e>
}
   46958:	bc70      	pop	{r4, r5, r6}
   4695a:	4770      	bx	lr
   4695c:	2001ad6c 	.word	0x2001ad6c

00046960 <z_sched_start>:
{
   46960:	b510      	push	{r4, lr}
	__asm__ volatile(
   46962:	f04f 0220 	mov.w	r2, #32
   46966:	f3ef 8411 	mrs	r4, BASEPRI
   4696a:	f382 8812 	msr	BASEPRI_MAX, r2
   4696e:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   46972:	7b42      	ldrb	r2, [r0, #13]
   46974:	0751      	lsls	r1, r2, #29
   46976:	d404      	bmi.n	46982 <z_sched_start+0x22>
	__asm__ volatile(
   46978:	f384 8811 	msr	BASEPRI, r4
   4697c:	f3bf 8f6f 	isb	sy
}
   46980:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   46982:	f022 0204 	bic.w	r2, r2, #4
   46986:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   46988:	f7ff ffb2 	bl	468f0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   4698c:	4621      	mov	r1, r4
}
   4698e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   46992:	4801      	ldr	r0, [pc, #4]	; (46998 <z_sched_start+0x38>)
   46994:	f7ff bee6 	b.w	46764 <z_reschedule>
   46998:	20020bac 	.word	0x20020bac

0004699c <unready_thread>:
{
   4699c:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   4699e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   469a2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   469a4:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   469a6:	7b43      	ldrb	r3, [r0, #13]
   469a8:	da04      	bge.n	469b4 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   469aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   469ae:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   469b0:	f001 ffcf 	bl	48952 <sys_dlist_remove>
	update_cache(thread == _current);
   469b4:	4b04      	ldr	r3, [pc, #16]	; (469c8 <unready_thread+0x2c>)
   469b6:	6898      	ldr	r0, [r3, #8]
   469b8:	1a43      	subs	r3, r0, r1
   469ba:	4258      	negs	r0, r3
   469bc:	4158      	adcs	r0, r3
}
   469be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   469c2:	f7ff bef5 	b.w	467b0 <update_cache>
   469c6:	bf00      	nop
   469c8:	2001ad6c 	.word	0x2001ad6c

000469cc <pend>:
{
   469cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   469d0:	4606      	mov	r6, r0
   469d2:	4614      	mov	r4, r2
   469d4:	461d      	mov	r5, r3
	__asm__ volatile(
   469d6:	f04f 0320 	mov.w	r3, #32
   469da:	f3ef 8711 	mrs	r7, BASEPRI
   469de:	f383 8812 	msr	BASEPRI_MAX, r3
   469e2:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   469e6:	f002 f83c 	bl	48a62 <add_to_waitq_locked>
	__asm__ volatile(
   469ea:	f387 8811 	msr	BASEPRI, r7
   469ee:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   469f2:	1c6b      	adds	r3, r5, #1
   469f4:	bf08      	it	eq
   469f6:	f1b4 3fff 	cmpeq.w	r4, #4294967295	; 0xffffffff
   469fa:	d008      	beq.n	46a0e <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   469fc:	4622      	mov	r2, r4
   469fe:	462b      	mov	r3, r5
   46a00:	f106 0018 	add.w	r0, r6, #24
   46a04:	4903      	ldr	r1, [pc, #12]	; (46a14 <pend+0x48>)
}
   46a06:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   46a0a:	f000 ba23 	b.w	46e54 <z_add_timeout>
   46a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46a12:	bf00      	nop
   46a14:	00048a1f 	.word	0x00048a1f

00046a18 <z_pend_curr>:
{
   46a18:	b510      	push	{r4, lr}
   46a1a:	460c      	mov	r4, r1
	pending_current = _current;
   46a1c:	4b06      	ldr	r3, [pc, #24]	; (46a38 <z_pend_curr+0x20>)
{
   46a1e:	4611      	mov	r1, r2
	pending_current = _current;
   46a20:	6898      	ldr	r0, [r3, #8]
   46a22:	4b06      	ldr	r3, [pc, #24]	; (46a3c <z_pend_curr+0x24>)
   46a24:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   46a26:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   46a2a:	f7ff ffcf 	bl	469cc <pend>
   46a2e:	4620      	mov	r0, r4
}
   46a30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   46a34:	f7fb bb44 	b.w	420c0 <arch_swap>
   46a38:	2001ad6c 	.word	0x2001ad6c
   46a3c:	2001ad94 	.word	0x2001ad94

00046a40 <z_set_prio>:
{
   46a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   46a42:	4604      	mov	r4, r0
	__asm__ volatile(
   46a44:	f04f 0320 	mov.w	r3, #32
   46a48:	f3ef 8611 	mrs	r6, BASEPRI
   46a4c:	f383 8812 	msr	BASEPRI_MAX, r3
   46a50:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46a54:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   46a56:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46a58:	06da      	lsls	r2, r3, #27
   46a5a:	d138      	bne.n	46ace <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   46a5c:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   46a5e:	2d00      	cmp	r5, #0
   46a60:	d135      	bne.n	46ace <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46a62:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46a66:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46a68:	f001 ff73 	bl	48952 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   46a6c:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   46a6e:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   46a70:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46a74:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   46a76:	4817      	ldr	r0, [pc, #92]	; (46ad4 <z_set_prio+0x94>)
   46a78:	4603      	mov	r3, r0
   46a7a:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46a7e:	429f      	cmp	r7, r3
   46a80:	bf18      	it	ne
   46a82:	463d      	movne	r5, r7
   46a84:	2d00      	cmp	r5, #0
   46a86:	461a      	mov	r2, r3
   46a88:	462b      	mov	r3, r5
   46a8a:	bf38      	it	cc
   46a8c:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46a8e:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46a90:	b1c3      	cbz	r3, 46ac4 <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   46a92:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46a96:	42a9      	cmp	r1, r5
   46a98:	d010      	beq.n	46abc <z_set_prio+0x7c>
		return b2 - b1;
   46a9a:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   46a9c:	2d00      	cmp	r5, #0
   46a9e:	dd0d      	ble.n	46abc <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   46aa0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46aa2:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   46aa6:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   46aa8:	605c      	str	r4, [r3, #4]
			update_cache(1);
   46aaa:	2001      	movs	r0, #1
   46aac:	f7ff fe80 	bl	467b0 <update_cache>
   46ab0:	2001      	movs	r0, #1
	__asm__ volatile(
   46ab2:	f386 8811 	msr	BASEPRI, r6
   46ab6:	f3bf 8f6f 	isb	sy
}
   46aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   46abc:	42bb      	cmp	r3, r7
   46abe:	d001      	beq.n	46ac4 <z_set_prio+0x84>
   46ac0:	681b      	ldr	r3, [r3, #0]
   46ac2:	e7e5      	b.n	46a90 <z_set_prio+0x50>
	node->prev = tail;
   46ac4:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   46ac8:	603c      	str	r4, [r7, #0]
	list->tail = node;
   46aca:	6244      	str	r4, [r0, #36]	; 0x24
}
   46acc:	e7ed      	b.n	46aaa <z_set_prio+0x6a>
			thread->base.prio = prio;
   46ace:	2000      	movs	r0, #0
   46ad0:	73a1      	strb	r1, [r4, #14]
   46ad2:	e7ee      	b.n	46ab2 <z_set_prio+0x72>
   46ad4:	2001ad6c 	.word	0x2001ad6c

00046ad8 <z_impl_k_thread_suspend>:
{
   46ad8:	b570      	push	{r4, r5, r6, lr}
   46ada:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   46adc:	3018      	adds	r0, #24
   46ade:	f002 f82a 	bl	48b36 <z_abort_timeout>
	__asm__ volatile(
   46ae2:	f04f 0320 	mov.w	r3, #32
   46ae6:	f3ef 8611 	mrs	r6, BASEPRI
   46aea:	f383 8812 	msr	BASEPRI_MAX, r3
   46aee:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   46af2:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46af6:	7b63      	ldrb	r3, [r4, #13]
   46af8:	2a00      	cmp	r2, #0
   46afa:	da05      	bge.n	46b08 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46afc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   46b00:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46b02:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46b04:	f001 ff25 	bl	48952 <sys_dlist_remove>
		update_cache(thread == _current);
   46b08:	4d0b      	ldr	r5, [pc, #44]	; (46b38 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   46b0a:	7b63      	ldrb	r3, [r4, #13]
   46b0c:	68a8      	ldr	r0, [r5, #8]
   46b0e:	f043 0310 	orr.w	r3, r3, #16
   46b12:	7363      	strb	r3, [r4, #13]
   46b14:	1b03      	subs	r3, r0, r4
   46b16:	4258      	negs	r0, r3
   46b18:	4158      	adcs	r0, r3
   46b1a:	f7ff fe49 	bl	467b0 <update_cache>
	__asm__ volatile(
   46b1e:	f386 8811 	msr	BASEPRI, r6
   46b22:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   46b26:	68ab      	ldr	r3, [r5, #8]
   46b28:	42a3      	cmp	r3, r4
   46b2a:	d103      	bne.n	46b34 <z_impl_k_thread_suspend+0x5c>
}
   46b2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   46b30:	f001 bf51 	b.w	489d6 <z_reschedule_unlocked>
}
   46b34:	bd70      	pop	{r4, r5, r6, pc}
   46b36:	bf00      	nop
   46b38:	2001ad6c 	.word	0x2001ad6c

00046b3c <k_sched_unlock>:
{
   46b3c:	b510      	push	{r4, lr}
	__asm__ volatile(
   46b3e:	f04f 0320 	mov.w	r3, #32
   46b42:	f3ef 8411 	mrs	r4, BASEPRI
   46b46:	f383 8812 	msr	BASEPRI_MAX, r3
   46b4a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   46b4e:	4b08      	ldr	r3, [pc, #32]	; (46b70 <k_sched_unlock+0x34>)
		update_cache(0);
   46b50:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   46b52:	689a      	ldr	r2, [r3, #8]
   46b54:	7bd3      	ldrb	r3, [r2, #15]
   46b56:	3301      	adds	r3, #1
   46b58:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   46b5a:	f7ff fe29 	bl	467b0 <update_cache>
	__asm__ volatile(
   46b5e:	f384 8811 	msr	BASEPRI, r4
   46b62:	f3bf 8f6f 	isb	sy
}
   46b66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   46b6a:	f001 bf34 	b.w	489d6 <z_reschedule_unlocked>
   46b6e:	bf00      	nop
   46b70:	2001ad6c 	.word	0x2001ad6c

00046b74 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   46b74:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   46b76:	4b04      	ldr	r3, [pc, #16]	; (46b88 <z_sched_init+0x14>)
   46b78:	4608      	mov	r0, r1
   46b7a:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   46b7e:	e9c3 2208 	strd	r2, r2, [r3, #32]
   46b82:	f7ff bdcb 	b.w	4671c <k_sched_time_slice_set>
   46b86:	bf00      	nop
   46b88:	2001ad6c 	.word	0x2001ad6c

00046b8c <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   46b8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   46b8e:	f04f 0320 	mov.w	r3, #32
   46b92:	f3ef 8411 	mrs	r4, BASEPRI
   46b96:	f383 8812 	msr	BASEPRI_MAX, r3
   46b9a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   46b9e:	491b      	ldr	r1, [pc, #108]	; (46c0c <z_impl_k_yield+0x80>)
   46ba0:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46ba2:	7b43      	ldrb	r3, [r0, #13]
   46ba4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46ba8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46baa:	f001 fed2 	bl	48952 <sys_dlist_remove>
	return list->head == list;
   46bae:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   46bb0:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   46bb2:	7b53      	ldrb	r3, [r2, #13]
   46bb4:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46bb8:	7353      	strb	r3, [r2, #13]
   46bba:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46bbe:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46bc0:	4283      	cmp	r3, r0
   46bc2:	bf08      	it	eq
   46bc4:	2300      	moveq	r3, #0
   46bc6:	2b00      	cmp	r3, #0
   46bc8:	bf38      	it	cc
   46bca:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46bcc:	b1cb      	cbz	r3, 46c02 <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   46bce:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   46bd2:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46bd6:	42af      	cmp	r7, r5
   46bd8:	d00f      	beq.n	46bfa <z_impl_k_yield+0x6e>
		return b2 - b1;
   46bda:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   46bdc:	2d00      	cmp	r5, #0
   46bde:	dd0c      	ble.n	46bfa <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   46be0:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46be2:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   46be6:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   46be8:	605a      	str	r2, [r3, #4]
	update_cache(1);
   46bea:	2001      	movs	r0, #1
   46bec:	f7ff fde0 	bl	467b0 <update_cache>
   46bf0:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   46bf2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   46bf6:	f7fb ba63 	b.w	420c0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   46bfa:	42b3      	cmp	r3, r6
   46bfc:	d001      	beq.n	46c02 <z_impl_k_yield+0x76>
   46bfe:	681b      	ldr	r3, [r3, #0]
   46c00:	e7e4      	b.n	46bcc <z_impl_k_yield+0x40>
	node->prev = tail;
   46c02:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   46c06:	6032      	str	r2, [r6, #0]
	list->tail = node;
   46c08:	624a      	str	r2, [r1, #36]	; 0x24
}
   46c0a:	e7ee      	b.n	46bea <z_impl_k_yield+0x5e>
   46c0c:	2001ad6c 	.word	0x2001ad6c

00046c10 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   46c10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46c14:	4604      	mov	r4, r0
   46c16:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   46c18:	ea54 0105 	orrs.w	r1, r4, r5
   46c1c:	d104      	bne.n	46c28 <z_tick_sleep+0x18>
	z_impl_k_yield();
   46c1e:	f7ff ffb5 	bl	46b8c <z_impl_k_yield>
		k_yield();
		return 0;
   46c22:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   46c24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   46c28:	f06f 0101 	mvn.w	r1, #1
   46c2c:	1a0a      	subs	r2, r1, r0
   46c2e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   46c32:	eb61 0305 	sbc.w	r3, r1, r5
   46c36:	2a01      	cmp	r2, #1
   46c38:	f173 0300 	sbcs.w	r3, r3, #0
   46c3c:	da2a      	bge.n	46c94 <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   46c3e:	f001 ffba 	bl	48bb6 <sys_clock_tick_get_32>
   46c42:	1906      	adds	r6, r0, r4
   46c44:	f04f 0320 	mov.w	r3, #32
   46c48:	f3ef 8811 	mrs	r8, BASEPRI
   46c4c:	f383 8812 	msr	BASEPRI_MAX, r3
   46c50:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   46c54:	4f11      	ldr	r7, [pc, #68]	; (46c9c <z_tick_sleep+0x8c>)
   46c56:	4b12      	ldr	r3, [pc, #72]	; (46ca0 <z_tick_sleep+0x90>)
   46c58:	68b8      	ldr	r0, [r7, #8]
   46c5a:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   46c5c:	f7ff fe9e 	bl	4699c <unready_thread>
	z_add_thread_timeout(_current, timeout);
   46c60:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46c62:	4910      	ldr	r1, [pc, #64]	; (46ca4 <z_tick_sleep+0x94>)
   46c64:	4622      	mov	r2, r4
   46c66:	462b      	mov	r3, r5
   46c68:	3018      	adds	r0, #24
   46c6a:	f000 f8f3 	bl	46e54 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   46c6e:	68ba      	ldr	r2, [r7, #8]
   46c70:	4640      	mov	r0, r8
   46c72:	7b53      	ldrb	r3, [r2, #13]
   46c74:	f043 0310 	orr.w	r3, r3, #16
   46c78:	7353      	strb	r3, [r2, #13]
   46c7a:	f7fb fa21 	bl	420c0 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   46c7e:	f001 ff9a 	bl	48bb6 <sys_clock_tick_get_32>
   46c82:	1a30      	subs	r0, r6, r0
   46c84:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   46c88:	2801      	cmp	r0, #1
   46c8a:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   46c8e:	bfb8      	it	lt
   46c90:	2000      	movlt	r0, #0
   46c92:	e7c7      	b.n	46c24 <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   46c94:	f06f 0601 	mvn.w	r6, #1
   46c98:	1a36      	subs	r6, r6, r0
   46c9a:	e7d3      	b.n	46c44 <z_tick_sleep+0x34>
   46c9c:	2001ad6c 	.word	0x2001ad6c
   46ca0:	2001ad94 	.word	0x2001ad94
   46ca4:	00048a1f 	.word	0x00048a1f

00046ca8 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   46ca8:	b508      	push	{r3, lr}
   46caa:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46cac:	3301      	adds	r3, #1
   46cae:	bf08      	it	eq
   46cb0:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   46cb4:	d003      	beq.n	46cbe <z_impl_k_sleep+0x16>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   46cb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ticks = z_tick_sleep(ticks);
   46cba:	f7ff bfa9 	b.w	46c10 <z_tick_sleep>
		k_thread_suspend(_current);
   46cbe:	4b03      	ldr	r3, [pc, #12]	; (46ccc <z_impl_k_sleep+0x24>)
   46cc0:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   46cc2:	f7ff ff09 	bl	46ad8 <z_impl_k_thread_suspend>
}
   46cc6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   46cca:	bd08      	pop	{r3, pc}
   46ccc:	2001ad6c 	.word	0x2001ad6c

00046cd0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   46cd0:	4b01      	ldr	r3, [pc, #4]	; (46cd8 <z_impl_z_current_get+0x8>)
   46cd2:	6898      	ldr	r0, [r3, #8]
   46cd4:	4770      	bx	lr
   46cd6:	bf00      	nop
   46cd8:	2001ad6c 	.word	0x2001ad6c

00046cdc <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   46cdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46ce0:	4604      	mov	r4, r0
   46ce2:	f04f 0320 	mov.w	r3, #32
   46ce6:	f3ef 8611 	mrs	r6, BASEPRI
   46cea:	f383 8812 	msr	BASEPRI_MAX, r3
   46cee:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   46cf2:	7b43      	ldrb	r3, [r0, #13]
   46cf4:	071a      	lsls	r2, r3, #28
   46cf6:	d505      	bpl.n	46d04 <z_thread_abort+0x28>
	__asm__ volatile(
   46cf8:	f386 8811 	msr	BASEPRI, r6
   46cfc:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   46d00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46d04:	f023 0220 	bic.w	r2, r3, #32
   46d08:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   46d0c:	09d2      	lsrs	r2, r2, #7
   46d0e:	d120      	bne.n	46d52 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46d10:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   46d12:	68a3      	ldr	r3, [r4, #8]
   46d14:	b113      	cbz	r3, 46d1c <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   46d16:	4620      	mov	r0, r4
   46d18:	f001 fe23 	bl	48962 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   46d1c:	f104 0018 	add.w	r0, r4, #24
   46d20:	f001 ff09 	bl	48b36 <z_abort_timeout>
   46d24:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   46d28:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   46d2c:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46d2e:	42bd      	cmp	r5, r7
   46d30:	d000      	beq.n	46d34 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   46d32:	b9b5      	cbnz	r5, 46d62 <z_thread_abort+0x86>
		update_cache(1);
   46d34:	2001      	movs	r0, #1
   46d36:	f7ff fd3b 	bl	467b0 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   46d3a:	4b10      	ldr	r3, [pc, #64]	; (46d7c <z_thread_abort+0xa0>)
   46d3c:	689b      	ldr	r3, [r3, #8]
   46d3e:	42a3      	cmp	r3, r4
   46d40:	d1da      	bne.n	46cf8 <z_thread_abort+0x1c>
   46d42:	f3ef 8305 	mrs	r3, IPSR
   46d46:	2b00      	cmp	r3, #0
   46d48:	d1d6      	bne.n	46cf8 <z_thread_abort+0x1c>
   46d4a:	4630      	mov	r0, r6
   46d4c:	f7fb f9b8 	bl	420c0 <arch_swap>
	return ret;
   46d50:	e7d2      	b.n	46cf8 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46d52:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   46d56:	f043 0308 	orr.w	r3, r3, #8
   46d5a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46d5c:	f001 fdf9 	bl	48952 <sys_dlist_remove>
}
   46d60:	e7d7      	b.n	46d12 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   46d62:	4628      	mov	r0, r5
   46d64:	f001 fdfd 	bl	48962 <unpend_thread_no_timeout>
   46d68:	f105 0018 	add.w	r0, r5, #24
   46d6c:	f001 fee3 	bl	48b36 <z_abort_timeout>
		ready_thread(thread);
   46d70:	4628      	mov	r0, r5
   46d72:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   46d76:	f7ff fdbb 	bl	468f0 <ready_thread>
   46d7a:	e7d7      	b.n	46d2c <z_thread_abort+0x50>
   46d7c:	2001ad6c 	.word	0x2001ad6c

00046d80 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   46d80:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   46d82:	4806      	ldr	r0, [pc, #24]	; (46d9c <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   46d84:	4a06      	ldr	r2, [pc, #24]	; (46da0 <z_data_copy+0x20>)
   46d86:	4907      	ldr	r1, [pc, #28]	; (46da4 <z_data_copy+0x24>)
   46d88:	1a12      	subs	r2, r2, r0
   46d8a:	f001 fa53 	bl	48234 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   46d8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   46d92:	4a05      	ldr	r2, [pc, #20]	; (46da8 <z_data_copy+0x28>)
   46d94:	4905      	ldr	r1, [pc, #20]	; (46dac <z_data_copy+0x2c>)
   46d96:	4806      	ldr	r0, [pc, #24]	; (46db0 <z_data_copy+0x30>)
   46d98:	f001 ba4c 	b.w	48234 <memcpy>
   46d9c:	2001a500 	.word	0x2001a500
   46da0:	2001a654 	.word	0x2001a654
   46da4:	00049c44 	.word	0x00049c44
   46da8:	00000000 	.word	0x00000000
   46dac:	00049c2c 	.word	0x00049c2c
   46db0:	2001a500 	.word	0x2001a500

00046db4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   46db4:	4b03      	ldr	r3, [pc, #12]	; (46dc4 <elapsed+0x10>)
   46db6:	681b      	ldr	r3, [r3, #0]
   46db8:	b90b      	cbnz	r3, 46dbe <elapsed+0xa>
   46dba:	f7fc bddf 	b.w	4397c <sys_clock_elapsed>
}
   46dbe:	2000      	movs	r0, #0
   46dc0:	4770      	bx	lr
   46dc2:	bf00      	nop
   46dc4:	2001ada0 	.word	0x2001ada0

00046dc8 <remove_timeout>:
{
   46dc8:	b530      	push	{r4, r5, lr}
   46dca:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46dcc:	b168      	cbz	r0, 46dea <remove_timeout+0x22>
   46dce:	4a0a      	ldr	r2, [pc, #40]	; (46df8 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   46dd0:	6852      	ldr	r2, [r2, #4]
   46dd2:	4290      	cmp	r0, r2
   46dd4:	d009      	beq.n	46dea <remove_timeout+0x22>
	if (next(t) != NULL) {
   46dd6:	b143      	cbz	r3, 46dea <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   46dd8:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   46ddc:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   46de0:	1912      	adds	r2, r2, r4
   46de2:	eb45 0101 	adc.w	r1, r5, r1
   46de6:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   46dea:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   46dec:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   46dee:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   46df0:	2300      	movs	r3, #0
	node->prev = NULL;
   46df2:	e9c0 3300 	strd	r3, r3, [r0]
}
   46df6:	bd30      	pop	{r4, r5, pc}
   46df8:	2001a58c 	.word	0x2001a58c

00046dfc <next_timeout>:

static int32_t next_timeout(void)
{
   46dfc:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   46dfe:	4b13      	ldr	r3, [pc, #76]	; (46e4c <next_timeout+0x50>)
   46e00:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46e02:	429c      	cmp	r4, r3
   46e04:	bf08      	it	eq
   46e06:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   46e08:	f7ff ffd4 	bl	46db4 <elapsed>
   46e0c:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   46e0e:	b1bc      	cbz	r4, 46e40 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46e10:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   46e14:	1b40      	subs	r0, r0, r5
   46e16:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   46e1a:	2801      	cmp	r0, #1
   46e1c:	f171 0300 	sbcs.w	r3, r1, #0
   46e20:	db11      	blt.n	46e46 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46e22:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   46e26:	2300      	movs	r3, #0
   46e28:	4282      	cmp	r2, r0
   46e2a:	eb73 0401 	sbcs.w	r4, r3, r1
   46e2e:	da00      	bge.n	46e32 <next_timeout+0x36>
   46e30:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   46e32:	4b07      	ldr	r3, [pc, #28]	; (46e50 <next_timeout+0x54>)
   46e34:	691b      	ldr	r3, [r3, #16]
   46e36:	b113      	cbz	r3, 46e3e <next_timeout+0x42>
   46e38:	4298      	cmp	r0, r3
   46e3a:	bfa8      	it	ge
   46e3c:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   46e3e:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   46e40:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   46e44:	e7f5      	b.n	46e32 <next_timeout+0x36>
   46e46:	2000      	movs	r0, #0
   46e48:	e7f3      	b.n	46e32 <next_timeout+0x36>
   46e4a:	bf00      	nop
   46e4c:	2001a58c 	.word	0x2001a58c
   46e50:	2001ad6c 	.word	0x2001ad6c

00046e54 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46e54:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   46e58:	bf08      	it	eq
   46e5a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   46e5e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46e62:	4604      	mov	r4, r0
   46e64:	4692      	mov	sl, r2
   46e66:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46e68:	d073      	beq.n	46f52 <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   46e6a:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   46e6c:	f04f 0320 	mov.w	r3, #32
   46e70:	f3ef 8511 	mrs	r5, BASEPRI
   46e74:	f383 8812 	msr	BASEPRI_MAX, r3
   46e78:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   46e7c:	f06f 0301 	mvn.w	r3, #1
   46e80:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   46e84:	ebb3 080a 	subs.w	r8, r3, sl
   46e88:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   46e8c:	f1b8 0f00 	cmp.w	r8, #0
   46e90:	f179 0100 	sbcs.w	r1, r9, #0
   46e94:	db1c      	blt.n	46ed0 <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   46e96:	4830      	ldr	r0, [pc, #192]	; (46f58 <z_add_timeout+0x104>)
   46e98:	e9d0 1000 	ldrd	r1, r0, [r0]
   46e9c:	1a5b      	subs	r3, r3, r1
   46e9e:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   46ea2:	ebb3 060a 	subs.w	r6, r3, sl
   46ea6:	eb62 070b 	sbc.w	r7, r2, fp
   46eaa:	2e01      	cmp	r6, #1
   46eac:	f177 0300 	sbcs.w	r3, r7, #0
   46eb0:	bfbc      	itt	lt
   46eb2:	2601      	movlt	r6, #1
   46eb4:	2700      	movlt	r7, #0
   46eb6:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   46eba:	4a28      	ldr	r2, [pc, #160]	; (46f5c <z_add_timeout+0x108>)
   46ebc:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46ec0:	4293      	cmp	r3, r2
   46ec2:	d11e      	bne.n	46f02 <z_add_timeout+0xae>
	node->prev = tail;
   46ec4:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   46ec8:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   46ecc:	6054      	str	r4, [r2, #4]
}
   46ece:	e02d      	b.n	46f2c <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   46ed0:	f7ff ff70 	bl	46db4 <elapsed>
   46ed4:	f11a 0301 	adds.w	r3, sl, #1
   46ed8:	9300      	str	r3, [sp, #0]
   46eda:	f14b 0300 	adc.w	r3, fp, #0
   46ede:	9301      	str	r3, [sp, #4]
   46ee0:	e9dd 2300 	ldrd	r2, r3, [sp]
   46ee4:	1812      	adds	r2, r2, r0
   46ee6:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   46eea:	e9c4 2304 	strd	r2, r3, [r4, #16]
   46eee:	e7e4      	b.n	46eba <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   46ef0:	ebb6 0008 	subs.w	r0, r6, r8
   46ef4:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   46ef8:	4563      	cmp	r3, ip
   46efa:	e9c4 0104 	strd	r0, r1, [r4, #16]
   46efe:	d0e1      	beq.n	46ec4 <z_add_timeout+0x70>
   46f00:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   46f02:	2b00      	cmp	r3, #0
   46f04:	d0de      	beq.n	46ec4 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   46f06:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   46f0a:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   46f0e:	4546      	cmp	r6, r8
   46f10:	eb77 0109 	sbcs.w	r1, r7, r9
   46f14:	daec      	bge.n	46ef0 <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   46f16:	ebb8 0006 	subs.w	r0, r8, r6
   46f1a:	eb69 0107 	sbc.w	r1, r9, r7
   46f1e:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   46f22:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46f24:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   46f28:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   46f2a:	605c      	str	r4, [r3, #4]
	return list->head == list;
   46f2c:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f2e:	4293      	cmp	r3, r2
   46f30:	d00b      	beq.n	46f4a <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   46f32:	429c      	cmp	r4, r3
   46f34:	d109      	bne.n	46f4a <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   46f36:	f7ff ff61 	bl	46dfc <next_timeout>

			if (next_time == 0 ||
   46f3a:	b118      	cbz	r0, 46f44 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   46f3c:	4b08      	ldr	r3, [pc, #32]	; (46f60 <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   46f3e:	691b      	ldr	r3, [r3, #16]
   46f40:	4283      	cmp	r3, r0
   46f42:	d002      	beq.n	46f4a <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   46f44:	2100      	movs	r1, #0
   46f46:	f7fc fce5 	bl	43914 <sys_clock_set_timeout>
	__asm__ volatile(
   46f4a:	f385 8811 	msr	BASEPRI, r5
   46f4e:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   46f52:	b003      	add	sp, #12
   46f54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   46f58:	2001a848 	.word	0x2001a848
   46f5c:	2001a58c 	.word	0x2001a58c
   46f60:	2001ad6c 	.word	0x2001ad6c

00046f64 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   46f64:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46f68:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   46f6a:	f7ff fc7f 	bl	4686c <z_time_slice>
	__asm__ volatile(
   46f6e:	f04f 0320 	mov.w	r3, #32
   46f72:	f3ef 8411 	mrs	r4, BASEPRI
   46f76:	f383 8812 	msr	BASEPRI_MAX, r3
   46f7a:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   46f7e:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 47030 <sys_clock_announce+0xcc>
   46f82:	4d2a      	ldr	r5, [pc, #168]	; (4702c <sys_clock_announce+0xc8>)
   46f84:	4651      	mov	r1, sl
	return list->head == list;
   46f86:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 47034 <sys_clock_announce+0xd0>
   46f8a:	602e      	str	r6, [r5, #0]
   46f8c:	f8d5 c000 	ldr.w	ip, [r5]
   46f90:	f8db 0000 	ldr.w	r0, [fp]
   46f94:	4662      	mov	r2, ip
   46f96:	e9da 8900 	ldrd	r8, r9, [sl]
   46f9a:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f9c:	4558      	cmp	r0, fp
   46f9e:	e9cd 2300 	strd	r2, r3, [sp]
   46fa2:	d00d      	beq.n	46fc0 <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   46fa4:	b160      	cbz	r0, 46fc0 <sys_clock_announce+0x5c>
   46fa6:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   46faa:	45b4      	cmp	ip, r6
   46fac:	41bb      	sbcs	r3, r7
   46fae:	da1d      	bge.n	46fec <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   46fb0:	9b00      	ldr	r3, [sp, #0]
   46fb2:	ebb6 0c03 	subs.w	ip, r6, r3
   46fb6:	9b01      	ldr	r3, [sp, #4]
   46fb8:	eb67 0603 	sbc.w	r6, r7, r3
   46fbc:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   46fc0:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   46fc2:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   46fc4:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   46fc6:	eb13 0208 	adds.w	r2, r3, r8
   46fca:	9b01      	ldr	r3, [sp, #4]
   46fcc:	eb43 0309 	adc.w	r3, r3, r9
   46fd0:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   46fd4:	f7ff ff12 	bl	46dfc <next_timeout>
   46fd8:	4631      	mov	r1, r6
   46fda:	f7fc fc9b 	bl	43914 <sys_clock_set_timeout>
	__asm__ volatile(
   46fde:	f384 8811 	msr	BASEPRI, r4
   46fe2:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   46fe6:	b003      	add	sp, #12
   46fe8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   46fec:	2200      	movs	r2, #0
   46fee:	2300      	movs	r3, #0
		curr_tick += dt;
   46ff0:	eb18 0806 	adds.w	r8, r8, r6
   46ff4:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   46ff8:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   46ffc:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   47000:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   47004:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   47006:	f7ff fedf 	bl	46dc8 <remove_timeout>
   4700a:	f384 8811 	msr	BASEPRI, r4
   4700e:	f3bf 8f6f 	isb	sy
		t->fn(t);
   47012:	6883      	ldr	r3, [r0, #8]
   47014:	4798      	blx	r3
	__asm__ volatile(
   47016:	f04f 0320 	mov.w	r3, #32
   4701a:	f3ef 8411 	mrs	r4, BASEPRI
   4701e:	f383 8812 	msr	BASEPRI_MAX, r3
   47022:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   47026:	4902      	ldr	r1, [pc, #8]	; (47030 <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   47028:	e7b0      	b.n	46f8c <sys_clock_announce+0x28>
   4702a:	bf00      	nop
   4702c:	2001ada0 	.word	0x2001ada0
   47030:	2001a848 	.word	0x2001a848
   47034:	2001a58c 	.word	0x2001a58c

00047038 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   47038:	b510      	push	{r4, lr}
   4703a:	f04f 0320 	mov.w	r3, #32
   4703e:	f3ef 8411 	mrs	r4, BASEPRI
   47042:	f383 8812 	msr	BASEPRI_MAX, r3
   47046:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   4704a:	f7fc fc97 	bl	4397c <sys_clock_elapsed>
   4704e:	4b06      	ldr	r3, [pc, #24]	; (47068 <sys_clock_tick_get+0x30>)
   47050:	e9d3 2300 	ldrd	r2, r3, [r3]
   47054:	1812      	adds	r2, r2, r0
   47056:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   4705a:	f384 8811 	msr	BASEPRI, r4
   4705e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   47062:	4610      	mov	r0, r2
   47064:	4619      	mov	r1, r3
   47066:	bd10      	pop	{r4, pc}
   47068:	2001a848 	.word	0x2001a848

0004706c <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   4706c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4706e:	4604      	mov	r4, r0
	__asm__ volatile(
   47070:	f04f 0320 	mov.w	r3, #32
   47074:	f3ef 8511 	mrs	r5, BASEPRI
   47078:	f383 8812 	msr	BASEPRI_MAX, r3
   4707c:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   47080:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   47084:	1c56      	adds	r6, r2, #1
   47086:	f143 0700 	adc.w	r7, r3, #0
   4708a:	2f00      	cmp	r7, #0
   4708c:	bf08      	it	eq
   4708e:	2e02      	cmpeq	r6, #2
   47090:	d302      	bcc.n	47098 <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47092:	4917      	ldr	r1, [pc, #92]	; (470f0 <z_timer_expiration_handler+0x84>)
   47094:	f7ff fede 	bl	46e54 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   47098:	6b23      	ldr	r3, [r4, #48]	; 0x30
   4709a:	3301      	adds	r3, #1
   4709c:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   4709e:	6a23      	ldr	r3, [r4, #32]
   470a0:	b173      	cbz	r3, 470c0 <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   470a2:	f385 8811 	msr	BASEPRI, r5
   470a6:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   470aa:	4620      	mov	r0, r4
   470ac:	6a23      	ldr	r3, [r4, #32]
   470ae:	4798      	blx	r3
	__asm__ volatile(
   470b0:	f04f 0320 	mov.w	r3, #32
   470b4:	f3ef 8511 	mrs	r5, BASEPRI
   470b8:	f383 8812 	msr	BASEPRI_MAX, r3
   470bc:	f3bf 8f6f 	isb	sy
	return list->head == list;
   470c0:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   470c4:	42a6      	cmp	r6, r4
   470c6:	d000      	beq.n	470ca <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   470c8:	b926      	cbnz	r6, 470d4 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   470ca:	f385 8811 	msr	BASEPRI, r5
   470ce:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   470d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   470d4:	4630      	mov	r0, r6
   470d6:	f001 fc4e 	bl	48976 <z_unpend_thread_no_timeout>
   470da:	2300      	movs	r3, #0
   470dc:	67b3      	str	r3, [r6, #120]	; 0x78
   470de:	f385 8811 	msr	BASEPRI, r5
   470e2:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   470e6:	4630      	mov	r0, r6
}
   470e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   470ec:	f001 bc87 	b.w	489fe <z_ready_thread>
   470f0:	0004706d 	.word	0x0004706d

000470f4 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   470f4:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   470f8:	4619      	mov	r1, r3
   470fa:	4606      	mov	r6, r0
   470fc:	4610      	mov	r0, r2
   470fe:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   47102:	1c4c      	adds	r4, r1, #1
   47104:	bf08      	it	eq
   47106:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   4710a:	4680      	mov	r8, r0
   4710c:	4689      	mov	r9, r1
   4710e:	d04c      	beq.n	471aa <z_impl_k_timer_start+0xb6>
   47110:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   47112:	1c6b      	adds	r3, r5, #1
   47114:	bf08      	it	eq
   47116:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   4711a:	4614      	mov	r4, r2
   4711c:	d019      	beq.n	47152 <z_impl_k_timer_start+0x5e>
   4711e:	ea54 0305 	orrs.w	r3, r4, r5
   47122:	d016      	beq.n	47152 <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   47124:	f06f 0301 	mvn.w	r3, #1
   47128:	ebb3 0a02 	subs.w	sl, r3, r2
   4712c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   47130:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   47134:	f1ba 0f00 	cmp.w	sl, #0
   47138:	f17b 0300 	sbcs.w	r3, fp, #0
   4713c:	da09      	bge.n	47152 <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   4713e:	f112 34ff 	adds.w	r4, r2, #4294967295	; 0xffffffff
   47142:	f145 35ff 	adc.w	r5, r5, #4294967295	; 0xffffffff
   47146:	2c01      	cmp	r4, #1
   47148:	f175 0300 	sbcs.w	r3, r5, #0
   4714c:	bfbc      	itt	lt
   4714e:	2401      	movlt	r4, #1
   47150:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   47152:	f06f 0301 	mvn.w	r3, #1
   47156:	1a1b      	subs	r3, r3, r0
   47158:	9300      	str	r3, [sp, #0]
   4715a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4715e:	eb63 0301 	sbc.w	r3, r3, r1
   47162:	9301      	str	r3, [sp, #4]
   47164:	e9dd 2300 	ldrd	r2, r3, [sp]
   47168:	2a00      	cmp	r2, #0
   4716a:	f173 0300 	sbcs.w	r3, r3, #0
   4716e:	da0c      	bge.n	4718a <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   47170:	f110 38ff 	adds.w	r8, r0, #4294967295	; 0xffffffff
   47174:	f141 39ff 	adc.w	r9, r1, #4294967295	; 0xffffffff
   47178:	f1b8 0f00 	cmp.w	r8, #0
   4717c:	f179 0300 	sbcs.w	r3, r9, #0
   47180:	bfbc      	itt	lt
   47182:	f04f 0800 	movlt.w	r8, #0
   47186:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   4718a:	4630      	mov	r0, r6
   4718c:	f001 fcd3 	bl	48b36 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   47190:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47192:	4642      	mov	r2, r8
	timer->status = 0U;
   47194:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47196:	4630      	mov	r0, r6
   47198:	464b      	mov	r3, r9
   4719a:	4905      	ldr	r1, [pc, #20]	; (471b0 <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   4719c:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   471a0:	b002      	add	sp, #8
   471a2:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   471a6:	f7ff be55 	b.w	46e54 <z_add_timeout>
}
   471aa:	b002      	add	sp, #8
   471ac:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   471b0:	0004706d 	.word	0x0004706d

000471b4 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   471b4:	4a02      	ldr	r2, [pc, #8]	; (471c0 <boot_banner+0xc>)
   471b6:	4903      	ldr	r1, [pc, #12]	; (471c4 <boot_banner+0x10>)
   471b8:	4803      	ldr	r0, [pc, #12]	; (471c8 <boot_banner+0x14>)
   471ba:	f000 b987 	b.w	474cc <printk>
   471be:	bf00      	nop
   471c0:	000494e0 	.word	0x000494e0
   471c4:	00049bf5 	.word	0x00049bf5
   471c8:	00049c04 	.word	0x00049c04

000471cc <tfm_platform_system_reset>:
#include "tfm_ns_interface.h"
#include "tfm_veneers.h"

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   471cc:	2300      	movs	r3, #0
{
   471ce:	b507      	push	{r0, r1, r2, lr}
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   471d0:	461a      	mov	r2, r3
   471d2:	4619      	mov	r1, r3
   471d4:	9300      	str	r3, [sp, #0]
   471d6:	4803      	ldr	r0, [pc, #12]	; (471e4 <tfm_platform_system_reset+0x18>)
   471d8:	f7fc fd9c 	bl	43d14 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_platform_sp_system_reset_veneer,
                                0,
                                0,
                                0,
                                0);
}
   471dc:	b003      	add	sp, #12
   471de:	f85d fb04 	ldr.w	pc, [sp], #4
   471e2:	bf00      	nop
   471e4:	00037e41 	.word	0x00037e41

000471e8 <psa_import_key>:

psa_status_t psa_import_key(const psa_key_attributes_t *attributes,
                            const uint8_t *data,
                            size_t data_length,
                            psa_key_id_t *key)
{
   471e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   471ea:	b097      	sub	sp, #92	; 0x5c
   471ec:	4607      	mov	r7, r0
   471ee:	460e      	mov	r6, r1
   471f0:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   471f2:	2100      	movs	r1, #0
   471f4:	2228      	movs	r2, #40	; 0x28
   471f6:	a80c      	add	r0, sp, #48	; 0x30
{
   471f8:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   471fa:	f001 f826 	bl	4824a <memset>
        .sfn_id = TFM_CRYPTO_IMPORT_KEY_SID,
    };
    psa_invec in_vec[] = {
   471fe:	aa0b      	add	r2, sp, #44	; 0x2c
    struct tfm_crypto_pack_iovec iov = {
   47200:	2304      	movs	r3, #4
    psa_invec in_vec[] = {
   47202:	9205      	str	r2, [sp, #20]
   47204:	222c      	movs	r2, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
        {.base = data, .len = data_length}
    };
    psa_outvec out_vec[] = {
   47206:	e9cd 4303 	strd	r4, r3, [sp, #12]
    psa_invec in_vec[] = {
   4720a:	e9cd 2706 	strd	r2, r7, [sp, #24]
    struct tfm_crypto_pack_iovec iov = {
   4720e:	930b      	str	r3, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   47210:	2214      	movs	r2, #20
        {.base = key, .len = sizeof(psa_key_id_t)}
    };

    status = API_DISPATCH(tfm_crypto_import_key,
   47212:	2301      	movs	r3, #1
    psa_invec in_vec[] = {
   47214:	e9cd 2608 	strd	r2, r6, [sp, #32]
    status = API_DISPATCH(tfm_crypto_import_key,
   47218:	9300      	str	r3, [sp, #0]
   4721a:	2203      	movs	r2, #3
   4721c:	ab03      	add	r3, sp, #12
   4721e:	a905      	add	r1, sp, #20
   47220:	4802      	ldr	r0, [pc, #8]	; (4722c <psa_import_key+0x44>)
    psa_invec in_vec[] = {
   47222:	950a      	str	r5, [sp, #40]	; 0x28
    status = API_DISPATCH(tfm_crypto_import_key,
   47224:	f7fc fd76 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_IMPORT_KEY);

    return status;
}
   47228:	b017      	add	sp, #92	; 0x5c
   4722a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4722c:	00037e91 	.word	0x00037e91

00047230 <psa_destroy_key>:

psa_status_t psa_destroy_key(psa_key_id_t key)
{
   47230:	b510      	push	{r4, lr}
   47232:	b090      	sub	sp, #64	; 0x40
   47234:	4604      	mov	r4, r0
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47236:	2228      	movs	r2, #40	; 0x28
   47238:	2100      	movs	r1, #0
   4723a:	a806      	add	r0, sp, #24
   4723c:	f001 f805 	bl	4824a <memset>
   47240:	2305      	movs	r3, #5
   47242:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_id = key,
    };
    psa_invec in_vec[] = {
   47244:	ab05      	add	r3, sp, #20
   47246:	9303      	str	r3, [sp, #12]
   47248:	232c      	movs	r3, #44	; 0x2c
   4724a:	9304      	str	r3, [sp, #16]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
   4724c:	2300      	movs	r3, #0
   4724e:	2201      	movs	r2, #1
   47250:	9300      	str	r3, [sp, #0]
   47252:	a903      	add	r1, sp, #12
   47254:	4802      	ldr	r0, [pc, #8]	; (47260 <psa_destroy_key+0x30>)
    struct tfm_crypto_pack_iovec iov = {
   47256:	9407      	str	r4, [sp, #28]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
   47258:	f7fc fd5c 	bl	43d14 <tfm_ns_interface_dispatch>
                                    TFM_CRYPTO_DESTROY_KEY);

    return status;
}
   4725c:	b010      	add	sp, #64	; 0x40
   4725e:	bd10      	pop	{r4, pc}
   47260:	00037d09 	.word	0x00037d09

00047264 <psa_reset_key_attributes>:
                          TFM_CRYPTO_GET_KEY_ATTRIBUTES);
    return status;
}

void psa_reset_key_attributes(psa_key_attributes_t *attributes)
{
   47264:	b510      	push	{r4, lr}
   47266:	b092      	sub	sp, #72	; 0x48
   47268:	4604      	mov	r4, r0
    struct tfm_crypto_pack_iovec iov = {
   4726a:	2228      	movs	r2, #40	; 0x28
   4726c:	2100      	movs	r1, #0
   4726e:	a808      	add	r0, sp, #32
   47270:	f000 ffeb 	bl	4824a <memset>
        .sfn_id = TFM_CRYPTO_RESET_KEY_ATTRIBUTES_SID,
    };
    psa_invec in_vec[] = {
   47274:	ab07      	add	r3, sp, #28
   47276:	9303      	str	r3, [sp, #12]
   47278:	232c      	movs	r3, #44	; 0x2c
    struct tfm_crypto_pack_iovec iov = {
   4727a:	2201      	movs	r2, #1
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
   4727c:	e9cd 3404 	strd	r3, r4, [sp, #16]
   47280:	2314      	movs	r3, #20
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
    };

    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   47282:	9200      	str	r2, [sp, #0]
    psa_outvec out_vec[] = {
   47284:	9306      	str	r3, [sp, #24]
    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   47286:	a903      	add	r1, sp, #12
   47288:	446b      	add	r3, sp
   4728a:	4803      	ldr	r0, [pc, #12]	; (47298 <psa_reset_key_attributes+0x34>)
    struct tfm_crypto_pack_iovec iov = {
   4728c:	9207      	str	r2, [sp, #28]
    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   4728e:	f7fc fd41 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_RESET_KEY_ATTRIBUTES);
    return;
}
   47292:	b012      	add	sp, #72	; 0x48
   47294:	bd10      	pop	{r4, pc}
   47296:	bf00      	nop
   47298:	00037d69 	.word	0x00037d69

0004729c <psa_export_public_key>:

psa_status_t psa_export_public_key(psa_key_id_t key,
                                   uint8_t *data,
                                   size_t data_size,
                                   size_t *data_length)
{
   4729c:	b5f0      	push	{r4, r5, r6, r7, lr}
   4729e:	b093      	sub	sp, #76	; 0x4c
   472a0:	4607      	mov	r7, r0
   472a2:	460e      	mov	r6, r1
   472a4:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   472a6:	2100      	movs	r1, #0
   472a8:	2228      	movs	r2, #40	; 0x28
   472aa:	a808      	add	r0, sp, #32
{
   472ac:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   472ae:	f000 ffcc 	bl	4824a <memset>
   472b2:	2307      	movs	r3, #7
   472b4:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_EXPORT_PUBLIC_KEY_SID,
        .key_id = key,
    };

    psa_invec in_vec[] = {
   472b6:	ab07      	add	r3, sp, #28
    };
    psa_outvec out_vec[] = {
        {.base = data, .len = data_size}
    };

    status = API_DISPATCH(tfm_crypto_export_public_key,
   472b8:	2201      	movs	r2, #1
    psa_invec in_vec[] = {
   472ba:	9303      	str	r3, [sp, #12]
   472bc:	232c      	movs	r3, #44	; 0x2c
    status = API_DISPATCH(tfm_crypto_export_public_key,
   472be:	9200      	str	r2, [sp, #0]
    psa_outvec out_vec[] = {
   472c0:	e9cd 3604 	strd	r3, r6, [sp, #16]
    status = API_DISPATCH(tfm_crypto_export_public_key,
   472c4:	a903      	add	r1, sp, #12
   472c6:	ab05      	add	r3, sp, #20
   472c8:	4804      	ldr	r0, [pc, #16]	; (472dc <psa_export_public_key+0x40>)
    struct tfm_crypto_pack_iovec iov = {
   472ca:	9709      	str	r7, [sp, #36]	; 0x24
    psa_outvec out_vec[] = {
   472cc:	9506      	str	r5, [sp, #24]
    status = API_DISPATCH(tfm_crypto_export_public_key,
   472ce:	f7fc fd21 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_EXPORT_PUBLIC_KEY);

    *data_length = out_vec[0].len;
   472d2:	9b06      	ldr	r3, [sp, #24]
   472d4:	6023      	str	r3, [r4, #0]

    return status;
}
   472d6:	b013      	add	sp, #76	; 0x4c
   472d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   472da:	bf00      	nop
   472dc:	00037e79 	.word	0x00037e79

000472e0 <psa_hash_compute>:
                              const uint8_t *input,
                              size_t input_length,
                              uint8_t *hash,
                              size_t hash_size,
                              size_t *hash_length)
{
   472e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   472e2:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   472e4:	2228      	movs	r2, #40	; 0x28
{
   472e6:	b095      	sub	sp, #84	; 0x54
   472e8:	4607      	mov	r7, r0
   472ea:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   472ec:	eb0d 0002 	add.w	r0, sp, r2
   472f0:	2100      	movs	r1, #0
{
   472f2:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   472f4:	f000 ffa9 	bl	4824a <memset>
   472f8:	230a      	movs	r3, #10
   472fa:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_HASH_COMPUTE_SID,
        .alg = alg,
    };

    psa_invec in_vec[] = {
   472fc:	ab09      	add	r3, sp, #36	; 0x24
   472fe:	9305      	str	r3, [sp, #20]
   47300:	232c      	movs	r3, #44	; 0x2c
   47302:	e9cd 3606 	strd	r3, r6, [sp, #24]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = input, .len = input_length},
    };

    psa_outvec out_vec[] = {
   47306:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = hash, .len = hash_size}
    };

    status = API_DISPATCH(tfm_crypto_hash_compute,
   47308:	2202      	movs	r2, #2
    psa_outvec out_vec[] = {
   4730a:	9304      	str	r3, [sp, #16]
    status = API_DISPATCH(tfm_crypto_hash_compute,
   4730c:	2301      	movs	r3, #1
   4730e:	a905      	add	r1, sp, #20
   47310:	9300      	str	r3, [sp, #0]
   47312:	4806      	ldr	r0, [pc, #24]	; (4732c <psa_hash_compute+0x4c>)
   47314:	ab03      	add	r3, sp, #12
    struct tfm_crypto_pack_iovec iov = {
   47316:	970c      	str	r7, [sp, #48]	; 0x30
    psa_invec in_vec[] = {
   47318:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
   4731a:	9403      	str	r4, [sp, #12]
    status = API_DISPATCH(tfm_crypto_hash_compute,
   4731c:	f7fc fcfa 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_HASH_COMPUTE);

    *hash_length = out_vec[0].len;
   47320:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   47322:	9a04      	ldr	r2, [sp, #16]
   47324:	601a      	str	r2, [r3, #0]

    return status;
}
   47326:	b015      	add	sp, #84	; 0x54
   47328:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4732a:	bf00      	nop
   4732c:	00037c81 	.word	0x00037c81

00047330 <psa_sign_hash>:
                           const uint8_t *hash,
                           size_t hash_length,
                           uint8_t *signature,
                           size_t signature_size,
                           size_t *signature_length)
{
   47330:	b5f0      	push	{r4, r5, r6, r7, lr}
   47332:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47334:	2228      	movs	r2, #40	; 0x28
{
   47336:	b095      	sub	sp, #84	; 0x54
   47338:	4607      	mov	r7, r0
   4733a:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   4733c:	eb0d 0002 	add.w	r0, sp, r2
   47340:	2100      	movs	r1, #0
{
   47342:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   47344:	f000 ff81 	bl	4824a <memset>
   47348:	2331      	movs	r3, #49	; 0x31
   4734a:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_SIGN_HASH_SID,
        .key_id = key,
        .alg = alg,
    };

    psa_invec in_vec[] = {
   4734c:	ab09      	add	r3, sp, #36	; 0x24
   4734e:	9305      	str	r3, [sp, #20]
   47350:	232c      	movs	r3, #44	; 0x2c
   47352:	e9cd 3506 	strd	r3, r5, [sp, #24]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = hash, .len = hash_length},
    };
    psa_outvec out_vec[] = {
   47356:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = signature, .len = signature_size},
    };

    status = API_DISPATCH(tfm_crypto_sign_hash,
   47358:	2202      	movs	r2, #2
    psa_outvec out_vec[] = {
   4735a:	9303      	str	r3, [sp, #12]
   4735c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    status = API_DISPATCH(tfm_crypto_sign_hash,
   4735e:	a905      	add	r1, sp, #20
    psa_outvec out_vec[] = {
   47360:	9304      	str	r3, [sp, #16]
    status = API_DISPATCH(tfm_crypto_sign_hash,
   47362:	2301      	movs	r3, #1
   47364:	4806      	ldr	r0, [pc, #24]	; (47380 <psa_sign_hash+0x50>)
   47366:	9300      	str	r3, [sp, #0]
   47368:	ab03      	add	r3, sp, #12
    struct tfm_crypto_pack_iovec iov = {
   4736a:	e9cd 760b 	strd	r7, r6, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   4736e:	9408      	str	r4, [sp, #32]
    status = API_DISPATCH(tfm_crypto_sign_hash,
   47370:	f7fc fcd0 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_SIGN_HASH);

    *signature_length = out_vec[0].len;
   47374:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   47376:	9a04      	ldr	r2, [sp, #16]
   47378:	601a      	str	r2, [r3, #0]

    return status;
}
   4737a:	b015      	add	sp, #84	; 0x54
   4737c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4737e:	bf00      	nop
   47380:	00037d79 	.word	0x00037d79

00047384 <psa_verify_hash>:
                             psa_algorithm_t alg,
                             const uint8_t *hash,
                             size_t hash_length,
                             const uint8_t *signature,
                             size_t signature_length)
{
   47384:	b5f0      	push	{r4, r5, r6, r7, lr}
   47386:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47388:	2228      	movs	r2, #40	; 0x28
{
   4738a:	b095      	sub	sp, #84	; 0x54
   4738c:	4607      	mov	r7, r0
   4738e:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   47390:	eb0d 0002 	add.w	r0, sp, r2
   47394:	2100      	movs	r1, #0
{
   47396:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   47398:	f000 ff57 	bl	4824a <memset>
   4739c:	2332      	movs	r3, #50	; 0x32
   4739e:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_VERIFY_HASH_SID,
        .key_id = key,
        .alg = alg
    };

    psa_invec in_vec[] = {
   473a0:	ab09      	add	r3, sp, #36	; 0x24
   473a2:	9303      	str	r3, [sp, #12]
   473a4:	232c      	movs	r3, #44	; 0x2c
   473a6:	e9cd 3504 	strd	r3, r5, [sp, #16]
   473aa:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = hash, .len = hash_length},
        {.base = signature, .len = signature_length}
    };

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   473ac:	2203      	movs	r2, #3
    psa_invec in_vec[] = {
   473ae:	9307      	str	r3, [sp, #28]
   473b0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   473b2:	a903      	add	r1, sp, #12
    psa_invec in_vec[] = {
   473b4:	9308      	str	r3, [sp, #32]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   473b6:	2300      	movs	r3, #0
   473b8:	4804      	ldr	r0, [pc, #16]	; (473cc <psa_verify_hash+0x48>)
   473ba:	9300      	str	r3, [sp, #0]
    struct tfm_crypto_pack_iovec iov = {
   473bc:	e9cd 760b 	strd	r7, r6, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   473c0:	9406      	str	r4, [sp, #24]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   473c2:	f7fc fca7 	bl	43d14 <tfm_ns_interface_dispatch>
                                    TFM_CRYPTO_VERIFY_HASH);

    return status;
}
   473c6:	b015      	add	sp, #84	; 0x54
   473c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   473ca:	bf00      	nop
   473cc:	00037db9 	.word	0x00037db9

000473d0 <psa_generate_random>:
    return status;
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   473d0:	b530      	push	{r4, r5, lr}
   473d2:	b093      	sub	sp, #76	; 0x4c
   473d4:	4605      	mov	r5, r0
   473d6:	460c      	mov	r4, r1
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   473d8:	2228      	movs	r2, #40	; 0x28
   473da:	2100      	movs	r1, #0
   473dc:	a808      	add	r0, sp, #32
   473de:	f000 ff34 	bl	4824a <memset>
   473e2:	233f      	movs	r3, #63	; 0x3f
   473e4:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_GENERATE_RANDOM_SID,
    };

    psa_invec in_vec[] = {
   473e6:	ab07      	add	r3, sp, #28
   473e8:	9303      	str	r3, [sp, #12]
   473ea:	232c      	movs	r3, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   473ec:	9406      	str	r4, [sp, #24]
   473ee:	e9cd 3504 	strd	r3, r5, [sp, #16]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   473f2:	b144      	cbz	r4, 47406 <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    status = API_DISPATCH(tfm_crypto_generate_random,
   473f4:	2201      	movs	r2, #1
   473f6:	4805      	ldr	r0, [pc, #20]	; (4740c <psa_generate_random+0x3c>)
   473f8:	9200      	str	r2, [sp, #0]
   473fa:	ab05      	add	r3, sp, #20
   473fc:	a903      	add	r1, sp, #12
   473fe:	f7fc fc89 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_RANDOM);

    return status;
}
   47402:	b013      	add	sp, #76	; 0x4c
   47404:	bd30      	pop	{r4, r5, pc}
        return PSA_SUCCESS;
   47406:	4620      	mov	r0, r4
   47408:	e7fb      	b.n	47402 <psa_generate_random+0x32>
   4740a:	bf00      	nop
   4740c:	00037c11 	.word	0x00037c11

00047410 <psa_generate_key>:

psa_status_t psa_generate_key(const psa_key_attributes_t *attributes,
                              psa_key_id_t *key)
{
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47410:	2228      	movs	r2, #40	; 0x28
{
   47412:	b530      	push	{r4, r5, lr}
   47414:	b095      	sub	sp, #84	; 0x54
   47416:	4605      	mov	r5, r0
   47418:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
   4741a:	eb0d 0002 	add.w	r0, sp, r2
   4741e:	2100      	movs	r1, #0
   47420:	f000 ff13 	bl	4824a <memset>
   47424:	2340      	movs	r3, #64	; 0x40
   47426:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_GENERATE_KEY_SID,
    };

    psa_invec in_vec[] = {
   47428:	ab09      	add	r3, sp, #36	; 0x24
   4742a:	9305      	str	r3, [sp, #20]
   4742c:	232c      	movs	r3, #44	; 0x2c
   4742e:	e9cd 3506 	strd	r3, r5, [sp, #24]
   47432:	2314      	movs	r3, #20
   47434:	9308      	str	r3, [sp, #32]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
    };

    psa_outvec out_vec[] = {
   47436:	2304      	movs	r3, #4
   47438:	9304      	str	r3, [sp, #16]
        {.base = key, .len = sizeof(psa_key_id_t)},
    };

    status = API_DISPATCH(tfm_crypto_generate_key,
   4743a:	2301      	movs	r3, #1
   4743c:	2202      	movs	r2, #2
   4743e:	9300      	str	r3, [sp, #0]
   47440:	a905      	add	r1, sp, #20
   47442:	ab03      	add	r3, sp, #12
   47444:	4802      	ldr	r0, [pc, #8]	; (47450 <psa_generate_key+0x40>)
    psa_outvec out_vec[] = {
   47446:	9403      	str	r4, [sp, #12]
    status = API_DISPATCH(tfm_crypto_generate_key,
   47448:	f7fc fc64 	bl	43d14 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_KEY);

    return status;
}
   4744c:	b015      	add	sp, #84	; 0x54
   4744e:	bd30      	pop	{r4, r5, pc}
   47450:	00037df9 	.word	0x00037df9

00047454 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   47454:	4770      	bx	lr

00047456 <crypto_init>:
{
   47456:	b508      	push	{r3, lr}
	status = psa_crypto_init();
   47458:	f001 fc09 	bl	48c6e <psa_crypto_init>
	if (status != PSA_SUCCESS)
   4745c:	3800      	subs	r0, #0
   4745e:	bf18      	it	ne
   47460:	2001      	movne	r0, #1
}
   47462:	4240      	negs	r0, r0
   47464:	bd08      	pop	{r3, pc}

00047466 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   47466:	4603      	mov	r3, r0
   47468:	b158      	cbz	r0, 47482 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   4746a:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   4746c:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   47470:	2a01      	cmp	r2, #1
   47472:	d003      	beq.n	4747c <sys_notify_validate+0x16>
   47474:	2a03      	cmp	r2, #3
   47476:	d104      	bne.n	47482 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   47478:	6802      	ldr	r2, [r0, #0]
   4747a:	b112      	cbz	r2, 47482 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   4747c:	2000      	movs	r0, #0
   4747e:	6098      	str	r0, [r3, #8]
   47480:	4770      	bx	lr
		return -EINVAL;
   47482:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   47486:	4770      	bx	lr

00047488 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   47488:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   4748a:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   4748c:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   47490:	2a03      	cmp	r2, #3
   47492:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   47496:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   47498:	bf14      	ite	ne
   4749a:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   4749c:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   4749e:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   474a0:	4770      	bx	lr

000474a2 <arch_printk_char_out>:
}
   474a2:	2000      	movs	r0, #0
   474a4:	4770      	bx	lr

000474a6 <str_out>:
{
   474a6:	b530      	push	{r4, r5, lr}
   474a8:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   474aa:	680c      	ldr	r4, [r1, #0]
   474ac:	1c55      	adds	r5, r2, #1
   474ae:	b114      	cbz	r4, 474b6 <str_out+0x10>
   474b0:	684b      	ldr	r3, [r1, #4]
   474b2:	4293      	cmp	r3, r2
   474b4:	dc01      	bgt.n	474ba <str_out+0x14>
		ctx->count++;
   474b6:	608d      	str	r5, [r1, #8]
}
   474b8:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   474ba:	3b01      	subs	r3, #1
   474bc:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   474be:	bf08      	it	eq
   474c0:	2200      	moveq	r2, #0
   474c2:	608d      	str	r5, [r1, #8]
   474c4:	bf0c      	ite	eq
   474c6:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   474c8:	54a0      	strbne	r0, [r4, r2]
   474ca:	e7f5      	b.n	474b8 <str_out+0x12>

000474cc <printk>:
{
   474cc:	b40f      	push	{r0, r1, r2, r3}
   474ce:	b507      	push	{r0, r1, r2, lr}
   474d0:	a904      	add	r1, sp, #16
   474d2:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   474d6:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   474d8:	f7f9 f978 	bl	407cc <vprintk>
}
   474dc:	b003      	add	sp, #12
   474de:	f85d eb04 	ldr.w	lr, [sp], #4
   474e2:	b004      	add	sp, #16
   474e4:	4770      	bx	lr

000474e6 <snprintk>:
{
   474e6:	b40c      	push	{r2, r3}
   474e8:	b507      	push	{r0, r1, r2, lr}
   474ea:	ab04      	add	r3, sp, #16
   474ec:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   474f0:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   474f2:	f7f9 f979 	bl	407e8 <vsnprintk>
}
   474f6:	b003      	add	sp, #12
   474f8:	f85d eb04 	ldr.w	lr, [sp], #4
   474fc:	b002      	add	sp, #8
   474fe:	4770      	bx	lr

00047500 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47500:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   47502:	f013 0307 	ands.w	r3, r3, #7
   47506:	d105      	bne.n	47514 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   47508:	6803      	ldr	r3, [r0, #0]
   4750a:	2b00      	cmp	r3, #0
		evt = EVT_START;
   4750c:	bf0c      	ite	eq
   4750e:	2000      	moveq	r0, #0
   47510:	2003      	movne	r0, #3
   47512:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   47514:	2b02      	cmp	r3, #2
   47516:	d105      	bne.n	47524 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   47518:	8b43      	ldrh	r3, [r0, #26]
   4751a:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   4751c:	bf14      	ite	ne
   4751e:	2000      	movne	r0, #0
   47520:	2004      	moveq	r0, #4
   47522:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   47524:	2b01      	cmp	r3, #1
   47526:	d105      	bne.n	47534 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   47528:	6803      	ldr	r3, [r0, #0]
   4752a:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   4752c:	bf0c      	ite	eq
   4752e:	2000      	moveq	r0, #0
   47530:	2005      	movne	r0, #5
   47532:	4770      	bx	lr
	int evt = EVT_NOP;
   47534:	2000      	movs	r0, #0
}
   47536:	4770      	bx	lr

00047538 <notify_one>:
{
   47538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4753c:	460d      	mov	r5, r1
   4753e:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47540:	4619      	mov	r1, r3
   47542:	1d28      	adds	r0, r5, #4
{
   47544:	4690      	mov	r8, r2
   47546:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47548:	f7ff ff9e 	bl	47488 <sys_notify_finalize>
	if (cb) {
   4754c:	4604      	mov	r4, r0
   4754e:	b138      	cbz	r0, 47560 <notify_one+0x28>
		cb(mgr, cli, state, res);
   47550:	4633      	mov	r3, r6
   47552:	4642      	mov	r2, r8
   47554:	4629      	mov	r1, r5
   47556:	4638      	mov	r0, r7
   47558:	46a4      	mov	ip, r4
}
   4755a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   4755e:	4760      	bx	ip
}
   47560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047564 <transition_complete>:
{
   47564:	b410      	push	{r4}
	__asm__ volatile(
   47566:	f04f 0420 	mov.w	r4, #32
   4756a:	f3ef 8211 	mrs	r2, BASEPRI
   4756e:	f384 8812 	msr	BASEPRI_MAX, r4
   47572:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   47576:	6141      	str	r1, [r0, #20]
}
   47578:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   4757a:	2101      	movs	r1, #1
   4757c:	f7f9 b948 	b.w	40810 <process_event>

00047580 <validate_args>:
{
   47580:	b510      	push	{r4, lr}
   47582:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   47584:	b140      	cbz	r0, 47598 <validate_args+0x18>
   47586:	b139      	cbz	r1, 47598 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   47588:	1d08      	adds	r0, r1, #4
   4758a:	f7ff ff6c 	bl	47466 <sys_notify_validate>
	if ((rv == 0)
   4758e:	b928      	cbnz	r0, 4759c <validate_args+0x1c>
	    && ((cli->notify.flags
   47590:	68a3      	ldr	r3, [r4, #8]
   47592:	f033 0303 	bics.w	r3, r3, #3
   47596:	d001      	beq.n	4759c <validate_args+0x1c>
		rv = -EINVAL;
   47598:	f06f 0015 	mvn.w	r0, #21
}
   4759c:	bd10      	pop	{r4, pc}

0004759e <onoff_manager_init>:
{
   4759e:	b538      	push	{r3, r4, r5, lr}
   475a0:	460c      	mov	r4, r1
	if ((mgr == NULL)
   475a2:	4605      	mov	r5, r0
   475a4:	b158      	cbz	r0, 475be <onoff_manager_init+0x20>
	    || (transitions == NULL)
   475a6:	b151      	cbz	r1, 475be <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   475a8:	680b      	ldr	r3, [r1, #0]
   475aa:	b143      	cbz	r3, 475be <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   475ac:	684b      	ldr	r3, [r1, #4]
   475ae:	b133      	cbz	r3, 475be <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   475b0:	221c      	movs	r2, #28
   475b2:	2100      	movs	r1, #0
   475b4:	f000 fe49 	bl	4824a <memset>
	return 0;
   475b8:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   475ba:	612c      	str	r4, [r5, #16]
}
   475bc:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   475be:	f06f 0015 	mvn.w	r0, #21
   475c2:	e7fb      	b.n	475bc <onoff_manager_init+0x1e>

000475c4 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   475c4:	b570      	push	{r4, r5, r6, lr}
   475c6:	4604      	mov	r4, r0
   475c8:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   475ca:	f7ff ffd9 	bl	47580 <validate_args>

	if (rv < 0) {
   475ce:	1e05      	subs	r5, r0, #0
   475d0:	db31      	blt.n	47636 <onoff_request+0x72>
   475d2:	f04f 0320 	mov.w	r3, #32
   475d6:	f3ef 8111 	mrs	r1, BASEPRI
   475da:	f383 8812 	msr	BASEPRI_MAX, r3
   475de:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   475e2:	f64f 75ff 	movw	r5, #65535	; 0xffff
   475e6:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   475e8:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   475ea:	42ab      	cmp	r3, r5
   475ec:	f000 0207 	and.w	r2, r0, #7
   475f0:	d02e      	beq.n	47650 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   475f2:	2a02      	cmp	r2, #2
   475f4:	d10e      	bne.n	47614 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   475f6:	3301      	adds	r3, #1
   475f8:	8363      	strh	r3, [r4, #26]
	rv = state;
   475fa:	4615      	mov	r5, r2
		notify = true;
   475fc:	2301      	movs	r3, #1
	__asm__ volatile(
   475fe:	f381 8811 	msr	BASEPRI, r1
   47602:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   47606:	b1b3      	cbz	r3, 47636 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   47608:	2300      	movs	r3, #0
   4760a:	4631      	mov	r1, r6
   4760c:	4620      	mov	r0, r4
   4760e:	f7ff ff93 	bl	47538 <notify_one>
   47612:	e010      	b.n	47636 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   47614:	0783      	lsls	r3, r0, #30
   47616:	d001      	beq.n	4761c <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   47618:	2a06      	cmp	r2, #6
   4761a:	d10e      	bne.n	4763a <onoff_request+0x76>
	parent->next = child;
   4761c:	2300      	movs	r3, #0
   4761e:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   47620:	6863      	ldr	r3, [r4, #4]
   47622:	b993      	cbnz	r3, 4764a <onoff_request+0x86>
	list->head = node;
   47624:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   47628:	4615      	mov	r5, r2
   4762a:	b962      	cbnz	r2, 47646 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   4762c:	460a      	mov	r2, r1
   4762e:	4620      	mov	r0, r4
   47630:	2102      	movs	r1, #2
   47632:	f7f9 f8ed 	bl	40810 <process_event>
		}
	}

	return rv;
}
   47636:	4628      	mov	r0, r5
   47638:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   4763a:	2a05      	cmp	r2, #5
   4763c:	bf0c      	ite	eq
   4763e:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   47642:	f06f 0504 	mvnne.w	r5, #4
   47646:	2300      	movs	r3, #0
   47648:	e7d9      	b.n	475fe <onoff_request+0x3a>
	parent->next = child;
   4764a:	601e      	str	r6, [r3, #0]
	list->tail = node;
   4764c:	6066      	str	r6, [r4, #4]
}
   4764e:	e7eb      	b.n	47628 <onoff_request+0x64>
		rv = -EAGAIN;
   47650:	f06f 050a 	mvn.w	r5, #10
   47654:	e7f7      	b.n	47646 <onoff_request+0x82>

00047656 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   47656:	4604      	mov	r4, r0
   47658:	b508      	push	{r3, lr}
   4765a:	4608      	mov	r0, r1
   4765c:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   4765e:	461a      	mov	r2, r3
   47660:	47a0      	blx	r4
	return z_impl_z_current_get();
   47662:	f7ff fb35 	bl	46cd0 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   47666:	f7fb f89d 	bl	427a4 <z_impl_k_thread_abort>

0004766a <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   4766a:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   4766e:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   47670:	0840      	lsrs	r0, r0, #1
   47672:	4770      	bx	lr

00047674 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   47674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47676:	4603      	mov	r3, r0
   47678:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   4767a:	f7ff fff6 	bl	4766a <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   4767e:	fab0 f080 	clz	r0, r0
   47682:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   47686:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   4768a:	f8dc 6010 	ldr.w	r6, [ip, #16]
   4768e:	00ca      	lsls	r2, r1, #3
   47690:	1d17      	adds	r7, r2, #4
   47692:	b28d      	uxth	r5, r1
   47694:	3206      	adds	r2, #6
   47696:	b956      	cbnz	r6, 476ae <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   47698:	2101      	movs	r1, #1
   4769a:	fa01 f000 	lsl.w	r0, r1, r0
   4769e:	68d9      	ldr	r1, [r3, #12]
   476a0:	4301      	orrs	r1, r0
   476a2:	60d9      	str	r1, [r3, #12]
		b->next = c;
   476a4:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   476a8:	53dd      	strh	r5, [r3, r7]
   476aa:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   476ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   476ae:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   476b0:	3104      	adds	r1, #4
   476b2:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   476b4:	53d8      	strh	r0, [r3, r7]
   476b6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   476ba:	529e      	strh	r6, [r3, r2]
   476bc:	80c5      	strh	r5, [r0, #6]
   476be:	525d      	strh	r5, [r3, r1]
   476c0:	e7f4      	b.n	476ac <free_list_add+0x38>

000476c2 <free_list_remove_bidx>:
{
   476c2:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   476c4:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   476c8:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   476ca:	4299      	cmp	r1, r3
   476cc:	f102 0104 	add.w	r1, r2, #4
   476d0:	d10a      	bne.n	476e8 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   476d2:	2301      	movs	r3, #1
   476d4:	fa03 f202 	lsl.w	r2, r3, r2
   476d8:	68c3      	ldr	r3, [r0, #12]
   476da:	ea23 0302 	bic.w	r3, r3, r2
   476de:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   476e0:	2300      	movs	r3, #0
   476e2:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   476e6:	bd10      	pop	{r4, pc}
   476e8:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   476ea:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   476ee:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   476f2:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   476f6:	80cb      	strh	r3, [r1, #6]
   476f8:	8082      	strh	r2, [r0, #4]
}
   476fa:	e7f4      	b.n	476e6 <free_list_remove_bidx+0x24>

000476fc <free_list_remove>:
{
   476fc:	b510      	push	{r4, lr}
   476fe:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   47700:	f7ff ffb3 	bl	4766a <chunk_size>
}
   47704:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   47708:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   4770c:	4618      	mov	r0, r3
   4770e:	f1c2 021f 	rsb	r2, r2, #31
   47712:	f7ff bfd6 	b.w	476c2 <free_list_remove_bidx>

00047716 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   47716:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4771a:	fab1 f581 	clz	r5, r1
   4771e:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   47722:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   47726:	693a      	ldr	r2, [r7, #16]
{
   47728:	4603      	mov	r3, r0
   4772a:	460e      	mov	r6, r1
	if (b->next) {
   4772c:	b1ca      	cbz	r2, 47762 <alloc_chunk+0x4c>
   4772e:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   47732:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   47734:	4618      	mov	r0, r3
   47736:	4621      	mov	r1, r4
   47738:	f7ff ff97 	bl	4766a <chunk_size>
   4773c:	42b0      	cmp	r0, r6
   4773e:	d307      	bcc.n	47750 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   47740:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   47742:	4621      	mov	r1, r4
   47744:	4618      	mov	r0, r3
   47746:	f7ff ffbc 	bl	476c2 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   4774a:	4620      	mov	r0, r4
   4774c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   47750:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   47754:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   47756:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   4775a:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   4775c:	d001      	beq.n	47762 <alloc_chunk+0x4c>
   4775e:	428a      	cmp	r2, r1
   47760:	d1e7      	bne.n	47732 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   47762:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   47766:	68d9      	ldr	r1, [r3, #12]
   47768:	f1c5 0520 	rsb	r5, r5, #32
   4776c:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   4776e:	400c      	ands	r4, r1
   47770:	d0eb      	beq.n	4774a <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   47772:	fa94 f2a4 	rbit	r2, r4
   47776:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   4777a:	1d11      	adds	r1, r2, #4
   4777c:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   47780:	e7df      	b.n	47742 <alloc_chunk+0x2c>

00047782 <merge_chunks>:
{
   47782:	b538      	push	{r3, r4, r5, lr}
   47784:	4603      	mov	r3, r0
   47786:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   47788:	f7ff ff6f 	bl	4766a <chunk_size>
   4778c:	4611      	mov	r1, r2
   4778e:	4604      	mov	r4, r0
   47790:	4618      	mov	r0, r3
   47792:	f7ff ff6a 	bl	4766a <chunk_size>
   47796:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   47798:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   4779c:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   4779e:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   477a0:	4618      	mov	r0, r3
   477a2:	4611      	mov	r1, r2
   477a4:	f7ff ff61 	bl	4766a <chunk_size>
	void *cmem = &buf[c];
   477a8:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   477aa:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   477ae:	bd38      	pop	{r3, r4, r5, pc}

000477b0 <split_chunks>:
{
   477b0:	b538      	push	{r3, r4, r5, lr}
   477b2:	4603      	mov	r3, r0
   477b4:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   477b6:	f7ff ff58 	bl	4766a <chunk_size>
	chunksz_t lsz = rc - lc;
   477ba:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   477bc:	1aa5      	subs	r5, r4, r2
   477be:	4405      	add	r5, r0
   477c0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   477c4:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   477c6:	8060      	strh	r0, [r4, #2]
   477c8:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   477cc:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   477ce:	8044      	strh	r4, [r0, #2]
   477d0:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   477d4:	4618      	mov	r0, r3
   477d6:	4611      	mov	r1, r2
   477d8:	f7ff ff47 	bl	4766a <chunk_size>
	void *cmem = &buf[c];
   477dc:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   477de:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   477e2:	bd38      	pop	{r3, r4, r5, pc}

000477e4 <free_chunk>:
{
   477e4:	b538      	push	{r3, r4, r5, lr}
   477e6:	4605      	mov	r5, r0
   477e8:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   477ea:	f7ff ff3e 	bl	4766a <chunk_size>
   477ee:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   477f0:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   477f4:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   477f6:	07da      	lsls	r2, r3, #31
   477f8:	d40a      	bmi.n	47810 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   477fa:	4628      	mov	r0, r5
   477fc:	f7ff ff7e 	bl	476fc <free_list_remove>
	return c + chunk_size(h, c);
   47800:	4621      	mov	r1, r4
   47802:	4628      	mov	r0, r5
   47804:	f7ff ff31 	bl	4766a <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   47808:	1822      	adds	r2, r4, r0
   4780a:	4628      	mov	r0, r5
   4780c:	f7ff ffb9 	bl	47782 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   47810:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47814:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   47816:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   4781a:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   4781c:	07db      	lsls	r3, r3, #31
   4781e:	d40c      	bmi.n	4783a <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   47820:	4628      	mov	r0, r5
   47822:	f7ff ff6b 	bl	476fc <free_list_remove>
		return ((uint16_t *)cmem)[f];
   47826:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   4782a:	4622      	mov	r2, r4
   4782c:	1a61      	subs	r1, r4, r1
   4782e:	4628      	mov	r0, r5
   47830:	f7ff ffa7 	bl	47782 <merge_chunks>
   47834:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47838:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   4783a:	4621      	mov	r1, r4
   4783c:	4628      	mov	r0, r5
}
   4783e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   47842:	f7ff bf17 	b.w	47674 <free_list_add>

00047846 <sys_heap_free>:
	if (mem == NULL) {
   47846:	b161      	cbz	r1, 47862 <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   47848:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   4784a:	3904      	subs	r1, #4
   4784c:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   4784e:	f021 0307 	bic.w	r3, r1, #7
   47852:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   47854:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   47856:	08c9      	lsrs	r1, r1, #3
   47858:	f022 0201 	bic.w	r2, r2, #1
   4785c:	805a      	strh	r2, [r3, #2]
   4785e:	f7ff bfc1 	b.w	477e4 <free_chunk>
}
   47862:	4770      	bx	lr

00047864 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   47864:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   47866:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   47868:	b909      	cbnz	r1, 4786e <sys_heap_alloc+0xa>
		return NULL;
   4786a:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   4786c:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   4786e:	68ab      	ldr	r3, [r5, #8]
   47870:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   47874:	d9f9      	bls.n	4786a <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47876:	310b      	adds	r1, #11
   47878:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   4787a:	4621      	mov	r1, r4
   4787c:	4628      	mov	r0, r5
   4787e:	f7ff ff4a 	bl	47716 <alloc_chunk>
	if (c == 0U) {
   47882:	4606      	mov	r6, r0
   47884:	2800      	cmp	r0, #0
   47886:	d0f0      	beq.n	4786a <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   47888:	4601      	mov	r1, r0
   4788a:	4628      	mov	r0, r5
   4788c:	f7ff feed 	bl	4766a <chunk_size>
   47890:	42a0      	cmp	r0, r4
   47892:	d908      	bls.n	478a6 <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   47894:	4434      	add	r4, r6
   47896:	4628      	mov	r0, r5
   47898:	4622      	mov	r2, r4
   4789a:	f7ff ff89 	bl	477b0 <split_chunks>
		free_list_add(h, c + chunk_sz);
   4789e:	4621      	mov	r1, r4
   478a0:	4628      	mov	r0, r5
   478a2:	f7ff fee7 	bl	47674 <free_list_add>
	void *cmem = &buf[c];
   478a6:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   478aa:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   478ac:	8853      	ldrh	r3, [r2, #2]
   478ae:	3004      	adds	r0, #4
   478b0:	f043 0301 	orr.w	r3, r3, #1
   478b4:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   478b6:	e7d9      	b.n	4786c <sys_heap_alloc+0x8>

000478b8 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   478b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   478bc:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   478be:	424a      	negs	r2, r1
   478c0:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   478c4:	ea31 0202 	bics.w	r2, r1, r2
{
   478c8:	4603      	mov	r3, r0
	if (align != rew) {
   478ca:	d00a      	beq.n	478e2 <sys_heap_aligned_alloc+0x2a>
		return false;
   478cc:	2f04      	cmp	r7, #4
   478ce:	463a      	mov	r2, r7
   478d0:	bf28      	it	cs
   478d2:	2204      	movcs	r2, #4
   478d4:	46b9      	mov	r9, r7
		align -= rew;
   478d6:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   478d8:	b974      	cbnz	r4, 478f8 <sys_heap_aligned_alloc+0x40>
		return NULL;
   478da:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   478dc:	4628      	mov	r0, r5
   478de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   478e2:	2904      	cmp	r1, #4
   478e4:	d804      	bhi.n	478f0 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   478e6:	4621      	mov	r1, r4
}
   478e8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   478ec:	f7ff bfba 	b.w	47864 <sys_heap_alloc>
		rew = 0;
   478f0:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   478f4:	2204      	movs	r2, #4
   478f6:	e7ef      	b.n	478d8 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   478f8:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   478fa:	68b3      	ldr	r3, [r6, #8]
   478fc:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   47900:	d9eb      	bls.n	478da <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47902:	f104 010b 	add.w	r1, r4, #11
   47906:	4439      	add	r1, r7
   47908:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   4790a:	4630      	mov	r0, r6
   4790c:	08c9      	lsrs	r1, r1, #3
   4790e:	f7ff ff02 	bl	47716 <alloc_chunk>
	if (c0 == 0) {
   47912:	4680      	mov	r8, r0
   47914:	2800      	cmp	r0, #0
   47916:	d0e0      	beq.n	478da <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   47918:	f109 0504 	add.w	r5, r9, #4
   4791c:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   47920:	1e7b      	subs	r3, r7, #1
   47922:	4435      	add	r5, r6
   47924:	441d      	add	r5, r3
   47926:	427f      	negs	r7, r7
   47928:	403d      	ands	r5, r7
   4792a:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   4792e:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47930:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47932:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47934:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47936:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   4793a:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   4793c:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47940:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   47944:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   47948:	d208      	bcs.n	4795c <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   4794a:	4601      	mov	r1, r0
   4794c:	463a      	mov	r2, r7
   4794e:	4630      	mov	r0, r6
   47950:	f7ff ff2e 	bl	477b0 <split_chunks>
		free_list_add(h, c0);
   47954:	4641      	mov	r1, r8
   47956:	4630      	mov	r0, r6
   47958:	f7ff fe8c 	bl	47674 <free_list_add>
	return c + chunk_size(h, c);
   4795c:	4639      	mov	r1, r7
   4795e:	4630      	mov	r0, r6
   47960:	f7ff fe83 	bl	4766a <chunk_size>
   47964:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   47966:	4284      	cmp	r4, r0
   47968:	d207      	bcs.n	4797a <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   4796a:	4630      	mov	r0, r6
   4796c:	4622      	mov	r2, r4
   4796e:	f7ff ff1f 	bl	477b0 <split_chunks>
		free_list_add(h, c_end);
   47972:	4621      	mov	r1, r4
   47974:	4630      	mov	r0, r6
   47976:	f7ff fe7d 	bl	47674 <free_list_add>
	void *cmem = &buf[c];
   4797a:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   4797e:	8873      	ldrh	r3, [r6, #2]
   47980:	f043 0301 	orr.w	r3, r3, #1
   47984:	8073      	strh	r3, [r6, #2]
   47986:	e7a9      	b.n	478dc <sys_heap_aligned_alloc+0x24>

00047988 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   47988:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   4798a:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   4798c:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   4798e:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47992:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   47996:	1ad2      	subs	r2, r2, r3
{
   47998:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   4799a:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   4799c:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   4799e:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   479a2:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   479a4:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   479a8:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   479aa:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   479ac:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   479ae:	60dd      	str	r5, [r3, #12]
   479b0:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   479b2:	f103 0610 	add.w	r6, r3, #16
   479b6:	4418      	add	r0, r3
   479b8:	4286      	cmp	r6, r0
   479ba:	d118      	bne.n	479ee <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   479bc:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   479be:	f040 0001 	orr.w	r0, r0, #1
   479c2:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   479c4:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   479c6:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   479c8:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   479cc:	801d      	strh	r5, [r3, #0]
   479ce:	8077      	strh	r7, [r6, #2]
   479d0:	189e      	adds	r6, r3, r2
   479d2:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   479d6:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   479da:	8075      	strh	r5, [r6, #2]
   479dc:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   479de:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   479e0:	4618      	mov	r0, r3
   479e2:	f042 0201 	orr.w	r2, r2, #1
   479e6:	8062      	strh	r2, [r4, #2]
}
   479e8:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   479ea:	f7ff be43 	b.w	47674 <free_list_add>
		h->buckets[i].next = 0;
   479ee:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   479f2:	e7e1      	b.n	479b8 <sys_heap_init+0x30>

000479f4 <encode_uint>:
{
   479f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   479f8:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   479fa:	78d3      	ldrb	r3, [r2, #3]
{
   479fc:	4614      	mov	r4, r2
	switch (specifier) {
   479fe:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   47a00:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   47a04:	4606      	mov	r6, r0
   47a06:	460f      	mov	r7, r1
   47a08:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   47a0a:	d02d      	beq.n	47a68 <encode_uint+0x74>
   47a0c:	d828      	bhi.n	47a60 <encode_uint+0x6c>
		return 16;
   47a0e:	2b58      	cmp	r3, #88	; 0x58
   47a10:	bf14      	ite	ne
   47a12:	250a      	movne	r5, #10
   47a14:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   47a16:	46aa      	mov	sl, r5
   47a18:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   47a1c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   47a20:	4652      	mov	r2, sl
   47a22:	465b      	mov	r3, fp
   47a24:	4630      	mov	r0, r6
   47a26:	4639      	mov	r1, r7
   47a28:	f7f8 fb8c 	bl	40144 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47a2c:	2a09      	cmp	r2, #9
   47a2e:	b2d3      	uxtb	r3, r2
   47a30:	d81f      	bhi.n	47a72 <encode_uint+0x7e>
   47a32:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   47a34:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47a36:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   47a38:	bf08      	it	eq
   47a3a:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47a3c:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   47a40:	d301      	bcc.n	47a46 <encode_uint+0x52>
   47a42:	45c8      	cmp	r8, r9
   47a44:	d812      	bhi.n	47a6c <encode_uint+0x78>
	if (conv->flag_hash) {
   47a46:	7823      	ldrb	r3, [r4, #0]
   47a48:	069b      	lsls	r3, r3, #26
   47a4a:	d505      	bpl.n	47a58 <encode_uint+0x64>
		if (radix == 8) {
   47a4c:	2d08      	cmp	r5, #8
   47a4e:	d116      	bne.n	47a7e <encode_uint+0x8a>
			conv->altform_0 = true;
   47a50:	78a3      	ldrb	r3, [r4, #2]
   47a52:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   47a56:	70a3      	strb	r3, [r4, #2]
}
   47a58:	4640      	mov	r0, r8
   47a5a:	b003      	add	sp, #12
   47a5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   47a60:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   47a64:	2b70      	cmp	r3, #112	; 0x70
   47a66:	e7d3      	b.n	47a10 <encode_uint+0x1c>
	switch (specifier) {
   47a68:	2508      	movs	r5, #8
   47a6a:	e7d4      	b.n	47a16 <encode_uint+0x22>
		value /= radix;
   47a6c:	4606      	mov	r6, r0
   47a6e:	460f      	mov	r7, r1
   47a70:	e7d6      	b.n	47a20 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47a72:	9a01      	ldr	r2, [sp, #4]
   47a74:	2a19      	cmp	r2, #25
   47a76:	bf94      	ite	ls
   47a78:	3337      	addls	r3, #55	; 0x37
   47a7a:	3357      	addhi	r3, #87	; 0x57
   47a7c:	e7da      	b.n	47a34 <encode_uint+0x40>
		} else if (radix == 16) {
   47a7e:	2d10      	cmp	r5, #16
   47a80:	d1ea      	bne.n	47a58 <encode_uint+0x64>
			conv->altform_0c = true;
   47a82:	78a3      	ldrb	r3, [r4, #2]
   47a84:	f043 0310 	orr.w	r3, r3, #16
   47a88:	e7e5      	b.n	47a56 <encode_uint+0x62>

00047a8a <outs>:
{
   47a8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47a8e:	4607      	mov	r7, r0
   47a90:	4688      	mov	r8, r1
   47a92:	4615      	mov	r5, r2
   47a94:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   47a96:	4614      	mov	r4, r2
   47a98:	42b4      	cmp	r4, r6
   47a9a:	eba4 0005 	sub.w	r0, r4, r5
   47a9e:	d302      	bcc.n	47aa6 <outs+0x1c>
   47aa0:	b93e      	cbnz	r6, 47ab2 <outs+0x28>
   47aa2:	7823      	ldrb	r3, [r4, #0]
   47aa4:	b12b      	cbz	r3, 47ab2 <outs+0x28>
		int rc = out((int)*sp++, ctx);
   47aa6:	4641      	mov	r1, r8
   47aa8:	f814 0b01 	ldrb.w	r0, [r4], #1
   47aac:	47b8      	blx	r7
		if (rc < 0) {
   47aae:	2800      	cmp	r0, #0
   47ab0:	daf2      	bge.n	47a98 <outs+0xe>
}
   47ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047ab6 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   47ab6:	4770      	bx	lr

00047ab8 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   47ab8:	b084      	sub	sp, #16
   47aba:	ab04      	add	r3, sp, #16
   47abc:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   47ac0:	f89d 3004 	ldrb.w	r3, [sp, #4]
   47ac4:	2b06      	cmp	r3, #6
   47ac6:	d108      	bne.n	47ada <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   47ac8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   47acc:	2201      	movs	r2, #1
   47ace:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   47ad2:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   47ad6:	bf20      	wfe
    while (true)
   47ad8:	e7fd      	b.n	47ad6 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   47ada:	b004      	add	sp, #16
   47adc:	4770      	bx	lr

00047ade <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   47ade:	b084      	sub	sp, #16
   47ae0:	ab04      	add	r3, sp, #16
   47ae2:	e903 0007 	stmdb	r3, {r0, r1, r2}
   47ae6:	2300      	movs	r3, #0
   47ae8:	f383 8811 	msr	BASEPRI, r3
   47aec:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   47af0:	b004      	add	sp, #16
   47af2:	4770      	bx	lr

00047af4 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   47af4:	2300      	movs	r3, #0
	list->head = NULL;
   47af6:	e9c0 3300 	strd	r3, r3, [r0]
}
   47afa:	4770      	bx	lr

00047afc <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   47afc:	6803      	ldr	r3, [r0, #0]
   47afe:	b923      	cbnz	r3, 47b0a <log_list_add_tail+0xe>
		list->head = msg;
   47b00:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   47b02:	2300      	movs	r3, #0
	list->tail = msg;
   47b04:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   47b06:	600b      	str	r3, [r1, #0]
}
   47b08:	4770      	bx	lr
		list->tail->next = msg;
   47b0a:	6843      	ldr	r3, [r0, #4]
   47b0c:	6019      	str	r1, [r3, #0]
   47b0e:	e7f8      	b.n	47b02 <log_list_add_tail+0x6>

00047b10 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   47b10:	6800      	ldr	r0, [r0, #0]
   47b12:	4770      	bx	lr

00047b14 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   47b14:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   47b16:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   47b18:	b108      	cbz	r0, 47b1e <log_list_head_get+0xa>
		list->head = list->head->next;
   47b1a:	6802      	ldr	r2, [r0, #0]
   47b1c:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   47b1e:	4770      	bx	lr

00047b20 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   47b20:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   47b22:	f7f9 fdf5 	bl	41710 <log_msg_chunk_alloc>

	if (msg != NULL) {
   47b26:	b118      	cbz	r0, 47b30 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   47b28:	2301      	movs	r3, #1
   47b2a:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   47b2c:	2300      	movs	r3, #0
   47b2e:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
   47b30:	bd08      	pop	{r3, pc}

00047b32 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   47b32:	f000 bcf3 	b.w	4851c <sys_clock_cycle_get_32>

00047b36 <dummy_timestamp>:
   47b36:	2000      	movs	r0, #0
   47b38:	4770      	bx	lr

00047b3a <z_log_get_s_mask>:
{
   47b3a:	b5f0      	push	{r4, r5, r6, r7, lr}
   47b3c:	4605      	mov	r5, r0
	uint32_t mask = 0U;
   47b3e:	2000      	movs	r0, #0
				mask |= BIT(arg);
   47b40:	2701      	movs	r7, #1
	uint32_t arg = 0U;
   47b42:	4603      	mov	r3, r0
	bool arm = false;
   47b44:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
   47b46:	f815 4b01 	ldrb.w	r4, [r5], #1
   47b4a:	b10c      	cbz	r4, 47b50 <z_log_get_s_mask+0x16>
   47b4c:	428b      	cmp	r3, r1
   47b4e:	d300      	bcc.n	47b52 <z_log_get_s_mask+0x18>
}
   47b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   47b52:	2c25      	cmp	r4, #37	; 0x25
   47b54:	d102      	bne.n	47b5c <z_log_get_s_mask+0x22>
			arm = !arm;
   47b56:	f082 0201 	eor.w	r2, r2, #1
   47b5a:	e7f4      	b.n	47b46 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   47b5c:	2a00      	cmp	r2, #0
   47b5e:	d0f2      	beq.n	47b46 <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   47b60:	f044 0620 	orr.w	r6, r4, #32
   47b64:	3e61      	subs	r6, #97	; 0x61
   47b66:	2e19      	cmp	r6, #25
   47b68:	d8ed      	bhi.n	47b46 <z_log_get_s_mask+0xc>
			if (curr == 's') {
   47b6a:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   47b6c:	bf04      	itt	eq
   47b6e:	fa07 f203 	lsleq.w	r2, r7, r3
   47b72:	4310      	orreq	r0, r2
			arg++;
   47b74:	3301      	adds	r3, #1
			arm = false;
   47b76:	2200      	movs	r2, #0
   47b78:	e7e5      	b.n	47b46 <z_log_get_s_mask+0xc>

00047b7a <log_0>:
{
   47b7a:	b538      	push	{r3, r4, r5, lr}
   47b7c:	4605      	mov	r5, r0
   47b7e:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   47b80:	f7ff ffce 	bl	47b20 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47b84:	b128      	cbz	r0, 47b92 <log_0+0x18>
		msg_finalize(msg, src_level);
   47b86:	4621      	mov	r1, r4
		msg->str = str;
   47b88:	6105      	str	r5, [r0, #16]
}
   47b8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   47b8e:	f7f9 bcc5 	b.w	4151c <msg_finalize>
}
   47b92:	bd38      	pop	{r3, r4, r5, pc}

00047b94 <log_1>:
{
   47b94:	b570      	push	{r4, r5, r6, lr}
   47b96:	4606      	mov	r6, r0
   47b98:	460d      	mov	r5, r1
   47b9a:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47b9c:	f7ff ffc0 	bl	47b20 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47ba0:	b158      	cbz	r0, 47bba <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   47ba2:	2101      	movs	r1, #1
   47ba4:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   47ba6:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   47ba8:	f361 1207 	bfi	r2, r1, #4, #4
   47bac:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
   47bae:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
   47bb0:	6145      	str	r5, [r0, #20]
}
   47bb2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   47bb6:	f7f9 bcb1 	b.w	4151c <msg_finalize>
}
   47bba:	bd70      	pop	{r4, r5, r6, pc}

00047bbc <log_2>:
{
   47bbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47bc0:	4680      	mov	r8, r0
   47bc2:	460f      	mov	r7, r1
   47bc4:	4616      	mov	r6, r2
   47bc6:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47bc8:	f7ff ffaa 	bl	47b20 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47bcc:	b168      	cbz	r0, 47bea <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   47bce:	2202      	movs	r2, #2
   47bd0:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47bd2:	4629      	mov	r1, r5
   47bd4:	f362 1307 	bfi	r3, r2, #4, #4
   47bd8:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47bda:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47bde:	f8c0 8010 	str.w	r8, [r0, #16]
}
   47be2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   47be6:	f7f9 bc99 	b.w	4151c <msg_finalize>
}
   47bea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047bee <log_3>:
{
   47bee:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47bf2:	4680      	mov	r8, r0
   47bf4:	460f      	mov	r7, r1
   47bf6:	4616      	mov	r6, r2
   47bf8:	461d      	mov	r5, r3
   47bfa:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47bfe:	f7ff ff8f 	bl	47b20 <z_log_msg_std_alloc>

	if (msg != NULL) {
   47c02:	b170      	cbz	r0, 47c22 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   47c04:	2203      	movs	r2, #3
   47c06:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47c08:	4649      	mov	r1, r9
   47c0a:	f362 1307 	bfi	r3, r2, #4, #4
   47c0e:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47c10:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47c14:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
   47c18:	61c5      	str	r5, [r0, #28]
}
   47c1a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   47c1e:	f7f9 bc7d 	b.w	4151c <msg_finalize>
}
   47c22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00047c26 <log_hexdump>:
{
   47c26:	b510      	push	{r4, lr}
   47c28:	461c      	mov	r4, r3
			log_msg_hexdump_create(str, (const uint8_t *)data, length);
   47c2a:	f000 f89b 	bl	47d64 <log_msg_hexdump_create>
		if (msg == NULL) {
   47c2e:	b120      	cbz	r0, 47c3a <log_hexdump+0x14>
		msg_finalize(msg, src_level);
   47c30:	4621      	mov	r1, r4
}
   47c32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   47c36:	f7f9 bc71 	b.w	4151c <msg_finalize>
}
   47c3a:	bd10      	pop	{r4, pc}

00047c3c <z_log_get_tag>:
}
   47c3c:	2000      	movs	r0, #0
   47c3e:	4770      	bx	lr

00047c40 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   47c40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47c44:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47c46:	8903      	ldrh	r3, [r0, #8]
{
   47c48:	460e      	mov	r6, r1
   47c4a:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47c4c:	f3c3 028d 	ubfx	r2, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   47c50:	42a2      	cmp	r2, r4
{
   47c52:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
   47c56:	d803      	bhi.n	47c60 <log_msg_hexdump_data_op+0x20>
		*length = 0;
   47c58:	2300      	movs	r3, #0
   47c5a:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   47c5c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   47c60:	680b      	ldr	r3, [r1, #0]
   47c62:	4423      	add	r3, r4
   47c64:	4293      	cmp	r3, r2
		*length = available_len - offset;
   47c66:	bf84      	itt	hi
   47c68:	1b13      	subhi	r3, r2, r4
   47c6a:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47c6c:	2a0c      	cmp	r2, #12
	req_len = *length;
   47c6e:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47c72:	d92a      	bls.n	47cca <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   47c74:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   47c76:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   47c7a:	d82d      	bhi.n	47cd8 <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   47c7c:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
   47c7e:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47c80:	454a      	cmp	r2, r9
   47c82:	bf28      	it	cs
   47c84:	464a      	movcs	r2, r9
   47c86:	4420      	add	r0, r4
   47c88:	4615      	mov	r5, r2
		if (put_op) {
   47c8a:	b317      	cbz	r7, 47cd2 <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
   47c8c:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   47c8e:	f000 fad1 	bl	48234 <memcpy>
		req_len -= cpy_len;
   47c92:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47c96:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
   47c98:	f1b9 0f00 	cmp.w	r9, #0
   47c9c:	d0de      	beq.n	47c5c <log_msg_hexdump_data_op+0x1c>
   47c9e:	f1b8 0f00 	cmp.w	r8, #0
   47ca2:	d0db      	beq.n	47c5c <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   47ca4:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47ca8:	454d      	cmp	r5, r9
   47caa:	bf28      	it	cs
   47cac:	464d      	movcs	r5, r9
		if (put_op) {
   47cae:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
   47cb0:	462a      	mov	r2, r5
   47cb2:	4440      	add	r0, r8
		if (put_op) {
   47cb4:	b1bf      	cbz	r7, 47ce6 <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
   47cb6:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   47cb8:	f000 fabc 	bl	48234 <memcpy>
		offset = 0;
   47cbc:	2400      	movs	r4, #0
		cont = cont->next;
   47cbe:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
   47cc2:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47cc6:	442e      	add	r6, r5
   47cc8:	e7e6      	b.n	47c98 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
   47cca:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
   47cce:	3014      	adds	r0, #20
	if (offset < chunk_len) {
   47cd0:	e7d6      	b.n	47c80 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   47cd2:	4601      	mov	r1, r0
   47cd4:	4630      	mov	r0, r6
   47cd6:	e7da      	b.n	47c8e <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   47cd8:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   47cda:	2c1b      	cmp	r4, #27
   47cdc:	d9dc      	bls.n	47c98 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   47cde:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   47ce2:	3c1c      	subs	r4, #28
   47ce4:	e7f9      	b.n	47cda <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
   47ce6:	4601      	mov	r1, r0
   47ce8:	4630      	mov	r0, r6
   47cea:	e7e5      	b.n	47cb8 <log_msg_hexdump_data_op+0x78>

00047cec <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   47cec:	3004      	adds	r0, #4
   47cee:	e8d0 3fef 	ldaex	r3, [r0]
   47cf2:	3301      	adds	r3, #1
   47cf4:	e8c0 3fe2 	stlex	r2, r3, [r0]
   47cf8:	2a00      	cmp	r2, #0
   47cfa:	d1f8      	bne.n	47cee <log_msg_get+0x2>
}
   47cfc:	4770      	bx	lr

00047cfe <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   47cfe:	7a40      	ldrb	r0, [r0, #9]
}
   47d00:	0900      	lsrs	r0, r0, #4
   47d02:	4770      	bx	lr

00047d04 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   47d04:	7a43      	ldrb	r3, [r0, #9]
   47d06:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   47d0a:	ea4f 1213 	mov.w	r2, r3, lsr #4
   47d0e:	d216      	bcs.n	47d3e <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   47d10:	2a03      	cmp	r2, #3
   47d12:	d803      	bhi.n	47d1c <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   47d14:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47d18:	6948      	ldr	r0, [r1, #20]
   47d1a:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   47d1c:	2901      	cmp	r1, #1
   47d1e:	d803      	bhi.n	47d28 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   47d20:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47d24:	6988      	ldr	r0, [r1, #24]
   47d26:	4770      	bx	lr
	cont = msg->payload.ext.next;
   47d28:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   47d2a:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   47d2c:	2906      	cmp	r1, #6
   47d2e:	d803      	bhi.n	47d38 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   47d30:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   47d34:	6848      	ldr	r0, [r1, #4]
   47d36:	4770      	bx	lr
		cont = cont->next;
   47d38:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   47d3a:	3907      	subs	r1, #7
		cont = cont->next;
   47d3c:	e7f6      	b.n	47d2c <log_msg_arg_get+0x28>
		return 0;
   47d3e:	2000      	movs	r0, #0
}
   47d40:	4770      	bx	lr

00047d42 <log_msg_put>:
{
   47d42:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   47d44:	1d02      	adds	r2, r0, #4
   47d46:	e8d2 1fef 	ldaex	r1, [r2]
   47d4a:	3901      	subs	r1, #1
   47d4c:	e8c2 1fec 	stlex	ip, r1, [r2]
   47d50:	f1bc 0f00 	cmp.w	ip, #0
   47d54:	d1f7      	bne.n	47d46 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
   47d56:	685b      	ldr	r3, [r3, #4]
   47d58:	b90b      	cbnz	r3, 47d5e <log_msg_put+0x1c>
		msg_free(msg);
   47d5a:	f7f9 bced 	b.w	41738 <msg_free>
}
   47d5e:	4770      	bx	lr

00047d60 <log_msg_str_get>:
}
   47d60:	6900      	ldr	r0, [r0, #16]
   47d62:	4770      	bx	lr

00047d64 <log_msg_hexdump_create>:
{
   47d64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   47d68:	f643 75ff 	movw	r5, #16383	; 0x3fff
   47d6c:	4295      	cmp	r5, r2
{
   47d6e:	4680      	mov	r8, r0
   47d70:	460e      	mov	r6, r1
   47d72:	4617      	mov	r7, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   47d74:	bf28      	it	cs
   47d76:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
   47d78:	f7f9 fcca 	bl	41710 <log_msg_chunk_alloc>
	if (msg == NULL) {
   47d7c:	4604      	mov	r4, r0
   47d7e:	b380      	cbz	r0, 47de2 <log_msg_hexdump_create+0x7e>
	msg->hdr.ref_cnt = 1;
   47d80:	2301      	movs	r3, #1
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   47d82:	8902      	ldrh	r2, [r0, #8]
	msg->hdr.ref_cnt = 1;
   47d84:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   47d86:	00ab      	lsls	r3, r5, #2
   47d88:	f043 0301 	orr.w	r3, r3, #1
   47d8c:	f002 0202 	and.w	r2, r2, #2
   47d90:	4313      	orrs	r3, r2
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47d92:	2f0c      	cmp	r7, #12
	msg->str = str;
   47d94:	f8c0 8010 	str.w	r8, [r0, #16]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   47d98:	8103      	strh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47d9a:	f100 0814 	add.w	r8, r0, #20
   47d9e:	d917      	bls.n	47dd0 <log_msg_hexdump_create+0x6c>
		(void)memcpy(msg->payload.ext.data.bytes,
   47da0:	2208      	movs	r2, #8
   47da2:	4631      	mov	r1, r6
   47da4:	3018      	adds	r0, #24
   47da6:	f000 fa45 	bl	48234 <memcpy>
		msg->payload.ext.next = NULL;
   47daa:	2300      	movs	r3, #0
   47dac:	4699      	mov	r9, r3
		msg->hdr.params.generic.ext = 1;
   47dae:	7a22      	ldrb	r2, [r4, #8]
		msg->payload.ext.next = NULL;
   47db0:	6163      	str	r3, [r4, #20]
		msg->hdr.params.generic.ext = 1;
   47db2:	f042 0202 	orr.w	r2, r2, #2
   47db6:	7222      	strb	r2, [r4, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   47db8:	3608      	adds	r6, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   47dba:	3d08      	subs	r5, #8
	while (length > 0) {
   47dbc:	b18d      	cbz	r5, 47de2 <log_msg_hexdump_create+0x7e>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   47dbe:	f7f9 fca7 	bl	41710 <log_msg_chunk_alloc>
		if (cont == NULL) {
   47dc2:	4607      	mov	r7, r0
   47dc4:	b980      	cbnz	r0, 47de8 <log_msg_hexdump_create+0x84>
			msg_free(msg);
   47dc6:	4620      	mov	r0, r4
   47dc8:	f7f9 fcb6 	bl	41738 <msg_free>
			return NULL;
   47dcc:	463c      	mov	r4, r7
   47dce:	e008      	b.n	47de2 <log_msg_hexdump_create+0x7e>
		(void)memcpy(msg->payload.single.bytes, data, length);
   47dd0:	462a      	mov	r2, r5
   47dd2:	4631      	mov	r1, r6
   47dd4:	4640      	mov	r0, r8
   47dd6:	f000 fa2d 	bl	48234 <memcpy>
		msg->hdr.params.generic.ext = 0;
   47dda:	7a23      	ldrb	r3, [r4, #8]
   47ddc:	f36f 0341 	bfc	r3, #1, #1
   47de0:	7223      	strb	r3, [r4, #8]
}
   47de2:	4620      	mov	r0, r4
   47de4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
   47de8:	2d1c      	cmp	r5, #28
   47dea:	462f      	mov	r7, r5
   47dec:	bf28      	it	cs
   47dee:	271c      	movcs	r7, #28
		*prev_cont = cont;
   47df0:	f8c8 0000 	str.w	r0, [r8]
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   47df4:	4631      	mov	r1, r6
		cont->next = NULL;
   47df6:	f8c0 9000 	str.w	r9, [r0]
		prev_cont = &cont->next;
   47dfa:	4680      	mov	r8, r0
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   47dfc:	463a      	mov	r2, r7
   47dfe:	3004      	adds	r0, #4
   47e00:	f000 fa18 	bl	48234 <memcpy>
		data += chunk_length;
   47e04:	443e      	add	r6, r7
		length -= chunk_length;
   47e06:	1bed      	subs	r5, r5, r7
   47e08:	e7d8      	b.n	47dbc <log_msg_hexdump_create+0x58>

00047e0a <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   47e0a:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   47e0c:	2400      	movs	r4, #0
   47e0e:	9400      	str	r4, [sp, #0]
   47e10:	f7ff ff16 	bl	47c40 <log_msg_hexdump_data_op>
}
   47e14:	b002      	add	sp, #8
   47e16:	bd10      	pop	{r4, pc}

00047e18 <buffer_write>:
{
   47e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47e1a:	4606      	mov	r6, r0
   47e1c:	460d      	mov	r5, r1
   47e1e:	4614      	mov	r4, r2
   47e20:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   47e22:	4621      	mov	r1, r4
   47e24:	4628      	mov	r0, r5
   47e26:	463a      	mov	r2, r7
   47e28:	47b0      	blx	r6
	} while (len != 0);
   47e2a:	1a24      	subs	r4, r4, r0
		buf += processed;
   47e2c:	4405      	add	r5, r0
	} while (len != 0);
   47e2e:	d1f8      	bne.n	47e22 <buffer_write+0xa>
}
   47e30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00047e32 <std_print>:
{
   47e32:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   47e36:	b08e      	sub	sp, #56	; 0x38
   47e38:	af0e      	add	r7, sp, #56	; 0x38
   47e3a:	4680      	mov	r8, r0
   47e3c:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   47e3e:	f7ff ff8f 	bl	47d60 <log_msg_str_get>
   47e42:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
   47e44:	4640      	mov	r0, r8
   47e46:	f7ff ff5a 	bl	47cfe <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
   47e4a:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
   47e4e:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
   47e50:	0083      	lsls	r3, r0, #2
   47e52:	3307      	adds	r3, #7
   47e54:	f023 0307 	bic.w	r3, r3, #7
   47e58:	ebad 0d03 	sub.w	sp, sp, r3
   47e5c:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   47e5e:	45d1      	cmp	r9, sl
   47e60:	d116      	bne.n	47e90 <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   47e62:	4640      	mov	r0, r8
   47e64:	f7ff ff4b 	bl	47cfe <log_msg_nargs_get>
   47e68:	280f      	cmp	r0, #15
   47e6a:	d81e      	bhi.n	47eaa <std_print+0x78>
   47e6c:	e8df f010 	tbh	[pc, r0, lsl #1]
   47e70:	00200019 	.word	0x00200019
   47e74:	002d0026 	.word	0x002d0026
   47e78:	00410036 	.word	0x00410036
   47e7c:	005d004e 	.word	0x005d004e
   47e80:	0081006e 	.word	0x0081006e
   47e84:	00ad0096 	.word	0x00ad0096
   47e88:	00e100c6 	.word	0x00e100c6
   47e8c:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
   47e90:	4649      	mov	r1, r9
   47e92:	4640      	mov	r0, r8
   47e94:	f7ff ff36 	bl	47d04 <log_msg_arg_get>
   47e98:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   47e9c:	f109 0901 	add.w	r9, r9, #1
   47ea0:	e7dd      	b.n	47e5e <std_print+0x2c>
		print_formatted(output, str);
   47ea2:	4631      	mov	r1, r6
   47ea4:	4628      	mov	r0, r5
   47ea6:	f7f9 fc85 	bl	417b4 <print_formatted>
}
   47eaa:	46bd      	mov	sp, r7
   47eac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
   47eb0:	4631      	mov	r1, r6
   47eb2:	4628      	mov	r0, r5
   47eb4:	6822      	ldr	r2, [r4, #0]
   47eb6:	f7f9 fc7d 	bl	417b4 <print_formatted>
		break;
   47eba:	e7f6      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
   47ebc:	4631      	mov	r1, r6
   47ebe:	e9d4 2300 	ldrd	r2, r3, [r4]
   47ec2:	4628      	mov	r0, r5
   47ec4:	f7f9 fc76 	bl	417b4 <print_formatted>
		break;
   47ec8:	e7ef      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
   47eca:	68a3      	ldr	r3, [r4, #8]
   47ecc:	4631      	mov	r1, r6
   47ece:	9300      	str	r3, [sp, #0]
   47ed0:	4628      	mov	r0, r5
   47ed2:	e9d4 2300 	ldrd	r2, r3, [r4]
   47ed6:	f7f9 fc6d 	bl	417b4 <print_formatted>
		break;
   47eda:	e7e6      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47edc:	68e3      	ldr	r3, [r4, #12]
   47ede:	4631      	mov	r1, r6
   47ee0:	9301      	str	r3, [sp, #4]
   47ee2:	68a3      	ldr	r3, [r4, #8]
   47ee4:	4628      	mov	r0, r5
   47ee6:	9300      	str	r3, [sp, #0]
   47ee8:	e9d4 2300 	ldrd	r2, r3, [r4]
   47eec:	f7f9 fc62 	bl	417b4 <print_formatted>
		break;
   47ef0:	e7db      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47ef2:	6923      	ldr	r3, [r4, #16]
   47ef4:	4631      	mov	r1, r6
   47ef6:	9302      	str	r3, [sp, #8]
   47ef8:	68e3      	ldr	r3, [r4, #12]
   47efa:	4628      	mov	r0, r5
   47efc:	9301      	str	r3, [sp, #4]
   47efe:	68a3      	ldr	r3, [r4, #8]
   47f00:	9300      	str	r3, [sp, #0]
   47f02:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f06:	f7f9 fc55 	bl	417b4 <print_formatted>
		break;
   47f0a:	e7ce      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f0c:	6963      	ldr	r3, [r4, #20]
   47f0e:	4631      	mov	r1, r6
   47f10:	9303      	str	r3, [sp, #12]
   47f12:	6923      	ldr	r3, [r4, #16]
   47f14:	4628      	mov	r0, r5
   47f16:	9302      	str	r3, [sp, #8]
   47f18:	68e3      	ldr	r3, [r4, #12]
   47f1a:	9301      	str	r3, [sp, #4]
   47f1c:	68a3      	ldr	r3, [r4, #8]
   47f1e:	9300      	str	r3, [sp, #0]
   47f20:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f24:	f7f9 fc46 	bl	417b4 <print_formatted>
		break;
   47f28:	e7bf      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f2a:	69a3      	ldr	r3, [r4, #24]
   47f2c:	4631      	mov	r1, r6
   47f2e:	9304      	str	r3, [sp, #16]
   47f30:	6963      	ldr	r3, [r4, #20]
   47f32:	4628      	mov	r0, r5
   47f34:	9303      	str	r3, [sp, #12]
   47f36:	6923      	ldr	r3, [r4, #16]
   47f38:	9302      	str	r3, [sp, #8]
   47f3a:	68e3      	ldr	r3, [r4, #12]
   47f3c:	9301      	str	r3, [sp, #4]
   47f3e:	68a3      	ldr	r3, [r4, #8]
   47f40:	9300      	str	r3, [sp, #0]
   47f42:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f46:	f7f9 fc35 	bl	417b4 <print_formatted>
		break;
   47f4a:	e7ae      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f4c:	69e3      	ldr	r3, [r4, #28]
   47f4e:	4631      	mov	r1, r6
   47f50:	9305      	str	r3, [sp, #20]
   47f52:	69a3      	ldr	r3, [r4, #24]
   47f54:	4628      	mov	r0, r5
   47f56:	9304      	str	r3, [sp, #16]
   47f58:	6963      	ldr	r3, [r4, #20]
   47f5a:	9303      	str	r3, [sp, #12]
   47f5c:	6923      	ldr	r3, [r4, #16]
   47f5e:	9302      	str	r3, [sp, #8]
   47f60:	68e3      	ldr	r3, [r4, #12]
   47f62:	9301      	str	r3, [sp, #4]
   47f64:	68a3      	ldr	r3, [r4, #8]
   47f66:	9300      	str	r3, [sp, #0]
   47f68:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f6c:	f7f9 fc22 	bl	417b4 <print_formatted>
		break;
   47f70:	e79b      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f72:	6a23      	ldr	r3, [r4, #32]
   47f74:	4631      	mov	r1, r6
   47f76:	9306      	str	r3, [sp, #24]
   47f78:	69e3      	ldr	r3, [r4, #28]
   47f7a:	4628      	mov	r0, r5
   47f7c:	9305      	str	r3, [sp, #20]
   47f7e:	69a3      	ldr	r3, [r4, #24]
   47f80:	9304      	str	r3, [sp, #16]
   47f82:	6963      	ldr	r3, [r4, #20]
   47f84:	9303      	str	r3, [sp, #12]
   47f86:	6923      	ldr	r3, [r4, #16]
   47f88:	9302      	str	r3, [sp, #8]
   47f8a:	68e3      	ldr	r3, [r4, #12]
   47f8c:	9301      	str	r3, [sp, #4]
   47f8e:	68a3      	ldr	r3, [r4, #8]
   47f90:	9300      	str	r3, [sp, #0]
   47f92:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f96:	f7f9 fc0d 	bl	417b4 <print_formatted>
		break;
   47f9a:	e786      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47f9e:	4631      	mov	r1, r6
   47fa0:	9307      	str	r3, [sp, #28]
   47fa2:	6a23      	ldr	r3, [r4, #32]
   47fa4:	4628      	mov	r0, r5
   47fa6:	9306      	str	r3, [sp, #24]
   47fa8:	69e3      	ldr	r3, [r4, #28]
   47faa:	9305      	str	r3, [sp, #20]
   47fac:	69a3      	ldr	r3, [r4, #24]
   47fae:	9304      	str	r3, [sp, #16]
   47fb0:	6963      	ldr	r3, [r4, #20]
   47fb2:	9303      	str	r3, [sp, #12]
   47fb4:	6923      	ldr	r3, [r4, #16]
   47fb6:	9302      	str	r3, [sp, #8]
   47fb8:	68e3      	ldr	r3, [r4, #12]
   47fba:	9301      	str	r3, [sp, #4]
   47fbc:	68a3      	ldr	r3, [r4, #8]
   47fbe:	9300      	str	r3, [sp, #0]
   47fc0:	e9d4 2300 	ldrd	r2, r3, [r4]
   47fc4:	f7f9 fbf6 	bl	417b4 <print_formatted>
		break;
   47fc8:	e76f      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47fca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   47fcc:	4631      	mov	r1, r6
   47fce:	9308      	str	r3, [sp, #32]
   47fd0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   47fd2:	4628      	mov	r0, r5
   47fd4:	9307      	str	r3, [sp, #28]
   47fd6:	6a23      	ldr	r3, [r4, #32]
   47fd8:	9306      	str	r3, [sp, #24]
   47fda:	69e3      	ldr	r3, [r4, #28]
   47fdc:	9305      	str	r3, [sp, #20]
   47fde:	69a3      	ldr	r3, [r4, #24]
   47fe0:	9304      	str	r3, [sp, #16]
   47fe2:	6963      	ldr	r3, [r4, #20]
   47fe4:	9303      	str	r3, [sp, #12]
   47fe6:	6923      	ldr	r3, [r4, #16]
   47fe8:	9302      	str	r3, [sp, #8]
   47fea:	68e3      	ldr	r3, [r4, #12]
   47fec:	9301      	str	r3, [sp, #4]
   47fee:	68a3      	ldr	r3, [r4, #8]
   47ff0:	9300      	str	r3, [sp, #0]
   47ff2:	e9d4 2300 	ldrd	r2, r3, [r4]
   47ff6:	f7f9 fbdd 	bl	417b4 <print_formatted>
		break;
   47ffa:	e756      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47ffc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   47ffe:	4631      	mov	r1, r6
   48000:	9309      	str	r3, [sp, #36]	; 0x24
   48002:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   48004:	4628      	mov	r0, r5
   48006:	9308      	str	r3, [sp, #32]
   48008:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4800a:	9307      	str	r3, [sp, #28]
   4800c:	6a23      	ldr	r3, [r4, #32]
   4800e:	9306      	str	r3, [sp, #24]
   48010:	69e3      	ldr	r3, [r4, #28]
   48012:	9305      	str	r3, [sp, #20]
   48014:	69a3      	ldr	r3, [r4, #24]
   48016:	9304      	str	r3, [sp, #16]
   48018:	6963      	ldr	r3, [r4, #20]
   4801a:	9303      	str	r3, [sp, #12]
   4801c:	6923      	ldr	r3, [r4, #16]
   4801e:	9302      	str	r3, [sp, #8]
   48020:	68e3      	ldr	r3, [r4, #12]
   48022:	9301      	str	r3, [sp, #4]
   48024:	68a3      	ldr	r3, [r4, #8]
   48026:	9300      	str	r3, [sp, #0]
   48028:	e9d4 2300 	ldrd	r2, r3, [r4]
   4802c:	f7f9 fbc2 	bl	417b4 <print_formatted>
		break;
   48030:	e73b      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48032:	6b23      	ldr	r3, [r4, #48]	; 0x30
   48034:	4631      	mov	r1, r6
   48036:	930a      	str	r3, [sp, #40]	; 0x28
   48038:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   4803a:	4628      	mov	r0, r5
   4803c:	9309      	str	r3, [sp, #36]	; 0x24
   4803e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   48040:	9308      	str	r3, [sp, #32]
   48042:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48044:	9307      	str	r3, [sp, #28]
   48046:	6a23      	ldr	r3, [r4, #32]
   48048:	9306      	str	r3, [sp, #24]
   4804a:	69e3      	ldr	r3, [r4, #28]
   4804c:	9305      	str	r3, [sp, #20]
   4804e:	69a3      	ldr	r3, [r4, #24]
   48050:	9304      	str	r3, [sp, #16]
   48052:	6963      	ldr	r3, [r4, #20]
   48054:	9303      	str	r3, [sp, #12]
   48056:	6923      	ldr	r3, [r4, #16]
   48058:	9302      	str	r3, [sp, #8]
   4805a:	68e3      	ldr	r3, [r4, #12]
   4805c:	9301      	str	r3, [sp, #4]
   4805e:	68a3      	ldr	r3, [r4, #8]
   48060:	9300      	str	r3, [sp, #0]
   48062:	e9d4 2300 	ldrd	r2, r3, [r4]
   48066:	f7f9 fba5 	bl	417b4 <print_formatted>
		break;
   4806a:	e71e      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   4806c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4806e:	4631      	mov	r1, r6
   48070:	930b      	str	r3, [sp, #44]	; 0x2c
   48072:	6b23      	ldr	r3, [r4, #48]	; 0x30
   48074:	4628      	mov	r0, r5
   48076:	930a      	str	r3, [sp, #40]	; 0x28
   48078:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   4807a:	9309      	str	r3, [sp, #36]	; 0x24
   4807c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   4807e:	9308      	str	r3, [sp, #32]
   48080:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48082:	9307      	str	r3, [sp, #28]
   48084:	6a23      	ldr	r3, [r4, #32]
   48086:	9306      	str	r3, [sp, #24]
   48088:	69e3      	ldr	r3, [r4, #28]
   4808a:	9305      	str	r3, [sp, #20]
   4808c:	69a3      	ldr	r3, [r4, #24]
   4808e:	9304      	str	r3, [sp, #16]
   48090:	6963      	ldr	r3, [r4, #20]
   48092:	9303      	str	r3, [sp, #12]
   48094:	6923      	ldr	r3, [r4, #16]
   48096:	9302      	str	r3, [sp, #8]
   48098:	68e3      	ldr	r3, [r4, #12]
   4809a:	9301      	str	r3, [sp, #4]
   4809c:	68a3      	ldr	r3, [r4, #8]
   4809e:	9300      	str	r3, [sp, #0]
   480a0:	e9d4 2300 	ldrd	r2, r3, [r4]
   480a4:	f7f9 fb86 	bl	417b4 <print_formatted>
		break;
   480a8:	e6ff      	b.n	47eaa <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   480aa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   480ac:	4631      	mov	r1, r6
   480ae:	930c      	str	r3, [sp, #48]	; 0x30
   480b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   480b2:	4628      	mov	r0, r5
   480b4:	930b      	str	r3, [sp, #44]	; 0x2c
   480b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
   480b8:	930a      	str	r3, [sp, #40]	; 0x28
   480ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   480bc:	9309      	str	r3, [sp, #36]	; 0x24
   480be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   480c0:	9308      	str	r3, [sp, #32]
   480c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   480c4:	9307      	str	r3, [sp, #28]
   480c6:	6a23      	ldr	r3, [r4, #32]
   480c8:	9306      	str	r3, [sp, #24]
   480ca:	69e3      	ldr	r3, [r4, #28]
   480cc:	9305      	str	r3, [sp, #20]
   480ce:	69a3      	ldr	r3, [r4, #24]
   480d0:	9304      	str	r3, [sp, #16]
   480d2:	6963      	ldr	r3, [r4, #20]
   480d4:	9303      	str	r3, [sp, #12]
   480d6:	6923      	ldr	r3, [r4, #16]
   480d8:	9302      	str	r3, [sp, #8]
   480da:	68e3      	ldr	r3, [r4, #12]
   480dc:	9301      	str	r3, [sp, #4]
   480de:	68a3      	ldr	r3, [r4, #8]
   480e0:	9300      	str	r3, [sp, #0]
   480e2:	e9d4 2300 	ldrd	r2, r3, [r4]
   480e6:	f7f9 fb65 	bl	417b4 <print_formatted>
}
   480ea:	e6de      	b.n	47eaa <std_print+0x78>

000480ec <log_output_flush>:
		     output->control_block->offset,
   480ec:	6842      	ldr	r2, [r0, #4]
{
   480ee:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
   480f0:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   480f4:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   480f6:	6881      	ldr	r1, [r0, #8]
   480f8:	6800      	ldr	r0, [r0, #0]
   480fa:	f7ff fe8d 	bl	47e18 <buffer_write>
	output->control_block->offset = 0;
   480fe:	2200      	movs	r2, #0
   48100:	6863      	ldr	r3, [r4, #4]
   48102:	601a      	str	r2, [r3, #0]
}
   48104:	bd10      	pop	{r4, pc}

00048106 <out_func>:
{
   48106:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   48108:	684b      	ldr	r3, [r1, #4]
{
   4810a:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
   4810c:	681a      	ldr	r2, [r3, #0]
   4810e:	68cb      	ldr	r3, [r1, #12]
{
   48110:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   48112:	429a      	cmp	r2, r3
   48114:	d102      	bne.n	4811c <out_func+0x16>
		log_output_flush(out_ctx);
   48116:	4608      	mov	r0, r1
   48118:	f7ff ffe8 	bl	480ec <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4811c:	6863      	ldr	r3, [r4, #4]
   4811e:	e8d3 2fef 	ldaex	r2, [r3]
   48122:	1c51      	adds	r1, r2, #1
   48124:	e8c3 1fe0 	stlex	r0, r1, [r3]
   48128:	2800      	cmp	r0, #0
   4812a:	d1f8      	bne.n	4811e <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
   4812c:	68a3      	ldr	r3, [r4, #8]
}
   4812e:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
   48130:	549d      	strb	r5, [r3, r2]
}
   48132:	bd38      	pop	{r3, r4, r5, pc}

00048134 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   48134:	2200      	movs	r2, #0
   48136:	e9c0 2200 	strd	r2, r2, [r0]
   4813a:	6082      	str	r2, [r0, #8]
}
   4813c:	4770      	bx	lr

0004813e <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   4813e:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   48140:	6800      	ldr	r0, [r0, #0]
   48142:	f7f9 bf23 	b.w	41f8c <z_arm_fatal_error>

00048146 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   48146:	2100      	movs	r1, #0
   48148:	2001      	movs	r0, #1
   4814a:	f7f9 bf1f 	b.w	41f8c <z_arm_fatal_error>

0004814e <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   4814e:	b508      	push	{r3, lr}
	handler();
   48150:	f7f9 ff96 	bl	42080 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   48154:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   48158:	f7fa b85e 	b.w	42218 <z_arm_exc_exit>

0004815c <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   4815c:	6e43      	ldr	r3, [r0, #100]	; 0x64
   4815e:	f383 880b 	msr	PSPLIM, r3
}
   48162:	4770      	bx	lr

00048164 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   48164:	4770      	bx	lr

00048166 <z_arm_restore_fp_context>:
   48166:	4770      	bx	lr

00048168 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   48168:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   4816c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   48170:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   48172:	bf08      	it	eq
   48174:	f06f 0015 	mvneq.w	r0, #21
   48178:	4770      	bx	lr

0004817a <mpu_configure_region>:
{
   4817a:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   4817c:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   4817e:	680c      	ldr	r4, [r1, #0]
{
   48180:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   48182:	890a      	ldrh	r2, [r1, #8]
   48184:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   48186:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48188:	3b01      	subs	r3, #1
   4818a:	f024 041f 	bic.w	r4, r4, #31
   4818e:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   48190:	f002 021f 	and.w	r2, r2, #31
   48194:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48198:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   4819c:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
   4819e:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   481a2:	9303      	str	r3, [sp, #12]
   481a4:	f7fa fb44 	bl	42830 <region_allocate_and_init>
}
   481a8:	b005      	add	sp, #20
   481aa:	bd30      	pop	{r4, r5, pc}

000481ac <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
   481ac:	4770      	bx	lr

000481ae <calloc>:

#endif /* CONFIG_MINIMAL_LIBC_MALLOC */

#ifdef CONFIG_MINIMAL_LIBC_CALLOC
void *calloc(size_t nmemb, size_t size)
{
   481ae:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   481b0:	fba0 4501 	umull	r4, r5, r0, r1
   481b4:	b935      	cbnz	r5, 481c4 <calloc+0x16>
	if (size_mul_overflow(nmemb, size, &size)) {
		errno = ENOMEM;
		return NULL;
	}

	ret = malloc(size);
   481b6:	4620      	mov	r0, r4
   481b8:	f7fa fca6 	bl	42b08 <malloc>

	if (ret != NULL) {
   481bc:	4606      	mov	r6, r0
   481be:	b938      	cbnz	r0, 481d0 <calloc+0x22>
		(void)memset(ret, 0, size);
	}

	return ret;
}
   481c0:	4630      	mov	r0, r6
   481c2:	bd70      	pop	{r4, r5, r6, pc}
   481c4:	f7fd ff3e 	bl	46044 <z_impl_z_errno>
		errno = ENOMEM;
   481c8:	230c      	movs	r3, #12
		return NULL;
   481ca:	2600      	movs	r6, #0
		errno = ENOMEM;
   481cc:	6003      	str	r3, [r0, #0]
		return NULL;
   481ce:	e7f7      	b.n	481c0 <calloc+0x12>
		(void)memset(ret, 0, size);
   481d0:	4622      	mov	r2, r4
   481d2:	4629      	mov	r1, r5
   481d4:	f000 f839 	bl	4824a <memset>
   481d8:	e7f2      	b.n	481c0 <calloc+0x12>

000481da <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   481da:	4603      	mov	r3, r0
   481dc:	3901      	subs	r1, #1
   481de:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   481e2:	b90a      	cbnz	r2, 481e8 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   481e4:	701a      	strb	r2, [r3, #0]

	return dest;
}
   481e6:	4770      	bx	lr
		*d = *s;
   481e8:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   481ec:	e7f7      	b.n	481de <strcpy+0x4>

000481ee <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
   481ee:	b570      	push	{r4, r5, r6, lr}
   481f0:	4605      	mov	r5, r0
   481f2:	3901      	subs	r1, #1
   481f4:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   481f6:	b142      	cbz	r2, 4820a <strncpy+0x1c>
   481f8:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   481fc:	1e56      	subs	r6, r2, #1
   481fe:	b92b      	cbnz	r3, 4820c <strncpy+0x1e>
   48200:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   48202:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   48206:	42a2      	cmp	r2, r4
   48208:	d1fb      	bne.n	48202 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   4820a:	bd70      	pop	{r4, r5, r6, pc}
		n--;
   4820c:	4632      	mov	r2, r6
		*d = *s;
   4820e:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   48212:	e7ef      	b.n	481f4 <strncpy+0x6>

00048214 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   48214:	4603      	mov	r3, r0
	size_t n = 0;
   48216:	2000      	movs	r0, #0

	while (*s != '\0') {
   48218:	5c1a      	ldrb	r2, [r3, r0]
   4821a:	b902      	cbnz	r2, 4821e <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   4821c:	4770      	bx	lr
		n++;
   4821e:	3001      	adds	r0, #1
   48220:	e7fa      	b.n	48218 <strlen+0x4>

00048222 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   48222:	4603      	mov	r3, r0
	size_t n = 0;
   48224:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   48226:	5c1a      	ldrb	r2, [r3, r0]
   48228:	b10a      	cbz	r2, 4822e <strnlen+0xc>
   4822a:	4288      	cmp	r0, r1
   4822c:	d100      	bne.n	48230 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   4822e:	4770      	bx	lr
		n++;
   48230:	3001      	adds	r0, #1
   48232:	e7f8      	b.n	48226 <strnlen+0x4>

00048234 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   48234:	b510      	push	{r4, lr}
   48236:	1e43      	subs	r3, r0, #1
   48238:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   4823a:	4291      	cmp	r1, r2
   4823c:	d100      	bne.n	48240 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   4823e:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   48240:	f811 4b01 	ldrb.w	r4, [r1], #1
   48244:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   48248:	e7f7      	b.n	4823a <memcpy+0x6>

0004824a <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   4824a:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   4824c:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   4824e:	4402      	add	r2, r0
   48250:	4293      	cmp	r3, r2
   48252:	d100      	bne.n	48256 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   48254:	4770      	bx	lr
		*(d_byte++) = c_byte;
   48256:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   4825a:	e7f9      	b.n	48250 <memset+0x6>

0004825c <_stdout_hook_default>:
}
   4825c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   48260:	4770      	bx	lr

00048262 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   48262:	b2cb      	uxtb	r3, r1
   48264:	210c      	movs	r1, #12
   48266:	6902      	ldr	r2, [r0, #16]
   48268:	fb03 2101 	mla	r1, r3, r1, r2
   4826c:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   4826e:	f000 0007 	and.w	r0, r0, #7
   48272:	4770      	bx	lr

00048274 <set_off_state>:
	__asm__ volatile(
   48274:	f04f 0320 	mov.w	r3, #32
   48278:	f3ef 8211 	mrs	r2, BASEPRI
   4827c:	f383 8812 	msr	BASEPRI_MAX, r3
   48280:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   48284:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   48286:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   4828a:	d001      	beq.n	48290 <set_off_state+0x1c>
   4828c:	428b      	cmp	r3, r1
   4828e:	d107      	bne.n	482a0 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   48290:	2301      	movs	r3, #1
   48292:	6003      	str	r3, [r0, #0]
	int err = 0;
   48294:	2000      	movs	r0, #0
	__asm__ volatile(
   48296:	f382 8811 	msr	BASEPRI, r2
   4829a:	f3bf 8f6f 	isb	sy
}
   4829e:	4770      	bx	lr
		err = -EPERM;
   482a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   482a4:	e7f7      	b.n	48296 <set_off_state+0x22>

000482a6 <set_starting_state>:
{
   482a6:	b510      	push	{r4, lr}
	__asm__ volatile(
   482a8:	f04f 0320 	mov.w	r3, #32
   482ac:	f3ef 8211 	mrs	r2, BASEPRI
   482b0:	f383 8812 	msr	BASEPRI_MAX, r3
   482b4:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   482b8:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   482ba:	f003 0407 	and.w	r4, r3, #7
   482be:	2c01      	cmp	r4, #1
   482c0:	d106      	bne.n	482d0 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   482c2:	6001      	str	r1, [r0, #0]
	int err = 0;
   482c4:	2000      	movs	r0, #0
	__asm__ volatile(
   482c6:	f382 8811 	msr	BASEPRI, r2
   482ca:	f3bf 8f6f 	isb	sy
}
   482ce:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   482d0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   482d4:	428b      	cmp	r3, r1
		err = -EALREADY;
   482d6:	bf14      	ite	ne
   482d8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   482dc:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   482e0:	e7f1      	b.n	482c6 <set_starting_state+0x20>

000482e2 <set_on_state>:
	__asm__ volatile(
   482e2:	f04f 0320 	mov.w	r3, #32
   482e6:	f3ef 8211 	mrs	r2, BASEPRI
   482ea:	f383 8812 	msr	BASEPRI_MAX, r3
   482ee:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   482f2:	6803      	ldr	r3, [r0, #0]
   482f4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   482f8:	f043 0302 	orr.w	r3, r3, #2
   482fc:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   482fe:	f382 8811 	msr	BASEPRI, r2
   48302:	f3bf 8f6f 	isb	sy
}
   48306:	4770      	bx	lr

00048308 <onoff_started_callback>:
{
   48308:	b410      	push	{r4}
	notify(mgr, 0);
   4830a:	241c      	movs	r4, #28
	return &data->mgr[type];
   4830c:	6900      	ldr	r0, [r0, #16]
   4830e:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   48310:	fb03 0004 	mla	r0, r3, r4, r0
   48314:	2100      	movs	r1, #0
}
   48316:	bc10      	pop	{r4}
	notify(mgr, 0);
   48318:	4710      	bx	r2

0004831a <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   4831a:	2000      	movs	r0, #0
   4831c:	f7fb bd74 	b.w	43e08 <nrfx_clock_start>

00048320 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   48320:	2000      	movs	r0, #0
   48322:	f7fb bda3 	b.w	43e6c <nrfx_clock_stop>

00048326 <blocking_start_callback>:
{
   48326:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   48328:	f7fe b998 	b.w	4665c <z_impl_k_sem_give>

0004832c <api_stop>:
{
   4832c:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   4832e:	240c      	movs	r4, #12
   48330:	b2c9      	uxtb	r1, r1
   48332:	434c      	muls	r4, r1
{
   48334:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   48336:	6900      	ldr	r0, [r0, #16]
   48338:	f104 0340 	add.w	r3, r4, #64	; 0x40
   4833c:	2180      	movs	r1, #128	; 0x80
   4833e:	4418      	add	r0, r3
   48340:	f7ff ff98 	bl	48274 <set_off_state>
	if (err < 0) {
   48344:	2800      	cmp	r0, #0
   48346:	db04      	blt.n	48352 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   48348:	6869      	ldr	r1, [r5, #4]
   4834a:	440c      	add	r4, r1
   4834c:	6863      	ldr	r3, [r4, #4]
   4834e:	4798      	blx	r3
	return 0;
   48350:	2000      	movs	r0, #0
}
   48352:	bd38      	pop	{r3, r4, r5, pc}

00048354 <api_start>:
{
   48354:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   48358:	240c      	movs	r4, #12
   4835a:	b2c9      	uxtb	r1, r1
   4835c:	434c      	muls	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   4835e:	6905      	ldr	r5, [r0, #16]
{
   48360:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   48362:	f104 0040 	add.w	r0, r4, #64	; 0x40
   48366:	2180      	movs	r1, #128	; 0x80
   48368:	4428      	add	r0, r5
{
   4836a:	4690      	mov	r8, r2
   4836c:	461f      	mov	r7, r3
	err = set_starting_state(&subdata->flags, ctx);
   4836e:	f7ff ff9a 	bl	482a6 <set_starting_state>
	if (err < 0) {
   48372:	2800      	cmp	r0, #0
   48374:	db06      	blt.n	48384 <api_start+0x30>
	subdata->cb = cb;
   48376:	4425      	add	r5, r4
	subdata->user_data = user_data;
   48378:	e9c5 870e 	strd	r8, r7, [r5, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   4837c:	6873      	ldr	r3, [r6, #4]
   4837e:	591b      	ldr	r3, [r3, r4]
   48380:	4798      	blx	r3
	return 0;
   48382:	2000      	movs	r0, #0
}
   48384:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00048388 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48388:	6843      	ldr	r3, [r0, #4]
}
   4838a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4838c:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   4838e:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   48390:	600b      	str	r3, [r1, #0]
}
   48392:	4770      	bx	lr

00048394 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48394:	6843      	ldr	r3, [r0, #4]
   48396:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   48398:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   4839a:	4042      	eors	r2, r0
   4839c:	400a      	ands	r2, r1
   4839e:	4042      	eors	r2, r0
    p_reg->OUT = value;
   483a0:	605a      	str	r2, [r3, #4]
}
   483a2:	2000      	movs	r0, #0
   483a4:	4770      	bx	lr

000483a6 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483a6:	6843      	ldr	r3, [r0, #4]
}
   483a8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483aa:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   483ac:	6099      	str	r1, [r3, #8]
}
   483ae:	4770      	bx	lr

000483b0 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483b0:	6843      	ldr	r3, [r0, #4]
}
   483b2:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483b4:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   483b6:	60d9      	str	r1, [r3, #12]
}
   483b8:	4770      	bx	lr

000483ba <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483ba:	6843      	ldr	r3, [r0, #4]
}
   483bc:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   483be:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   483c0:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   483c2:	404b      	eors	r3, r1
    p_reg->OUT = value;
   483c4:	6053      	str	r3, [r2, #4]
}
   483c6:	4770      	bx	lr

000483c8 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   483c8:	6903      	ldr	r3, [r0, #16]
{
   483ca:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   483cc:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   483ce:	b158      	cbz	r0, 483e8 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   483d0:	2400      	movs	r4, #0
   483d2:	4281      	cmp	r1, r0
   483d4:	d113      	bne.n	483fe <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   483d6:	6808      	ldr	r0, [r1, #0]
   483d8:	b95c      	cbnz	r4, 483f2 <gpio_nrfx_manage_callback+0x2a>
   483da:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   483dc:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   483de:	42a1      	cmp	r1, r4
   483e0:	d100      	bne.n	483e4 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   483e2:	6098      	str	r0, [r3, #8]
	parent->next = child;
   483e4:	2000      	movs	r0, #0
   483e6:	6008      	str	r0, [r1, #0]
	if (set) {
   483e8:	b972      	cbnz	r2, 48408 <gpio_nrfx_manage_callback+0x40>
	return 0;
   483ea:	2000      	movs	r0, #0
}
   483ec:	bd30      	pop	{r4, r5, pc}
   483ee:	4628      	mov	r0, r5
   483f0:	e7ef      	b.n	483d2 <gpio_nrfx_manage_callback+0xa>
   483f2:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   483f4:	6898      	ldr	r0, [r3, #8]
   483f6:	4281      	cmp	r1, r0
	list->tail = node;
   483f8:	bf08      	it	eq
   483fa:	609c      	streq	r4, [r3, #8]
}
   483fc:	e7f2      	b.n	483e4 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   483fe:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48400:	4604      	mov	r4, r0
   48402:	2d00      	cmp	r5, #0
   48404:	d1f3      	bne.n	483ee <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   48406:	b13a      	cbz	r2, 48418 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   48408:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   4840a:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   4840c:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   4840e:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   48410:	2800      	cmp	r0, #0
   48412:	d1ea      	bne.n	483ea <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   48414:	6099      	str	r1, [r3, #8]
}
   48416:	e7e9      	b.n	483ec <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   48418:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   4841c:	e7e6      	b.n	483ec <gpio_nrfx_manage_callback+0x24>

0004841e <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   4841e:	6843      	ldr	r3, [r0, #4]
   48420:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   48422:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   48426:	05d1      	lsls	r1, r2, #23
   48428:	d518      	bpl.n	4845c <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4842a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   4842e:	b1aa      	cbz	r2, 4845c <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   48430:	f04f 0120 	mov.w	r1, #32
   48434:	f3ef 8211 	mrs	r2, BASEPRI
   48438:	f381 8812 	msr	BASEPRI_MAX, r1
   4843c:	f3bf 8f6f 	isb	sy
   48440:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   48444:	b131      	cbz	r1, 48454 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48446:	2100      	movs	r1, #0
   48448:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   4844c:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48450:	2101      	movs	r1, #1
   48452:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   48454:	f382 8811 	msr	BASEPRI, r2
   48458:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   4845c:	6842      	ldr	r2, [r0, #4]
   4845e:	6852      	ldr	r2, [r2, #4]
   48460:	06d2      	lsls	r2, r2, #27
   48462:	d515      	bpl.n	48490 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   48464:	f04f 0120 	mov.w	r1, #32
   48468:	f3ef 8211 	mrs	r2, BASEPRI
   4846c:	f381 8812 	msr	BASEPRI_MAX, r1
   48470:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48474:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   48478:	b111      	cbz	r1, 48480 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   4847a:	2100      	movs	r1, #0
   4847c:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   48480:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   48484:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   48488:	f382 8811 	msr	BASEPRI, r2
   4848c:	f3bf 8f6f 	isb	sy
}
   48490:	4770      	bx	lr

00048492 <uarte_nrfx_config_get>:
{
   48492:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   48494:	6902      	ldr	r2, [r0, #16]
   48496:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   4849a:	e883 0003 	stmia.w	r3, {r0, r1}
}
   4849e:	2000      	movs	r0, #0
   484a0:	4770      	bx	lr

000484a2 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   484a2:	6843      	ldr	r3, [r0, #4]
   484a4:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   484a6:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   484aa:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   484ae:	4770      	bx	lr

000484b0 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   484b0:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   484b2:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   484b4:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   484b8:	b940      	cbnz	r0, 484cc <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   484ba:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   484bc:	0792      	lsls	r2, r2, #30
   484be:	d406      	bmi.n	484ce <is_tx_ready+0x1e>
   484c0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   484c4:	3800      	subs	r0, #0
   484c6:	bf18      	it	ne
   484c8:	2001      	movne	r0, #1
   484ca:	4770      	bx	lr
   484cc:	2001      	movs	r0, #1
}
   484ce:	4770      	bx	lr

000484d0 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   484d0:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   484d2:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   484d4:	681b      	ldr	r3, [r3, #0]
   484d6:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   484da:	b148      	cbz	r0, 484f0 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   484dc:	2000      	movs	r0, #0
	*c = data->rx_data;
   484de:	7c52      	ldrb	r2, [r2, #17]
   484e0:	700a      	strb	r2, [r1, #0]
   484e2:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   484e6:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   484ea:	2201      	movs	r2, #1
   484ec:	601a      	str	r2, [r3, #0]
	return 0;
   484ee:	4770      	bx	lr
		return -1;
   484f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   484f4:	4770      	bx	lr

000484f6 <entropy_cc3xx_rng_get_entropy>:

static int entropy_cc3xx_rng_get_entropy(
	const struct device *dev,
	uint8_t *buffer,
	uint16_t length)
{
   484f6:	4608      	mov	r0, r1
   484f8:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buffer != NULL);


#if defined(CONFIG_BUILD_WITH_TFM)

	res = psa_generate_random(buffer, length);
   484fa:	4611      	mov	r1, r2
   484fc:	f7fe ff68 	bl	473d0 <psa_generate_random>
	if (res != PSA_SUCCESS) {
   48500:	2800      	cmp	r0, #0
		offset += chunk_size;
	}
#endif

	return res;
}
   48502:	bf18      	it	ne
   48504:	f06f 0015 	mvnne.w	r0, #21
   48508:	bd08      	pop	{r3, pc}

0004850a <entropy_cc3xx_rng_init>:

static int entropy_cc3xx_rng_init(const struct device *dev)
{
   4850a:	b508      	push	{r3, lr}
	(void)dev;

	#if defined(CONFIG_BUILD_WITH_TFM)
		int ret = -1;

		ret = psa_crypto_init();
   4850c:	f000 fbaf 	bl	48c6e <psa_crypto_init>
		if (ret != PSA_SUCCESS) {
   48510:	2800      	cmp	r0, #0
			return -EINVAL;
		}
	#endif

	return 0;
}
   48512:	bf18      	it	ne
   48514:	f06f 0015 	mvnne.w	r0, #21
   48518:	bd08      	pop	{r3, pc}

0004851a <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   4851a:	4770      	bx	lr

0004851c <sys_clock_cycle_get_32>:
{
   4851c:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   4851e:	f7fb f881 	bl	43624 <z_nrf_rtc_timer_read>
}
   48522:	bd08      	pop	{r3, pc}

00048524 <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   48524:	f000 bb4d 	b.w	48bc2 <z_impl_k_busy_wait>

00048528 <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   48528:	f000 b9ee 	b.w	48908 <k_is_in_isr>

0004852c <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   4852c:	f7fe b896 	b.w	4665c <z_impl_k_sem_give>

00048530 <nrf_modem_os_sem_take>:
{
   48530:	b508      	push	{r3, lr}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   48532:	1c4b      	adds	r3, r1, #1
   48534:	bf13      	iteet	ne
   48536:	ea21 72e1 	bicne.w	r2, r1, r1, asr #31
   4853a:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   4853e:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   48542:	17d3      	asrne	r3, r2, #31
	return z_impl_k_sem_take(sem, timeout);
   48544:	f7fe f8aa 	bl	4669c <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   48548:	f110 0f0b 	cmn.w	r0, #11
}
   4854c:	bf0c      	ite	eq
   4854e:	2074      	moveq	r0, #116	; 0x74
   48550:	2000      	movne	r0, #0
   48552:	bd08      	pop	{r3, pc}

00048554 <read_task_create>:
{
   48554:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   48556:	201c      	movs	r0, #28
   48558:	2200      	movs	r2, #0
   4855a:	2106      	movs	r1, #6
   4855c:	f7f9 fd6c 	bl	42038 <z_arm_irq_priority_set>
}
   48560:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   48564:	201c      	movs	r0, #28
   48566:	f7f9 bd49 	b.w	41ffc <arch_irq_enable>

0004856a <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   4856a:	2000      	movs	r0, #0
   4856c:	4770      	bx	lr

0004856e <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   4856e:	2000      	movs	r0, #0
   48570:	4770      	bx	lr

00048572 <sys_arch_reboot>:
#if defined(CONFIG_TFM_PARTITION_PLATFORM)
void sys_arch_reboot(int type)
{
	ARG_UNUSED(type);

	(void)tfm_platform_system_reset();
   48572:	f7fe be2b 	b.w	471cc <tfm_platform_system_reset>

00048576 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   48576:	4700      	bx	r0

00048578 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   48578:	f000 bb23 	b.w	48bc2 <z_impl_k_busy_wait>

0004857c <nrfx_clock_enable>:
{
   4857c:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   4857e:	2005      	movs	r0, #5
   48580:	f7f9 fd4c 	bl	4201c <arch_irq_is_enabled>
   48584:	b920      	cbnz	r0, 48590 <nrfx_clock_enable+0x14>
}
   48586:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   4858a:	2005      	movs	r0, #5
   4858c:	f7f9 bd36 	b.w	41ffc <arch_irq_enable>
   48590:	bd08      	pop	{r3, pc}

00048592 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   48592:	f7fc b89d 	b.w	446d0 <_DoInit>

00048596 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   48596:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   48598:	f7ff fffb 	bl	48592 <SEGGER_RTT_Init>

	return 0;
}
   4859c:	2000      	movs	r0, #0
   4859e:	bd08      	pop	{r3, pc}

000485a0 <rpc_handle_ctrl_message>:
   485a0:	2902      	cmp	r1, #2
   485a2:	b510      	push	{r4, lr}
   485a4:	4604      	mov	r4, r0
   485a6:	d005      	beq.n	485b4 <rpc_handle_ctrl_message+0x14>
   485a8:	2904      	cmp	r1, #4
   485aa:	d001      	beq.n	485b0 <rpc_handle_ctrl_message+0x10>
   485ac:	2901      	cmp	r1, #1
   485ae:	d107      	bne.n	485c0 <rpc_handle_ctrl_message+0x20>
   485b0:	2000      	movs	r0, #0
   485b2:	bd10      	pop	{r4, pc}
   485b4:	6880      	ldr	r0, [r0, #8]
   485b6:	2800      	cmp	r0, #0
   485b8:	d0fa      	beq.n	485b0 <rpc_handle_ctrl_message+0x10>
   485ba:	f000 f831 	bl	48620 <rpc_transport_local_data_free>
   485be:	e7f7      	b.n	485b0 <rpc_handle_ctrl_message+0x10>
   485c0:	6880      	ldr	r0, [r0, #8]
   485c2:	b108      	cbz	r0, 485c8 <rpc_handle_ctrl_message+0x28>
   485c4:	f000 f82c 	bl	48620 <rpc_transport_local_data_free>
   485c8:	4620      	mov	r0, r4
   485ca:	f000 f825 	bl	48618 <rpc_transport_msg_free>
   485ce:	e7ef      	b.n	485b0 <rpc_handle_ctrl_message+0x10>

000485d0 <rpc_message_send>:
   485d0:	6843      	ldr	r3, [r0, #4]
   485d2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   485d6:	f043 0302 	orr.w	r3, r3, #2
   485da:	6043      	str	r3, [r0, #4]
   485dc:	f000 b824 	b.w	48628 <rpc_transport_data_msg_send>

000485e0 <rpc_message_alloc>:
   485e0:	b570      	push	{r4, r5, r6, lr}
   485e2:	4606      	mov	r6, r0
   485e4:	b130      	cbz	r0, 485f4 <rpc_message_alloc+0x14>
   485e6:	f000 f819 	bl	4861c <rpc_transport_data_alloc>
   485ea:	4605      	mov	r5, r0
   485ec:	b918      	cbnz	r0, 485f6 <rpc_message_alloc+0x16>
   485ee:	2400      	movs	r4, #0
   485f0:	4620      	mov	r0, r4
   485f2:	bd70      	pop	{r4, r5, r6, pc}
   485f4:	4605      	mov	r5, r0
   485f6:	f000 f80d 	bl	48614 <rpc_transport_data_msg_alloc>
   485fa:	4604      	mov	r4, r0
   485fc:	b110      	cbz	r0, 48604 <rpc_message_alloc+0x24>
   485fe:	60c6      	str	r6, [r0, #12]
   48600:	6085      	str	r5, [r0, #8]
   48602:	e7f5      	b.n	485f0 <rpc_message_alloc+0x10>
   48604:	2d00      	cmp	r5, #0
   48606:	d0f2      	beq.n	485ee <rpc_message_alloc+0xe>
   48608:	4628      	mov	r0, r5
   4860a:	f000 f809 	bl	48620 <rpc_transport_local_data_free>
   4860e:	e7ef      	b.n	485f0 <rpc_message_alloc+0x10>

00048610 <rpc_message_data_free>:
   48610:	f000 b808 	b.w	48624 <rpc_transport_peer_data_free>

00048614 <rpc_transport_data_msg_alloc>:
   48614:	f7fc bb44 	b.w	44ca0 <rpc_transport_ipc_data_msg_alloc>

00048618 <rpc_transport_msg_free>:
   48618:	f7fc bb8e 	b.w	44d38 <rpc_transport_ipc_msg_free>

0004861c <rpc_transport_data_alloc>:
   4861c:	f7fc bb72 	b.w	44d04 <rpc_transport_ipc_data_alloc>

00048620 <rpc_transport_local_data_free>:
   48620:	f000 b804 	b.w	4862c <rpc_transport_ipc_local_data_free>

00048624 <rpc_transport_peer_data_free>:
   48624:	f000 b809 	b.w	4863a <rpc_transport_ipc_peer_data_free>

00048628 <rpc_transport_data_msg_send>:
   48628:	f7fc bafe 	b.w	44c28 <rpc_transport_ipc_data_msg_send>

0004862c <rpc_transport_ipc_local_data_free>:
   4862c:	b508      	push	{r3, lr}
   4862e:	f7fb fb29 	bl	43c84 <nrf_modem_os_shm_tx_free>
   48632:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   48636:	f7fb baef 	b.w	43c18 <nrf_modem_os_application_irq_set>

0004863a <rpc_transport_ipc_peer_data_free>:
   4863a:	b510      	push	{r4, lr}
   4863c:	4604      	mov	r4, r0
   4863e:	f7fc fb41 	bl	44cc4 <rpc_transport_ipc_ctrl_msg_alloc>
   48642:	2101      	movs	r1, #1
   48644:	2200      	movs	r2, #0
   48646:	7001      	strb	r1, [r0, #0]
   48648:	2102      	movs	r1, #2
   4864a:	6084      	str	r4, [r0, #8]
   4864c:	7042      	strb	r2, [r0, #1]
   4864e:	7081      	strb	r1, [r0, #2]
   48650:	70c2      	strb	r2, [r0, #3]
   48652:	f7fc fb07 	bl	44c64 <rpc_transport_ipc_ctrl_msg_send>
   48656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   4865a:	f7fb badd 	b.w	43c18 <nrf_modem_os_application_irq_set>

0004865e <rpc_client_request_alloc>:
   4865e:	b508      	push	{r3, lr}
   48660:	f7ff ffbe 	bl	485e0 <rpc_message_alloc>
   48664:	b100      	cbz	r0, 48668 <rpc_client_request_alloc+0xa>
   48666:	3008      	adds	r0, #8
   48668:	bd08      	pop	{r3, pc}

0004866a <rpc_client_request_send>:
   4866a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   4866e:	4610      	mov	r0, r2
   48670:	f840 1d08 	str.w	r1, [r0, #-8]!
   48674:	f7ff bfac 	b.w	485d0 <rpc_message_send>

00048678 <rpc_client_data_free>:
   48678:	f7ff bfca 	b.w	48610 <rpc_message_data_free>

0004867c <ip_interface_request_create>:
   4867c:	b570      	push	{r4, r5, r6, lr}
   4867e:	4606      	mov	r6, r0
   48680:	4618      	mov	r0, r3
   48682:	460d      	mov	r5, r1
   48684:	4614      	mov	r4, r2
   48686:	f7ff ffea 	bl	4865e <rpc_client_request_alloc>
   4868a:	b148      	cbz	r0, 486a0 <ip_interface_request_create+0x24>
   4868c:	2300      	movs	r3, #0
   4868e:	2208      	movs	r2, #8
   48690:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   48694:	60c4      	str	r4, [r0, #12]
   48696:	6105      	str	r5, [r0, #16]
   48698:	7202      	strb	r2, [r0, #8]
   4869a:	7243      	strb	r3, [r0, #9]
   4869c:	7283      	strb	r3, [r0, #10]
   4869e:	72c3      	strb	r3, [r0, #11]
   486a0:	bd70      	pop	{r4, r5, r6, pc}

000486a2 <ip_interface_wait>:
   486a2:	b538      	push	{r3, r4, r5, lr}
   486a4:	4605      	mov	r5, r0
   486a6:	f7fc fccd 	bl	45044 <interface_socket_wait>
   486aa:	4604      	mov	r4, r0
   486ac:	b938      	cbnz	r0, 486be <ip_interface_wait+0x1c>
   486ae:	4628      	mov	r0, r5
   486b0:	f7fc fd42 	bl	45138 <interface_socket_from_handle_get>
   486b4:	b118      	cbz	r0, 486be <ip_interface_wait+0x1c>
   486b6:	6844      	ldr	r4, [r0, #4]
   486b8:	b10c      	cbz	r4, 486be <ip_interface_wait+0x1c>
   486ba:	2300      	movs	r3, #0
   486bc:	6043      	str	r3, [r0, #4]
   486be:	4620      	mov	r0, r4
   486c0:	bd38      	pop	{r3, r4, r5, pc}

000486c2 <secure_client_socket>:
   486c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   486c6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   486c8:	9301      	str	r3, [sp, #4]
   486ca:	680b      	ldr	r3, [r1, #0]
   486cc:	4606      	mov	r6, r0
   486ce:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   486d2:	600b      	str	r3, [r1, #0]
   486d4:	680b      	ldr	r3, [r1, #0]
   486d6:	460c      	mov	r4, r1
   486d8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   486dc:	600b      	str	r3, [r1, #0]
   486de:	680f      	ldr	r7, [r1, #0]
   486e0:	463a      	mov	r2, r7
   486e2:	f7fc fff5 	bl	456d0 <secure_socket_attach_initiate>
   486e6:	4605      	mov	r5, r0
   486e8:	b950      	cbnz	r0, 48700 <secure_client_socket+0x3e>
   486ea:	220c      	movs	r2, #12
   486ec:	4630      	mov	r0, r6
   486ee:	4611      	mov	r1, r2
   486f0:	ab01      	add	r3, sp, #4
   486f2:	f7ff ffd6 	bl	486a2 <ip_interface_wait>
   486f6:	4605      	mov	r5, r0
   486f8:	b128      	cbz	r0, 48706 <secure_client_socket+0x44>
   486fa:	2877      	cmp	r0, #119	; 0x77
   486fc:	d000      	beq.n	48700 <secure_client_socket+0x3e>
   486fe:	6027      	str	r7, [r4, #0]
   48700:	4628      	mov	r0, r5
   48702:	b003      	add	sp, #12
   48704:	bdf0      	pop	{r4, r5, r6, r7, pc}
   48706:	4630      	mov	r0, r6
   48708:	f7fc ffd0 	bl	456ac <hostname_free>
   4870c:	6823      	ldr	r3, [r4, #0]
   4870e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   48712:	6023      	str	r3, [r4, #0]
   48714:	6823      	ldr	r3, [r4, #0]
   48716:	0c1b      	lsrs	r3, r3, #16
   48718:	041b      	lsls	r3, r3, #16
   4871a:	f043 030c 	orr.w	r3, r3, #12
   4871e:	6023      	str	r3, [r4, #0]
   48720:	6823      	ldr	r3, [r4, #0]
   48722:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   48726:	6023      	str	r3, [r4, #0]
   48728:	6823      	ldr	r3, [r4, #0]
   4872a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   4872e:	6023      	str	r3, [r4, #0]
   48730:	e7e6      	b.n	48700 <secure_client_socket+0x3e>

00048732 <nrf_modem_recoverable_error_handler>:
   48732:	4770      	bx	lr

00048734 <nrf_modem_platform_error_handler>:
   48734:	b508      	push	{r3, lr}
   48736:	f7ff fffc 	bl	48732 <nrf_modem_recoverable_error_handler>
   4873a:	bd08      	pop	{r3, pc}

0004873c <rpc_transport_ipc_fault_handler>:
   4873c:	f7ff bffa 	b.w	48734 <nrf_modem_platform_error_handler>

00048740 <nrf_modem_platform_init>:
   48740:	b513      	push	{r0, r1, r4, lr}
   48742:	4604      	mov	r4, r0
   48744:	f7fb faa4 	bl	43c90 <nrf_modem_os_init>
   48748:	6a23      	ldr	r3, [r4, #32]
   4874a:	4668      	mov	r0, sp
   4874c:	9400      	str	r4, [sp, #0]
   4874e:	f88d 3004 	strb.w	r3, [sp, #4]
   48752:	f7fc fb17 	bl	44d84 <rpc_transport_ipc_init>
   48756:	4604      	mov	r4, r0
   48758:	b948      	cbnz	r0, 4876e <nrf_modem_platform_init+0x2e>
   4875a:	f7fc fc67 	bl	4502c <interface_init>
   4875e:	f7fd f8ab 	bl	458b8 <nrf_modem_at_init>
   48762:	4604      	mov	r4, r0
   48764:	b918      	cbnz	r0, 4876e <nrf_modem_platform_init+0x2e>
   48766:	f7fc fd1f 	bl	451a8 <ip_interface_init>
   4876a:	f7fd f803 	bl	45774 <tls_interface_init>
   4876e:	4620      	mov	r0, r4
   48770:	b002      	add	sp, #8
   48772:	bd10      	pop	{r4, pc}

00048774 <mbedtls_heap_init>:
{
	mbedtls_memory_buffer_alloc_free();
}

static int mbedtls_heap_init(const struct device *dev)
{
   48774:	b508      	push	{r3, lr}
	ARG_UNUSED(dev);

	_heap_init();
   48776:	f7fd fac7 	bl	45d08 <_heap_init>

	return 0;
}
   4877a:	2000      	movs	r0, #0
   4877c:	bd08      	pop	{r3, pc}

0004877e <z_device_state_init>:
}
   4877e:	4770      	bx	lr

00048780 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   48780:	b138      	cbz	r0, 48792 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   48782:	68c3      	ldr	r3, [r0, #12]
   48784:	8818      	ldrh	r0, [r3, #0]
   48786:	f3c0 0008 	ubfx	r0, r0, #0, #9
   4878a:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   4878e:	4258      	negs	r0, r3
   48790:	4158      	adcs	r0, r3
}
   48792:	4770      	bx	lr

00048794 <k_heap_init>:
{
   48794:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   48796:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   4879a:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   4879e:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   487a0:	f7ff b8f2 	b.w	47988 <sys_heap_init>

000487a4 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   487a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   487a8:	b087      	sub	sp, #28
   487aa:	4604      	mov	r4, r0
   487ac:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   487ae:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   487b2:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   487b4:	f000 fa09 	bl	48bca <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   487b8:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   487bc:	4605      	mov	r5, r0
   487be:	4688      	mov	r8, r1
	__asm__ volatile(
   487c0:	f04f 0320 	mov.w	r3, #32
   487c4:	f3ef 8b11 	mrs	fp, BASEPRI
   487c8:	f383 8812 	msr	BASEPRI_MAX, r3
   487cc:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   487d0:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   487d4:	463a      	mov	r2, r7
   487d6:	4631      	mov	r1, r6
   487d8:	4620      	mov	r0, r4
   487da:	f7ff f86d 	bl	478b8 <sys_heap_aligned_alloc>
   487de:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   487e0:	f7fe fc2a 	bl	47038 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   487e4:	9b05      	ldr	r3, [sp, #20]
   487e6:	b13b      	cbz	r3, 487f8 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   487e8:	f38b 8811 	msr	BASEPRI, fp
   487ec:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   487f0:	4618      	mov	r0, r3
   487f2:	b007      	add	sp, #28
   487f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   487f8:	1a2a      	subs	r2, r5, r0
   487fa:	9202      	str	r2, [sp, #8]
   487fc:	eb68 0201 	sbc.w	r2, r8, r1
   48800:	9203      	str	r2, [sp, #12]
   48802:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   48806:	2901      	cmp	r1, #1
   48808:	f172 0200 	sbcs.w	r2, r2, #0
   4880c:	dbec      	blt.n	487e8 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   4880e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   48812:	4659      	mov	r1, fp
   48814:	e9cd 2300 	strd	r2, r3, [sp]
   48818:	4648      	mov	r0, r9
   4881a:	4652      	mov	r2, sl
   4881c:	f7fe f8fc 	bl	46a18 <z_pend_curr>
	__asm__ volatile(
   48820:	f04f 0320 	mov.w	r3, #32
   48824:	f3ef 8b11 	mrs	fp, BASEPRI
   48828:	f383 8812 	msr	BASEPRI_MAX, r3
   4882c:	f3bf 8f6f 	isb	sy
   48830:	e7d0      	b.n	487d4 <k_heap_aligned_alloc+0x30>

00048832 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   48832:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   48834:	e9cd 2300 	strd	r2, r3, [sp]
   48838:	460a      	mov	r2, r1
   4883a:	2104      	movs	r1, #4
   4883c:	f7ff ffb2 	bl	487a4 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   48840:	b003      	add	sp, #12
   48842:	f85d fb04 	ldr.w	pc, [sp], #4

00048846 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   48846:	b538      	push	{r3, r4, r5, lr}
   48848:	4604      	mov	r4, r0
   4884a:	f04f 0320 	mov.w	r3, #32
   4884e:	f3ef 8511 	mrs	r5, BASEPRI
   48852:	f383 8812 	msr	BASEPRI_MAX, r3
   48856:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   4885a:	f7fe fff4 	bl	47846 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   4885e:	f104 000c 	add.w	r0, r4, #12
   48862:	f000 f958 	bl	48b16 <z_unpend_all>
   48866:	b130      	cbz	r0, 48876 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   48868:	4629      	mov	r1, r5
   4886a:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   4886e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   48872:	f7fd bf77 	b.w	46764 <z_reschedule>
	__asm__ volatile(
   48876:	f385 8811 	msr	BASEPRI, r5
   4887a:	f3bf 8f6f 	isb	sy
}
   4887e:	bd38      	pop	{r3, r4, r5, pc}

00048880 <k_mem_slab_init>:
{
   48880:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   48882:	2400      	movs	r4, #0
   48884:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   48886:	ea41 0402 	orr.w	r4, r1, r2
   4888a:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   4888e:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   48892:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   48894:	d10c      	bne.n	488b0 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   48896:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   48898:	42a3      	cmp	r3, r4
   4889a:	d103      	bne.n	488a4 <k_mem_slab_init+0x24>
   4889c:	e9c0 0000 	strd	r0, r0, [r0]
}
   488a0:	2000      	movs	r0, #0
}
   488a2:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   488a4:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   488a6:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   488a8:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   488aa:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   488ac:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   488ae:	e7f3      	b.n	48898 <k_mem_slab_init+0x18>
		return -EINVAL;
   488b0:	f06f 0015 	mvn.w	r0, #21
	return rc;
   488b4:	e7f5      	b.n	488a2 <k_mem_slab_init+0x22>

000488b6 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   488b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   488b8:	4604      	mov	r4, r0
   488ba:	460d      	mov	r5, r1
	__asm__ volatile(
   488bc:	f04f 0320 	mov.w	r3, #32
   488c0:	f3ef 8611 	mrs	r6, BASEPRI
   488c4:	f383 8812 	msr	BASEPRI_MAX, r3
   488c8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   488cc:	6947      	ldr	r7, [r0, #20]
   488ce:	b977      	cbnz	r7, 488ee <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   488d0:	f000 f909 	bl	48ae6 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   488d4:	b158      	cbz	r0, 488ee <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   488d6:	682a      	ldr	r2, [r5, #0]
   488d8:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   488da:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   488dc:	f000 f88f 	bl	489fe <z_ready_thread>
			z_reschedule(&slab->lock, key);
   488e0:	4631      	mov	r1, r6
   488e2:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   488e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   488ea:	f7fd bf3b 	b.w	46764 <z_reschedule>
	**(char ***) mem = slab->free_list;
   488ee:	682b      	ldr	r3, [r5, #0]
   488f0:	6962      	ldr	r2, [r4, #20]
   488f2:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   488f4:	682b      	ldr	r3, [r5, #0]
   488f6:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   488f8:	69a3      	ldr	r3, [r4, #24]
   488fa:	3b01      	subs	r3, #1
   488fc:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   488fe:	f386 8811 	msr	BASEPRI, r6
   48902:	f3bf 8f6f 	isb	sy
}
   48906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00048908 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   48908:	f3ef 8005 	mrs	r0, IPSR
}
   4890c:	3800      	subs	r0, #0
   4890e:	bf18      	it	ne
   48910:	2001      	movne	r0, #1
   48912:	4770      	bx	lr

00048914 <z_impl_k_thread_name_set>:
}
   48914:	f06f 0057 	mvn.w	r0, #87	; 0x57
   48918:	4770      	bx	lr

0004891a <k_thread_name_get>:
}
   4891a:	2000      	movs	r0, #0
   4891c:	4770      	bx	lr

0004891e <z_pm_save_idle_exit>:
{
   4891e:	b508      	push	{r3, lr}
	pm_system_resume();
   48920:	f7f9 fa56 	bl	41dd0 <pm_system_resume>
}
   48924:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   48928:	f7ff bdf7 	b.w	4851a <sys_clock_idle_exit>

0004892c <z_impl_k_mutex_init>:
{
   4892c:	4603      	mov	r3, r0
	mutex->owner = NULL;
   4892e:	2000      	movs	r0, #0
   48930:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   48934:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   48938:	4770      	bx	lr

0004893a <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   4893a:	b13a      	cbz	r2, 4894c <z_impl_k_sem_init+0x12>
   4893c:	428a      	cmp	r2, r1
   4893e:	d305      	bcc.n	4894c <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   48940:	e9c0 1202 	strd	r1, r2, [r0, #8]
   48944:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   48948:	2000      	movs	r0, #0
   4894a:	4770      	bx	lr
		return -EINVAL;
   4894c:	f06f 0015 	mvn.w	r0, #21
}
   48950:	4770      	bx	lr

00048952 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   48952:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   48956:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   48958:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   4895a:	2300      	movs	r3, #0
	node->prev = NULL;
   4895c:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   48960:	4770      	bx	lr

00048962 <unpend_thread_no_timeout>:
{
   48962:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   48964:	f7ff fff5 	bl	48952 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   48968:	7b43      	ldrb	r3, [r0, #13]
   4896a:	f023 0302 	bic.w	r3, r3, #2
   4896e:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   48970:	2300      	movs	r3, #0
   48972:	6083      	str	r3, [r0, #8]
}
   48974:	bd08      	pop	{r3, pc}

00048976 <z_unpend_thread_no_timeout>:
{
   48976:	b508      	push	{r3, lr}
	__asm__ volatile(
   48978:	f04f 0320 	mov.w	r3, #32
   4897c:	f3ef 8111 	mrs	r1, BASEPRI
   48980:	f383 8812 	msr	BASEPRI_MAX, r3
   48984:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   48988:	f7ff ffeb 	bl	48962 <unpend_thread_no_timeout>
	__asm__ volatile(
   4898c:	f381 8811 	msr	BASEPRI, r1
   48990:	f3bf 8f6f 	isb	sy
}
   48994:	bd08      	pop	{r3, pc}

00048996 <z_unpend_thread>:
{
   48996:	b510      	push	{r4, lr}
	__asm__ volatile(
   48998:	f04f 0320 	mov.w	r3, #32
   4899c:	f3ef 8411 	mrs	r4, BASEPRI
   489a0:	f383 8812 	msr	BASEPRI_MAX, r3
   489a4:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   489a8:	f7ff ffdb 	bl	48962 <unpend_thread_no_timeout>
	__asm__ volatile(
   489ac:	f384 8811 	msr	BASEPRI, r4
   489b0:	f3bf 8f6f 	isb	sy
}
   489b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   489b8:	3018      	adds	r0, #24
   489ba:	f000 b8bc 	b.w	48b36 <z_abort_timeout>

000489be <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   489be:	4603      	mov	r3, r0
   489c0:	b920      	cbnz	r0, 489cc <z_reschedule_irqlock+0xe>
   489c2:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   489c6:	b90a      	cbnz	r2, 489cc <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   489c8:	f7f9 bb7a 	b.w	420c0 <arch_swap>
   489cc:	f383 8811 	msr	BASEPRI, r3
   489d0:	f3bf 8f6f 	isb	sy
}
   489d4:	4770      	bx	lr

000489d6 <z_reschedule_unlocked>:
	__asm__ volatile(
   489d6:	f04f 0320 	mov.w	r3, #32
   489da:	f3ef 8011 	mrs	r0, BASEPRI
   489de:	f383 8812 	msr	BASEPRI_MAX, r3
   489e2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   489e6:	f7ff bfea 	b.w	489be <z_reschedule_irqlock>

000489ea <z_priq_dumb_best>:
{
   489ea:	4603      	mov	r3, r0
	return list->head == list;
   489ec:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   489ee:	4283      	cmp	r3, r0
   489f0:	d003      	beq.n	489fa <z_priq_dumb_best+0x10>
	if (n != NULL) {
   489f2:	2800      	cmp	r0, #0
   489f4:	bf38      	it	cc
   489f6:	2000      	movcc	r0, #0
   489f8:	4770      	bx	lr
	struct k_thread *thread = NULL;
   489fa:	2000      	movs	r0, #0
}
   489fc:	4770      	bx	lr

000489fe <z_ready_thread>:
{
   489fe:	b510      	push	{r4, lr}
   48a00:	f04f 0320 	mov.w	r3, #32
   48a04:	f3ef 8411 	mrs	r4, BASEPRI
   48a08:	f383 8812 	msr	BASEPRI_MAX, r3
   48a0c:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   48a10:	f7fd ff6e 	bl	468f0 <ready_thread>
	__asm__ volatile(
   48a14:	f384 8811 	msr	BASEPRI, r4
   48a18:	f3bf 8f6f 	isb	sy
}
   48a1c:	bd10      	pop	{r4, pc}

00048a1e <z_thread_timeout>:
{
   48a1e:	4601      	mov	r1, r0
   48a20:	b510      	push	{r4, lr}
	__asm__ volatile(
   48a22:	f04f 0320 	mov.w	r3, #32
   48a26:	f3ef 8411 	mrs	r4, BASEPRI
   48a2a:	f383 8812 	msr	BASEPRI_MAX, r3
   48a2e:	f3bf 8f6f 	isb	sy
		if (!killed) {
   48a32:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   48a36:	f013 0f28 	tst.w	r3, #40	; 0x28
   48a3a:	d10d      	bne.n	48a58 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   48a3c:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   48a40:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   48a42:	b10b      	cbz	r3, 48a48 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   48a44:	f7ff ff8d 	bl	48962 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   48a48:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   48a4c:	f023 0314 	bic.w	r3, r3, #20
   48a50:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   48a54:	f7fd ff4c 	bl	468f0 <ready_thread>
	__asm__ volatile(
   48a58:	f384 8811 	msr	BASEPRI, r4
   48a5c:	f3bf 8f6f 	isb	sy
}
   48a60:	bd10      	pop	{r4, pc}

00048a62 <add_to_waitq_locked>:
{
   48a62:	b538      	push	{r3, r4, r5, lr}
   48a64:	4604      	mov	r4, r0
   48a66:	460d      	mov	r5, r1
	unready_thread(thread);
   48a68:	f7fd ff98 	bl	4699c <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   48a6c:	7b63      	ldrb	r3, [r4, #13]
   48a6e:	f043 0302 	orr.w	r3, r3, #2
   48a72:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   48a74:	b1b5      	cbz	r5, 48aa4 <add_to_waitq_locked+0x42>
	return list->head == list;
   48a76:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   48a78:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48a7a:	429d      	cmp	r5, r3
   48a7c:	bf08      	it	eq
   48a7e:	2300      	moveq	r3, #0
   48a80:	2b00      	cmp	r3, #0
   48a82:	bf38      	it	cc
   48a84:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   48a86:	b19b      	cbz	r3, 48ab0 <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   48a88:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   48a8c:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   48a90:	4291      	cmp	r1, r2
   48a92:	d008      	beq.n	48aa6 <add_to_waitq_locked+0x44>
		return b2 - b1;
   48a94:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   48a96:	2a00      	cmp	r2, #0
   48a98:	dd05      	ble.n	48aa6 <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   48a9a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   48a9c:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   48aa0:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   48aa2:	605c      	str	r4, [r3, #4]
}
   48aa4:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   48aa6:	686a      	ldr	r2, [r5, #4]
   48aa8:	4293      	cmp	r3, r2
   48aaa:	d001      	beq.n	48ab0 <add_to_waitq_locked+0x4e>
   48aac:	681b      	ldr	r3, [r3, #0]
   48aae:	e7ea      	b.n	48a86 <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   48ab0:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   48ab2:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   48ab6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   48ab8:	606c      	str	r4, [r5, #4]
   48aba:	e7f3      	b.n	48aa4 <add_to_waitq_locked+0x42>

00048abc <z_unpend1_no_timeout>:
{
   48abc:	b510      	push	{r4, lr}
	__asm__ volatile(
   48abe:	f04f 0320 	mov.w	r3, #32
   48ac2:	f3ef 8411 	mrs	r4, BASEPRI
   48ac6:	f383 8812 	msr	BASEPRI_MAX, r3
   48aca:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48ace:	f7ff ff8c 	bl	489ea <z_priq_dumb_best>
		if (thread != NULL) {
   48ad2:	4601      	mov	r1, r0
   48ad4:	b108      	cbz	r0, 48ada <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   48ad6:	f7ff ff44 	bl	48962 <unpend_thread_no_timeout>
	__asm__ volatile(
   48ada:	f384 8811 	msr	BASEPRI, r4
   48ade:	f3bf 8f6f 	isb	sy
}
   48ae2:	4608      	mov	r0, r1
   48ae4:	bd10      	pop	{r4, pc}

00048ae6 <z_unpend_first_thread>:
{
   48ae6:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   48ae8:	f04f 0320 	mov.w	r3, #32
   48aec:	f3ef 8511 	mrs	r5, BASEPRI
   48af0:	f383 8812 	msr	BASEPRI_MAX, r3
   48af4:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48af8:	f7ff ff77 	bl	489ea <z_priq_dumb_best>
		if (thread != NULL) {
   48afc:	4604      	mov	r4, r0
   48afe:	b120      	cbz	r0, 48b0a <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   48b00:	f7ff ff2f 	bl	48962 <unpend_thread_no_timeout>
   48b04:	3018      	adds	r0, #24
   48b06:	f000 f816 	bl	48b36 <z_abort_timeout>
	__asm__ volatile(
   48b0a:	f385 8811 	msr	BASEPRI, r5
   48b0e:	f3bf 8f6f 	isb	sy
}
   48b12:	4620      	mov	r0, r4
   48b14:	bd38      	pop	{r3, r4, r5, pc}

00048b16 <z_unpend_all>:
{
   48b16:	b538      	push	{r3, r4, r5, lr}
   48b18:	4605      	mov	r5, r0
	int need_sched = 0;
   48b1a:	2000      	movs	r0, #0
	return list->head == list;
   48b1c:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48b1e:	42a5      	cmp	r5, r4
   48b20:	d000      	beq.n	48b24 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   48b22:	b904      	cbnz	r4, 48b26 <z_unpend_all+0x10>
}
   48b24:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   48b26:	4620      	mov	r0, r4
   48b28:	f7ff ff35 	bl	48996 <z_unpend_thread>
		z_ready_thread(thread);
   48b2c:	4620      	mov	r0, r4
   48b2e:	f7ff ff66 	bl	489fe <z_ready_thread>
		need_sched = 1;
   48b32:	2001      	movs	r0, #1
   48b34:	e7f2      	b.n	48b1c <z_unpend_all+0x6>

00048b36 <z_abort_timeout>:
{
   48b36:	b510      	push	{r4, lr}
	__asm__ volatile(
   48b38:	f04f 0220 	mov.w	r2, #32
   48b3c:	f3ef 8411 	mrs	r4, BASEPRI
   48b40:	f382 8812 	msr	BASEPRI_MAX, r2
   48b44:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   48b48:	6803      	ldr	r3, [r0, #0]
   48b4a:	b13b      	cbz	r3, 48b5c <z_abort_timeout+0x26>
			remove_timeout(to);
   48b4c:	f7fe f93c 	bl	46dc8 <remove_timeout>
			ret = 0;
   48b50:	2000      	movs	r0, #0
	__asm__ volatile(
   48b52:	f384 8811 	msr	BASEPRI, r4
   48b56:	f3bf 8f6f 	isb	sy
}
   48b5a:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   48b5c:	f06f 0015 	mvn.w	r0, #21
   48b60:	e7f7      	b.n	48b52 <z_abort_timeout+0x1c>

00048b62 <z_get_next_timeout_expiry>:
{
   48b62:	b510      	push	{r4, lr}
	__asm__ volatile(
   48b64:	f04f 0320 	mov.w	r3, #32
   48b68:	f3ef 8411 	mrs	r4, BASEPRI
   48b6c:	f383 8812 	msr	BASEPRI_MAX, r3
   48b70:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   48b74:	f7fe f942 	bl	46dfc <next_timeout>
	__asm__ volatile(
   48b78:	f384 8811 	msr	BASEPRI, r4
   48b7c:	f3bf 8f6f 	isb	sy
}
   48b80:	bd10      	pop	{r4, pc}

00048b82 <z_set_timeout_expiry>:
{
   48b82:	b570      	push	{r4, r5, r6, lr}
   48b84:	4604      	mov	r4, r0
   48b86:	460d      	mov	r5, r1
	__asm__ volatile(
   48b88:	f04f 0320 	mov.w	r3, #32
   48b8c:	f3ef 8611 	mrs	r6, BASEPRI
   48b90:	f383 8812 	msr	BASEPRI_MAX, r3
   48b94:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   48b98:	f7fe f930 	bl	46dfc <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   48b9c:	2801      	cmp	r0, #1
   48b9e:	dd05      	ble.n	48bac <z_set_timeout_expiry+0x2a>
   48ba0:	42a0      	cmp	r0, r4
   48ba2:	db03      	blt.n	48bac <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   48ba4:	4629      	mov	r1, r5
   48ba6:	4620      	mov	r0, r4
   48ba8:	f7fa feb4 	bl	43914 <sys_clock_set_timeout>
	__asm__ volatile(
   48bac:	f386 8811 	msr	BASEPRI, r6
   48bb0:	f3bf 8f6f 	isb	sy
}
   48bb4:	bd70      	pop	{r4, r5, r6, pc}

00048bb6 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   48bb6:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   48bb8:	f7fe fa3e 	bl	47038 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   48bbc:	bd08      	pop	{r3, pc}

00048bbe <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   48bbe:	f7fe ba3b 	b.w	47038 <sys_clock_tick_get>

00048bc2 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   48bc2:	b108      	cbz	r0, 48bc8 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   48bc4:	f7f8 bade 	b.w	41184 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   48bc8:	4770      	bx	lr

00048bca <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   48bca:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48bcc:	1c4b      	adds	r3, r1, #1
   48bce:	bf08      	it	eq
   48bd0:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   48bd4:	4604      	mov	r4, r0
   48bd6:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48bd8:	d013      	beq.n	48c02 <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   48bda:	ea54 0105 	orrs.w	r1, r4, r5
   48bde:	d103      	bne.n	48be8 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   48be0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   48be4:	f7fe ba28 	b.w	47038 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   48be8:	f06f 0101 	mvn.w	r1, #1
   48bec:	1a0a      	subs	r2, r1, r0
   48bee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   48bf2:	eb61 0305 	sbc.w	r3, r1, r5
   48bf6:	2a00      	cmp	r2, #0
   48bf8:	f173 0100 	sbcs.w	r1, r3, #0
   48bfc:	db02      	blt.n	48c04 <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   48bfe:	4610      	mov	r0, r2
   48c00:	4619      	mov	r1, r3
}
   48c02:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   48c04:	f7fe fa18 	bl	47038 <sys_clock_tick_get>
   48c08:	2c01      	cmp	r4, #1
   48c0a:	f175 0300 	sbcs.w	r3, r5, #0
   48c0e:	bfbc      	itt	lt
   48c10:	2401      	movlt	r4, #1
   48c12:	2500      	movlt	r5, #0
   48c14:	1820      	adds	r0, r4, r0
   48c16:	eb45 0101 	adc.w	r1, r5, r1
   48c1a:	e7f2      	b.n	48c02 <sys_clock_timeout_end_calc+0x38>

00048c1c <k_timer_init>:
	timer->status = 0U;
   48c1c:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   48c1e:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
   48c22:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   48c26:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   48c2a:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   48c2e:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   48c30:	6343      	str	r3, [r0, #52]	; 0x34
}
   48c32:	4770      	bx	lr

00048c34 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   48c34:	b510      	push	{r4, lr}
   48c36:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   48c38:	f7ff ff7d 	bl	48b36 <z_abort_timeout>

	if (inactive) {
   48c3c:	b9b0      	cbnz	r0, 48c6c <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   48c3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48c40:	b10b      	cbz	r3, 48c46 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   48c42:	4620      	mov	r0, r4
   48c44:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   48c46:	f104 0018 	add.w	r0, r4, #24
   48c4a:	f7ff ff37 	bl	48abc <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   48c4e:	b168      	cbz	r0, 48c6c <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   48c50:	f7ff fed5 	bl	489fe <z_ready_thread>
	__asm__ volatile(
   48c54:	f04f 0320 	mov.w	r3, #32
   48c58:	f3ef 8011 	mrs	r0, BASEPRI
   48c5c:	f383 8812 	msr	BASEPRI_MAX, r3
   48c60:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   48c64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   48c68:	f7ff bea9 	b.w	489be <z_reschedule_irqlock>
   48c6c:	bd10      	pop	{r4, pc}

00048c6e <psa_crypto_init>:
}
   48c6e:	2000      	movs	r0, #0
   48c70:	4770      	bx	lr
	...

00048c74 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   48c74:	f7fb b872 	b.w	43d5c <SystemInit>
