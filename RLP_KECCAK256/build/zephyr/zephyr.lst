
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00040000 <_vector_start>:
   40000:	20023240 	.word	0x20023240
   40004:	000427d9 	.word	0x000427d9
   40008:	000481bd 	.word	0x000481bd
   4000c:	000427ad 	.word	0x000427ad
   40010:	000427ad 	.word	0x000427ad
   40014:	000427ad 	.word	0x000427ad
   40018:	000427ad 	.word	0x000427ad
   4001c:	000427ad 	.word	0x000427ad
	...
   4002c:	00042255 	.word	0x00042255
   40030:	000427ad 	.word	0x000427ad
   40034:	00000000 	.word	0x00000000
   40038:	000421f5 	.word	0x000421f5
   4003c:	000427ad 	.word	0x000427ad

00040040 <_irq_vector_table>:
   40040:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40050:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40060:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40070:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40080:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40090:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   400a0:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   400b0:	00043bc5 000422d9 000422d9 000422d9     .;..."..."..."..
   400c0:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   400d0:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   400e0:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   400f0:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40100:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40110:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40120:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40130:	000422d9 000422d9 000422d9 000422d9     ."..."..."..."..
   40140:	000422d9                                ."..

Disassembly of section text:

00040144 <__aeabi_uldivmod>:
   40144:	b953      	cbnz	r3, 4015c <__aeabi_uldivmod+0x18>
   40146:	b94a      	cbnz	r2, 4015c <__aeabi_uldivmod+0x18>
   40148:	2900      	cmp	r1, #0
   4014a:	bf08      	it	eq
   4014c:	2800      	cmpeq	r0, #0
   4014e:	bf1c      	itt	ne
   40150:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   40154:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   40158:	f000 b970 	b.w	4043c <__aeabi_idiv0>
   4015c:	f1ad 0c08 	sub.w	ip, sp, #8
   40160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   40164:	f000 f806 	bl	40174 <__udivmoddi4>
   40168:	f8dd e004 	ldr.w	lr, [sp, #4]
   4016c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   40170:	b004      	add	sp, #16
   40172:	4770      	bx	lr

00040174 <__udivmoddi4>:
   40174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   40178:	9e08      	ldr	r6, [sp, #32]
   4017a:	460d      	mov	r5, r1
   4017c:	4604      	mov	r4, r0
   4017e:	468a      	mov	sl, r1
   40180:	2b00      	cmp	r3, #0
   40182:	d17f      	bne.n	40284 <__udivmoddi4+0x110>
   40184:	428a      	cmp	r2, r1
   40186:	4617      	mov	r7, r2
   40188:	d941      	bls.n	4020e <__udivmoddi4+0x9a>
   4018a:	fab2 f282 	clz	r2, r2
   4018e:	b14a      	cbz	r2, 401a4 <__udivmoddi4+0x30>
   40190:	f1c2 0120 	rsb	r1, r2, #32
   40194:	fa05 f302 	lsl.w	r3, r5, r2
   40198:	4097      	lsls	r7, r2
   4019a:	4094      	lsls	r4, r2
   4019c:	fa20 f101 	lsr.w	r1, r0, r1
   401a0:	ea41 0a03 	orr.w	sl, r1, r3
   401a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
   401a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   401ac:	fa1f f987 	uxth.w	r9, r7
   401b0:	fbba fef8 	udiv	lr, sl, r8
   401b4:	fb08 a31e 	mls	r3, r8, lr, sl
   401b8:	fb0e f109 	mul.w	r1, lr, r9
   401bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   401c0:	4299      	cmp	r1, r3
   401c2:	d906      	bls.n	401d2 <__udivmoddi4+0x5e>
   401c4:	18fb      	adds	r3, r7, r3
   401c6:	d202      	bcs.n	401ce <__udivmoddi4+0x5a>
   401c8:	4299      	cmp	r1, r3
   401ca:	f200 8124 	bhi.w	40416 <__udivmoddi4+0x2a2>
   401ce:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   401d2:	1a59      	subs	r1, r3, r1
   401d4:	b2a3      	uxth	r3, r4
   401d6:	fbb1 f0f8 	udiv	r0, r1, r8
   401da:	fb08 1110 	mls	r1, r8, r0, r1
   401de:	fb00 f909 	mul.w	r9, r0, r9
   401e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   401e6:	45a1      	cmp	r9, r4
   401e8:	d905      	bls.n	401f6 <__udivmoddi4+0x82>
   401ea:	193c      	adds	r4, r7, r4
   401ec:	d202      	bcs.n	401f4 <__udivmoddi4+0x80>
   401ee:	45a1      	cmp	r9, r4
   401f0:	f200 810e 	bhi.w	40410 <__udivmoddi4+0x29c>
   401f4:	3801      	subs	r0, #1
   401f6:	eba4 0409 	sub.w	r4, r4, r9
   401fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   401fe:	2100      	movs	r1, #0
   40200:	b11e      	cbz	r6, 4020a <__udivmoddi4+0x96>
   40202:	40d4      	lsrs	r4, r2
   40204:	2300      	movs	r3, #0
   40206:	e9c6 4300 	strd	r4, r3, [r6]
   4020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4020e:	b902      	cbnz	r2, 40212 <__udivmoddi4+0x9e>
   40210:	deff      	udf	#255	; 0xff
   40212:	fab2 f282 	clz	r2, r2
   40216:	2a00      	cmp	r2, #0
   40218:	d14f      	bne.n	402ba <__udivmoddi4+0x146>
   4021a:	1bcb      	subs	r3, r1, r7
   4021c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   40220:	fa1f f887 	uxth.w	r8, r7
   40224:	2101      	movs	r1, #1
   40226:	0c25      	lsrs	r5, r4, #16
   40228:	fbb3 fcfe 	udiv	ip, r3, lr
   4022c:	fb0e 301c 	mls	r0, lr, ip, r3
   40230:	462b      	mov	r3, r5
   40232:	fb08 f90c 	mul.w	r9, r8, ip
   40236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   4023a:	45a9      	cmp	r9, r5
   4023c:	d90a      	bls.n	40254 <__udivmoddi4+0xe0>
   4023e:	197d      	adds	r5, r7, r5
   40240:	bf2c      	ite	cs
   40242:	2301      	movcs	r3, #1
   40244:	2300      	movcc	r3, #0
   40246:	45a9      	cmp	r9, r5
   40248:	d902      	bls.n	40250 <__udivmoddi4+0xdc>
   4024a:	2b00      	cmp	r3, #0
   4024c:	f000 80d9 	beq.w	40402 <__udivmoddi4+0x28e>
   40250:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   40254:	eba5 0509 	sub.w	r5, r5, r9
   40258:	b2a3      	uxth	r3, r4
   4025a:	fbb5 f0fe 	udiv	r0, r5, lr
   4025e:	fb0e 5510 	mls	r5, lr, r0, r5
   40262:	fb08 f800 	mul.w	r8, r8, r0
   40266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   4026a:	45a0      	cmp	r8, r4
   4026c:	d905      	bls.n	4027a <__udivmoddi4+0x106>
   4026e:	193c      	adds	r4, r7, r4
   40270:	d202      	bcs.n	40278 <__udivmoddi4+0x104>
   40272:	45a0      	cmp	r8, r4
   40274:	f200 80c9 	bhi.w	4040a <__udivmoddi4+0x296>
   40278:	3801      	subs	r0, #1
   4027a:	eba4 0408 	sub.w	r4, r4, r8
   4027e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   40282:	e7bd      	b.n	40200 <__udivmoddi4+0x8c>
   40284:	428b      	cmp	r3, r1
   40286:	d908      	bls.n	4029a <__udivmoddi4+0x126>
   40288:	2e00      	cmp	r6, #0
   4028a:	f000 80b1 	beq.w	403f0 <__udivmoddi4+0x27c>
   4028e:	2100      	movs	r1, #0
   40290:	e9c6 0500 	strd	r0, r5, [r6]
   40294:	4608      	mov	r0, r1
   40296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4029a:	fab3 f183 	clz	r1, r3
   4029e:	2900      	cmp	r1, #0
   402a0:	d146      	bne.n	40330 <__udivmoddi4+0x1bc>
   402a2:	42ab      	cmp	r3, r5
   402a4:	f0c0 80a7 	bcc.w	403f6 <__udivmoddi4+0x282>
   402a8:	4282      	cmp	r2, r0
   402aa:	f240 80a4 	bls.w	403f6 <__udivmoddi4+0x282>
   402ae:	4608      	mov	r0, r1
   402b0:	2e00      	cmp	r6, #0
   402b2:	d0aa      	beq.n	4020a <__udivmoddi4+0x96>
   402b4:	e9c6 4a00 	strd	r4, sl, [r6]
   402b8:	e7a7      	b.n	4020a <__udivmoddi4+0x96>
   402ba:	f1c2 0020 	rsb	r0, r2, #32
   402be:	4097      	lsls	r7, r2
   402c0:	fa01 f302 	lsl.w	r3, r1, r2
   402c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   402c8:	40c1      	lsrs	r1, r0
   402ca:	fa24 f500 	lsr.w	r5, r4, r0
   402ce:	fa1f f887 	uxth.w	r8, r7
   402d2:	4094      	lsls	r4, r2
   402d4:	431d      	orrs	r5, r3
   402d6:	fbb1 f0fe 	udiv	r0, r1, lr
   402da:	0c2b      	lsrs	r3, r5, #16
   402dc:	fb0e 1110 	mls	r1, lr, r0, r1
   402e0:	fb00 fc08 	mul.w	ip, r0, r8
   402e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   402e8:	459c      	cmp	ip, r3
   402ea:	d909      	bls.n	40300 <__udivmoddi4+0x18c>
   402ec:	18fb      	adds	r3, r7, r3
   402ee:	bf2c      	ite	cs
   402f0:	2101      	movcs	r1, #1
   402f2:	2100      	movcc	r1, #0
   402f4:	459c      	cmp	ip, r3
   402f6:	d902      	bls.n	402fe <__udivmoddi4+0x18a>
   402f8:	2900      	cmp	r1, #0
   402fa:	f000 8095 	beq.w	40428 <__udivmoddi4+0x2b4>
   402fe:	3801      	subs	r0, #1
   40300:	eba3 030c 	sub.w	r3, r3, ip
   40304:	b2ad      	uxth	r5, r5
   40306:	fbb3 f1fe 	udiv	r1, r3, lr
   4030a:	fb0e 3311 	mls	r3, lr, r1, r3
   4030e:	fb01 fc08 	mul.w	ip, r1, r8
   40312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   40316:	45ac      	cmp	ip, r5
   40318:	d905      	bls.n	40326 <__udivmoddi4+0x1b2>
   4031a:	197d      	adds	r5, r7, r5
   4031c:	d202      	bcs.n	40324 <__udivmoddi4+0x1b0>
   4031e:	45ac      	cmp	ip, r5
   40320:	f200 8089 	bhi.w	40436 <__udivmoddi4+0x2c2>
   40324:	3901      	subs	r1, #1
   40326:	eba5 030c 	sub.w	r3, r5, ip
   4032a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   4032e:	e77a      	b.n	40226 <__udivmoddi4+0xb2>
   40330:	f1c1 0420 	rsb	r4, r1, #32
   40334:	408b      	lsls	r3, r1
   40336:	fa02 f701 	lsl.w	r7, r2, r1
   4033a:	fa05 fc01 	lsl.w	ip, r5, r1
   4033e:	40e2      	lsrs	r2, r4
   40340:	fa20 f804 	lsr.w	r8, r0, r4
   40344:	40e5      	lsrs	r5, r4
   40346:	fa00 fe01 	lsl.w	lr, r0, r1
   4034a:	4313      	orrs	r3, r2
   4034c:	ea48 020c 	orr.w	r2, r8, ip
   40350:	ea4f 4813 	mov.w	r8, r3, lsr #16
   40354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   40358:	fa1f f983 	uxth.w	r9, r3
   4035c:	fbb5 faf8 	udiv	sl, r5, r8
   40360:	fb08 551a 	mls	r5, r8, sl, r5
   40364:	fb0a f009 	mul.w	r0, sl, r9
   40368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   4036c:	4560      	cmp	r0, ip
   4036e:	d90a      	bls.n	40386 <__udivmoddi4+0x212>
   40370:	eb13 0c0c 	adds.w	ip, r3, ip
   40374:	bf2c      	ite	cs
   40376:	2501      	movcs	r5, #1
   40378:	2500      	movcc	r5, #0
   4037a:	4560      	cmp	r0, ip
   4037c:	d901      	bls.n	40382 <__udivmoddi4+0x20e>
   4037e:	2d00      	cmp	r5, #0
   40380:	d055      	beq.n	4042e <__udivmoddi4+0x2ba>
   40382:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   40386:	ebac 0c00 	sub.w	ip, ip, r0
   4038a:	b292      	uxth	r2, r2
   4038c:	fbbc f0f8 	udiv	r0, ip, r8
   40390:	fb08 cc10 	mls	ip, r8, r0, ip
   40394:	fb00 f909 	mul.w	r9, r0, r9
   40398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   4039c:	45e1      	cmp	r9, ip
   4039e:	d905      	bls.n	403ac <__udivmoddi4+0x238>
   403a0:	eb13 0c0c 	adds.w	ip, r3, ip
   403a4:	d201      	bcs.n	403aa <__udivmoddi4+0x236>
   403a6:	45e1      	cmp	r9, ip
   403a8:	d83b      	bhi.n	40422 <__udivmoddi4+0x2ae>
   403aa:	3801      	subs	r0, #1
   403ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   403b0:	ebac 0c09 	sub.w	ip, ip, r9
   403b4:	fba0 8907 	umull	r8, r9, r0, r7
   403b8:	45cc      	cmp	ip, r9
   403ba:	4645      	mov	r5, r8
   403bc:	464a      	mov	r2, r9
   403be:	d302      	bcc.n	403c6 <__udivmoddi4+0x252>
   403c0:	d106      	bne.n	403d0 <__udivmoddi4+0x25c>
   403c2:	45c6      	cmp	lr, r8
   403c4:	d204      	bcs.n	403d0 <__udivmoddi4+0x25c>
   403c6:	3801      	subs	r0, #1
   403c8:	ebb8 0507 	subs.w	r5, r8, r7
   403cc:	eb69 0203 	sbc.w	r2, r9, r3
   403d0:	b32e      	cbz	r6, 4041e <__udivmoddi4+0x2aa>
   403d2:	ebbe 0305 	subs.w	r3, lr, r5
   403d6:	eb6c 0c02 	sbc.w	ip, ip, r2
   403da:	fa23 f201 	lsr.w	r2, r3, r1
   403de:	fa0c f404 	lsl.w	r4, ip, r4
   403e2:	fa2c f301 	lsr.w	r3, ip, r1
   403e6:	2100      	movs	r1, #0
   403e8:	4314      	orrs	r4, r2
   403ea:	e9c6 4300 	strd	r4, r3, [r6]
   403ee:	e70c      	b.n	4020a <__udivmoddi4+0x96>
   403f0:	4631      	mov	r1, r6
   403f2:	4630      	mov	r0, r6
   403f4:	e709      	b.n	4020a <__udivmoddi4+0x96>
   403f6:	1a84      	subs	r4, r0, r2
   403f8:	eb65 0303 	sbc.w	r3, r5, r3
   403fc:	2001      	movs	r0, #1
   403fe:	469a      	mov	sl, r3
   40400:	e756      	b.n	402b0 <__udivmoddi4+0x13c>
   40402:	f1ac 0c02 	sub.w	ip, ip, #2
   40406:	443d      	add	r5, r7
   40408:	e724      	b.n	40254 <__udivmoddi4+0xe0>
   4040a:	3802      	subs	r0, #2
   4040c:	443c      	add	r4, r7
   4040e:	e734      	b.n	4027a <__udivmoddi4+0x106>
   40410:	3802      	subs	r0, #2
   40412:	443c      	add	r4, r7
   40414:	e6ef      	b.n	401f6 <__udivmoddi4+0x82>
   40416:	f1ae 0e02 	sub.w	lr, lr, #2
   4041a:	443b      	add	r3, r7
   4041c:	e6d9      	b.n	401d2 <__udivmoddi4+0x5e>
   4041e:	4631      	mov	r1, r6
   40420:	e6f3      	b.n	4020a <__udivmoddi4+0x96>
   40422:	3802      	subs	r0, #2
   40424:	449c      	add	ip, r3
   40426:	e7c1      	b.n	403ac <__udivmoddi4+0x238>
   40428:	3802      	subs	r0, #2
   4042a:	443b      	add	r3, r7
   4042c:	e768      	b.n	40300 <__udivmoddi4+0x18c>
   4042e:	f1aa 0a02 	sub.w	sl, sl, #2
   40432:	449c      	add	ip, r3
   40434:	e7a7      	b.n	40386 <__udivmoddi4+0x212>
   40436:	3902      	subs	r1, #2
   40438:	443d      	add	r5, r7
   4043a:	e774      	b.n	40326 <__udivmoddi4+0x1b2>

0004043c <__aeabi_idiv0>:
   4043c:	4770      	bx	lr
   4043e:	bf00      	nop

00040440 <debug_hexstring.part.0>:

// Gather
RlpElement_t const *const ethTxn[] = {&nonce, &gasPrice, &gasLimit, &addressTo, &value, &data, &v, &r, &s};


static void debug_hexstring(const void *const address, size_t nBytes)
   40440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   40444:	4604      	mov	r4, r0
{
     uint8_t *a = ((uint8_t*)(address));
     unsigned long int b = ((volatile unsigned long int)(nBytes));
     if ((NULL == a) || (b <= 0)) return;
     for (unsigned long int i = 1; i <= b; i++) {
        strncat(myString, &a[i-1], 1);
   40446:	4e0d      	ldr	r6, [pc, #52]	; (4047c <debug_hexstring.part.0+0x3c>)

       if(a[i-1] < 0x10)
          printf("0%x",a[i-1]);
        else
          printf("%x",a[i-1]);
   40448:	4f0d      	ldr	r7, [pc, #52]	; (40480 <debug_hexstring.part.0+0x40>)
          printf("0%x",a[i-1]);
   4044a:	f8df 803c 	ldr.w	r8, [pc, #60]	; 40488 <debug_hexstring.part.0+0x48>
   4044e:	1845      	adds	r5, r0, r1
     for (unsigned long int i = 1; i <= b; i++) {
   40450:	42ac      	cmp	r4, r5
   40452:	d104      	bne.n	4045e <debug_hexstring.part.0+0x1e>
     }
     printf("\n");
}
   40454:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
     printf("\n");
   40458:	480a      	ldr	r0, [pc, #40]	; (40484 <debug_hexstring.part.0+0x44>)
   4045a:	f002 bc1f 	b.w	42c9c <printf>
        strncat(myString, &a[i-1], 1);
   4045e:	4621      	mov	r1, r4
   40460:	2201      	movs	r2, #1
   40462:	6830      	ldr	r0, [r6, #0]
   40464:	f007 ff1d 	bl	482a2 <strncat>
       if(a[i-1] < 0x10)
   40468:	f814 1b01 	ldrb.w	r1, [r4], #1
   4046c:	290f      	cmp	r1, #15
          printf("0%x",a[i-1]);
   4046e:	bf94      	ite	ls
   40470:	4640      	movls	r0, r8
          printf("%x",a[i-1]);
   40472:	4638      	movhi	r0, r7
   40474:	f002 fc12 	bl	42c9c <printf>
     for (unsigned long int i = 1; i <= b; i++) {
   40478:	e7ea      	b.n	40450 <debug_hexstring.part.0+0x10>
   4047a:	bf00      	nop
   4047c:	2001a888 	.word	0x2001a888
   40480:	000492cd 	.word	0x000492cd
   40484:	00049305 	.word	0x00049305
   40488:	000492cc 	.word	0x000492cc

0004048c <main>:

    // Clear out the contents of what we hashed (in case it was secret)
    memset((char*)&context, 0, sizeof(SHA3_CTX));
}

int main() {
   4048c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t rlpTx[2048] = {0};
   40490:	2500      	movs	r5, #0
int main() {
   40492:	f5ad 6d02 	sub.w	sp, sp, #2080	; 0x820
    uint8_t rlpTx[2048] = {0};
   40496:	f240 72fc 	movw	r2, #2044	; 0x7fc
   4049a:	4629      	mov	r1, r5
   4049c:	a809      	add	r0, sp, #36	; 0x24
   4049e:	9508      	str	r5, [sp, #32]
   404a0:	f007 ff1e 	bl	482e0 <memset>
    int outputLen = 0;
    outputLen = rlp_encode_list(rlpTx, sizeof(rlpTx)/sizeof(rlpTx[0]), ethTxn, sizeof(ethTxn)/sizeof(ethTxn[0]));
   404a4:	f44f 6100 	mov.w	r1, #2048	; 0x800
   404a8:	2309      	movs	r3, #9
   404aa:	4a1e      	ldr	r2, [pc, #120]	; (40524 <main+0x98>)
   404ac:	a808      	add	r0, sp, #32
   404ae:	f006 ff93 	bl	473d8 <rlp_encode_list>
   404b2:	4604      	mov	r4, r0
    myString = k_malloc(outputLen);
   404b4:	f008 fc48 	bl	48d48 <k_malloc>
   404b8:	4f1b      	ldr	r7, [pc, #108]	; (40528 <main+0x9c>)
    if(outputLen < 0)
   404ba:	42ac      	cmp	r4, r5
      printf("error, return code: %d\r\n", outputLen);
   404bc:	4621      	mov	r1, r4
    myString = k_malloc(outputLen);
   404be:	6038      	str	r0, [r7, #0]
    if(outputLen < 0)
   404c0:	da18      	bge.n	404f4 <main+0x68>
      printf("error, return code: %d\r\n", outputLen);
   404c2:	481a      	ldr	r0, [pc, #104]	; (4052c <main+0xa0>)
   404c4:	f002 fbea 	bl	42c9c <printf>
      debug_hexstring(rlpTx, outputLen);
    }
  // Convert text to hex.
    for (int i = 0, j = 0; i < outputLen; ++i, j += 2)
      sprintf(myString + j, "%02x", rlpTx[i] & 0xff);
    printf("%s\nla mia stringa\n", myString);
   404c8:	6839      	ldr	r1, [r7, #0]
   404ca:	4819      	ldr	r0, [pc, #100]	; (40530 <main+0xa4>)
   404cc:	f002 fbe6 	bl	42c9c <printf>

    uint8_t publicKey[70] = "e2844349414f844c4f5245845345494c83554e4f855343454d4f855355504552808080";
    uint8_t hashed[32];
    
    ethers_keccak256(myString, strlen(myString), hashed);
   404d0:	683c      	ldr	r4, [r7, #0]
   404d2:	4620      	mov	r0, r4
   404d4:	f007 fed5 	bl	48282 <strlen>
   404d8:	466a      	mov	r2, sp
   404da:	b281      	uxth	r1, r0
   404dc:	4620      	mov	r0, r4
   404de:	f006 ff62 	bl	473a6 <ethers_keccak256>
     if ((NULL == a) || (b <= 0)) return;
   404e2:	4668      	mov	r0, sp
   404e4:	2120      	movs	r1, #32
   404e6:	f7ff ffab 	bl	40440 <debug_hexstring.part.0>
    debug_hexstring(hashed, 32);
  return 0;

}
   404ea:	2000      	movs	r0, #0
   404ec:	f50d 6d02 	add.w	sp, sp, #2080	; 0x820
   404f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      printf("RLP encoded eth txn [%d B]:\r\n", outputLen);
   404f4:	480f      	ldr	r0, [pc, #60]	; (40534 <main+0xa8>)
   404f6:	f002 fbd1 	bl	42c9c <printf>
     if ((NULL == a) || (b <= 0)) return;
   404fa:	2c00      	cmp	r4, #0
   404fc:	d0e4      	beq.n	404c8 <main+0x3c>
   404fe:	4621      	mov	r1, r4
   40500:	a808      	add	r0, sp, #32
   40502:	f7ff ff9d 	bl	40440 <debug_hexstring.part.0>
      sprintf(myString + j, "%02x", rlpTx[i] & 0xff);
   40506:	f8df 8030 	ldr.w	r8, [pc, #48]	; 40538 <main+0xac>
   4050a:	ae08      	add	r6, sp, #32
    for (int i = 0, j = 0; i < outputLen; ++i, j += 2)
   4050c:	42a5      	cmp	r5, r4
   4050e:	6838      	ldr	r0, [r7, #0]
   40510:	d0da      	beq.n	404c8 <main+0x3c>
      sprintf(myString + j, "%02x", rlpTx[i] & 0xff);
   40512:	eb00 0045 	add.w	r0, r0, r5, lsl #1
   40516:	4641      	mov	r1, r8
   40518:	f816 2b01 	ldrb.w	r2, [r6], #1
   4051c:	f002 fba6 	bl	42c6c <sprintf>
    for (int i = 0, j = 0; i < outputLen; ++i, j += 2)
   40520:	3501      	adds	r5, #1
   40522:	e7f3      	b.n	4050c <main+0x80>
   40524:	000490c8 	.word	0x000490c8
   40528:	2001a888 	.word	0x2001a888
   4052c:	000492d0 	.word	0x000492d0
   40530:	0004930c 	.word	0x0004930c
   40534:	000492e9 	.word	0x000492e9
   40538:	00049307 	.word	0x00049307

0004053c <rlp_encode_element>:
  return ERR_RLP_EBADARG;
}

// Returns length of output in bytes, or a negative error value
int rlp_encode_element(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, const RlpElement_t *const rlpElement)
{
   4053c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4053e:	460d      	mov	r5, r1
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   40540:	2800      	cmp	r0, #0
   40542:	d06d      	beq.n	40620 <rlp_encode_element+0xe4>
   40544:	2a00      	cmp	r2, #0
   40546:	d06b      	beq.n	40620 <rlp_encode_element+0xe4>
   40548:	2900      	cmp	r1, #0
   4054a:	d069      	beq.n	40620 <rlp_encode_element+0xe4>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   4054c:	7811      	ldrb	r1, [r2, #0]
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   4054e:	2900      	cmp	r1, #0
   40550:	d066      	beq.n	40620 <rlp_encode_element+0xe4>
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   40552:	1e8c      	subs	r4, r1, #2
   40554:	b2e4      	uxtb	r4, r4
   40556:	2c07      	cmp	r4, #7
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40558:	6853      	ldr	r3, [r2, #4]
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   4055a:	d82a      	bhi.n	405b2 <rlp_encode_element+0x76>
      return buffSz == rlp_int_size_from_type(type);
   4055c:	4935      	ldr	r1, [pc, #212]	; (40634 <rlp_encode_element+0xf8>)
   4055e:	5d09      	ldrb	r1, [r1, r4]
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40560:	428b      	cmp	r3, r1
    else if (type == RLP_TYPE_BYTE_ARRAY)
   40562:	d15d      	bne.n	40620 <rlp_encode_element+0xe4>
    return ERR_RLP_EBADARG;
  if(rlpEncodedOutputLen < (rlpElement->len + 1)) // extra byte for rlp encoding tag
   40564:	1c59      	adds	r1, r3, #1
   40566:	42a9      	cmp	r1, r5
   40568:	d860      	bhi.n	4062c <rlp_encode_element+0xf0>
    return ERR_RLP_ENOMEM;
  if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElement->buff, rlpElement->len)) // No overlapping memory regions
   4056a:	6891      	ldr	r1, [r2, #8]
    if( (aAddr == bAddr) ||
   4056c:	4281      	cmp	r1, r0
   4056e:	d05a      	beq.n	40626 <rlp_encode_element+0xea>
   40570:	d902      	bls.n	40578 <rlp_encode_element+0x3c>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   40572:	1942      	adds	r2, r0, r5
   40574:	4291      	cmp	r1, r2
   40576:	d956      	bls.n	40626 <rlp_encode_element+0xea>
   40578:	4281      	cmp	r1, r0
   4057a:	d202      	bcs.n	40582 <rlp_encode_element+0x46>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   4057c:	18ca      	adds	r2, r1, r3
   4057e:	4290      	cmp	r0, r2
   40580:	d951      	bls.n	40626 <rlp_encode_element+0xea>
  uint8_t *rlpOut = (uint8_t *)rlpEncodedOutput;
  uint8_t const *rlpElementBuff = (uint8_t *)rlpElement->buff;
  size_t rlpElementLen = rlpElement->len;
  size_t rlpEncodedLen = 0;

  if(RLP_TYPE_IS_INTEGER_TYPE(rlpElement->type)) {
   40582:	2c07      	cmp	r4, #7
   40584:	d81c      	bhi.n	405c0 <rlp_encode_element+0x84>
   40586:	460e      	mov	r6, r1
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40588:	461c      	mov	r4, r3
    const uint8_t *buffBase = rlpElement->buff;
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   4058a:	2200      	movs	r2, #0
      if(buffBase[scanZero]) {
        rlpElementBuff = (buffBase + scanZero);
        rlpElementLen -= scanZero;
        break;
      } else if (scanZero == rlpElement->len - 1) {
   4058c:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   40590:	4293      	cmp	r3, r2
   40592:	d008      	beq.n	405a6 <rlp_encode_element+0x6a>
      if(buffBase[scanZero]) {
   40594:	4637      	mov	r7, r6
   40596:	f897 e000 	ldrb.w	lr, [r7]
   4059a:	3601      	adds	r6, #1
   4059c:	f1be 0f00 	cmp.w	lr, #0
   405a0:	d009      	beq.n	405b6 <rlp_encode_element+0x7a>
   405a2:	4639      	mov	r1, r7
        rlpElementLen -= scanZero;
   405a4:	1aa4      	subs	r4, r4, r2
        rlpElementLen = 0;
      }
    }
  }
  // Element Header Generation
  if(rlpElementLen == 0) {
   405a6:	b96c      	cbnz	r4, 405c4 <rlp_encode_element+0x88>
    rlpEncodedLen = 1;
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   405a8:	2380      	movs	r3, #128	; 0x80
    rlpEncodedLen = 1;
   405aa:	2401      	movs	r4, #1
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   405ac:	7003      	strb	r3, [r0, #0]
    }
    // Payload
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
  }
  return rlpEncodedLen; // all was successful, return encoded length.
   405ae:	4620      	mov	r0, r4
}
   405b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (type == RLP_TYPE_BYTE_ARRAY)
   405b2:	2901      	cmp	r1, #1
   405b4:	e7d5      	b.n	40562 <rlp_encode_element+0x26>
        rlpElementLen = 0;
   405b6:	4594      	cmp	ip, r2
   405b8:	bf08      	it	eq
   405ba:	2400      	moveq	r4, #0
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   405bc:	3201      	adds	r2, #1
   405be:	e7e7      	b.n	40590 <rlp_encode_element+0x54>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   405c0:	461c      	mov	r4, r3
   405c2:	e7f0      	b.n	405a6 <rlp_encode_element+0x6a>
  else if(rlpElementLen == 1 && (rlpElementBuff[0] == 0x00 || 
   405c4:	2c01      	cmp	r4, #1
   405c6:	d106      	bne.n	405d6 <rlp_encode_element+0x9a>
   405c8:	f991 2000 	ldrsb.w	r2, [r1]
   405cc:	780b      	ldrb	r3, [r1, #0]
   405ce:	2a00      	cmp	r2, #0
   405d0:	db03      	blt.n	405da <rlp_encode_element+0x9e>
    rlpOut[0] = rlpElementBuff[0];
   405d2:	7003      	strb	r3, [r0, #0]
   405d4:	e7eb      	b.n	405ae <rlp_encode_element+0x72>
  else if (rlpElementLen <= RLP_EXTENDED_LENGTH_THRESHOLD) {
   405d6:	2c37      	cmp	r4, #55	; 0x37
   405d8:	d808      	bhi.n	405ec <rlp_encode_element+0xb0>
    uint8_t length = (uint8_t) (RLP_OFFSET_ITEM_SHORT + rlpElementLen);
   405da:	f1a4 0380 	sub.w	r3, r4, #128	; 0x80
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   405de:	4622      	mov	r2, r4
    rlpOut[0] = length;
   405e0:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   405e4:	f007 fe71 	bl	482ca <memcpy>
    rlpEncodedLen = rlpElementLen + 1;
   405e8:	3401      	adds	r4, #1
   405ea:	e7e0      	b.n	405ae <rlp_encode_element+0x72>
    int tmpLength = rlpElementLen;
   405ec:	4622      	mov	r2, r4
   405ee:	4627      	mov	r7, r4
    size_t lengthOfLength = (size_t) 0;
   405f0:	2300      	movs	r3, #0
    while (tmpLength != 0) {
   405f2:	123f      	asrs	r7, r7, #8
   405f4:	461e      	mov	r6, r3
        ++lengthOfLength;
   405f6:	f103 0301 	add.w	r3, r3, #1
    while (tmpLength != 0) {
   405fa:	d1fa      	bne.n	405f2 <rlp_encode_element+0xb6>
    if(rlpEncodedOutputLen < (rlpElementLen + lengthOfLength + 1))
   405fc:	3602      	adds	r6, #2
   405fe:	4434      	add	r4, r6
   40600:	42ac      	cmp	r4, r5
   40602:	d813      	bhi.n	4062c <rlp_encode_element+0xf0>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_ITEM_LONG + lengthOfLength);
   40604:	f1a3 0549 	sub.w	r5, r3, #73	; 0x49
   40608:	7005      	strb	r5, [r0, #0]
    for(int i = lengthOfLength; i > 0; --i) {
   4060a:	2b00      	cmp	r3, #0
   4060c:	dc04      	bgt.n	40618 <rlp_encode_element+0xdc>
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
   4060e:	4622      	mov	r2, r4
   40610:	4430      	add	r0, r6
   40612:	f007 fe5a 	bl	482ca <memcpy>
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
   40616:	e7ca      	b.n	405ae <rlp_encode_element+0x72>
      rlpOut[i] = (uint8_t) tmpLength;
   40618:	54c2      	strb	r2, [r0, r3]
      tmpLength = tmpLength >> 8;
   4061a:	1212      	asrs	r2, r2, #8
    for(int i = lengthOfLength; i > 0; --i) {
   4061c:	3b01      	subs	r3, #1
   4061e:	e7f4      	b.n	4060a <rlp_encode_element+0xce>
    return ERR_RLP_EBADARG;
   40620:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   40624:	e7c4      	b.n	405b0 <rlp_encode_element+0x74>
    return ERR_RLP_EILLEGALMEM;
   40626:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   4062a:	e7c1      	b.n	405b0 <rlp_encode_element+0x74>
    return ERR_RLP_ENOMEM;
   4062c:	f06f 007c 	mvn.w	r0, #124	; 0x7c
   40630:	e7be      	b.n	405b0 <rlp_encode_element+0x74>
   40632:	bf00      	nop
   40634:	0004931f 	.word	0x0004931f

00040638 <sha3_process_block>:
 *
 * @param hash the algorithm state
 * @param block the message block to process
 * @param block_size the size of the processed block in bytes
 */
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   40638:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4063c:	f1a0 0a08 	sub.w	sl, r0, #8
   40640:	4653      	mov	r3, sl
   40642:	b099      	sub	sp, #100	; 0x64
   40644:	3908      	subs	r1, #8
   40646:	f100 0680 	add.w	r6, r0, #128	; 0x80
    for (uint8_t i = 0; i < 17; i++) {
        hash[i] ^= le2me_64(block[i]);
   4064a:	f853 4f08 	ldr.w	r4, [r3, #8]!
   4064e:	f851 7f08 	ldr.w	r7, [r1, #8]!
   40652:	685a      	ldr	r2, [r3, #4]
   40654:	684d      	ldr	r5, [r1, #4]
   40656:	407c      	eors	r4, r7
   40658:	406a      	eors	r2, r5
    for (uint8_t i = 0; i < 17; i++) {
   4065a:	429e      	cmp	r6, r3
        hash[i] ^= le2me_64(block[i]);
   4065c:	e9c3 4200 	strd	r4, r2, [r3]
    for (uint8_t i = 0; i < 17; i++) {
   40660:	d1f3      	bne.n	4064a <sha3_process_block+0x12>
   40662:	f04f 0b18 	mov.w	fp, #24
   40666:	4b8f      	ldr	r3, [pc, #572]	; (408a4 <sha3_process_block+0x26c>)
   40668:	9301      	str	r3, [sp, #4]
   4066a:	f100 03c0 	add.w	r3, r0, #192	; 0xc0
   4066e:	9302      	str	r3, [sp, #8]
   40670:	f100 03c8 	add.w	r3, r0, #200	; 0xc8
   40674:	9303      	str	r3, [sp, #12]
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   40676:	4651      	mov	r1, sl
   40678:	2700      	movs	r7, #0
   4067a:	ab04      	add	r3, sp, #16
        C[i] = A[i];
   4067c:	2405      	movs	r4, #5
   4067e:	f851 6f08 	ldr.w	r6, [r1, #8]!
   40682:	684d      	ldr	r5, [r1, #4]
   40684:	e9c3 6500 	strd	r6, r5, [r3]
   40688:	3308      	adds	r3, #8
        for (uint8_t j = 5; j < 25; j += 5) { C[i] ^= A[i + j]; }
   4068a:	eb01 0cc4 	add.w	ip, r1, r4, lsl #3
   4068e:	f851 2034 	ldr.w	r2, [r1, r4, lsl #3]
   40692:	f8dc c004 	ldr.w	ip, [ip, #4]
   40696:	3405      	adds	r4, #5
   40698:	2c19      	cmp	r4, #25
   4069a:	ea86 0602 	eor.w	r6, r6, r2
   4069e:	ea85 050c 	eor.w	r5, r5, ip
   406a2:	d1f2      	bne.n	4068a <sha3_process_block+0x52>
   406a4:	3701      	adds	r7, #1
    for (uint8_t i = 0; i < 5; i++) {
   406a6:	2f05      	cmp	r7, #5
   406a8:	e943 6502 	strd	r6, r5, [r3, #-8]
   406ac:	d1e6      	bne.n	4067c <sha3_process_block+0x44>
   406ae:	ac0e      	add	r4, sp, #56	; 0x38
   406b0:	4621      	mov	r1, r4
   406b2:	2201      	movs	r2, #1
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   406b4:	f04f 0c05 	mov.w	ip, #5
   406b8:	fbb2 f3fc 	udiv	r3, r2, ip
   406bc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   406c0:	1ad3      	subs	r3, r2, r3
   406c2:	ad18      	add	r5, sp, #96	; 0x60
   406c4:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
   406c8:	e953 5714 	ldrd	r5, r7, [r3, #-80]	; 0x50
   406cc:	007e      	lsls	r6, r7, #1
   406ce:	ea46 76d5 	orr.w	r6, r6, r5, lsr #31
   406d2:	006b      	lsls	r3, r5, #1
   406d4:	1cd5      	adds	r5, r2, #3
   406d6:	ea43 73d7 	orr.w	r3, r3, r7, lsr #31
   406da:	fbb5 f7fc 	udiv	r7, r5, ip
   406de:	eb07 0787 	add.w	r7, r7, r7, lsl #2
   406e2:	1bed      	subs	r5, r5, r7
   406e4:	af18      	add	r7, sp, #96	; 0x60
   406e6:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
   406ea:	3201      	adds	r2, #1
   406ec:	e955 7514 	ldrd	r7, r5, [r5, #-80]	; 0x50
    for (uint8_t i = 0; i < 5; i++) {
   406f0:	2a06      	cmp	r2, #6
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   406f2:	ea83 0307 	eor.w	r3, r3, r7
   406f6:	ea86 0605 	eor.w	r6, r6, r5
   406fa:	e9c1 3600 	strd	r3, r6, [r1]
   406fe:	f101 0108 	add.w	r1, r1, #8
    for (uint8_t i = 0; i < 5; i++) {
   40702:	d1d7      	bne.n	406b4 <sha3_process_block+0x7c>
   40704:	2500      	movs	r5, #0
        for (uint8_t j = 0; j < 25; j += 5) { A[i + j] ^= D[i]; }
   40706:	e9d4 c700 	ldrd	ip, r7, [r4]
   4070a:	2600      	movs	r6, #0
   4070c:	3408      	adds	r4, #8
   4070e:	eb00 01c5 	add.w	r1, r0, r5, lsl #3
   40712:	3601      	adds	r6, #1
   40714:	e9d1 2300 	ldrd	r2, r3, [r1]
   40718:	2e05      	cmp	r6, #5
   4071a:	ea82 020c 	eor.w	r2, r2, ip
   4071e:	ea83 0307 	eor.w	r3, r3, r7
   40722:	e9c1 2300 	strd	r2, r3, [r1]
   40726:	f101 0128 	add.w	r1, r1, #40	; 0x28
   4072a:	d1f2      	bne.n	40712 <sha3_process_block+0xda>
    for (uint8_t i = 0; i < 5; i++) {
   4072c:	3501      	adds	r5, #1
   4072e:	2d05      	cmp	r5, #5
   40730:	d1e9      	bne.n	40706 <sha3_process_block+0xce>
        for (uint8_t i = 1; i < 25; i++) {
   40732:	4604      	mov	r4, r0
   40734:	f8df e174 	ldr.w	lr, [pc, #372]	; 408ac <sha3_process_block+0x274>
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40738:	f854 2f08 	ldr.w	r2, [r4, #8]!
    return constants[type + index];
   4073c:	f81e 3b01 	ldrb.w	r3, [lr], #1
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40740:	6865      	ldr	r5, [r4, #4]
   40742:	f1a3 0720 	sub.w	r7, r3, #32
   40746:	fa02 f707 	lsl.w	r7, r2, r7
   4074a:	f1c3 0620 	rsb	r6, r3, #32
   4074e:	fa05 f103 	lsl.w	r1, r5, r3
   40752:	fa22 f606 	lsr.w	r6, r2, r6
   40756:	4339      	orrs	r1, r7
   40758:	4331      	orrs	r1, r6
   4075a:	fa02 f603 	lsl.w	r6, r2, r3
   4075e:	425b      	negs	r3, r3
   40760:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   40764:	f1c3 0c20 	rsb	ip, r3, #32
   40768:	f1a3 0720 	sub.w	r7, r3, #32
   4076c:	40da      	lsrs	r2, r3
   4076e:	fa05 fc0c 	lsl.w	ip, r5, ip
   40772:	fa25 f303 	lsr.w	r3, r5, r3
   40776:	4319      	orrs	r1, r3
   40778:	ea42 020c 	orr.w	r2, r2, ip
        for (uint8_t i = 1; i < 25; i++) {
   4077c:	9b02      	ldr	r3, [sp, #8]
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   4077e:	fa25 f707 	lsr.w	r7, r5, r7
   40782:	433a      	orrs	r2, r7
   40784:	4332      	orrs	r2, r6
        for (uint8_t i = 1; i < 25; i++) {
   40786:	42a3      	cmp	r3, r4
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40788:	e9c4 2100 	strd	r2, r1, [r4]
        for (uint8_t i = 1; i < 25; i++) {
   4078c:	d1d4      	bne.n	40738 <sha3_process_block+0x100>
    for (uint8_t i = 1; i < 24; i++) {
   4078e:	2101      	movs	r1, #1
    uint64_t A1 = A[1];
   40790:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
    for (uint8_t i = 1; i < 24; i++) {
   40794:	4f44      	ldr	r7, [pc, #272]	; (408a8 <sha3_process_block+0x270>)
    return constants[type + index];
   40796:	463e      	mov	r6, r7
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   40798:	787c      	ldrb	r4, [r7, #1]
   4079a:	7836      	ldrb	r6, [r6, #0]
    for (uint8_t i = 1; i < 24; i++) {
   4079c:	3101      	adds	r1, #1
   4079e:	b2c9      	uxtb	r1, r1
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   407a0:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   407a4:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
    for (uint8_t i = 1; i < 24; i++) {
   407a8:	2918      	cmp	r1, #24
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   407aa:	e9d4 4500 	ldrd	r4, r5, [r4]
   407ae:	f107 0701 	add.w	r7, r7, #1
   407b2:	e9c6 4500 	strd	r4, r5, [r6]
    for (uint8_t i = 1; i < 24; i++) {
   407b6:	d1ee      	bne.n	40796 <sha3_process_block+0x15e>
    A[10] = A1;
   407b8:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
   407bc:	4603      	mov	r3, r0
        uint64_t A0 = A[0 + i], A1 = A[1 + i];
   407be:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
   407c2:	e9d3 7600 	ldrd	r7, r6, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   407c6:	e9d3 ec06 	ldrd	lr, ip, [r3, #24]
        A[0 + i] ^= ~A1 & A[2 + i];
   407ca:	691c      	ldr	r4, [r3, #16]
   407cc:	ea24 0501 	bic.w	r5, r4, r1
   407d0:	695c      	ldr	r4, [r3, #20]
   407d2:	407d      	eors	r5, r7
   407d4:	ea24 0402 	bic.w	r4, r4, r2
   407d8:	4074      	eors	r4, r6
   407da:	e9c3 5400 	strd	r5, r4, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   407de:	691c      	ldr	r4, [r3, #16]
   407e0:	ea2e 0504 	bic.w	r5, lr, r4
   407e4:	695c      	ldr	r4, [r3, #20]
   407e6:	404d      	eors	r5, r1
   407e8:	ea2c 0404 	bic.w	r4, ip, r4
   407ec:	4054      	eors	r4, r2
   407ee:	e9c3 5402 	strd	r5, r4, [r3, #8]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   407f2:	e9d3 5408 	ldrd	r5, r4, [r3, #32]
   407f6:	ea24 080c 	bic.w	r8, r4, ip
   407fa:	9400      	str	r4, [sp, #0]
   407fc:	691c      	ldr	r4, [r3, #16]
   407fe:	ea25 090e 	bic.w	r9, r5, lr
   40802:	ea89 0904 	eor.w	r9, r9, r4
   40806:	695c      	ldr	r4, [r3, #20]
        A[4 + i] ^= ~A0 & A1;
   40808:	ea22 0206 	bic.w	r2, r2, r6
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   4080c:	ea88 0804 	eor.w	r8, r8, r4
        A[3 + i] ^= ~A[4 + i] & A0;
   40810:	9c00      	ldr	r4, [sp, #0]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   40812:	e9c3 9804 	strd	r9, r8, [r3, #16]
        A[4 + i] ^= ~A0 & A1;
   40816:	ea21 0107 	bic.w	r1, r1, r7
        A[3 + i] ^= ~A[4 + i] & A0;
   4081a:	ea27 0905 	bic.w	r9, r7, r5
   4081e:	ea26 0804 	bic.w	r8, r6, r4
   40822:	ea89 0e0e 	eor.w	lr, r9, lr
        A[4 + i] ^= ~A0 & A1;
   40826:	4054      	eors	r4, r2
        A[3 + i] ^= ~A[4 + i] & A0;
   40828:	ea88 0c0c 	eor.w	ip, r8, ip
    for (uint8_t i = 0; i < 25; i += 5) {
   4082c:	9a03      	ldr	r2, [sp, #12]
        A[4 + i] ^= ~A0 & A1;
   4082e:	404d      	eors	r5, r1
        A[3 + i] ^= ~A[4 + i] & A0;
   40830:	e9c3 ec06 	strd	lr, ip, [r3, #24]
        A[4 + i] ^= ~A0 & A1;
   40834:	e9c3 5408 	strd	r5, r4, [r3, #32]
    for (uint8_t i = 0; i < 25; i += 5) {
   40838:	3328      	adds	r3, #40	; 0x28
   4083a:	429a      	cmp	r2, r3
   4083c:	d1bf      	bne.n	407be <sha3_process_block+0x186>
    return constants[type + index];
   4083e:	9b01      	ldr	r3, [sp, #4]
   40840:	f813 2b01 	ldrb.w	r2, [r3], #1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   40844:	f012 0140 	ands.w	r1, r2, #64	; 0x40
   40848:	bf16      	itet	ne
   4084a:	2100      	movne	r1, #0
    uint64_t result = 0;
   4084c:	460c      	moveq	r4, r1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   4084e:	f04f 4400 	movne.w	r4, #2147483648	; 0x80000000
    if (roundInfo & (1 << 5)) { result |= ((uint64_t)1 << 31); }
   40852:	f012 0f20 	tst.w	r2, #32
   40856:	bf18      	it	ne
   40858:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
    return constants[type + index];
   4085c:	9301      	str	r3, [sp, #4]
    if (roundInfo & (1 << 4)) { result |= ((uint64_t)1 << 15); }
   4085e:	06d3      	lsls	r3, r2, #27
   40860:	bf48      	it	mi
   40862:	f441 4100 	orrmi.w	r1, r1, #32768	; 0x8000
    if (roundInfo & (1 << 3)) { result |= ((uint64_t)1 << 7); }
   40866:	0717      	lsls	r7, r2, #28
   40868:	bf48      	it	mi
   4086a:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
    if (roundInfo & (1 << 2)) { result |= ((uint64_t)1 << 3); }
   4086e:	0756      	lsls	r6, r2, #29
   40870:	bf48      	it	mi
   40872:	f041 0108 	orrmi.w	r1, r1, #8
    if (roundInfo & (1 << 1)) { result |= ((uint64_t)1 << 1); }
   40876:	0795      	lsls	r5, r2, #30
   40878:	bf48      	it	mi
   4087a:	f041 0102 	orrmi.w	r1, r1, #2
    if (roundInfo & (1 << 0)) { result |= ((uint64_t)1 << 0); }
   4087e:	07d3      	lsls	r3, r2, #31
   40880:	bf48      	it	mi
   40882:	f041 0101 	orrmi.w	r1, r1, #1
        *state ^= get_round_constant(round);
   40886:	e9d0 2300 	ldrd	r2, r3, [r0]
   4088a:	4063      	eors	r3, r4
   4088c:	404a      	eors	r2, r1
   4088e:	e9c0 2300 	strd	r2, r3, [r0]
    for (uint8_t round = 0; round < 24; round++) {
   40892:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   40896:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   4089a:	f47f aeec 	bne.w	40676 <sha3_process_block+0x3e>
    }

    /* make a permutation of the hash */
    sha3_permutation(hash);
}
   4089e:	b019      	add	sp, #100	; 0x64
   408a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   408a4:	00049327 	.word	0x00049327
   408a8:	0004933f 	.word	0x0004933f
   408ac:	00049357 	.word	0x00049357

000408b0 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   408b0:	680b      	ldr	r3, [r1, #0]
   408b2:	3301      	adds	r3, #1
   408b4:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   408b6:	4b01      	ldr	r3, [pc, #4]	; (408bc <char_out+0xc>)
   408b8:	681b      	ldr	r3, [r3, #0]
   408ba:	4718      	bx	r3
   408bc:	2001a56c 	.word	0x2001a56c

000408c0 <__printk_hook_install>:
	_char_out = fn;
   408c0:	4b01      	ldr	r3, [pc, #4]	; (408c8 <__printk_hook_install+0x8>)
   408c2:	6018      	str	r0, [r3, #0]
}
   408c4:	4770      	bx	lr
   408c6:	bf00      	nop
   408c8:	2001a56c 	.word	0x2001a56c

000408cc <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   408cc:	b507      	push	{r0, r1, r2, lr}
   408ce:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   408d0:	2100      	movs	r1, #0
{
   408d2:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   408d4:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   408d6:	4803      	ldr	r0, [pc, #12]	; (408e4 <vprintk+0x18>)
   408d8:	a901      	add	r1, sp, #4
   408da:	f000 f8ff 	bl	40adc <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   408de:	b003      	add	sp, #12
   408e0:	f85d fb04 	ldr.w	pc, [sp], #4
   408e4:	000408b1 	.word	0x000408b1

000408e8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   408e8:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   408ea:	2500      	movs	r5, #0
{
   408ec:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   408ee:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   408f2:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
   408f4:	a901      	add	r1, sp, #4
   408f6:	4805      	ldr	r0, [pc, #20]	; (4090c <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   408f8:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
   408fa:	f000 f8ef 	bl	40adc <cbvprintf>

	if (ctx.count < ctx.max) {
   408fe:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   40902:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   40904:	bfb8      	it	lt
   40906:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   40908:	b005      	add	sp, #20
   4090a:	bd30      	pop	{r4, r5, pc}
   4090c:	000475d1 	.word	0x000475d1

00040910 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   40910:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40914:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   40918:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   4091a:	f019 0808 	ands.w	r8, r9, #8
{
   4091e:	4693      	mov	fp, r2
	if (processing) {
   40920:	d00d      	beq.n	4093e <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   40922:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   40924:	bf0c      	ite	eq
   40926:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   4092a:	f049 0920 	orrne.w	r9, r9, #32
   4092e:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   40932:	f38b 8811 	msr	BASEPRI, fp
   40936:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   4093a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4093e:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   40942:	2902      	cmp	r1, #2
   40944:	d107      	bne.n	40956 <process_event+0x46>
			evt = process_recheck(mgr);
   40946:	4620      	mov	r0, r4
   40948:	f006 fe6f 	bl	4762a <process_recheck>
		if (evt == EVT_NOP) {
   4094c:	2800      	cmp	r0, #0
   4094e:	d0f0      	beq.n	40932 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   40950:	2801      	cmp	r0, #1
   40952:	8b23      	ldrh	r3, [r4, #24]
   40954:	d150      	bne.n	409f8 <process_event+0xe8>
			res = mgr->last_res;
   40956:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40958:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   4095a:	2f00      	cmp	r7, #0
   4095c:	da15      	bge.n	4098a <process_event+0x7a>
		*clients = mgr->clients;
   4095e:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40960:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   40964:	e9c4 8800 	strd	r8, r8, [r4]
   40968:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   4096c:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   4096e:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   40970:	8b21      	ldrh	r1, [r4, #24]
   40972:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   40976:	45ca      	cmp	sl, r9
   40978:	d002      	beq.n	40980 <process_event+0x70>
		if (do_monitors
   4097a:	68a3      	ldr	r3, [r4, #8]
   4097c:	2b00      	cmp	r3, #0
   4097e:	d15c      	bne.n	40a3a <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   40980:	b90d      	cbnz	r5, 40986 <process_event+0x76>
		    || (transit != NULL)) {
   40982:	2e00      	cmp	r6, #0
   40984:	d074      	beq.n	40a70 <process_event+0x160>
   40986:	2300      	movs	r3, #0
   40988:	e058      	b.n	40a3c <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4098a:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   4098e:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   40990:	2a01      	cmp	r2, #1
   40992:	d820      	bhi.n	409d6 <process_event+0xc6>
		*clients = mgr->clients;
   40994:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   40998:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   4099a:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   4099c:	b289      	uxth	r1, r1
	list->tail = NULL;
   4099e:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   409a2:	d10c      	bne.n	409be <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   409a4:	2d00      	cmp	r5, #0
   409a6:	462b      	mov	r3, r5
   409a8:	bf38      	it	cc
   409aa:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   409ac:	b12b      	cbz	r3, 409ba <process_event+0xaa>
				mgr->refs += 1U;
   409ae:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   409b0:	681b      	ldr	r3, [r3, #0]
   409b2:	3201      	adds	r2, #1
   409b4:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   409b6:	2b00      	cmp	r3, #0
   409b8:	d1f8      	bne.n	409ac <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   409ba:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   409be:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   409c0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   409c2:	f006 fe32 	bl	4762a <process_recheck>
   409c6:	4606      	mov	r6, r0
   409c8:	2800      	cmp	r0, #0
   409ca:	d0d1      	beq.n	40970 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   409cc:	8b23      	ldrh	r3, [r4, #24]
   409ce:	f043 0320 	orr.w	r3, r3, #32
   409d2:	8323      	strh	r3, [r4, #24]
   409d4:	e7cb      	b.n	4096e <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   409d6:	2b04      	cmp	r3, #4
   409d8:	d10c      	bne.n	409f4 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   409da:	f021 0107 	bic.w	r1, r1, #7
   409de:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   409e0:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   409e2:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   409e4:	f006 fe21 	bl	4762a <process_recheck>
   409e8:	4605      	mov	r5, r0
   409ea:	2800      	cmp	r0, #0
   409ec:	d0bf      	beq.n	4096e <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   409ee:	f041 0120 	orr.w	r1, r1, #32
   409f2:	8321      	strh	r1, [r4, #24]
   409f4:	2500      	movs	r5, #0
   409f6:	e7ba      	b.n	4096e <process_event+0x5e>
		} else if (evt == EVT_START) {
   409f8:	2803      	cmp	r0, #3
   409fa:	d109      	bne.n	40a10 <process_event+0x100>
			transit = mgr->transitions->start;
   409fc:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   409fe:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   40a02:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40a04:	f043 0306 	orr.w	r3, r3, #6
}
   40a08:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   40a0a:	8323      	strh	r3, [r4, #24]
		res = 0;
   40a0c:	462f      	mov	r7, r5
   40a0e:	e7af      	b.n	40970 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   40a10:	2804      	cmp	r0, #4
   40a12:	d106      	bne.n	40a22 <process_event+0x112>
			transit = mgr->transitions->stop;
   40a14:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40a16:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   40a1a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40a1c:	f043 0304 	orr.w	r3, r3, #4
   40a20:	e7f2      	b.n	40a08 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   40a22:	2805      	cmp	r0, #5
   40a24:	d106      	bne.n	40a34 <process_event+0x124>
			transit = mgr->transitions->reset;
   40a26:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40a28:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   40a2c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40a2e:	f043 0305 	orr.w	r3, r3, #5
   40a32:	e7e9      	b.n	40a08 <process_event+0xf8>
   40a34:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   40a36:	462e      	mov	r6, r5
   40a38:	e7e8      	b.n	40a0c <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   40a3a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   40a3c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   40a40:	8321      	strh	r1, [r4, #24]
   40a42:	f38b 8811 	msr	BASEPRI, fp
   40a46:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   40a4a:	bb03      	cbnz	r3, 40a8e <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   40a4c:	2d00      	cmp	r5, #0
   40a4e:	d133      	bne.n	40ab8 <process_event+0x1a8>
			if (transit != NULL) {
   40a50:	b116      	cbz	r6, 40a58 <process_event+0x148>
				transit(mgr, transition_complete);
   40a52:	4620      	mov	r0, r4
   40a54:	4920      	ldr	r1, [pc, #128]	; (40ad8 <process_event+0x1c8>)
   40a56:	47b0      	blx	r6
	__asm__ volatile(
   40a58:	f04f 0320 	mov.w	r3, #32
   40a5c:	f3ef 8b11 	mrs	fp, BASEPRI
   40a60:	f383 8812 	msr	BASEPRI_MAX, r3
   40a64:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   40a68:	8b23      	ldrh	r3, [r4, #24]
   40a6a:	f023 0308 	bic.w	r3, r3, #8
   40a6e:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   40a70:	8b23      	ldrh	r3, [r4, #24]
   40a72:	06da      	lsls	r2, r3, #27
   40a74:	d528      	bpl.n	40ac8 <process_event+0x1b8>
			evt = EVT_COMPLETE;
   40a76:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   40a78:	f023 0310 	bic.w	r3, r3, #16
   40a7c:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   40a7e:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   40a82:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   40a86:	2900      	cmp	r1, #0
   40a88:	f47f af5b 	bne.w	40942 <process_event+0x32>
out:
   40a8c:	e751      	b.n	40932 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   40a8e:	68a1      	ldr	r1, [r4, #8]
   40a90:	2900      	cmp	r1, #0
   40a92:	d0db      	beq.n	40a4c <process_event+0x13c>
	return node->next;
   40a94:	680b      	ldr	r3, [r1, #0]
   40a96:	2b00      	cmp	r3, #0
   40a98:	bf38      	it	cc
   40a9a:	2300      	movcc	r3, #0
   40a9c:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   40a9e:	4652      	mov	r2, sl
   40aa0:	463b      	mov	r3, r7
   40aa2:	4620      	mov	r0, r4
   40aa4:	f8d1 b004 	ldr.w	fp, [r1, #4]
   40aa8:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   40aaa:	f1b9 0f00 	cmp.w	r9, #0
   40aae:	d0cd      	beq.n	40a4c <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   40ab0:	4649      	mov	r1, r9
   40ab2:	f8d9 3000 	ldr.w	r3, [r9]
   40ab6:	e7ee      	b.n	40a96 <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   40ab8:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   40aba:	463b      	mov	r3, r7
   40abc:	4652      	mov	r2, sl
   40abe:	4620      	mov	r0, r4
   40ac0:	682d      	ldr	r5, [r5, #0]
   40ac2:	f006 fdce 	bl	47662 <notify_one>
   40ac6:	e7c1      	b.n	40a4c <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   40ac8:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   40acc:	bf1e      	ittt	ne
   40ace:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   40ad2:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   40ad4:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   40ad6:	e7d2      	b.n	40a7e <process_event+0x16e>
   40ad8:	0004768f 	.word	0x0004768f

00040adc <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   40adc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   40ae0:	468b      	mov	fp, r1
   40ae2:	4692      	mov	sl, r2
   40ae4:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   40ae6:	2500      	movs	r5, #0
{
   40ae8:	b091      	sub	sp, #68	; 0x44
   40aea:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   40aec:	f89a 0000 	ldrb.w	r0, [sl]
   40af0:	b908      	cbnz	r0, 40af6 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   40af2:	4628      	mov	r0, r5
   40af4:	e35e      	b.n	411b4 <cbvprintf+0x6d8>
		if (*fp != '%') {
   40af6:	2825      	cmp	r0, #37	; 0x25
   40af8:	f10a 0701 	add.w	r7, sl, #1
   40afc:	d007      	beq.n	40b0e <cbvprintf+0x32>
			OUTC('%');
   40afe:	4659      	mov	r1, fp
   40b00:	9b02      	ldr	r3, [sp, #8]
   40b02:	4798      	blx	r3
   40b04:	2800      	cmp	r0, #0
   40b06:	f2c0 8355 	blt.w	411b4 <cbvprintf+0x6d8>
   40b0a:	3501      	adds	r5, #1
			break;
   40b0c:	e210      	b.n	40f30 <cbvprintf+0x454>
		} state = {
   40b0e:	2218      	movs	r2, #24
   40b10:	2100      	movs	r1, #0
   40b12:	a80a      	add	r0, sp, #40	; 0x28
   40b14:	f007 fbe4 	bl	482e0 <memset>
	if (*sp == '%') {
   40b18:	f89a 3001 	ldrb.w	r3, [sl, #1]
   40b1c:	2b25      	cmp	r3, #37	; 0x25
   40b1e:	d078      	beq.n	40c12 <cbvprintf+0x136>
   40b20:	2200      	movs	r2, #0
   40b22:	4694      	mov	ip, r2
   40b24:	4616      	mov	r6, r2
   40b26:	4696      	mov	lr, r2
   40b28:	4610      	mov	r0, r2
   40b2a:	4639      	mov	r1, r7
		switch (*sp) {
   40b2c:	f817 3b01 	ldrb.w	r3, [r7], #1
   40b30:	2b2b      	cmp	r3, #43	; 0x2b
   40b32:	f000 809d 	beq.w	40c70 <cbvprintf+0x194>
   40b36:	f200 8094 	bhi.w	40c62 <cbvprintf+0x186>
   40b3a:	2b20      	cmp	r3, #32
   40b3c:	f000 809b 	beq.w	40c76 <cbvprintf+0x19a>
   40b40:	2b23      	cmp	r3, #35	; 0x23
   40b42:	f000 809a 	beq.w	40c7a <cbvprintf+0x19e>
   40b46:	b128      	cbz	r0, 40b54 <cbvprintf+0x78>
   40b48:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40b4c:	f040 0004 	orr.w	r0, r0, #4
   40b50:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40b54:	f1be 0f00 	cmp.w	lr, #0
   40b58:	d005      	beq.n	40b66 <cbvprintf+0x8a>
   40b5a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40b5e:	f040 0008 	orr.w	r0, r0, #8
   40b62:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40b66:	b12e      	cbz	r6, 40b74 <cbvprintf+0x98>
   40b68:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40b6c:	f040 0010 	orr.w	r0, r0, #16
   40b70:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40b74:	f1bc 0f00 	cmp.w	ip, #0
   40b78:	d005      	beq.n	40b86 <cbvprintf+0xaa>
   40b7a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40b7e:	f040 0020 	orr.w	r0, r0, #32
   40b82:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40b86:	b12a      	cbz	r2, 40b94 <cbvprintf+0xb8>
   40b88:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40b8c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   40b90:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   40b94:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40b98:	f002 0044 	and.w	r0, r2, #68	; 0x44
   40b9c:	2844      	cmp	r0, #68	; 0x44
   40b9e:	d103      	bne.n	40ba8 <cbvprintf+0xcc>
		conv->flag_zero = false;
   40ba0:	f36f 1286 	bfc	r2, #6, #1
   40ba4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   40ba8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40bac:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   40bae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   40bb2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40bb6:	d17b      	bne.n	40cb0 <cbvprintf+0x1d4>
		conv->width_star = true;
   40bb8:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40bbc:	1c4b      	adds	r3, r1, #1
   40bbe:	f042 0201 	orr.w	r2, r2, #1
   40bc2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   40bc6:	781a      	ldrb	r2, [r3, #0]
   40bc8:	2a2e      	cmp	r2, #46	; 0x2e
   40bca:	bf0c      	ite	eq
   40bcc:	2101      	moveq	r1, #1
   40bce:	2100      	movne	r1, #0
   40bd0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40bd4:	f361 0241 	bfi	r2, r1, #1, #1
   40bd8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   40bdc:	d174      	bne.n	40cc8 <cbvprintf+0x1ec>
	if (*sp == '*') {
   40bde:	785a      	ldrb	r2, [r3, #1]
   40be0:	2a2a      	cmp	r2, #42	; 0x2a
   40be2:	d06a      	beq.n	40cba <cbvprintf+0x1de>
	size_t val = 0;
   40be4:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   40be6:	260a      	movs	r6, #10
   40be8:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   40bea:	4618      	mov	r0, r3
   40bec:	f810 2b01 	ldrb.w	r2, [r0], #1
   40bf0:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40bf4:	2f09      	cmp	r7, #9
   40bf6:	f240 808e 	bls.w	40d16 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   40bfa:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   40bfe:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   40c00:	f3c2 0040 	ubfx	r0, r2, #1, #1
   40c04:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   40c08:	f361 0241 	bfi	r2, r1, #1, #1
   40c0c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40c10:	e05a      	b.n	40cc8 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   40c12:	f10a 0702 	add.w	r7, sl, #2
   40c16:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   40c1a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40c1e:	07d9      	lsls	r1, r3, #31
   40c20:	f140 8149 	bpl.w	40eb6 <cbvprintf+0x3da>
			width = va_arg(ap, int);
   40c24:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   40c28:	f1b9 0f00 	cmp.w	r9, #0
   40c2c:	da07      	bge.n	40c3e <cbvprintf+0x162>
				conv->flag_dash = true;
   40c2e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   40c32:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   40c36:	f042 0204 	orr.w	r2, r2, #4
   40c3a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   40c3e:	075a      	lsls	r2, r3, #29
   40c40:	f140 8142 	bpl.w	40ec8 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   40c44:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   40c48:	f1b8 0f00 	cmp.w	r8, #0
   40c4c:	f280 8141 	bge.w	40ed2 <cbvprintf+0x3f6>
				conv->prec_present = false;
   40c50:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40c54:	f36f 0341 	bfc	r3, #1, #1
   40c58:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   40c5c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   40c60:	e137      	b.n	40ed2 <cbvprintf+0x3f6>
		switch (*sp) {
   40c62:	2b2d      	cmp	r3, #45	; 0x2d
   40c64:	d00c      	beq.n	40c80 <cbvprintf+0x1a4>
   40c66:	2b30      	cmp	r3, #48	; 0x30
   40c68:	f47f af6d 	bne.w	40b46 <cbvprintf+0x6a>
			conv->flag_zero = true;
   40c6c:	2201      	movs	r2, #1
	} while (loop);
   40c6e:	e75c      	b.n	40b2a <cbvprintf+0x4e>
			conv->flag_plus = true;
   40c70:	f04f 0e01 	mov.w	lr, #1
   40c74:	e759      	b.n	40b2a <cbvprintf+0x4e>
			conv->flag_space = true;
   40c76:	2601      	movs	r6, #1
   40c78:	e757      	b.n	40b2a <cbvprintf+0x4e>
			conv->flag_hash = true;
   40c7a:	f04f 0c01 	mov.w	ip, #1
   40c7e:	e754      	b.n	40b2a <cbvprintf+0x4e>
		switch (*sp) {
   40c80:	2001      	movs	r0, #1
   40c82:	e752      	b.n	40b2a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   40c84:	4633      	mov	r3, r6
   40c86:	fb0c 0202 	mla	r2, ip, r2, r0
   40c8a:	3a30      	subs	r2, #48	; 0x30
   40c8c:	461e      	mov	r6, r3
   40c8e:	f816 0b01 	ldrb.w	r0, [r6], #1
   40c92:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40c96:	2f09      	cmp	r7, #9
   40c98:	d9f4      	bls.n	40c84 <cbvprintf+0x1a8>
	if (sp != wp) {
   40c9a:	4299      	cmp	r1, r3
   40c9c:	d093      	beq.n	40bc6 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   40c9e:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   40ca2:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   40ca4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   40ca6:	f362 0141 	bfi	r1, r2, #1, #1
   40caa:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   40cae:	e78a      	b.n	40bc6 <cbvprintf+0xea>
   40cb0:	460b      	mov	r3, r1
	size_t val = 0;
   40cb2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   40cb4:	f04f 0c0a 	mov.w	ip, #10
   40cb8:	e7e8      	b.n	40c8c <cbvprintf+0x1b0>
		conv->prec_star = true;
   40cba:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   40cbe:	3302      	adds	r3, #2
		conv->prec_star = true;
   40cc0:	f042 0204 	orr.w	r2, r2, #4
   40cc4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   40cc8:	461f      	mov	r7, r3
   40cca:	f817 2b01 	ldrb.w	r2, [r7], #1
   40cce:	2a6c      	cmp	r2, #108	; 0x6c
   40cd0:	d041      	beq.n	40d56 <cbvprintf+0x27a>
   40cd2:	d825      	bhi.n	40d20 <cbvprintf+0x244>
   40cd4:	2a68      	cmp	r2, #104	; 0x68
   40cd6:	d02b      	beq.n	40d30 <cbvprintf+0x254>
   40cd8:	2a6a      	cmp	r2, #106	; 0x6a
   40cda:	d046      	beq.n	40d6a <cbvprintf+0x28e>
   40cdc:	2a4c      	cmp	r2, #76	; 0x4c
   40cde:	d04c      	beq.n	40d7a <cbvprintf+0x29e>
   40ce0:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   40ce2:	f817 2b01 	ldrb.w	r2, [r7], #1
   40ce6:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   40cea:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   40cec:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   40cf0:	f200 80d9 	bhi.w	40ea6 <cbvprintf+0x3ca>
   40cf4:	2a57      	cmp	r2, #87	; 0x57
   40cf6:	d84d      	bhi.n	40d94 <cbvprintf+0x2b8>
   40cf8:	2a41      	cmp	r2, #65	; 0x41
   40cfa:	d003      	beq.n	40d04 <cbvprintf+0x228>
   40cfc:	3a45      	subs	r2, #69	; 0x45
   40cfe:	2a02      	cmp	r2, #2
   40d00:	f200 80d1 	bhi.w	40ea6 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   40d04:	2204      	movs	r2, #4
   40d06:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40d0a:	f362 0302 	bfi	r3, r2, #0, #3
   40d0e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   40d12:	2301      	movs	r3, #1
			break;
   40d14:	e09e      	b.n	40e54 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   40d16:	fb06 2101 	mla	r1, r6, r1, r2
   40d1a:	4603      	mov	r3, r0
   40d1c:	3930      	subs	r1, #48	; 0x30
   40d1e:	e764      	b.n	40bea <cbvprintf+0x10e>
	switch (*sp) {
   40d20:	2a74      	cmp	r2, #116	; 0x74
   40d22:	d026      	beq.n	40d72 <cbvprintf+0x296>
   40d24:	2a7a      	cmp	r2, #122	; 0x7a
   40d26:	d1db      	bne.n	40ce0 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   40d28:	2206      	movs	r2, #6
   40d2a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40d2e:	e00d      	b.n	40d4c <cbvprintf+0x270>
		if (*++sp == 'h') {
   40d30:	785a      	ldrb	r2, [r3, #1]
   40d32:	2a68      	cmp	r2, #104	; 0x68
   40d34:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40d38:	d106      	bne.n	40d48 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   40d3a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   40d3c:	f361 02c6 	bfi	r2, r1, #3, #4
   40d40:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   40d44:	1c9f      	adds	r7, r3, #2
   40d46:	e7cc      	b.n	40ce2 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   40d48:	4613      	mov	r3, r2
   40d4a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   40d4c:	f362 03c6 	bfi	r3, r2, #3, #4
   40d50:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   40d54:	e7c5      	b.n	40ce2 <cbvprintf+0x206>
		if (*++sp == 'l') {
   40d56:	785a      	ldrb	r2, [r3, #1]
   40d58:	2a6c      	cmp	r2, #108	; 0x6c
   40d5a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40d5e:	d101      	bne.n	40d64 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   40d60:	2104      	movs	r1, #4
   40d62:	e7eb      	b.n	40d3c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   40d64:	4613      	mov	r3, r2
   40d66:	2203      	movs	r2, #3
   40d68:	e7f0      	b.n	40d4c <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   40d6a:	2205      	movs	r2, #5
   40d6c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40d70:	e7ec      	b.n	40d4c <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   40d72:	2207      	movs	r2, #7
   40d74:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40d78:	e7e8      	b.n	40d4c <cbvprintf+0x270>
		conv->unsupported = true;
   40d7a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   40d7e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   40d82:	f023 0302 	bic.w	r3, r3, #2
   40d86:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   40d8a:	f043 0302 	orr.w	r3, r3, #2
   40d8e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   40d92:	e7a6      	b.n	40ce2 <cbvprintf+0x206>
   40d94:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   40d98:	2920      	cmp	r1, #32
   40d9a:	f200 8084 	bhi.w	40ea6 <cbvprintf+0x3ca>
   40d9e:	a001      	add	r0, pc, #4	; (adr r0, 40da4 <cbvprintf+0x2c8>)
   40da0:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   40da4:	00040e69 	.word	0x00040e69
   40da8:	00040ea7 	.word	0x00040ea7
   40dac:	00040ea7 	.word	0x00040ea7
   40db0:	00040ea7 	.word	0x00040ea7
   40db4:	00040ea7 	.word	0x00040ea7
   40db8:	00040ea7 	.word	0x00040ea7
   40dbc:	00040ea7 	.word	0x00040ea7
   40dc0:	00040ea7 	.word	0x00040ea7
   40dc4:	00040ea7 	.word	0x00040ea7
   40dc8:	00040d05 	.word	0x00040d05
   40dcc:	00040ea7 	.word	0x00040ea7
   40dd0:	00040e69 	.word	0x00040e69
   40dd4:	00040e29 	.word	0x00040e29
   40dd8:	00040d05 	.word	0x00040d05
   40ddc:	00040d05 	.word	0x00040d05
   40de0:	00040d05 	.word	0x00040d05
   40de4:	00040ea7 	.word	0x00040ea7
   40de8:	00040e29 	.word	0x00040e29
   40dec:	00040ea7 	.word	0x00040ea7
   40df0:	00040ea7 	.word	0x00040ea7
   40df4:	00040ea7 	.word	0x00040ea7
   40df8:	00040ea7 	.word	0x00040ea7
   40dfc:	00040e71 	.word	0x00040e71
   40e00:	00040e69 	.word	0x00040e69
   40e04:	00040e8d 	.word	0x00040e8d
   40e08:	00040ea7 	.word	0x00040ea7
   40e0c:	00040ea7 	.word	0x00040ea7
   40e10:	00040e8d 	.word	0x00040e8d
   40e14:	00040ea7 	.word	0x00040ea7
   40e18:	00040e69 	.word	0x00040e69
   40e1c:	00040ea7 	.word	0x00040ea7
   40e20:	00040ea7 	.word	0x00040ea7
   40e24:	00040e69 	.word	0x00040e69
		conv->specifier_cat = SPECIFIER_SINT;
   40e28:	2001      	movs	r0, #1
   40e2a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40e2e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   40e32:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40e36:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   40e38:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   40e3c:	bf02      	ittt	eq
   40e3e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   40e42:	f041 0101 	orreq.w	r1, r1, #1
   40e46:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   40e4a:	2a63      	cmp	r2, #99	; 0x63
   40e4c:	d131      	bne.n	40eb2 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   40e4e:	3b00      	subs	r3, #0
   40e50:	bf18      	it	ne
   40e52:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   40e54:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40e58:	f3c2 0140 	ubfx	r1, r2, #1, #1
   40e5c:	430b      	orrs	r3, r1
   40e5e:	f363 0241 	bfi	r2, r3, #1, #1
   40e62:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40e66:	e6d8      	b.n	40c1a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   40e68:	2002      	movs	r0, #2
   40e6a:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   40e6e:	e7de      	b.n	40e2e <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   40e70:	2103      	movs	r1, #3
   40e72:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40e76:	f003 0378 	and.w	r3, r3, #120	; 0x78
   40e7a:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   40e7e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   40e82:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   40e84:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   40e88:	4143      	adcs	r3, r0
   40e8a:	e7e3      	b.n	40e54 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   40e8c:	2103      	movs	r1, #3
   40e8e:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40e92:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   40e96:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   40e9a:	bf14      	ite	ne
   40e9c:	2301      	movne	r3, #1
   40e9e:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   40ea0:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   40ea4:	e7d6      	b.n	40e54 <cbvprintf+0x378>
		conv->invalid = true;
   40ea6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40eaa:	f043 0301 	orr.w	r3, r3, #1
   40eae:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   40eb2:	2300      	movs	r3, #0
   40eb4:	e7ce      	b.n	40e54 <cbvprintf+0x378>
		} else if (conv->width_present) {
   40eb6:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   40eba:	2a00      	cmp	r2, #0
		int width = -1;
   40ebc:	bfac      	ite	ge
   40ebe:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
			width = conv->width_value;
   40ec2:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   40ec6:	e6ba      	b.n	40c3e <cbvprintf+0x162>
		} else if (conv->prec_present) {
   40ec8:	079b      	lsls	r3, r3, #30
   40eca:	f57f aec7 	bpl.w	40c5c <cbvprintf+0x180>
			precision = conv->prec_value;
   40ece:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   40ed2:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   40ed4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   40ed8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   40edc:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   40ee0:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   40ee4:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   40ee6:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   40eea:	d136      	bne.n	40f5a <cbvprintf+0x47e>
			switch (length_mod) {
   40eec:	1ed3      	subs	r3, r2, #3
   40eee:	2b04      	cmp	r3, #4
   40ef0:	d820      	bhi.n	40f34 <cbvprintf+0x458>
   40ef2:	e8df f003 	tbb	[pc, r3]
   40ef6:	0703      	.short	0x0703
   40ef8:	1f07      	.short	0x1f07
   40efa:	1f          	.byte	0x1f
   40efb:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   40efc:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   40f00:	17c1      	asrs	r1, r0, #31
   40f02:	e004      	b.n	40f0e <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   40f04:	3407      	adds	r4, #7
   40f06:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   40f0a:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   40f0e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   40f12:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   40f16:	f013 0603 	ands.w	r6, r3, #3
   40f1a:	d054      	beq.n	40fc6 <cbvprintf+0x4ea>
			OUTS(sp, fp);
   40f1c:	463b      	mov	r3, r7
   40f1e:	4652      	mov	r2, sl
   40f20:	4659      	mov	r1, fp
   40f22:	9802      	ldr	r0, [sp, #8]
   40f24:	f006 fe46 	bl	47bb4 <outs>
   40f28:	2800      	cmp	r0, #0
   40f2a:	f2c0 8143 	blt.w	411b4 <cbvprintf+0x6d8>
   40f2e:	4405      	add	r5, r0
			continue;
   40f30:	46ba      	mov	sl, r7
   40f32:	e5db      	b.n	40aec <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40f34:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   40f38:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   40f3a:	ea4f 71e0 	mov.w	r1, r0, asr #31
   40f3e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   40f42:	d105      	bne.n	40f50 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   40f44:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   40f48:	930a      	str	r3, [sp, #40]	; 0x28
   40f4a:	2300      	movs	r3, #0
   40f4c:	930b      	str	r3, [sp, #44]	; 0x2c
   40f4e:	e7e0      	b.n	40f12 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   40f50:	2a02      	cmp	r2, #2
   40f52:	d1de      	bne.n	40f12 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   40f54:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   40f58:	e7d2      	b.n	40f00 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   40f5a:	2b02      	cmp	r3, #2
   40f5c:	d123      	bne.n	40fa6 <cbvprintf+0x4ca>
			switch (length_mod) {
   40f5e:	1ed3      	subs	r3, r2, #3
   40f60:	2b04      	cmp	r3, #4
   40f62:	d813      	bhi.n	40f8c <cbvprintf+0x4b0>
   40f64:	e8df f003 	tbb	[pc, r3]
   40f68:	120a0a03 	.word	0x120a0a03
   40f6c:	12          	.byte	0x12
   40f6d:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   40f6e:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   40f70:	6820      	ldr	r0, [r4, #0]
   40f72:	1d23      	adds	r3, r4, #4
   40f74:	900a      	str	r0, [sp, #40]	; 0x28
   40f76:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   40f78:	461c      	mov	r4, r3
   40f7a:	e7ca      	b.n	40f12 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   40f7c:	3407      	adds	r4, #7
   40f7e:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   40f82:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   40f86:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   40f8a:	e7f5      	b.n	40f78 <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   40f8c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   40f90:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   40f92:	930a      	str	r3, [sp, #40]	; 0x28
   40f94:	f04f 0300 	mov.w	r3, #0
   40f98:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   40f9a:	d0d3      	beq.n	40f44 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   40f9c:	2a02      	cmp	r2, #2
   40f9e:	d1b8      	bne.n	40f12 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   40fa0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   40fa4:	e7d0      	b.n	40f48 <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   40fa6:	2b04      	cmp	r3, #4
   40fa8:	d107      	bne.n	40fba <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   40faa:	3407      	adds	r4, #7
   40fac:	f024 0407 	bic.w	r4, r4, #7
   40fb0:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   40fb4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   40fb8:	e7ab      	b.n	40f12 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   40fba:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   40fbc:	bf04      	itt	eq
   40fbe:	f854 3b04 	ldreq.w	r3, [r4], #4
   40fc2:	930a      	streq	r3, [sp, #40]	; 0x28
   40fc4:	e7a5      	b.n	40f12 <cbvprintf+0x436>
		switch (conv->specifier) {
   40fc6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   40fca:	2878      	cmp	r0, #120	; 0x78
   40fcc:	d8b0      	bhi.n	40f30 <cbvprintf+0x454>
   40fce:	2862      	cmp	r0, #98	; 0x62
   40fd0:	d822      	bhi.n	41018 <cbvprintf+0x53c>
   40fd2:	2825      	cmp	r0, #37	; 0x25
   40fd4:	f43f ad93 	beq.w	40afe <cbvprintf+0x22>
   40fd8:	2858      	cmp	r0, #88	; 0x58
   40fda:	d1a9      	bne.n	40f30 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   40fdc:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   40fe0:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   40fe4:	9300      	str	r3, [sp, #0]
   40fe6:	aa0c      	add	r2, sp, #48	; 0x30
   40fe8:	ab04      	add	r3, sp, #16
   40fea:	f006 fd98 	bl	47b1e <encode_uint>
   40fee:	4682      	mov	sl, r0
			if (precision >= 0) {
   40ff0:	f1b8 0f00 	cmp.w	r8, #0
   40ff4:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   40ff8:	db0c      	blt.n	41014 <cbvprintf+0x538>
				conv->flag_zero = false;
   40ffa:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   40ffe:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   41002:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   41006:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   41008:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   4100c:	d902      	bls.n	41014 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   4100e:	eba8 0303 	sub.w	r3, r8, r3
   41012:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   41014:	4680      	mov	r8, r0
   41016:	e03d      	b.n	41094 <cbvprintf+0x5b8>
   41018:	3863      	subs	r0, #99	; 0x63
   4101a:	2815      	cmp	r0, #21
   4101c:	d888      	bhi.n	40f30 <cbvprintf+0x454>
   4101e:	a101      	add	r1, pc, #4	; (adr r1, 41024 <cbvprintf+0x548>)
   41020:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   41024:	000410a5 	.word	0x000410a5
   41028:	00041109 	.word	0x00041109
   4102c:	00040f31 	.word	0x00040f31
   41030:	00040f31 	.word	0x00040f31
   41034:	00040f31 	.word	0x00040f31
   41038:	00040f31 	.word	0x00040f31
   4103c:	00041109 	.word	0x00041109
   41040:	00040f31 	.word	0x00040f31
   41044:	00040f31 	.word	0x00040f31
   41048:	00040f31 	.word	0x00040f31
   4104c:	00040f31 	.word	0x00040f31
   41050:	00041167 	.word	0x00041167
   41054:	00041135 	.word	0x00041135
   41058:	00041139 	.word	0x00041139
   4105c:	00040f31 	.word	0x00040f31
   41060:	00040f31 	.word	0x00040f31
   41064:	0004107d 	.word	0x0004107d
   41068:	00040f31 	.word	0x00040f31
   4106c:	00041135 	.word	0x00041135
   41070:	00040f31 	.word	0x00040f31
   41074:	00040f31 	.word	0x00040f31
   41078:	00041135 	.word	0x00041135
			if (precision >= 0) {
   4107c:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   41080:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   41084:	db0a      	blt.n	4109c <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   41086:	4641      	mov	r1, r8
   41088:	4650      	mov	r0, sl
   4108a:	f007 f901 	bl	48290 <strnlen>
		char sign = 0;
   4108e:	2600      	movs	r6, #0
			bpe = bps + len;
   41090:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   41094:	f1ba 0f00 	cmp.w	sl, #0
   41098:	d10c      	bne.n	410b4 <cbvprintf+0x5d8>
   4109a:	e749      	b.n	40f30 <cbvprintf+0x454>
				len = strlen(bps);
   4109c:	4650      	mov	r0, sl
   4109e:	f007 f8f0 	bl	48282 <strlen>
   410a2:	e7f4      	b.n	4108e <cbvprintf+0x5b2>
			break;
   410a4:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   410a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   410a8:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   410ac:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   410b0:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   410b4:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   410b8:	b106      	cbz	r6, 410bc <cbvprintf+0x5e0>
			nj_len += 1U;
   410ba:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   410bc:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   410c0:	06d0      	lsls	r0, r2, #27
   410c2:	d56b      	bpl.n	4119c <cbvprintf+0x6c0>
			nj_len += 2U;
   410c4:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   410c6:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   410c8:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   410ca:	bf48      	it	mi
   410cc:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   410ce:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   410d0:	bf48      	it	mi
   410d2:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   410d4:	f1b9 0f00 	cmp.w	r9, #0
   410d8:	dd79      	ble.n	411ce <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   410da:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   410de:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   410e2:	f3c2 0380 	ubfx	r3, r2, #2, #1
   410e6:	9303      	str	r3, [sp, #12]
   410e8:	0753      	lsls	r3, r2, #29
   410ea:	d470      	bmi.n	411ce <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   410ec:	0650      	lsls	r0, r2, #25
   410ee:	d564      	bpl.n	411ba <cbvprintf+0x6de>
					if (sign != 0) {
   410f0:	b146      	cbz	r6, 41104 <cbvprintf+0x628>
						OUTC(sign);
   410f2:	4659      	mov	r1, fp
   410f4:	4630      	mov	r0, r6
   410f6:	9b02      	ldr	r3, [sp, #8]
   410f8:	4798      	blx	r3
   410fa:	2800      	cmp	r0, #0
   410fc:	db5a      	blt.n	411b4 <cbvprintf+0x6d8>
						sign = 0;
   410fe:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   41100:	3501      	adds	r5, #1
						sign = 0;
   41102:	461e      	mov	r6, r3
					pad = '0';
   41104:	2330      	movs	r3, #48	; 0x30
   41106:	e059      	b.n	411bc <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   41108:	071e      	lsls	r6, r3, #28
   4110a:	d411      	bmi.n	41130 <cbvprintf+0x654>
				sign = ' ';
   4110c:	f013 0610 	ands.w	r6, r3, #16
   41110:	bf18      	it	ne
   41112:	2620      	movne	r6, #32
			sint = value->sint;
   41114:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   41118:	2a00      	cmp	r2, #0
   4111a:	f173 0100 	sbcs.w	r1, r3, #0
   4111e:	f6bf af5d 	bge.w	40fdc <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   41122:	4252      	negs	r2, r2
   41124:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   41128:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   4112a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   4112e:	e755      	b.n	40fdc <cbvprintf+0x500>
				sign = '+';
   41130:	262b      	movs	r6, #43	; 0x2b
   41132:	e7ef      	b.n	41114 <cbvprintf+0x638>
		switch (conv->specifier) {
   41134:	2600      	movs	r6, #0
   41136:	e751      	b.n	40fdc <cbvprintf+0x500>
			if (value->ptr != NULL) {
   41138:	980a      	ldr	r0, [sp, #40]	; 0x28
   4113a:	b348      	cbz	r0, 41190 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   4113c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   41140:	9300      	str	r3, [sp, #0]
   41142:	2100      	movs	r1, #0
   41144:	ab04      	add	r3, sp, #16
   41146:	aa0c      	add	r2, sp, #48	; 0x30
   41148:	f006 fce9 	bl	47b1e <encode_uint>
				conv->altform_0c = true;
   4114c:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   41150:	4682      	mov	sl, r0
				conv->altform_0c = true;
   41152:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   41156:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   4115a:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   4115e:	2600      	movs	r6, #0
				conv->altform_0c = true;
   41160:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   41164:	e744      	b.n	40ff0 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   41166:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   41168:	2a07      	cmp	r2, #7
   4116a:	f63f aee1 	bhi.w	40f30 <cbvprintf+0x454>
   4116e:	e8df f002 	tbb	[pc, r2]
   41172:	040d      	.short	0x040d
   41174:	08080d06 	.word	0x08080d06
   41178:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   4117a:	701d      	strb	r5, [r3, #0]
		break;
   4117c:	e6d8      	b.n	40f30 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   4117e:	801d      	strh	r5, [r3, #0]
		break;
   41180:	e6d6      	b.n	40f30 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   41182:	4628      	mov	r0, r5
   41184:	17e9      	asrs	r1, r5, #31
   41186:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   4118a:	e6d1      	b.n	40f30 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   4118c:	601d      	str	r5, [r3, #0]
		break;
   4118e:	e6cf      	b.n	40f30 <cbvprintf+0x454>
			bpe = bps + 5;
   41190:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 41258 <cbvprintf+0x77c>
   41194:	4606      	mov	r6, r0
			bps = "(nil)";
   41196:	f1a8 0a05 	sub.w	sl, r8, #5
   4119a:	e78b      	b.n	410b4 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   4119c:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   4119e:	bf48      	it	mi
   411a0:	3301      	addmi	r3, #1
   411a2:	e790      	b.n	410c6 <cbvprintf+0x5ea>
					OUTC(pad);
   411a4:	4618      	mov	r0, r3
   411a6:	9303      	str	r3, [sp, #12]
   411a8:	4659      	mov	r1, fp
   411aa:	9b02      	ldr	r3, [sp, #8]
   411ac:	4798      	blx	r3
   411ae:	2800      	cmp	r0, #0
   411b0:	9b03      	ldr	r3, [sp, #12]
   411b2:	da04      	bge.n	411be <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   411b4:	b011      	add	sp, #68	; 0x44
   411b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   411ba:	2320      	movs	r3, #32
   411bc:	444d      	add	r5, r9
   411be:	464a      	mov	r2, r9
				while (width-- > 0) {
   411c0:	2a00      	cmp	r2, #0
   411c2:	eba5 0109 	sub.w	r1, r5, r9
   411c6:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   411ca:	dceb      	bgt.n	411a4 <cbvprintf+0x6c8>
   411cc:	460d      	mov	r5, r1
		if (sign != 0) {
   411ce:	b136      	cbz	r6, 411de <cbvprintf+0x702>
			OUTC(sign);
   411d0:	4659      	mov	r1, fp
   411d2:	4630      	mov	r0, r6
   411d4:	9b02      	ldr	r3, [sp, #8]
   411d6:	4798      	blx	r3
   411d8:	2800      	cmp	r0, #0
   411da:	dbeb      	blt.n	411b4 <cbvprintf+0x6d8>
   411dc:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   411de:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   411e2:	06d9      	lsls	r1, r3, #27
   411e4:	d401      	bmi.n	411ea <cbvprintf+0x70e>
   411e6:	071a      	lsls	r2, r3, #28
   411e8:	d506      	bpl.n	411f8 <cbvprintf+0x71c>
				OUTC('0');
   411ea:	4659      	mov	r1, fp
   411ec:	2030      	movs	r0, #48	; 0x30
   411ee:	9b02      	ldr	r3, [sp, #8]
   411f0:	4798      	blx	r3
   411f2:	2800      	cmp	r0, #0
   411f4:	dbde      	blt.n	411b4 <cbvprintf+0x6d8>
   411f6:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   411f8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   411fc:	06db      	lsls	r3, r3, #27
   411fe:	d507      	bpl.n	41210 <cbvprintf+0x734>
				OUTC(conv->specifier);
   41200:	4659      	mov	r1, fp
   41202:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   41206:	9b02      	ldr	r3, [sp, #8]
   41208:	4798      	blx	r3
   4120a:	2800      	cmp	r0, #0
   4120c:	dbd2      	blt.n	411b4 <cbvprintf+0x6d8>
   4120e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   41210:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   41212:	442e      	add	r6, r5
   41214:	1b73      	subs	r3, r6, r5
   41216:	2b00      	cmp	r3, #0
   41218:	dc16      	bgt.n	41248 <cbvprintf+0x76c>
			OUTS(bps, bpe);
   4121a:	4643      	mov	r3, r8
   4121c:	4652      	mov	r2, sl
   4121e:	4659      	mov	r1, fp
   41220:	9802      	ldr	r0, [sp, #8]
   41222:	f006 fcc7 	bl	47bb4 <outs>
   41226:	2800      	cmp	r0, #0
   41228:	dbc4      	blt.n	411b4 <cbvprintf+0x6d8>
   4122a:	4405      	add	r5, r0
		while (width > 0) {
   4122c:	44a9      	add	r9, r5
   4122e:	eba9 0305 	sub.w	r3, r9, r5
   41232:	2b00      	cmp	r3, #0
   41234:	f77f ae7c 	ble.w	40f30 <cbvprintf+0x454>
			OUTC(' ');
   41238:	4659      	mov	r1, fp
   4123a:	2020      	movs	r0, #32
   4123c:	9b02      	ldr	r3, [sp, #8]
   4123e:	4798      	blx	r3
   41240:	2800      	cmp	r0, #0
   41242:	dbb7      	blt.n	411b4 <cbvprintf+0x6d8>
   41244:	3501      	adds	r5, #1
			--width;
   41246:	e7f2      	b.n	4122e <cbvprintf+0x752>
				OUTC('0');
   41248:	4659      	mov	r1, fp
   4124a:	2030      	movs	r0, #48	; 0x30
   4124c:	9b02      	ldr	r3, [sp, #8]
   4124e:	4798      	blx	r3
   41250:	2800      	cmp	r0, #0
   41252:	dbaf      	blt.n	411b4 <cbvprintf+0x6d8>
   41254:	3501      	adds	r5, #1
   41256:	e7dd      	b.n	41214 <cbvprintf+0x738>
   41258:	00049374 	.word	0x00049374

0004125c <nordicsemi_nrf91_init>:
   4125c:	f04f 0220 	mov.w	r2, #32
   41260:	f3ef 8311 	mrs	r3, BASEPRI
   41264:	f382 8812 	msr	BASEPRI_MAX, r2
   41268:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   4126c:	2101      	movs	r1, #1
   4126e:	4a04      	ldr	r2, [pc, #16]	; (41280 <nordicsemi_nrf91_init+0x24>)
   41270:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   41274:	f383 8811 	msr	BASEPRI, r3
   41278:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   4127c:	2000      	movs	r0, #0
   4127e:	4770      	bx	lr
   41280:	40039000 	.word	0x40039000

00041284 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   41284:	b120      	cbz	r0, 41290 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   41286:	4b03      	ldr	r3, [pc, #12]	; (41294 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   41288:	0180      	lsls	r0, r0, #6
   4128a:	f043 0301 	orr.w	r3, r3, #1
   4128e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   41290:	4770      	bx	lr
   41292:	bf00      	nop
   41294:	000490c0 	.word	0x000490c0

00041298 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
   41298:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   4129a:	2200      	movs	r2, #0
{
   4129c:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
   4129e:	490f      	ldr	r1, [pc, #60]	; (412dc <enable_logger+0x44>)
   412a0:	480f      	ldr	r0, [pc, #60]	; (412e0 <enable_logger+0x48>)
   412a2:	f007 fd15 	bl	48cd0 <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   412a6:	2200      	movs	r2, #0
   412a8:	2300      	movs	r3, #0
   412aa:	2400      	movs	r4, #0
   412ac:	e9cd 2306 	strd	r2, r3, [sp, #24]
   412b0:	230e      	movs	r3, #14
   412b2:	4d0c      	ldr	r5, [pc, #48]	; (412e4 <enable_logger+0x4c>)
   412b4:	e9cd 3403 	strd	r3, r4, [sp, #12]
   412b8:	f44f 7240 	mov.w	r2, #768	; 0x300
   412bc:	4628      	mov	r0, r5
   412be:	e9cd 4401 	strd	r4, r4, [sp, #4]
   412c2:	4b09      	ldr	r3, [pc, #36]	; (412e8 <enable_logger+0x50>)
   412c4:	4909      	ldr	r1, [pc, #36]	; (412ec <enable_logger+0x54>)
   412c6:	9400      	str	r4, [sp, #0]
   412c8:	f005 f930 	bl	4652c <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
   412cc:	4908      	ldr	r1, [pc, #32]	; (412f0 <enable_logger+0x58>)
   412ce:	4628      	mov	r0, r5
   412d0:	f007 fb7a 	bl	489c8 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   412d4:	4620      	mov	r0, r4
   412d6:	b009      	add	sp, #36	; 0x24
   412d8:	bd30      	pop	{r4, r5, pc}
   412da:	bf00      	nop
   412dc:	000412f5 	.word	0x000412f5
   412e0:	2001a690 	.word	0x2001a690
   412e4:	2001a6c8 	.word	0x2001a6c8
   412e8:	000416d5 	.word	0x000416d5
   412ec:	20020b40 	.word	0x20020b40
   412f0:	00049379 	.word	0x00049379

000412f4 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   412f4:	4801      	ldr	r0, [pc, #4]	; (412fc <log_process_thread_timer_expiry_fn+0x8>)
   412f6:	f005 ba67 	b.w	467c8 <z_impl_k_sem_give>
   412fa:	bf00      	nop
   412fc:	2001a67c 	.word	0x2001a67c

00041300 <log_core_init>:
	panic_mode = false;
   41300:	2300      	movs	r3, #0
   41302:	4a0c      	ldr	r2, [pc, #48]	; (41334 <log_core_init+0x34>)
{
   41304:	b510      	push	{r4, lr}
	panic_mode = false;
   41306:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
   41308:	4a0b      	ldr	r2, [pc, #44]	; (41338 <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
   4130a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	dropped_cnt = 0;
   4130e:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
   41310:	4b0a      	ldr	r3, [pc, #40]	; (4133c <log_core_init+0x3c>)
   41312:	4a0b      	ldr	r2, [pc, #44]	; (41340 <log_core_init+0x40>)
   41314:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   41316:	f000 fcb5 	bl	41c84 <log_output_timestamp_freq_set>
		log_msg_pool_init();
   4131a:	f000 fa55 	bl	417c8 <log_msg_pool_init>
		log_list_init(&list);
   4131e:	4809      	ldr	r0, [pc, #36]	; (41344 <log_core_init+0x44>)
   41320:	f006 fc7d 	bl	47c1e <log_list_init>
}
   41324:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   41328:	2304      	movs	r3, #4
   4132a:	2228      	movs	r2, #40	; 0x28
   4132c:	4906      	ldr	r1, [pc, #24]	; (41348 <log_core_init+0x48>)
   4132e:	4807      	ldr	r0, [pc, #28]	; (4134c <log_core_init+0x4c>)
   41330:	f007 bb00 	b.w	48934 <k_mem_slab_init>
   41334:	2001ade7 	.word	0x2001ade7
   41338:	2001a890 	.word	0x2001a890
   4133c:	2001a570 	.word	0x2001a570
   41340:	00047c5d 	.word	0x00047c5d
   41344:	2001a898 	.word	0x2001a898
   41348:	20025b80 	.word	0x20025b80
   4134c:	2001a8a0 	.word	0x2001a8a0

00041350 <log_init>:
{
   41350:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   41352:	4b10      	ldr	r3, [pc, #64]	; (41394 <log_init+0x44>)
   41354:	e8d3 5fef 	ldaex	r5, [r3]
   41358:	1c6a      	adds	r2, r5, #1
   4135a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4135e:	2900      	cmp	r1, #0
   41360:	d1f8      	bne.n	41354 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
   41362:	b92d      	cbnz	r5, 41370 <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   41364:	4c0c      	ldr	r4, [pc, #48]	; (41398 <log_init+0x48>)
   41366:	4e0d      	ldr	r6, [pc, #52]	; (4139c <log_init+0x4c>)
   41368:	1b36      	subs	r6, r6, r4
   4136a:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   4136c:	42b5      	cmp	r5, r6
   4136e:	db00      	blt.n	41372 <log_init+0x22>
}
   41370:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   41372:	7b23      	ldrb	r3, [r4, #12]
   41374:	b153      	cbz	r3, 4138c <log_init+0x3c>
			if (backend->api->init != NULL) {
   41376:	6823      	ldr	r3, [r4, #0]
   41378:	699b      	ldr	r3, [r3, #24]
   4137a:	b10b      	cbz	r3, 41380 <log_init+0x30>
				backend->api->init(backend);
   4137c:	4620      	mov	r0, r4
   4137e:	4798      	blx	r3
			log_backend_enable(backend,
   41380:	6863      	ldr	r3, [r4, #4]
   41382:	2204      	movs	r2, #4
   41384:	4620      	mov	r0, r4
   41386:	6819      	ldr	r1, [r3, #0]
   41388:	f000 fa10 	bl	417ac <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   4138c:	3501      	adds	r5, #1
   4138e:	3410      	adds	r4, #16
   41390:	e7ec      	b.n	4136c <log_init+0x1c>
   41392:	bf00      	nop
   41394:	2001a894 	.word	0x2001a894
   41398:	00049088 	.word	0x00049088
   4139c:	000490a8 	.word	0x000490a8

000413a0 <get_msg>:
{
   413a0:	b510      	push	{r4, lr}
	__asm__ volatile(
   413a2:	f04f 0320 	mov.w	r3, #32
   413a6:	f3ef 8411 	mrs	r4, BASEPRI
   413aa:	f383 8812 	msr	BASEPRI_MAX, r3
   413ae:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
   413b2:	4804      	ldr	r0, [pc, #16]	; (413c4 <get_msg+0x24>)
   413b4:	f006 fc43 	bl	47c3e <log_list_head_get>
	__asm__ volatile(
   413b8:	f384 8811 	msr	BASEPRI, r4
   413bc:	f3bf 8f6f 	isb	sy
}
   413c0:	bd10      	pop	{r4, pc}
   413c2:	bf00      	nop
   413c4:	2001a898 	.word	0x2001a898

000413c8 <z_log_notify_backend_enabled>:
{
   413c8:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
   413ca:	4c04      	ldr	r4, [pc, #16]	; (413dc <z_log_notify_backend_enabled+0x14>)
   413cc:	7822      	ldrb	r2, [r4, #0]
   413ce:	b912      	cbnz	r2, 413d6 <z_log_notify_backend_enabled+0xe>
   413d0:	4803      	ldr	r0, [pc, #12]	; (413e0 <z_log_notify_backend_enabled+0x18>)
   413d2:	f005 f9f9 	bl	467c8 <z_impl_k_sem_give>
	backend_attached = true;
   413d6:	2301      	movs	r3, #1
   413d8:	7023      	strb	r3, [r4, #0]
}
   413da:	bd10      	pop	{r4, pc}
   413dc:	2001ade6 	.word	0x2001ade6
   413e0:	2001a67c 	.word	0x2001a67c

000413e4 <z_log_dropped>:
   413e4:	4b08      	ldr	r3, [pc, #32]	; (41408 <z_log_dropped+0x24>)
   413e6:	e8d3 2fef 	ldaex	r2, [r3]
   413ea:	3201      	adds	r2, #1
   413ec:	e8c3 2fe1 	stlex	r1, r2, [r3]
   413f0:	2900      	cmp	r1, #0
   413f2:	d1f8      	bne.n	413e6 <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   413f4:	4b05      	ldr	r3, [pc, #20]	; (4140c <z_log_dropped+0x28>)
   413f6:	e8d3 2fef 	ldaex	r2, [r3]
   413fa:	3a01      	subs	r2, #1
   413fc:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41400:	2900      	cmp	r1, #0
   41402:	d1f8      	bne.n	413f6 <z_log_dropped+0x12>
}
   41404:	4770      	bx	lr
   41406:	bf00      	nop
   41408:	2001a890 	.word	0x2001a890
   4140c:	2001a88c 	.word	0x2001a88c

00041410 <z_log_dropped_read_and_clear>:
}
   41410:	2000      	movs	r0, #0
   41412:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   41414:	4b03      	ldr	r3, [pc, #12]	; (41424 <z_log_dropped_read_and_clear+0x14>)
   41416:	e8d3 0fef 	ldaex	r0, [r3]
   4141a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4141e:	2900      	cmp	r1, #0
   41420:	d1f9      	bne.n	41416 <z_log_dropped_read_and_clear+0x6>
   41422:	4770      	bx	lr
   41424:	2001a890 	.word	0x2001a890

00041428 <dropped_notify>:
{
   41428:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
   4142a:	f7ff fff1 	bl	41410 <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
   4142e:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
   41430:	4607      	mov	r7, r0
   41432:	4c09      	ldr	r4, [pc, #36]	; (41458 <dropped_notify+0x30>)
   41434:	4d09      	ldr	r5, [pc, #36]	; (4145c <dropped_notify+0x34>)
   41436:	1b2d      	subs	r5, r5, r4
   41438:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   4143a:	42ae      	cmp	r6, r5
   4143c:	db00      	blt.n	41440 <dropped_notify+0x18>
}
   4143e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   41440:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41442:	795b      	ldrb	r3, [r3, #5]
   41444:	b12b      	cbz	r3, 41452 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
   41446:	6823      	ldr	r3, [r4, #0]
   41448:	691b      	ldr	r3, [r3, #16]
   4144a:	b113      	cbz	r3, 41452 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
   4144c:	4639      	mov	r1, r7
   4144e:	4620      	mov	r0, r4
   41450:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41452:	3601      	adds	r6, #1
   41454:	3410      	adds	r4, #16
   41456:	e7f0      	b.n	4143a <dropped_notify+0x12>
   41458:	00049088 	.word	0x00049088
   4145c:	000490a8 	.word	0x000490a8

00041460 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   41460:	4b14      	ldr	r3, [pc, #80]	; (414b4 <z_log_strdup+0x54>)
{
   41462:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
   41464:	4298      	cmp	r0, r3
{
   41466:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41468:	d302      	bcc.n	41470 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   4146a:	4b13      	ldr	r3, [pc, #76]	; (414b8 <z_log_strdup+0x58>)
   4146c:	4298      	cmp	r0, r3
   4146e:	d31c      	bcc.n	414aa <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   41470:	2200      	movs	r2, #0
   41472:	2300      	movs	r3, #0
   41474:	4811      	ldr	r0, [pc, #68]	; (414bc <z_log_strdup+0x5c>)
   41476:	a901      	add	r1, sp, #4
   41478:	f004 fff8 	bl	4646c <k_mem_slab_alloc>
	if (err != 0) {
   4147c:	4605      	mov	r5, r0
   4147e:	b9b8      	cbnz	r0, 414b0 <z_log_strdup+0x50>
   41480:	2201      	movs	r2, #1
   41482:	9b01      	ldr	r3, [sp, #4]
   41484:	e8d3 1fef 	ldaex	r1, [r3]
   41488:	e8c3 2fe0 	stlex	r0, r2, [r3]
   4148c:	2800      	cmp	r0, #0
   4148e:	d1f9      	bne.n	41484 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   41490:	9801      	ldr	r0, [sp, #4]
   41492:	4621      	mov	r1, r4
   41494:	221f      	movs	r2, #31
   41496:	3004      	adds	r0, #4
   41498:	f006 fee0 	bl	4825c <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   4149c:	237e      	movs	r3, #126	; 0x7e
   4149e:	9c01      	ldr	r4, [sp, #4]
   414a0:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   414a4:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   414a8:	3404      	adds	r4, #4
}
   414aa:	4620      	mov	r0, r4
   414ac:	b003      	add	sp, #12
   414ae:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   414b0:	4c03      	ldr	r4, [pc, #12]	; (414c0 <z_log_strdup+0x60>)
   414b2:	e7fa      	b.n	414aa <z_log_strdup+0x4a>
   414b4:	00048d60 	.word	0x00048d60
   414b8:	00049b6c 	.word	0x00049b6c
   414bc:	2001a8a0 	.word	0x2001a8a0
   414c0:	00049381 	.word	0x00049381

000414c4 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
   414c4:	b148      	cbz	r0, 414da <log_is_strdup+0x16>
   414c6:	4b05      	ldr	r3, [pc, #20]	; (414dc <log_is_strdup+0x18>)
   414c8:	4298      	cmp	r0, r3
   414ca:	d305      	bcc.n	414d8 <log_is_strdup+0x14>
   414cc:	33a0      	adds	r3, #160	; 0xa0
   414ce:	4298      	cmp	r0, r3
   414d0:	bf2c      	ite	cs
   414d2:	2000      	movcs	r0, #0
   414d4:	2001      	movcc	r0, #1
   414d6:	4770      	bx	lr
   414d8:	2000      	movs	r0, #0
}
   414da:	4770      	bx	lr
   414dc:	20025b80 	.word	0x20025b80

000414e0 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
   414e0:	4b41      	ldr	r3, [pc, #260]	; (415e8 <z_impl_log_process+0x108>)
{
   414e2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   414e6:	781b      	ldrb	r3, [r3, #0]
{
   414e8:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   414ea:	b903      	cbnz	r3, 414ee <z_impl_log_process+0xe>
   414ec:	b1a0      	cbz	r0, 41518 <z_impl_log_process+0x38>
	msg = get_msg();
   414ee:	f7ff ff57 	bl	413a0 <get_msg>
	if (msg.msg) {
   414f2:	4605      	mov	r5, r0
   414f4:	b118      	cbz	r0, 414fe <z_impl_log_process+0x1e>
		if (!bypass) {
   414f6:	b19c      	cbz	r4, 41520 <z_impl_log_process+0x40>
			log_msg_put(msg.msg);
   414f8:	4628      	mov	r0, r5
   414fa:	f006 fcac 	bl	47e56 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
   414fe:	b92c      	cbnz	r4, 4150c <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
   41500:	4b3a      	ldr	r3, [pc, #232]	; (415ec <z_impl_log_process+0x10c>)
	if (!bypass && z_log_dropped_pending()) {
   41502:	681b      	ldr	r3, [r3, #0]
   41504:	2b00      	cmp	r3, #0
   41506:	dd01      	ble.n	4150c <z_impl_log_process+0x2c>
		dropped_notify();
   41508:	f7ff ff8e 	bl	41428 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   4150c:	4838      	ldr	r0, [pc, #224]	; (415f0 <z_impl_log_process+0x110>)
   4150e:	f006 fb94 	bl	47c3a <log_list_head_peek>
   41512:	1e04      	subs	r4, r0, #0
   41514:	bf18      	it	ne
   41516:	2401      	movne	r4, #1
}
   41518:	4620      	mov	r0, r4
   4151a:	b003      	add	sp, #12
   4151c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41520:	4b34      	ldr	r3, [pc, #208]	; (415f4 <z_impl_log_process+0x114>)
   41522:	e8d3 2fef 	ldaex	r2, [r3]
   41526:	3a01      	subs	r2, #1
   41528:	e8c3 2fe1 	stlex	r1, r2, [r3]
   4152c:	2900      	cmp	r1, #0
   4152e:	d1f8      	bne.n	41522 <z_impl_log_process+0x42>
		    !panic_mode) {
   41530:	4b31      	ldr	r3, [pc, #196]	; (415f8 <z_impl_log_process+0x118>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
   41532:	781b      	ldrb	r3, [r3, #0]
   41534:	b9bb      	cbnz	r3, 41566 <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41536:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   41538:	07db      	lsls	r3, r3, #31
   4153a:	d414      	bmi.n	41566 <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
   4153c:	f006 fc9a 	bl	47e74 <log_msg_str_get>
   41540:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
   41542:	4628      	mov	r0, r5
   41544:	f006 fc65 	bl	47e12 <log_msg_nargs_get>
   41548:	4601      	mov	r1, r0
   4154a:	4640      	mov	r0, r8
   4154c:	f006 fb8a 	bl	47c64 <z_log_get_s_mask>
   41550:	4606      	mov	r6, r0
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
   41552:	4b2a      	ldr	r3, [pc, #168]	; (415fc <z_impl_log_process+0x11c>)
   41554:	4a2a      	ldr	r2, [pc, #168]	; (41600 <z_impl_log_process+0x120>)
		if (!is_rodata(str) && !log_is_strdup(str) &&
   41556:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 41614 <z_impl_log_process+0x134>
   4155a:	1a9b      	subs	r3, r3, r2
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   4155c:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 41618 <z_impl_log_process+0x138>
   41560:	ea4f 09d3 	mov.w	r9, r3, lsr #3
	while (mask) {
   41564:	b936      	cbnz	r6, 41574 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
   41566:	4e27      	ldr	r6, [pc, #156]	; (41604 <z_impl_log_process+0x124>)
   41568:	4f27      	ldr	r7, [pc, #156]	; (41608 <z_impl_log_process+0x128>)
   4156a:	f04f 0800 	mov.w	r8, #0
   4156e:	1bbf      	subs	r7, r7, r6
   41570:	113f      	asrs	r7, r7, #4
   41572:	e036      	b.n	415e2 <z_impl_log_process+0x102>
		idx = 31 - __builtin_clz(mask);
   41574:	fab6 f786 	clz	r7, r6
   41578:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   4157c:	4639      	mov	r1, r7
   4157e:	4628      	mov	r0, r5
   41580:	f006 fc4a 	bl	47e18 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   41584:	4b21      	ldr	r3, [pc, #132]	; (4160c <z_impl_log_process+0x12c>)
		str = (const char *)log_msg_arg_get(msg, idx);
   41586:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   41588:	4298      	cmp	r0, r3
   4158a:	d302      	bcc.n	41592 <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   4158c:	4b20      	ldr	r3, [pc, #128]	; (41610 <z_impl_log_process+0x130>)
   4158e:	4298      	cmp	r0, r3
   41590:	d316      	bcc.n	415c0 <z_impl_log_process+0xe0>
   41592:	4610      	mov	r0, r2
   41594:	f7ff ff96 	bl	414c4 <log_is_strdup>
   41598:	b990      	cbnz	r0, 415c0 <z_impl_log_process+0xe0>
   4159a:	4552      	cmp	r2, sl
   4159c:	d010      	beq.n	415c0 <z_impl_log_process+0xe0>
	return msg->hdr.ids.source_id;
   4159e:	8969      	ldrh	r1, [r5, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   415a0:	f3c1 1189 	ubfx	r1, r1, #6, #10
   415a4:	f000 f8f4 	bl	41790 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   415a8:	ea4f 1389 	mov.w	r3, r9, lsl #6
   415ac:	f043 0301 	orr.w	r3, r3, #1
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   415b0:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   415b2:	f8ad 3000 	strh.w	r3, [sp]
   415b6:	4639      	mov	r1, r7
   415b8:	4643      	mov	r3, r8
   415ba:	4658      	mov	r0, fp
   415bc:	f006 fbac 	bl	47d18 <log_3>
		mask &= ~BIT(idx);
   415c0:	2301      	movs	r3, #1
   415c2:	fa03 f707 	lsl.w	r7, r3, r7
   415c6:	ea26 0607 	bic.w	r6, r6, r7
   415ca:	e7cb      	b.n	41564 <z_impl_log_process+0x84>
	return backend->cb->active;
   415cc:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
   415ce:	795b      	ldrb	r3, [r3, #5]
   415d0:	b123      	cbz	r3, 415dc <z_impl_log_process+0xfc>
	backend->api->put(backend, msg);
   415d2:	6833      	ldr	r3, [r6, #0]
   415d4:	4629      	mov	r1, r5
   415d6:	4630      	mov	r0, r6
   415d8:	685b      	ldr	r3, [r3, #4]
   415da:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   415dc:	f108 0801 	add.w	r8, r8, #1
   415e0:	3610      	adds	r6, #16
   415e2:	45b8      	cmp	r8, r7
   415e4:	dbf2      	blt.n	415cc <z_impl_log_process+0xec>
   415e6:	e787      	b.n	414f8 <z_impl_log_process+0x18>
   415e8:	2001ade6 	.word	0x2001ade6
   415ec:	2001a890 	.word	0x2001a890
   415f0:	2001a898 	.word	0x2001a898
   415f4:	2001a88c 	.word	0x2001a88c
   415f8:	2001ade7 	.word	0x2001ade7
   415fc:	00049048 	.word	0x00049048
   41600:	00049038 	.word	0x00049038
   41604:	00049088 	.word	0x00049088
   41608:	000490a8 	.word	0x000490a8
   4160c:	00048d60 	.word	0x00048d60
   41610:	00049b6c 	.word	0x00049b6c
   41614:	00049381 	.word	0x00049381
   41618:	0004939b 	.word	0x0004939b

0004161c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   4161c:	4b26      	ldr	r3, [pc, #152]	; (416b8 <msg_finalize+0x9c>)
{
   4161e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
   41620:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   41622:	8141      	strh	r1, [r0, #10]
{
   41624:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
   41626:	4798      	blx	r3
   41628:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4162a:	f04f 0320 	mov.w	r3, #32
   4162e:	f3ef 8511 	mrs	r5, BASEPRI
   41632:	f383 8812 	msr	BASEPRI_MAX, r3
   41636:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   4163a:	4820      	ldr	r0, [pc, #128]	; (416bc <msg_finalize+0xa0>)
   4163c:	4621      	mov	r1, r4
   4163e:	f006 faf2 	bl	47c26 <log_list_add_tail>
	__asm__ volatile(
   41642:	f385 8811 	msr	BASEPRI, r5
   41646:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4164a:	4b1d      	ldr	r3, [pc, #116]	; (416c0 <msg_finalize+0xa4>)
   4164c:	e8d3 2fef 	ldaex	r2, [r3]
   41650:	1c51      	adds	r1, r2, #1
   41652:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41656:	2800      	cmp	r0, #0
   41658:	d1f8      	bne.n	4164c <msg_finalize+0x30>
	if (panic_mode) {
   4165a:	4b1a      	ldr	r3, [pc, #104]	; (416c4 <msg_finalize+0xa8>)
   4165c:	781b      	ldrb	r3, [r3, #0]
   4165e:	b183      	cbz	r3, 41682 <msg_finalize+0x66>
	__asm__ volatile(
   41660:	f04f 0320 	mov.w	r3, #32
   41664:	f3ef 8411 	mrs	r4, BASEPRI
   41668:	f383 8812 	msr	BASEPRI_MAX, r3
   4166c:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   41670:	2000      	movs	r0, #0
   41672:	f7ff ff35 	bl	414e0 <z_impl_log_process>
	__asm__ volatile(
   41676:	f384 8811 	msr	BASEPRI, r4
   4167a:	f3bf 8f6f 	isb	sy
}
   4167e:	b003      	add	sp, #12
   41680:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && cnt == 0) {
   41682:	4b11      	ldr	r3, [pc, #68]	; (416c8 <msg_finalize+0xac>)
   41684:	681b      	ldr	r3, [r3, #0]
   41686:	2b00      	cmp	r3, #0
   41688:	d0f9      	beq.n	4167e <msg_finalize+0x62>
   4168a:	b952      	cbnz	r2, 416a2 <msg_finalize+0x86>
	z_impl_k_timer_start(timer, duration, period);
   4168c:	2200      	movs	r2, #0
   4168e:	2300      	movs	r3, #0
   41690:	480e      	ldr	r0, [pc, #56]	; (416cc <msg_finalize+0xb0>)
   41692:	e9cd 2300 	strd	r2, r3, [sp]
   41696:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   4169a:	2300      	movs	r3, #0
   4169c:	f005 fde0 	bl	47260 <z_impl_k_timer_start>
   416a0:	e7ed      	b.n	4167e <msg_finalize+0x62>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   416a2:	2a0a      	cmp	r2, #10
   416a4:	d1eb      	bne.n	4167e <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
   416a6:	4809      	ldr	r0, [pc, #36]	; (416cc <msg_finalize+0xb0>)
   416a8:	f007 fb1e 	bl	48ce8 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   416ac:	4808      	ldr	r0, [pc, #32]	; (416d0 <msg_finalize+0xb4>)
}
   416ae:	b003      	add	sp, #12
   416b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   416b4:	f005 b888 	b.w	467c8 <z_impl_k_sem_give>
   416b8:	2001a570 	.word	0x2001a570
   416bc:	2001a898 	.word	0x2001a898
   416c0:	2001a88c 	.word	0x2001a88c
   416c4:	2001ade7 	.word	0x2001ade7
   416c8:	2001a8bc 	.word	0x2001a8bc
   416cc:	2001a690 	.word	0x2001a690
   416d0:	2001a67c 	.word	0x2001a67c

000416d4 <log_process_thread_func>:
{
   416d4:	b510      	push	{r4, lr}
	log_init();
   416d6:	f7ff fe3b 	bl	41350 <log_init>
	return z_impl_z_current_get();
   416da:	f005 fbaf 	bl	46e3c <z_impl_z_current_get>
	proc_tid = process_tid;
   416de:	4b0c      	ldr	r3, [pc, #48]	; (41710 <log_process_thread_func+0x3c>)
   416e0:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   416e2:	b130      	cbz	r0, 416f2 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   416e4:	4b0b      	ldr	r3, [pc, #44]	; (41714 <log_process_thread_func+0x40>)
	    process_tid &&
   416e6:	681b      	ldr	r3, [r3, #0]
   416e8:	2b09      	cmp	r3, #9
   416ea:	dd02      	ble.n	416f2 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   416ec:	480a      	ldr	r0, [pc, #40]	; (41718 <log_process_thread_func+0x44>)
   416ee:	f005 f86b 	bl	467c8 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   416f2:	4c09      	ldr	r4, [pc, #36]	; (41718 <log_process_thread_func+0x44>)
   416f4:	2000      	movs	r0, #0
   416f6:	f7ff fef3 	bl	414e0 <z_impl_log_process>
		if (log_process(false) == false) {
   416fa:	2800      	cmp	r0, #0
   416fc:	d1fa      	bne.n	416f4 <log_process_thread_func+0x20>
   416fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   41702:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41706:	4620      	mov	r0, r4
   41708:	f005 f87e 	bl	46808 <z_impl_k_sem_take>
   4170c:	e7f2      	b.n	416f4 <log_process_thread_func+0x20>
   4170e:	bf00      	nop
   41710:	2001a8bc 	.word	0x2001a8bc
   41714:	2001a88c 	.word	0x2001a88c
   41718:	2001a67c 	.word	0x2001a67c

0004171c <z_impl_log_panic>:
{
   4171c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   4171e:	4f0e      	ldr	r7, [pc, #56]	; (41758 <z_impl_log_panic+0x3c>)
   41720:	783d      	ldrb	r5, [r7, #0]
   41722:	b975      	cbnz	r5, 41742 <z_impl_log_panic+0x26>
	log_init();
   41724:	f7ff fe14 	bl	41350 <log_init>
	return __log_backends_end - __log_backends_start;
   41728:	4c0c      	ldr	r4, [pc, #48]	; (4175c <z_impl_log_panic+0x40>)
   4172a:	4e0d      	ldr	r6, [pc, #52]	; (41760 <z_impl_log_panic+0x44>)
   4172c:	1b36      	subs	r6, r6, r4
   4172e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   41730:	42b5      	cmp	r5, r6
   41732:	db07      	blt.n	41744 <z_impl_log_panic+0x28>
   41734:	2000      	movs	r0, #0
   41736:	f7ff fed3 	bl	414e0 <z_impl_log_process>
		while (log_process(false) == true) {
   4173a:	2800      	cmp	r0, #0
   4173c:	d1fa      	bne.n	41734 <z_impl_log_panic+0x18>
	panic_mode = true;
   4173e:	2301      	movs	r3, #1
   41740:	703b      	strb	r3, [r7, #0]
}
   41742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   41744:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41746:	795b      	ldrb	r3, [r3, #5]
   41748:	b11b      	cbz	r3, 41752 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   4174a:	6823      	ldr	r3, [r4, #0]
   4174c:	4620      	mov	r0, r4
   4174e:	695b      	ldr	r3, [r3, #20]
   41750:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41752:	3501      	adds	r5, #1
   41754:	3410      	adds	r4, #16
   41756:	e7eb      	b.n	41730 <z_impl_log_panic+0x14>
   41758:	2001ade7 	.word	0x2001ade7
   4175c:	00049088 	.word	0x00049088
   41760:	000490a8 	.word	0x000490a8

00041764 <z_log_free>:
{
   41764:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   41766:	3804      	subs	r0, #4
   41768:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4176a:	e8d0 3fef 	ldaex	r3, [r0]
   4176e:	1e5a      	subs	r2, r3, #1
   41770:	e8c0 2fe1 	stlex	r1, r2, [r0]
   41774:	2900      	cmp	r1, #0
   41776:	d1f8      	bne.n	4176a <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
   41778:	2b01      	cmp	r3, #1
   4177a:	d103      	bne.n	41784 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   4177c:	4803      	ldr	r0, [pc, #12]	; (4178c <z_log_free+0x28>)
   4177e:	a901      	add	r1, sp, #4
   41780:	f007 f8f3 	bl	4896a <k_mem_slab_free>
}
   41784:	b003      	add	sp, #12
   41786:	f85d fb04 	ldr.w	pc, [sp], #4
   4178a:	bf00      	nop
   4178c:	2001a8a0 	.word	0x2001a8a0

00041790 <log_source_name_get>:
   41790:	4a04      	ldr	r2, [pc, #16]	; (417a4 <log_source_name_get+0x14>)
   41792:	4b05      	ldr	r3, [pc, #20]	; (417a8 <log_source_name_get+0x18>)
   41794:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   41796:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   4179a:	bf34      	ite	cc
   4179c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   417a0:	2000      	movcs	r0, #0
}
   417a2:	4770      	bx	lr
   417a4:	00049038 	.word	0x00049038
   417a8:	00049088 	.word	0x00049088

000417ac <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   417ac:	4b05      	ldr	r3, [pc, #20]	; (417c4 <log_backend_enable+0x18>)

	log_backend_id_set(backend, id);
   417ae:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
   417b0:	1ac3      	subs	r3, r0, r3
   417b2:	111b      	asrs	r3, r3, #4
   417b4:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   417b6:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
   417b8:	2201      	movs	r2, #1
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);
   417ba:	6843      	ldr	r3, [r0, #4]
	backend->cb->ctx = ctx;
   417bc:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
   417be:	715a      	strb	r2, [r3, #5]

	z_log_notify_backend_enabled();
   417c0:	f7ff be02 	b.w	413c8 <z_log_notify_backend_enabled>
   417c4:	00049088 	.word	0x00049088

000417c8 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   417c8:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   417cc:	2220      	movs	r2, #32
   417ce:	4902      	ldr	r1, [pc, #8]	; (417d8 <log_msg_pool_init+0x10>)
   417d0:	4802      	ldr	r0, [pc, #8]	; (417dc <log_msg_pool_init+0x14>)
   417d2:	f007 b8af 	b.w	48934 <k_mem_slab_init>
   417d6:	bf00      	nop
   417d8:	20025c20 	.word	0x20025c20
   417dc:	2001a8c0 	.word	0x2001a8c0

000417e0 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
   417e0:	2300      	movs	r3, #0
{
   417e2:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   417e4:	4d09      	ldr	r5, [pc, #36]	; (4180c <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   417e6:	9301      	str	r3, [sp, #4]
   417e8:	2001      	movs	r0, #1
   417ea:	f7ff fe79 	bl	414e0 <z_impl_log_process>
   417ee:	4604      	mov	r4, r0
			z_log_dropped();
   417f0:	f7ff fdf8 	bl	413e4 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   417f4:	2200      	movs	r2, #0
   417f6:	2300      	movs	r3, #0
   417f8:	4628      	mov	r0, r5
   417fa:	a901      	add	r1, sp, #4
   417fc:	f004 fe36 	bl	4646c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   41800:	b108      	cbz	r0, 41806 <log_msg_no_space_handle+0x26>
   41802:	2c00      	cmp	r4, #0
   41804:	d1f0      	bne.n	417e8 <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
   41806:	9801      	ldr	r0, [sp, #4]
   41808:	b003      	add	sp, #12
   4180a:	bd30      	pop	{r4, r5, pc}
   4180c:	2001a8c0 	.word	0x2001a8c0

00041810 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
   41810:	2300      	movs	r3, #0
{
   41812:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41814:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
   41816:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41818:	4806      	ldr	r0, [pc, #24]	; (41834 <log_msg_chunk_alloc+0x24>)
   4181a:	2300      	movs	r3, #0
   4181c:	a901      	add	r1, sp, #4
   4181e:	f004 fe25 	bl	4646c <k_mem_slab_alloc>
	if (err != 0) {
   41822:	b110      	cbz	r0, 4182a <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
   41824:	f7ff ffdc 	bl	417e0 <log_msg_no_space_handle>
   41828:	9001      	str	r0, [sp, #4]
}
   4182a:	9801      	ldr	r0, [sp, #4]
   4182c:	b003      	add	sp, #12
   4182e:	f85d fb04 	ldr.w	pc, [sp], #4
   41832:	bf00      	nop
   41834:	2001a8c0 	.word	0x2001a8c0

00041838 <msg_free>:
{
   41838:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4183a:	7a03      	ldrb	r3, [r0, #8]
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
   4183c:	7a45      	ldrb	r5, [r0, #9]
{
   4183e:	b085      	sub	sp, #20
   41840:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   41842:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
   41844:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   41848:	d41c      	bmi.n	41884 <msg_free+0x4c>
   4184a:	b1dd      	cbz	r5, 41884 <msg_free+0x4c>
		uint32_t smask = 0U;
   4184c:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
   4184e:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
   41850:	4631      	mov	r1, r6
   41852:	9801      	ldr	r0, [sp, #4]
   41854:	f006 fae0 	bl	47e18 <log_msg_arg_get>
   41858:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
   4185a:	f7ff fe33 	bl	414c4 <log_is_strdup>
   4185e:	b170      	cbz	r0, 4187e <msg_free+0x46>
				if (smask == 0U) {
   41860:	b934      	cbnz	r4, 41870 <msg_free+0x38>
					smask = z_log_get_s_mask(
   41862:	9b01      	ldr	r3, [sp, #4]
   41864:	4629      	mov	r1, r5
   41866:	6918      	ldr	r0, [r3, #16]
   41868:	f006 f9fc 	bl	47c64 <z_log_get_s_mask>
					if (smask == 0U) {
   4186c:	4604      	mov	r4, r0
   4186e:	b148      	cbz	r0, 41884 <msg_free+0x4c>
				if (smask & BIT(i)) {
   41870:	fa24 f306 	lsr.w	r3, r4, r6
   41874:	07d9      	lsls	r1, r3, #31
   41876:	d502      	bpl.n	4187e <msg_free+0x46>
					z_log_free(buf);
   41878:	4638      	mov	r0, r7
   4187a:	f7ff ff73 	bl	41764 <z_log_free>
		for (i = 0U; i < nargs; i++) {
   4187e:	3601      	adds	r6, #1
   41880:	42ae      	cmp	r6, r5
   41882:	d3e5      	bcc.n	41850 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
   41884:	9b01      	ldr	r3, [sp, #4]
   41886:	7a1a      	ldrb	r2, [r3, #8]
   41888:	0792      	lsls	r2, r2, #30
   4188a:	d504      	bpl.n	41896 <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
   4188c:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   4188e:	4c08      	ldr	r4, [pc, #32]	; (418b0 <msg_free+0x78>)
   41890:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   41892:	9b03      	ldr	r3, [sp, #12]
   41894:	b92b      	cbnz	r3, 418a2 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   41896:	4806      	ldr	r0, [pc, #24]	; (418b0 <msg_free+0x78>)
   41898:	a901      	add	r1, sp, #4
   4189a:	f007 f866 	bl	4896a <k_mem_slab_free>
}
   4189e:	b005      	add	sp, #20
   418a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
   418a2:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   418a4:	4620      	mov	r0, r4
   418a6:	a903      	add	r1, sp, #12
   418a8:	f007 f85f 	bl	4896a <k_mem_slab_free>
		cont = next;
   418ac:	9503      	str	r5, [sp, #12]
   418ae:	e7f0      	b.n	41892 <msg_free+0x5a>
   418b0:	2001a8c0 	.word	0x2001a8c0

000418b4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
   418b4:	b40e      	push	{r1, r2, r3}
   418b6:	b503      	push	{r0, r1, lr}
   418b8:	ab03      	add	r3, sp, #12
   418ba:	f853 2b04 	ldr.w	r2, [r3], #4
   418be:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
   418c0:	4804      	ldr	r0, [pc, #16]	; (418d4 <print_formatted+0x20>)
	va_start(args, fmt);
   418c2:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
   418c4:	f7ff f90a 	bl	40adc <cbvprintf>
	va_end(args);

	return length;
}
   418c8:	b002      	add	sp, #8
   418ca:	f85d eb04 	ldr.w	lr, [sp], #4
   418ce:	b003      	add	sp, #12
   418d0:	4770      	bx	lr
   418d2:	bf00      	nop
   418d4:	00048175 	.word	0x00048175

000418d8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
   418d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   418dc:	461f      	mov	r7, r3
   418de:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   418e0:	f001 0301 	and.w	r3, r1, #1
{
   418e4:	9205      	str	r2, [sp, #20]
   418e6:	4606      	mov	r6, r0
   418e8:	4688      	mov	r8, r1
   418ea:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
   418ee:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   418f2:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   418f6:	9304      	str	r3, [sp, #16]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   418f8:	f001 0508 	and.w	r5, r1, #8
	const char *tag = z_log_get_tag();
   418fc:	f006 fa28 	bl	47d50 <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
   41900:	4602      	mov	r2, r0
   41902:	2800      	cmp	r0, #0
   41904:	d044      	beq.n	41990 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
   41906:	4630      	mov	r0, r6
   41908:	4938      	ldr	r1, [pc, #224]	; (419ec <prefix_print+0x114>)
   4190a:	f7ff ffd3 	bl	418b4 <print_formatted>
   4190e:	4604      	mov	r4, r0
	}

	if (stamp) {
   41910:	f1bb 0f00 	cmp.w	fp, #0
   41914:	d008      	beq.n	41928 <prefix_print+0x50>
	if (!format) {
   41916:	f018 0f44 	tst.w	r8, #68	; 0x44
   4191a:	d13b      	bne.n	41994 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
   4191c:	463a      	mov	r2, r7
   4191e:	4630      	mov	r0, r6
   41920:	4933      	ldr	r1, [pc, #204]	; (419f0 <prefix_print+0x118>)
   41922:	f7ff ffc7 	bl	418b4 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
   41926:	4404      	add	r4, r0
	if (color) {
   41928:	9b04      	ldr	r3, [sp, #16]
   4192a:	b153      	cbz	r3, 41942 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
   4192c:	4b31      	ldr	r3, [pc, #196]	; (419f4 <prefix_print+0x11c>)
		print_formatted(output, "%s", log_color);
   4192e:	4630      	mov	r0, r6
		const char *log_color = start && (colors[level] != NULL) ?
   41930:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
   41934:	4b30      	ldr	r3, [pc, #192]	; (419f8 <prefix_print+0x120>)
   41936:	4931      	ldr	r1, [pc, #196]	; (419fc <prefix_print+0x124>)
   41938:	2a00      	cmp	r2, #0
   4193a:	bf08      	it	eq
   4193c:	461a      	moveq	r2, r3
   4193e:	f7ff ffb9 	bl	418b4 <print_formatted>
	if (level_on) {
   41942:	b13d      	cbz	r5, 41954 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
   41944:	4b2e      	ldr	r3, [pc, #184]	; (41a00 <prefix_print+0x128>)
   41946:	4630      	mov	r0, r6
   41948:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   4194c:	492d      	ldr	r1, [pc, #180]	; (41a04 <prefix_print+0x12c>)
   4194e:	f7ff ffb1 	bl	418b4 <print_formatted>
   41952:	4605      	mov	r5, r0
	if (source_id >= 0) {
   41954:	f1ba 0f00 	cmp.w	sl, #0
   41958:	db16      	blt.n	41988 <prefix_print+0xb0>
		total += print_formatted(output,
   4195a:	9b05      	ldr	r3, [sp, #20]
   4195c:	2b00      	cmp	r3, #0
   4195e:	d043      	beq.n	419e8 <prefix_print+0x110>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   41960:	2301      	movs	r3, #1
   41962:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
   41966:	4b28      	ldr	r3, [pc, #160]	; (41a08 <prefix_print+0x130>)
   41968:	f019 0f10 	tst.w	r9, #16
   4196c:	4f27      	ldr	r7, [pc, #156]	; (41a0c <prefix_print+0x134>)
   4196e:	bf18      	it	ne
   41970:	461f      	movne	r7, r3
   41972:	4651      	mov	r1, sl
   41974:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
   41978:	f7ff ff0a 	bl	41790 <log_source_name_get>
   4197c:	4639      	mov	r1, r7
   4197e:	4602      	mov	r2, r0
   41980:	4630      	mov	r0, r6
   41982:	f7ff ff97 	bl	418b4 <print_formatted>
   41986:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
   41988:	1928      	adds	r0, r5, r4
   4198a:	b007      	add	sp, #28
   4198c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
   41990:	4604      	mov	r4, r0
   41992:	e7bd      	b.n	41910 <prefix_print+0x38>
	} else if (freq != 0U) {
   41994:	4b1e      	ldr	r3, [pc, #120]	; (41a10 <prefix_print+0x138>)
   41996:	6818      	ldr	r0, [r3, #0]
   41998:	2800      	cmp	r0, #0
   4199a:	d0c4      	beq.n	41926 <prefix_print+0x4e>
		timestamp /= timestamp_div;
   4199c:	4b1d      	ldr	r3, [pc, #116]	; (41a14 <prefix_print+0x13c>)
   4199e:	f44f 6c61 	mov.w	ip, #3600	; 0xe10
   419a2:	6819      	ldr	r1, [r3, #0]
		mins = seconds / 60U;
   419a4:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
		timestamp /= timestamp_div;
   419a8:	fbb7 f7f1 	udiv	r7, r7, r1
		total_seconds = timestamp / freq;
   419ac:	fbb7 f1f0 	udiv	r1, r7, r0
		seconds -= hours * 3600U;
   419b0:	fbb1 f2fc 	udiv	r2, r1, ip
		remainder = timestamp % freq;
   419b4:	fb00 7711 	mls	r7, r0, r1, r7
   419b8:	fb0c 1c12 	mls	ip, ip, r2, r1
		ms = (remainder * 1000U) / freq;
   419bc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   419c0:	434f      	muls	r7, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   419c2:	fbb7 f8f0 	udiv	r8, r7, r0
   419c6:	fb00 7718 	mls	r7, r0, r8, r7
		mins = seconds / 60U;
   419ca:	fbbc f3fe 	udiv	r3, ip, lr
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   419ce:	434f      	muls	r7, r1
   419d0:	fbb7 f0f0 	udiv	r0, r7, r0
			length = print_formatted(output,
   419d4:	fb0e c113 	mls	r1, lr, r3, ip
   419d8:	e9cd 8001 	strd	r8, r0, [sp, #4]
   419dc:	9100      	str	r1, [sp, #0]
   419de:	4630      	mov	r0, r6
   419e0:	490d      	ldr	r1, [pc, #52]	; (41a18 <prefix_print+0x140>)
   419e2:	f7ff ff67 	bl	418b4 <print_formatted>
   419e6:	e79e      	b.n	41926 <prefix_print+0x4e>
		total += print_formatted(output,
   419e8:	4f08      	ldr	r7, [pc, #32]	; (41a0c <prefix_print+0x134>)
   419ea:	e7c2      	b.n	41972 <prefix_print+0x9a>
   419ec:	000493ed 	.word	0x000493ed
   419f0:	000493f1 	.word	0x000493f1
   419f4:	000490ec 	.word	0x000490ec
   419f8:	000493df 	.word	0x000493df
   419fc:	00049416 	.word	0x00049416
   41a00:	00049100 	.word	0x00049100
   41a04:	00049419 	.word	0x00049419
   41a08:	000493e9 	.word	0x000493e9
   41a0c:	000493e4 	.word	0x000493e4
   41a10:	2001a8dc 	.word	0x2001a8dc
   41a14:	2001a8e0 	.word	0x2001a8e0
   41a18:	000493fa 	.word	0x000493fa

00041a1c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
   41a1c:	b538      	push	{r3, r4, r5, lr}
   41a1e:	460c      	mov	r4, r1
	if (color) {
   41a20:	07e1      	lsls	r1, r4, #31
{
   41a22:	4605      	mov	r5, r0
	if (color) {
   41a24:	d503      	bpl.n	41a2e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
   41a26:	4a08      	ldr	r2, [pc, #32]	; (41a48 <postfix_print+0x2c>)
   41a28:	4908      	ldr	r1, [pc, #32]	; (41a4c <postfix_print+0x30>)
   41a2a:	f7ff ff43 	bl	418b4 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41a2e:	06e2      	lsls	r2, r4, #27
   41a30:	d408      	bmi.n	41a44 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41a32:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   41a34:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
   41a36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   41a3a:	bf4c      	ite	mi
   41a3c:	4904      	ldrmi	r1, [pc, #16]	; (41a50 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   41a3e:	4905      	ldrpl	r1, [pc, #20]	; (41a54 <postfix_print+0x38>)
   41a40:	f7ff bf38 	b.w	418b4 <print_formatted>
}
   41a44:	bd38      	pop	{r3, r4, r5, pc}
   41a46:	bf00      	nop
   41a48:	000493df 	.word	0x000493df
   41a4c:	00049416 	.word	0x00049416
   41a50:	00049305 	.word	0x00049305
   41a54:	00049304 	.word	0x00049304

00041a58 <hexdump_line_print>:
{
   41a58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   41a5c:	461d      	mov	r5, r3
   41a5e:	9b08      	ldr	r3, [sp, #32]
   41a60:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41a62:	06da      	lsls	r2, r3, #27
{
   41a64:	4604      	mov	r4, r0
   41a66:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41a68:	d405      	bmi.n	41a76 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41a6a:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   41a6c:	bf4c      	ite	mi
   41a6e:	492a      	ldrmi	r1, [pc, #168]	; (41b18 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   41a70:	492a      	ldrpl	r1, [pc, #168]	; (41b1c <hexdump_line_print+0xc4>)
   41a72:	f7ff ff1f 	bl	418b4 <print_formatted>
{
   41a76:	f04f 0800 	mov.w	r8, #0
		print_formatted(output, " ");
   41a7a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 41b24 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   41a7e:	45a8      	cmp	r8, r5
   41a80:	db2a      	blt.n	41ad8 <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41a82:	2500      	movs	r5, #0
			print_formatted(output, "   ");
   41a84:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 41b28 <hexdump_line_print+0xd0>
			print_formatted(output, "%02x ", data[i]);
   41a88:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 41b2c <hexdump_line_print+0xd4>
			print_formatted(output, " ");
   41a8c:	f8df a094 	ldr.w	sl, [pc, #148]	; 41b24 <hexdump_line_print+0xcc>
		if (i < length) {
   41a90:	42bd      	cmp	r5, r7
   41a92:	d22f      	bcs.n	41af4 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
   41a94:	4649      	mov	r1, r9
   41a96:	4620      	mov	r0, r4
   41a98:	5d72      	ldrb	r2, [r6, r5]
   41a9a:	f7ff ff0b 	bl	418b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41a9e:	3501      	adds	r5, #1
   41aa0:	2d10      	cmp	r5, #16
   41aa2:	d120      	bne.n	41ae6 <hexdump_line_print+0x8e>
	print_formatted(output, "|");
   41aa4:	4620      	mov	r0, r4
   41aa6:	491e      	ldr	r1, [pc, #120]	; (41b20 <hexdump_line_print+0xc8>)
   41aa8:	f7ff ff04 	bl	418b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41aac:	2500      	movs	r5, #0
			print_formatted(output, " ");
   41aae:	f8df 8074 	ldr.w	r8, [pc, #116]	; 41b24 <hexdump_line_print+0xcc>
			print_formatted(output, "%c",
   41ab2:	f8df 907c 	ldr.w	r9, [pc, #124]	; 41b30 <hexdump_line_print+0xd8>
		if (i < length) {
   41ab6:	42af      	cmp	r7, r5
   41ab8:	d928      	bls.n	41b0c <hexdump_line_print+0xb4>
			char c = (char)data[i];
   41aba:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
   41abc:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
   41abe:	f1a2 0320 	sub.w	r3, r2, #32
   41ac2:	2b5f      	cmp	r3, #95	; 0x5f
   41ac4:	bf28      	it	cs
   41ac6:	222e      	movcs	r2, #46	; 0x2e
   41ac8:	4620      	mov	r0, r4
   41aca:	f7ff fef3 	bl	418b4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41ace:	3501      	adds	r5, #1
   41ad0:	2d10      	cmp	r5, #16
   41ad2:	d114      	bne.n	41afe <hexdump_line_print+0xa6>
}
   41ad4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
   41ad8:	4649      	mov	r1, r9
   41ada:	4620      	mov	r0, r4
   41adc:	f7ff feea 	bl	418b4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   41ae0:	f108 0801 	add.w	r8, r8, #1
   41ae4:	e7cb      	b.n	41a7e <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
   41ae6:	076a      	lsls	r2, r5, #29
   41ae8:	d1d2      	bne.n	41a90 <hexdump_line_print+0x38>
			print_formatted(output, " ");
   41aea:	4651      	mov	r1, sl
   41aec:	4620      	mov	r0, r4
   41aee:	f7ff fee1 	bl	418b4 <print_formatted>
   41af2:	e7cd      	b.n	41a90 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
   41af4:	4641      	mov	r1, r8
   41af6:	4620      	mov	r0, r4
   41af8:	f7ff fedc 	bl	418b4 <print_formatted>
   41afc:	e7cf      	b.n	41a9e <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
   41afe:	076b      	lsls	r3, r5, #29
   41b00:	d1d9      	bne.n	41ab6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41b02:	4641      	mov	r1, r8
   41b04:	4620      	mov	r0, r4
   41b06:	f7ff fed5 	bl	418b4 <print_formatted>
   41b0a:	e7d4      	b.n	41ab6 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41b0c:	4641      	mov	r1, r8
   41b0e:	4620      	mov	r0, r4
   41b10:	f7ff fed0 	bl	418b4 <print_formatted>
   41b14:	e7db      	b.n	41ace <hexdump_line_print+0x76>
   41b16:	bf00      	nop
   41b18:	00049305 	.word	0x00049305
   41b1c:	00049304 	.word	0x00049304
   41b20:	00049429 	.word	0x00049429
   41b24:	00049427 	.word	0x00049427
   41b28:	00049425 	.word	0x00049425
   41b2c:	0004941f 	.word	0x0004941f
   41b30:	0004942b 	.word	0x0004942b

00041b34 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
   41b34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   41b38:	7a8b      	ldrb	r3, [r1, #10]
   41b3a:	4617      	mov	r7, r2
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
   41b3c:	f013 0807 	ands.w	r8, r3, #7
{
   41b40:	4605      	mov	r5, r0
   41b42:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41b44:	7a0a      	ldrb	r2, [r1, #8]
   41b46:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
   41b48:	d021      	beq.n	41b8e <log_output_msg_process+0x5a>
   41b4a:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
   41b4c:	8949      	ldrh	r1, [r1, #10]
   41b4e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   41b52:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41b56:	e9cd 8300 	strd	r8, r3, [sp]
   41b5a:	9102      	str	r1, [sp, #8]
   41b5c:	68f3      	ldr	r3, [r6, #12]
   41b5e:	4639      	mov	r1, r7
   41b60:	f002 0201 	and.w	r2, r2, #1
   41b64:	f7ff feb8 	bl	418d8 <prefix_print>
   41b68:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41b6a:	7a34      	ldrb	r4, [r6, #8]
   41b6c:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   41b6e:	f014 0401 	ands.w	r4, r4, #1
   41b72:	d00e      	beq.n	41b92 <log_output_msg_process+0x5e>
		std_print(msg, output);
   41b74:	4629      	mov	r1, r5
   41b76:	4630      	mov	r0, r6
   41b78:	f006 f992 	bl	47ea0 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
   41b7c:	f1b8 0f00 	cmp.w	r8, #0
   41b80:	d02b      	beq.n	41bda <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
   41b82:	4642      	mov	r2, r8
   41b84:	4639      	mov	r1, r7
   41b86:	4628      	mov	r0, r5
   41b88:	f7ff ff48 	bl	41a1c <postfix_print>
   41b8c:	e025      	b.n	41bda <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
   41b8e:	46c1      	mov	r9, r8
   41b90:	e7eb      	b.n	41b6a <log_output_msg_process+0x36>
	} else if (raw_string) {
   41b92:	f1b8 0f00 	cmp.w	r8, #0
   41b96:	d126      	bne.n	41be6 <log_output_msg_process+0xb2>
	size_t offset = 0;
   41b98:	4627      	mov	r7, r4
		length = output->size;
   41b9a:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41b9c:	aa06      	add	r2, sp, #24
		length = output->size;
   41b9e:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41ba0:	4630      	mov	r0, r6
   41ba2:	463b      	mov	r3, r7
   41ba4:	68a9      	ldr	r1, [r5, #8]
   41ba6:	f006 f967 	bl	47e78 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
   41baa:	9a06      	ldr	r2, [sp, #24]
   41bac:	686b      	ldr	r3, [r5, #4]
   41bae:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   41bb0:	b13a      	cbz	r2, 41bc2 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
   41bb2:	68ab      	ldr	r3, [r5, #8]
   41bb4:	4413      	add	r3, r2
   41bb6:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   41bba:	f1a4 030a 	sub.w	r3, r4, #10
   41bbe:	425c      	negs	r4, r3
   41bc0:	415c      	adcs	r4, r3
		log_output_flush(output);
   41bc2:	4628      	mov	r0, r5
   41bc4:	f006 fac9 	bl	4815a <log_output_flush>
		offset += length;
   41bc8:	9b06      	ldr	r3, [sp, #24]
   41bca:	441f      	add	r7, r3
	} while (length > 0);
   41bcc:	2b00      	cmp	r3, #0
   41bce:	d1e4      	bne.n	41b9a <log_output_msg_process+0x66>
	if (eol) {
   41bd0:	b11c      	cbz	r4, 41bda <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
   41bd2:	4628      	mov	r0, r5
   41bd4:	4913      	ldr	r1, [pc, #76]	; (41c24 <log_output_msg_process+0xf0>)
   41bd6:	f7ff fe6d 	bl	418b4 <print_formatted>
	}

	log_output_flush(output);
   41bda:	4628      	mov	r0, r5
   41bdc:	f006 fabd 	bl	4815a <log_output_flush>
}
   41be0:	b00a      	add	sp, #40	; 0x28
   41be2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(output, "%s", log_msg_str_get(msg));
   41be6:	4630      	mov	r0, r6
   41be8:	f006 f944 	bl	47e74 <log_msg_str_get>
   41bec:	490e      	ldr	r1, [pc, #56]	; (41c28 <log_output_msg_process+0xf4>)
   41bee:	4602      	mov	r2, r0
   41bf0:	4628      	mov	r0, r5
   41bf2:	f7ff fe5f 	bl	418b4 <print_formatted>
		length = sizeof(buf);
   41bf6:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41bfa:	aa05      	add	r2, sp, #20
   41bfc:	4623      	mov	r3, r4
   41bfe:	4630      	mov	r0, r6
   41c00:	a906      	add	r1, sp, #24
		length = sizeof(buf);
   41c02:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41c06:	f006 f937 	bl	47e78 <log_msg_hexdump_data_get>
		if (length) {
   41c0a:	9a05      	ldr	r2, [sp, #20]
   41c0c:	2a00      	cmp	r2, #0
   41c0e:	d0b8      	beq.n	41b82 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
   41c10:	464b      	mov	r3, r9
   41c12:	4628      	mov	r0, r5
   41c14:	9700      	str	r7, [sp, #0]
   41c16:	a906      	add	r1, sp, #24
   41c18:	f7ff ff1e 	bl	41a58 <hexdump_line_print>
			offset += length;
   41c1c:	9b05      	ldr	r3, [sp, #20]
   41c1e:	441c      	add	r4, r3
		length = sizeof(buf);
   41c20:	e7eb      	b.n	41bfa <log_output_msg_process+0xc6>
   41c22:	bf00      	nop
   41c24:	0004942e 	.word	0x0004942e
   41c28:	00049416 	.word	0x00049416

00041c2c <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41c2c:	f242 730f 	movw	r3, #9999	; 0x270f
{
   41c30:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41c32:	428b      	cmp	r3, r1
   41c34:	bf28      	it	cs
   41c36:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
   41c38:	6805      	ldr	r5, [r0, #0]
{
   41c3a:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41c3c:	2105      	movs	r1, #5
   41c3e:	4668      	mov	r0, sp
   41c40:	4a0d      	ldr	r2, [pc, #52]	; (41c78 <log_output_dropped_process+0x4c>)
   41c42:	f005 fce5 	bl	47610 <snprintk>
   41c46:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
   41c48:	6863      	ldr	r3, [r4, #4]
   41c4a:	4628      	mov	r0, r5
   41c4c:	220b      	movs	r2, #11
   41c4e:	685b      	ldr	r3, [r3, #4]
   41c50:	490a      	ldr	r1, [pc, #40]	; (41c7c <log_output_dropped_process+0x50>)
   41c52:	f006 f918 	bl	47e86 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
   41c56:	6863      	ldr	r3, [r4, #4]
   41c58:	4632      	mov	r2, r6
   41c5a:	4669      	mov	r1, sp
   41c5c:	4628      	mov	r0, r5
   41c5e:	685b      	ldr	r3, [r3, #4]
   41c60:	f006 f911 	bl	47e86 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
   41c64:	6863      	ldr	r3, [r4, #4]
   41c66:	221b      	movs	r2, #27
   41c68:	4628      	mov	r0, r5
   41c6a:	685b      	ldr	r3, [r3, #4]
   41c6c:	4904      	ldr	r1, [pc, #16]	; (41c80 <log_output_dropped_process+0x54>)
   41c6e:	f006 f90a 	bl	47e86 <buffer_write>
		     output->control_block->ctx);
}
   41c72:	b002      	add	sp, #8
   41c74:	bd70      	pop	{r4, r5, r6, pc}
   41c76:	bf00      	nop
   41c78:	00049aa5 	.word	0x00049aa5
   41c7c:	0004946c 	.word	0x0004946c
   41c80:	00049450 	.word	0x00049450

00041c84 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
   41c84:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   41c86:	2100      	movs	r1, #0
	timestamp_div = 1U;
   41c88:	4a07      	ldr	r2, [pc, #28]	; (41ca8 <log_output_timestamp_freq_set+0x24>)
{
   41c8a:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   41c8c:	4c07      	ldr	r4, [pc, #28]	; (41cac <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   41c8e:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   41c90:	42a0      	cmp	r0, r4
   41c92:	d804      	bhi.n	41c9e <log_output_timestamp_freq_set+0x1a>
   41c94:	b101      	cbz	r1, 41c98 <log_output_timestamp_freq_set+0x14>
   41c96:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   41c98:	4b05      	ldr	r3, [pc, #20]	; (41cb0 <log_output_timestamp_freq_set+0x2c>)
   41c9a:	6018      	str	r0, [r3, #0]
}
   41c9c:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
   41c9e:	2101      	movs	r1, #1
		frequency /= 2U;
   41ca0:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   41ca2:	005b      	lsls	r3, r3, #1
   41ca4:	e7f4      	b.n	41c90 <log_output_timestamp_freq_set+0xc>
   41ca6:	bf00      	nop
   41ca8:	2001a8e0 	.word	0x2001a8e0
   41cac:	000f4240 	.word	0x000f4240
   41cb0:	2001a8dc 	.word	0x2001a8dc

00041cb4 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
   41cb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   41cb6:	460d      	mov	r5, r1
   41cb8:	4604      	mov	r4, r0
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
   41cba:	4f06      	ldr	r7, [pc, #24]	; (41cd4 <char_out+0x20>)
   41cbc:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
   41cbe:	42b4      	cmp	r4, r6
   41cc0:	d101      	bne.n	41cc6 <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
   41cc2:	4628      	mov	r0, r5
   41cc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
   41cc6:	6838      	ldr	r0, [r7, #0]
   41cc8:	f814 1b01 	ldrb.w	r1, [r4], #1
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   41ccc:	6883      	ldr	r3, [r0, #8]
   41cce:	685b      	ldr	r3, [r3, #4]
   41cd0:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
   41cd2:	e7f4      	b.n	41cbe <char_out+0xa>
   41cd4:	2001a8f8 	.word	0x2001a8f8

00041cd8 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   41cd8:	4b01      	ldr	r3, [pc, #4]	; (41ce0 <log_backend_uart_init+0x8>)
   41cda:	4a02      	ldr	r2, [pc, #8]	; (41ce4 <log_backend_uart_init+0xc>)
   41cdc:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
   41cde:	4770      	bx	lr
   41ce0:	2001a8f8 	.word	0x2001a8f8
   41ce4:	00048e18 	.word	0x00048e18

00041ce8 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
   41ce8:	2201      	movs	r2, #1
   41cea:	4b02      	ldr	r3, [pc, #8]	; (41cf4 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
   41cec:	4802      	ldr	r0, [pc, #8]	; (41cf8 <panic+0x10>)
   41cee:	701a      	strb	r2, [r3, #0]
   41cf0:	f006 ba33 	b.w	4815a <log_output_flush>
   41cf4:	2001ade8 	.word	0x2001ade8
   41cf8:	00049130 	.word	0x00049130

00041cfc <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
   41cfc:	4801      	ldr	r0, [pc, #4]	; (41d04 <dropped+0x8>)
   41cfe:	f7ff bf95 	b.w	41c2c <log_output_dropped_process>
   41d02:	bf00      	nop
   41d04:	00049130 	.word	0x00049130

00041d08 <put>:
{
   41d08:	b510      	push	{r4, lr}
   41d0a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41d0c:	4608      	mov	r0, r1
   41d0e:	f006 f877 	bl	47e00 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41d12:	4621      	mov	r1, r4
   41d14:	4804      	ldr	r0, [pc, #16]	; (41d28 <put+0x20>)
   41d16:	220f      	movs	r2, #15
   41d18:	f7ff ff0c 	bl	41b34 <log_output_msg_process>
	log_msg_put(msg);
   41d1c:	4620      	mov	r0, r4
}
   41d1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41d22:	f006 b898 	b.w	47e56 <log_msg_put>
   41d26:	bf00      	nop
   41d28:	00049130 	.word	0x00049130

00041d2c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   41d2c:	2201      	movs	r2, #1
   41d2e:	4b01      	ldr	r3, [pc, #4]	; (41d34 <log_backend_rtt_init+0x8>)
   41d30:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   41d32:	4770      	bx	lr
   41d34:	2001adfa 	.word	0x2001adfa

00041d38 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
   41d38:	2201      	movs	r2, #1
   41d3a:	4b02      	ldr	r3, [pc, #8]	; (41d44 <panic+0xc>)
	log_output_flush(output);
   41d3c:	4802      	ldr	r0, [pc, #8]	; (41d48 <panic+0x10>)
   41d3e:	701a      	strb	r2, [r3, #0]
   41d40:	f006 ba0b 	b.w	4815a <log_output_flush>
   41d44:	2001adfb 	.word	0x2001adfb
   41d48:	0004915c 	.word	0x0004915c

00041d4c <dropped>:
	log_output_dropped_process(output, cnt);
   41d4c:	4801      	ldr	r0, [pc, #4]	; (41d54 <dropped+0x8>)
   41d4e:	f7ff bf6d 	b.w	41c2c <log_output_dropped_process>
   41d52:	bf00      	nop
   41d54:	0004915c 	.word	0x0004915c

00041d58 <put>:
{
   41d58:	b510      	push	{r4, lr}
   41d5a:	460c      	mov	r4, r1
	log_msg_get(msg);
   41d5c:	4608      	mov	r0, r1
   41d5e:	f006 f84f 	bl	47e00 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   41d62:	4621      	mov	r1, r4
   41d64:	4804      	ldr	r0, [pc, #16]	; (41d78 <put+0x20>)
   41d66:	220f      	movs	r2, #15
   41d68:	f7ff fee4 	bl	41b34 <log_output_msg_process>
	log_msg_put(msg);
   41d6c:	4620      	mov	r0, r4
}
   41d6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   41d72:	f006 b870 	b.w	47e56 <log_msg_put>
   41d76:	bf00      	nop
   41d78:	0004915c 	.word	0x0004915c

00041d7c <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41d7c:	4b05      	ldr	r3, [pc, #20]	; (41d94 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
   41d7e:	781b      	ldrb	r3, [r3, #0]
   41d80:	b11b      	cbz	r3, 41d8a <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
   41d82:	f241 3088 	movw	r0, #5000	; 0x1388
   41d86:	f006 bf76 	b.w	48c76 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
   41d8a:	2005      	movs	r0, #5
   41d8c:	2100      	movs	r1, #0
   41d8e:	f005 b841 	b.w	46e14 <z_impl_k_sleep>
   41d92:	bf00      	nop
   41d94:	2001adfb 	.word	0x2001adfb

00041d98 <data_out_block_mode>:
{
   41d98:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   41d9c:	f8df 9094 	ldr.w	r9, [pc, #148]	; 41e34 <data_out_block_mode+0x9c>
{
   41da0:	4680      	mov	r8, r0
   41da2:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
   41da4:	2404      	movs	r4, #4
   41da6:	46cb      	mov	fp, r9
	return z_impl_k_mutex_lock(mutex, timeout);
   41da8:	f8df a08c 	ldr.w	sl, [pc, #140]	; 41e38 <data_out_block_mode+0xa0>
		if (!is_sync_mode()) {
   41dac:	f899 5000 	ldrb.w	r5, [r9]
   41db0:	b9cd      	cbnz	r5, 41de6 <data_out_block_mode+0x4e>
   41db2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41db6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   41dba:	4650      	mov	r0, sl
   41dbc:	f004 fc40 	bl	46640 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41dc0:	463a      	mov	r2, r7
   41dc2:	4641      	mov	r1, r8
   41dc4:	4628      	mov	r0, r5
   41dc6:	f002 fd69 	bl	4489c <SEGGER_RTT_WriteSkipNoLock>
   41dca:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   41dcc:	4650      	mov	r0, sl
   41dce:	f004 fcb5 	bl	4673c <z_impl_k_mutex_unlock>
		if (ret) {
   41dd2:	4d17      	ldr	r5, [pc, #92]	; (41e30 <data_out_block_mode+0x98>)
   41dd4:	b1fe      	cbz	r6, 41e16 <data_out_block_mode+0x7e>
	host_present = true;
   41dd6:	2301      	movs	r3, #1
   41dd8:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
   41dda:	f89b 3000 	ldrb.w	r3, [fp]
   41dde:	b96b      	cbnz	r3, 41dfc <data_out_block_mode+0x64>
}
   41de0:	4638      	mov	r0, r7
   41de2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   41de6:	463a      	mov	r2, r7
   41de8:	4641      	mov	r1, r8
   41dea:	2000      	movs	r0, #0
   41dec:	f002 fd56 	bl	4489c <SEGGER_RTT_WriteSkipNoLock>
   41df0:	4606      	mov	r6, r0
   41df2:	e7ee      	b.n	41dd2 <data_out_block_mode+0x3a>
	if (retry_cnt == 0) {
   41df4:	b95c      	cbnz	r4, 41e0e <data_out_block_mode+0x76>
		host_present = false;
   41df6:	702c      	strb	r4, [r5, #0]
   41df8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   41dfc:	2000      	movs	r0, #0
   41dfe:	f002 fd99 	bl	44934 <SEGGER_RTT_HasDataUp>
   41e02:	2800      	cmp	r0, #0
   41e04:	d0ec      	beq.n	41de0 <data_out_block_mode+0x48>
   41e06:	782b      	ldrb	r3, [r5, #0]
   41e08:	2b00      	cmp	r3, #0
   41e0a:	d1f3      	bne.n	41df4 <data_out_block_mode+0x5c>
   41e0c:	e7e8      	b.n	41de0 <data_out_block_mode+0x48>
			on_failed_write(retry_cnt--);
   41e0e:	3c01      	subs	r4, #1
   41e10:	f7ff ffb4 	bl	41d7c <on_failed_write.part.0>
   41e14:	e7f2      	b.n	41dfc <data_out_block_mode+0x64>
		} else if (host_present) {
   41e16:	782b      	ldrb	r3, [r5, #0]
   41e18:	b113      	cbz	r3, 41e20 <data_out_block_mode+0x88>
	if (retry_cnt == 0) {
   41e1a:	3c01      	subs	r4, #1
   41e1c:	d104      	bne.n	41e28 <data_out_block_mode+0x90>
		host_present = false;
   41e1e:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   41e20:	782b      	ldrb	r3, [r5, #0]
   41e22:	2b00      	cmp	r3, #0
   41e24:	d1c2      	bne.n	41dac <data_out_block_mode+0x14>
   41e26:	e7db      	b.n	41de0 <data_out_block_mode+0x48>
   41e28:	f7ff ffa8 	bl	41d7c <on_failed_write.part.0>
   41e2c:	e7f8      	b.n	41e20 <data_out_block_mode+0x88>
   41e2e:	bf00      	nop
   41e30:	2001adfa 	.word	0x2001adfa
   41e34:	2001adfb 	.word	0x2001adfb
   41e38:	2001a654 	.word	0x2001a654

00041e3c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   41e3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   41e40:	4605      	mov	r5, r0
	__asm__ volatile(
   41e42:	f04f 0320 	mov.w	r3, #32
   41e46:	f3ef 8611 	mrs	r6, BASEPRI
   41e4a:	f383 8812 	msr	BASEPRI_MAX, r3
   41e4e:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41e52:	4b10      	ldr	r3, [pc, #64]	; (41e94 <pm_state_notify+0x58>)
   41e54:	681c      	ldr	r4, [r3, #0]
   41e56:	2c00      	cmp	r4, #0
   41e58:	bf38      	it	cc
   41e5a:	2400      	movcc	r4, #0
   41e5c:	b19c      	cbz	r4, 41e86 <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   41e5e:	f04f 090c 	mov.w	r9, #12
   41e62:	4f0d      	ldr	r7, [pc, #52]	; (41e98 <pm_state_notify+0x5c>)
   41e64:	f8df 8034 	ldr.w	r8, [pc, #52]	; 41e9c <pm_state_notify+0x60>
			callback = notifier->state_exit;
   41e68:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   41e6c:	2d00      	cmp	r5, #0
   41e6e:	bf08      	it	eq
   41e70:	4613      	moveq	r3, r2
		if (callback) {
   41e72:	b12b      	cbz	r3, 41e80 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   41e74:	f898 2014 	ldrb.w	r2, [r8, #20]
   41e78:	fb09 f202 	mul.w	r2, r9, r2
   41e7c:	5cb8      	ldrb	r0, [r7, r2]
   41e7e:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   41e80:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   41e82:	2c00      	cmp	r4, #0
   41e84:	d1f0      	bne.n	41e68 <pm_state_notify+0x2c>
	__asm__ volatile(
   41e86:	f386 8811 	msr	BASEPRI, r6
   41e8a:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   41e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   41e92:	bf00      	nop
   41e94:	2001a910 	.word	0x2001a910
   41e98:	2001a91c 	.word	0x2001a91c
   41e9c:	2001ada0 	.word	0x2001ada0

00041ea0 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41ea0:	2201      	movs	r2, #1
   41ea2:	f000 031f 	and.w	r3, r0, #31
   41ea6:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41ea8:	4b08      	ldr	r3, [pc, #32]	; (41ecc <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   41eaa:	0940      	lsrs	r0, r0, #5
   41eac:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   41eb0:	e8d0 3fef 	ldaex	r3, [r0]
   41eb4:	ea43 0102 	orr.w	r1, r3, r2
   41eb8:	e8c0 1fec 	stlex	ip, r1, [r0]
   41ebc:	f1bc 0f00 	cmp.w	ip, #0
   41ec0:	d1f6      	bne.n	41eb0 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   41ec2:	421a      	tst	r2, r3
}
   41ec4:	bf14      	ite	ne
   41ec6:	2001      	movne	r0, #1
   41ec8:	2000      	moveq	r0, #0
   41eca:	4770      	bx	lr
   41ecc:	2001a928 	.word	0x2001a928

00041ed0 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   41ed0:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   41ed2:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   41ed4:	4b1a      	ldr	r3, [pc, #104]	; (41f40 <pm_system_resume+0x70>)
{
   41ed6:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   41ed8:	7d1d      	ldrb	r5, [r3, #20]
   41eda:	f005 031f 	and.w	r3, r5, #31
   41ede:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   41ee0:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   41ee2:	4b18      	ldr	r3, [pc, #96]	; (41f44 <pm_system_resume+0x74>)
   41ee4:	0969      	lsrs	r1, r5, #5
   41ee6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   41eea:	e8d3 1fef 	ldaex	r1, [r3]
   41eee:	ea01 0400 	and.w	r4, r1, r0
   41ef2:	e8c3 4fec 	stlex	ip, r4, [r3]
   41ef6:	f1bc 0f00 	cmp.w	ip, #0
   41efa:	d1f6      	bne.n	41eea <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   41efc:	4211      	tst	r1, r2
   41efe:	d017      	beq.n	41f30 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   41f00:	220c      	movs	r2, #12
   41f02:	4c11      	ldr	r4, [pc, #68]	; (41f48 <pm_system_resume+0x78>)
   41f04:	ab01      	add	r3, sp, #4
   41f06:	fb02 4205 	mla	r2, r2, r5, r4
   41f0a:	ca07      	ldmia	r2, {r0, r1, r2}
   41f0c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   41f10:	4a0e      	ldr	r2, [pc, #56]	; (41f4c <pm_system_resume+0x7c>)
   41f12:	b17a      	cbz	r2, 41f34 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   41f14:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41f18:	f005 fe76 	bl	47c08 <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   41f1c:	2000      	movs	r0, #0
   41f1e:	f7ff ff8d 	bl	41e3c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   41f22:	230c      	movs	r3, #12
   41f24:	2200      	movs	r2, #0
   41f26:	436b      	muls	r3, r5
   41f28:	18e1      	adds	r1, r4, r3
   41f2a:	50e2      	str	r2, [r4, r3]
   41f2c:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   41f30:	b005      	add	sp, #20
   41f32:	bd30      	pop	{r4, r5, pc}
   41f34:	f382 8811 	msr	BASEPRI, r2
   41f38:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   41f3c:	e7ee      	b.n	41f1c <pm_system_resume+0x4c>
   41f3e:	bf00      	nop
   41f40:	2001ada0 	.word	0x2001ada0
   41f44:	2001a918 	.word	0x2001a918
   41f48:	2001a91c 	.word	0x2001a91c
   41f4c:	00047c09 	.word	0x00047c09

00041f50 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   41f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   41f54:	4b39      	ldr	r3, [pc, #228]	; (4203c <pm_system_suspend+0xec>)
{
   41f56:	4605      	mov	r5, r0
	uint8_t id = _current_cpu->id;
   41f58:	7d1c      	ldrb	r4, [r3, #20]
{
   41f5a:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   41f5c:	4620      	mov	r0, r4
   41f5e:	f7ff ff9f 	bl	41ea0 <atomic_test_and_set_bit.constprop.0>
   41f62:	4e37      	ldr	r6, [pc, #220]	; (42040 <pm_system_suspend+0xf0>)
   41f64:	b960      	cbnz	r0, 41f80 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   41f66:	270c      	movs	r7, #12
   41f68:	46e8      	mov	r8, sp
   41f6a:	fb07 6704 	mla	r7, r7, r4, r6
   41f6e:	462a      	mov	r2, r5
   41f70:	4621      	mov	r1, r4
   41f72:	4640      	mov	r0, r8
   41f74:	f006 f915 	bl	481a2 <pm_policy_next_state>
   41f78:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
   41f7c:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   41f80:	230c      	movs	r3, #12
   41f82:	4363      	muls	r3, r4
   41f84:	5cf0      	ldrb	r0, [r6, r3]
   41f86:	18f2      	adds	r2, r6, r3
   41f88:	0967      	lsrs	r7, r4, #5
   41f8a:	f004 081f 	and.w	r8, r4, #31
   41f8e:	2800      	cmp	r0, #0
   41f90:	d03b      	beq.n	4200a <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   41f92:	1c6b      	adds	r3, r5, #1
   41f94:	d014      	beq.n	41fc0 <pm_system_suspend+0x70>
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
   41f96:	f240 30e7 	movw	r0, #999	; 0x3e7
   41f9a:	2100      	movs	r1, #0
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
		     k_us_to_ticks_ceil32(
   41f9c:	6893      	ldr	r3, [r2, #8]
   41f9e:	18c0      	adds	r0, r0, r3
   41fa0:	f141 0100 	adc.w	r1, r1, #0
		if (result32 && (t < BIT64(32))) {
   41fa4:	2901      	cmp	r1, #1
   41fa6:	bf08      	it	eq
   41fa8:	2800      	cmpeq	r0, #0
   41faa:	d241      	bcs.n	42030 <pm_system_suspend+0xe0>
			return ((uint32_t)t) / (from_hz / to_hz);
   41fac:	f203 30e7 	addw	r0, r3, #999	; 0x3e7
   41fb0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   41fb4:	fbb0 f0f3 	udiv	r0, r0, r3
		z_set_timeout_expiry(ticks -
   41fb8:	2101      	movs	r1, #1
   41fba:	1a28      	subs	r0, r5, r0
   41fbc:	f006 fe3b 	bl	48c36 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   41fc0:	f004 fc98 	bl	468f4 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   41fc4:	2001      	movs	r0, #1
   41fc6:	f7ff ff39 	bl	41e3c <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   41fca:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   41fcc:	4b1d      	ldr	r3, [pc, #116]	; (42044 <pm_system_suspend+0xf4>)
   41fce:	fa02 f208 	lsl.w	r2, r2, r8
   41fd2:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   41fd6:	e8d3 1fef 	ldaex	r1, [r3]
   41fda:	4311      	orrs	r1, r2
   41fdc:	e8c3 1fe0 	stlex	r0, r1, [r3]
   41fe0:	2800      	cmp	r0, #0
   41fe2:	d1f8      	bne.n	41fd6 <pm_system_suspend+0x86>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   41fe4:	230c      	movs	r3, #12
   41fe6:	fb03 6404 	mla	r4, r3, r4, r6
   41fea:	ab05      	add	r3, sp, #20
   41fec:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   41ff0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   41ff4:	4a14      	ldr	r2, [pc, #80]	; (42048 <pm_system_suspend+0xf8>)
   41ff6:	b11a      	cbz	r2, 42000 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
   41ff8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   41ffc:	f005 fdf1 	bl	47be2 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   42000:	f7ff ff66 	bl	41ed0 <pm_system_resume>
	k_sched_unlock();
   42004:	f004 fe50 	bl	46ca8 <k_sched_unlock>
	bool ret = true;
   42008:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   4200a:	2301      	movs	r3, #1
   4200c:	fa03 f808 	lsl.w	r8, r3, r8
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   42010:	ea6f 0808 	mvn.w	r8, r8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   42014:	4b0d      	ldr	r3, [pc, #52]	; (4204c <pm_system_suspend+0xfc>)
   42016:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   4201a:	e8d7 3fef 	ldaex	r3, [r7]
   4201e:	ea03 0308 	and.w	r3, r3, r8
   42022:	e8c7 3fe2 	stlex	r2, r3, [r7]
   42026:	2a00      	cmp	r2, #0
   42028:	d1f7      	bne.n	4201a <pm_system_suspend+0xca>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   4202a:	b008      	add	sp, #32
   4202c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else {
			return t / ((uint64_t)from_hz / to_hz);
   42030:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   42034:	2300      	movs	r3, #0
   42036:	f7fe f885 	bl	40144 <__aeabi_uldivmod>
   4203a:	e7bd      	b.n	41fb8 <pm_system_suspend+0x68>
   4203c:	2001ada0 	.word	0x2001ada0
   42040:	2001a91c 	.word	0x2001a91c
   42044:	2001a918 	.word	0x2001a918
   42048:	00047be3 	.word	0x00047be3
   4204c:	2001a928 	.word	0x2001a928

00042050 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   42050:	4901      	ldr	r1, [pc, #4]	; (42058 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   42052:	2210      	movs	r2, #16
	str	r2, [r1]
   42054:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   42056:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   42058:	e000ed10 	.word	0xe000ed10

0004205c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   4205c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   4205e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   42060:	f380 8811 	msr	BASEPRI, r0
	isb
   42064:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   42068:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   4206c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   4206e:	b662      	cpsie	i
	isb
   42070:	f3bf 8f6f 	isb	sy

	bx	lr
   42074:	4770      	bx	lr
   42076:	bf00      	nop

00042078 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   42078:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   4207a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   4207c:	f381 8811 	msr	BASEPRI, r1

	wfe
   42080:	bf20      	wfe

	msr	BASEPRI, r0
   42082:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   42086:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   42088:	4770      	bx	lr
   4208a:	bf00      	nop

0004208c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   4208c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   4208e:	4606      	mov	r6, r0

	if (esf != NULL) {
   42090:	460c      	mov	r4, r1
   42092:	b301      	cbz	r1, 420d6 <z_arm_fatal_error+0x4a>
   42094:	4b13      	ldr	r3, [pc, #76]	; (420e4 <z_arm_fatal_error+0x58>)
   42096:	4d14      	ldr	r5, [pc, #80]	; (420e8 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   42098:	4814      	ldr	r0, [pc, #80]	; (420ec <z_arm_fatal_error+0x60>)
   4209a:	1aed      	subs	r5, r5, r3
   4209c:	08ed      	lsrs	r5, r5, #3
   4209e:	01ad      	lsls	r5, r5, #6
   420a0:	f045 0501 	orr.w	r5, r5, #1
   420a4:	f8ad 5000 	strh.w	r5, [sp]
   420a8:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   420ac:	6809      	ldr	r1, [r1, #0]
   420ae:	f005 fe33 	bl	47d18 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   420b2:	f8ad 5000 	strh.w	r5, [sp]
   420b6:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   420ba:	68e1      	ldr	r1, [r4, #12]
   420bc:	480c      	ldr	r0, [pc, #48]	; (420f0 <z_arm_fatal_error+0x64>)
   420be:	f005 fe2b 	bl	47d18 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   420c2:	462a      	mov	r2, r5
   420c4:	69e1      	ldr	r1, [r4, #28]
   420c6:	480b      	ldr	r0, [pc, #44]	; (420f4 <z_arm_fatal_error+0x68>)
   420c8:	f005 fdf9 	bl	47cbe <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   420cc:	462a      	mov	r2, r5
   420ce:	69a1      	ldr	r1, [r4, #24]
   420d0:	4809      	ldr	r0, [pc, #36]	; (420f8 <z_arm_fatal_error+0x6c>)
   420d2:	f005 fdf4 	bl	47cbe <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   420d6:	4621      	mov	r1, r4
   420d8:	4630      	mov	r0, r6
}
   420da:	b002      	add	sp, #8
   420dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
   420e0:	f004 b86c 	b.w	461bc <z_fatal_error>
   420e4:	00049038 	.word	0x00049038
   420e8:	00049068 	.word	0x00049068
   420ec:	000494a5 	.word	0x000494a5
   420f0:	000494d4 	.word	0x000494d4
   420f4:	00049503 	.word	0x00049503
   420f8:	00049512 	.word	0x00049512

000420fc <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   420fc:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   420fe:	2b00      	cmp	r3, #0
   42100:	db08      	blt.n	42114 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42102:	2201      	movs	r2, #1
   42104:	f000 001f 	and.w	r0, r0, #31
   42108:	fa02 f000 	lsl.w	r0, r2, r0
   4210c:	4a02      	ldr	r2, [pc, #8]	; (42118 <arch_irq_enable+0x1c>)
   4210e:	095b      	lsrs	r3, r3, #5
   42110:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   42114:	4770      	bx	lr
   42116:	bf00      	nop
   42118:	e000e100 	.word	0xe000e100

0004211c <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   4211c:	4b05      	ldr	r3, [pc, #20]	; (42134 <arch_irq_is_enabled+0x18>)
   4211e:	0942      	lsrs	r2, r0, #5
   42120:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   42124:	2301      	movs	r3, #1
   42126:	f000 001f 	and.w	r0, r0, #31
   4212a:	fa03 f000 	lsl.w	r0, r3, r0
}
   4212e:	4010      	ands	r0, r2
   42130:	4770      	bx	lr
   42132:	bf00      	nop
   42134:	e000e100 	.word	0xe000e100

00042138 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   42138:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   4213a:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   4213c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42140:	bfac      	ite	ge
   42142:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42146:	4b06      	ldrlt	r3, [pc, #24]	; (42160 <z_arm_irq_priority_set+0x28>)
   42148:	ea4f 1141 	mov.w	r1, r1, lsl #5
   4214c:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   4214e:	bfab      	itete	ge
   42150:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42154:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42158:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   4215c:	5419      	strblt	r1, [r3, r0]
}
   4215e:	4770      	bx	lr
   42160:	e000ed14 	.word	0xe000ed14

00042164 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   42164:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   42166:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   42168:	4b04      	ldr	r3, [pc, #16]	; (4217c <_arch_isr_direct_pm+0x18>)
   4216a:	699a      	ldr	r2, [r3, #24]
   4216c:	b11a      	cbz	r2, 42176 <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   4216e:	2200      	movs	r2, #0
   42170:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   42172:	f006 fc2e 	bl	489d2 <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   42176:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   42178:	bd08      	pop	{r3, pc}
   4217a:	bf00      	nop
   4217c:	2001ada0 	.word	0x2001ada0

00042180 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   42180:	bf30      	wfi
    b z_SysNmiOnReset
   42182:	f7ff bffd 	b.w	42180 <z_SysNmiOnReset>
   42186:	bf00      	nop

00042188 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   42188:	4a0b      	ldr	r2, [pc, #44]	; (421b8 <z_arm_prep_c+0x30>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   4218a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   4218c:	4b0b      	ldr	r3, [pc, #44]	; (421bc <z_arm_prep_c+0x34>)
   4218e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   42192:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   42194:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42198:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   4219c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   421a0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   421a4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   421a8:	f004 f8ae 	bl	46308 <z_bss_zero>
	z_data_copy();
   421ac:	f004 fe9e 	bl	46eec <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   421b0:	f000 fb06 	bl	427c0 <z_arm_interrupt_init>
	z_cstart();
   421b4:	f004 f8b2 	bl	4631c <z_cstart>
   421b8:	00040000 	.word	0x00040000
   421bc:	e000ed00 	.word	0xe000ed00

000421c0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   421c0:	4a09      	ldr	r2, [pc, #36]	; (421e8 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   421c2:	490a      	ldr	r1, [pc, #40]	; (421ec <arch_swap+0x2c>)
	_current->arch.basepri = key;
   421c4:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   421c6:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   421c8:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   421ca:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   421cc:	4908      	ldr	r1, [pc, #32]	; (421f0 <arch_swap+0x30>)
   421ce:	684b      	ldr	r3, [r1, #4]
   421d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   421d4:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   421d6:	2300      	movs	r3, #0
   421d8:	f383 8811 	msr	BASEPRI, r3
   421dc:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   421e0:	6893      	ldr	r3, [r2, #8]
}
   421e2:	6f98      	ldr	r0, [r3, #120]	; 0x78
   421e4:	4770      	bx	lr
   421e6:	bf00      	nop
   421e8:	2001ada0 	.word	0x2001ada0
   421ec:	000492b4 	.word	0x000492b4
   421f0:	e000ed00 	.word	0xe000ed00

000421f4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   421f4:	4915      	ldr	r1, [pc, #84]	; (4224c <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   421f6:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   421f8:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   421fc:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   42200:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   42202:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   42206:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   4220a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   4220c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   42210:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   42214:	4f0e      	ldr	r7, [pc, #56]	; (42250 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   42216:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   4221a:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   4221c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   4221e:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   42220:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   42224:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   42226:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   42228:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   4222a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   4222e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   42232:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   42236:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   4223a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   4223e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   42240:	f005 ffc3 	bl	481ca <configure_builtin_stack_guard>
    pop {r2, lr}
   42244:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   42248:	4770      	bx	lr
   4224a:	0000      	.short	0x0000
    ldr r1, =_kernel
   4224c:	2001ada0 	.word	0x2001ada0
    ldr v4, =_SCS_ICSR
   42250:	e000ed04 	.word	0xe000ed04

00042254 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   42254:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   42258:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   4225a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   4225e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   42262:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   42264:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   42268:	2902      	cmp	r1, #2
    beq _oops
   4226a:	d0ff      	beq.n	4226c <_oops>

0004226c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   4226c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   4226e:	f005 ff9d 	bl	481ac <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   42272:	bd01      	pop	{r0, pc}

00042274 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   42274:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   42278:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   4227a:	490c      	ldr	r1, [pc, #48]	; (422ac <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   4227c:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   42280:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   42282:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   42286:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   4228a:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   4228c:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   42290:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   42294:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   42298:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   4229c:	2300      	movs	r3, #0
   4229e:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   422a0:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   422a4:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   422a6:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   422a8:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   422aa:	4770      	bx	lr
   422ac:	00047781 	.word	0x00047781

000422b0 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   422b0:	4b08      	ldr	r3, [pc, #32]	; (422d4 <arch_switch_to_main_thread+0x24>)
   422b2:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   422b4:	6e43      	ldr	r3, [r0, #100]	; 0x64
   422b6:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   422ba:	4610      	mov	r0, r2
   422bc:	f381 8809 	msr	PSP, r1
   422c0:	2100      	movs	r1, #0
   422c2:	b663      	cpsie	if
   422c4:	f381 8811 	msr	BASEPRI, r1
   422c8:	f3bf 8f6f 	isb	sy
   422cc:	2200      	movs	r2, #0
   422ce:	2300      	movs	r3, #0
   422d0:	f005 fa56 	bl	47780 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   422d4:	2001ada0 	.word	0x2001ada0

000422d8 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   422d8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   422da:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   422dc:	4a0b      	ldr	r2, [pc, #44]	; (4230c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   422de:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   422e0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   422e2:	bf1e      	ittt	ne
	movne	r1, #0
   422e4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   422e6:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   422e8:	f006 fb73 	blne	489d2 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   422ec:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   422ee:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   422f2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   422f6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   422fa:	4905      	ldr	r1, [pc, #20]	; (42310 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   422fc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   422fe:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   42300:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   42302:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   42306:	4903      	ldr	r1, [pc, #12]	; (42314 <_isr_wrapper+0x3c>)
	bx r1
   42308:	4708      	bx	r1
   4230a:	0000      	.short	0x0000
	ldr r2, =_kernel
   4230c:	2001ada0 	.word	0x2001ada0
	ldr r1, =_sw_isr_table
   42310:	00048e30 	.word	0x00048e30
	ldr r1, =z_arm_int_exit
   42314:	00042319 	.word	0x00042319

00042318 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   42318:	4b04      	ldr	r3, [pc, #16]	; (4232c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   4231a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   4231c:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   4231e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   42320:	d003      	beq.n	4232a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   42322:	4903      	ldr	r1, [pc, #12]	; (42330 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   42324:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   42328:	600a      	str	r2, [r1, #0]

0004232a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   4232a:	4770      	bx	lr
	ldr r3, =_kernel
   4232c:	2001ada0 	.word	0x2001ada0
	ldr r1, =_SCS_ICSR
   42330:	e000ed04 	.word	0xe000ed04

00042334 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
   42334:	b570      	push	{r4, r5, r6, lr}
   42336:	4b28      	ldr	r3, [pc, #160]	; (423d8 <usage_fault.isra.0+0xa4>)
   42338:	4c28      	ldr	r4, [pc, #160]	; (423dc <usage_fault.isra.0+0xa8>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4233a:	4d29      	ldr	r5, [pc, #164]	; (423e0 <usage_fault.isra.0+0xac>)
   4233c:	1ae4      	subs	r4, r4, r3
   4233e:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
   42340:	01a4      	lsls	r4, r4, #6
   42342:	f044 0601 	orr.w	r6, r4, #1
   42346:	4631      	mov	r1, r6
   42348:	4826      	ldr	r0, [pc, #152]	; (423e4 <usage_fault.isra.0+0xb0>)
   4234a:	f005 fcab 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4234e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42350:	0193      	lsls	r3, r2, #6
   42352:	d503      	bpl.n	4235c <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
   42354:	4631      	mov	r1, r6
   42356:	4824      	ldr	r0, [pc, #144]	; (423e8 <usage_fault.isra.0+0xb4>)
   42358:	f005 fca4 	bl	47ca4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   4235c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4235e:	01dd      	lsls	r5, r3, #7
   42360:	d504      	bpl.n	4236c <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
   42362:	4822      	ldr	r0, [pc, #136]	; (423ec <usage_fault.isra.0+0xb8>)
   42364:	f044 0101 	orr.w	r1, r4, #1
   42368:	f005 fc9c 	bl	47ca4 <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   4236c:	4d1c      	ldr	r5, [pc, #112]	; (423e0 <usage_fault.isra.0+0xac>)
   4236e:	6aae      	ldr	r6, [r5, #40]	; 0x28
   42370:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   42374:	d005      	beq.n	42382 <usage_fault.isra.0+0x4e>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   42376:	481e      	ldr	r0, [pc, #120]	; (423f0 <usage_fault.isra.0+0xbc>)
   42378:	f044 0101 	orr.w	r1, r4, #1
   4237c:	f005 fc92 	bl	47ca4 <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   42380:	2602      	movs	r6, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   42382:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42384:	0318      	lsls	r0, r3, #12
   42386:	d504      	bpl.n	42392 <usage_fault.isra.0+0x5e>
		PR_FAULT_INFO("  No coprocessor instructions");
   42388:	481a      	ldr	r0, [pc, #104]	; (423f4 <usage_fault.isra.0+0xc0>)
   4238a:	f044 0101 	orr.w	r1, r4, #1
   4238e:	f005 fc89 	bl	47ca4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   42392:	4d13      	ldr	r5, [pc, #76]	; (423e0 <usage_fault.isra.0+0xac>)
   42394:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42396:	0351      	lsls	r1, r2, #13
   42398:	d504      	bpl.n	423a4 <usage_fault.isra.0+0x70>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   4239a:	4817      	ldr	r0, [pc, #92]	; (423f8 <usage_fault.isra.0+0xc4>)
   4239c:	f044 0101 	orr.w	r1, r4, #1
   423a0:	f005 fc80 	bl	47ca4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   423a4:	6aab      	ldr	r3, [r5, #40]	; 0x28
   423a6:	039a      	lsls	r2, r3, #14
   423a8:	d504      	bpl.n	423b4 <usage_fault.isra.0+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   423aa:	4814      	ldr	r0, [pc, #80]	; (423fc <usage_fault.isra.0+0xc8>)
   423ac:	f044 0101 	orr.w	r1, r4, #1
   423b0:	f005 fc78 	bl	47ca4 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   423b4:	4d0a      	ldr	r5, [pc, #40]	; (423e0 <usage_fault.isra.0+0xac>)
   423b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   423b8:	03db      	lsls	r3, r3, #15
   423ba:	d504      	bpl.n	423c6 <usage_fault.isra.0+0x92>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   423bc:	4810      	ldr	r0, [pc, #64]	; (42400 <usage_fault.isra.0+0xcc>)
   423be:	f044 0101 	orr.w	r1, r4, #1
   423c2:	f005 fc6f 	bl	47ca4 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   423c6:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
   423c8:	4630      	mov	r0, r6
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   423ca:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   423ce:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   423d2:	62ab      	str	r3, [r5, #40]	; 0x28
}
   423d4:	bd70      	pop	{r4, r5, r6, pc}
   423d6:	bf00      	nop
   423d8:	00049038 	.word	0x00049038
   423dc:	00049068 	.word	0x00049068
   423e0:	e000ed00 	.word	0xe000ed00
   423e4:	00049540 	.word	0x00049540
   423e8:	00049558 	.word	0x00049558
   423ec:	0004956b 	.word	0x0004956b
   423f0:	00049585 	.word	0x00049585
   423f4:	000495af 	.word	0x000495af
   423f8:	000495cd 	.word	0x000495cd
   423fc:	000495f2 	.word	0x000495f2
   42400:	0004960c 	.word	0x0004960c

00042404 <mem_manage_fault.isra.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   42408:	4b28      	ldr	r3, [pc, #160]	; (424ac <mem_manage_fault.isra.0+0xa8>)
   4240a:	4c29      	ldr	r4, [pc, #164]	; (424b0 <mem_manage_fault.isra.0+0xac>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   4240c:	4d29      	ldr	r5, [pc, #164]	; (424b4 <mem_manage_fault.isra.0+0xb0>)
   4240e:	1ae4      	subs	r4, r4, r3
   42410:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
   42412:	01a4      	lsls	r4, r4, #6
   42414:	f044 0801 	orr.w	r8, r4, #1
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42418:	4607      	mov	r7, r0
   4241a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   4241c:	4826      	ldr	r0, [pc, #152]	; (424b8 <mem_manage_fault.isra.0+0xb4>)
   4241e:	4641      	mov	r1, r8
   42420:	f005 fc40 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42424:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42426:	06d0      	lsls	r0, r2, #27
   42428:	d503      	bpl.n	42432 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
   4242a:	4641      	mov	r1, r8
   4242c:	4823      	ldr	r0, [pc, #140]	; (424bc <mem_manage_fault.isra.0+0xb8>)
   4242e:	f005 fc39 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   42432:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42434:	0719      	lsls	r1, r3, #28
   42436:	d504      	bpl.n	42442 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42438:	4821      	ldr	r0, [pc, #132]	; (424c0 <mem_manage_fault.isra.0+0xbc>)
   4243a:	f044 0101 	orr.w	r1, r4, #1
   4243e:	f005 fc31 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   42442:	4d1c      	ldr	r5, [pc, #112]	; (424b4 <mem_manage_fault.isra.0+0xb0>)
   42444:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42446:	079a      	lsls	r2, r3, #30
   42448:	d512      	bpl.n	42470 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
   4244a:	f044 0801 	orr.w	r8, r4, #1
   4244e:	4641      	mov	r1, r8
   42450:	481c      	ldr	r0, [pc, #112]	; (424c4 <mem_manage_fault.isra.0+0xc0>)
   42452:	f005 fc27 	bl	47ca4 <log_0>
		uint32_t temp = SCB->MMFAR;
   42456:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   42458:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4245a:	061b      	lsls	r3, r3, #24
   4245c:	d508      	bpl.n	42470 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   4245e:	4642      	mov	r2, r8
   42460:	4819      	ldr	r0, [pc, #100]	; (424c8 <mem_manage_fault.isra.0+0xc4>)
   42462:	f005 fc2c 	bl	47cbe <log_1>
			if (from_hard_fault != 0) {
   42466:	b11f      	cbz	r7, 42470 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   42468:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4246a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   4246e:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   42470:	4d10      	ldr	r5, [pc, #64]	; (424b4 <mem_manage_fault.isra.0+0xb0>)
   42472:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   42474:	07d0      	lsls	r0, r2, #31
   42476:	d504      	bpl.n	42482 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
   42478:	4814      	ldr	r0, [pc, #80]	; (424cc <mem_manage_fault.isra.0+0xc8>)
   4247a:	f044 0101 	orr.w	r1, r4, #1
   4247e:	f005 fc11 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   42482:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42484:	0699      	lsls	r1, r3, #26
   42486:	d504      	bpl.n	42492 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
   42488:	4811      	ldr	r0, [pc, #68]	; (424d0 <mem_manage_fault.isra.0+0xcc>)
   4248a:	f044 0101 	orr.w	r1, r4, #1
   4248e:	f005 fc09 	bl	47ca4 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   42492:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   42494:	4b07      	ldr	r3, [pc, #28]	; (424b4 <mem_manage_fault.isra.0+0xb0>)
   42496:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   42498:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   4249a:	bf58      	it	pl
   4249c:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   4249e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   424a0:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   424a4:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   424a6:	7030      	strb	r0, [r6, #0]
}
   424a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   424ac:	00049038 	.word	0x00049038
   424b0:	00049068 	.word	0x00049068
   424b4:	e000ed00 	.word	0xe000ed00
   424b8:	00049637 	.word	0x00049637
   424bc:	0004964d 	.word	0x0004964d
   424c0:	00049680 	.word	0x00049680
   424c4:	00049693 	.word	0x00049693
   424c8:	000496ab 	.word	0x000496ab
   424cc:	000496c1 	.word	0x000496c1
   424d0:	000496e0 	.word	0x000496e0

000424d4 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   424d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   424d8:	4b2a      	ldr	r3, [pc, #168]	; (42584 <bus_fault.isra.0+0xb0>)
   424da:	4c2b      	ldr	r4, [pc, #172]	; (42588 <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   424dc:	4d2b      	ldr	r5, [pc, #172]	; (4258c <bus_fault.isra.0+0xb8>)
   424de:	1ae4      	subs	r4, r4, r3
   424e0:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
   424e2:	01a4      	lsls	r4, r4, #6
   424e4:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   424e8:	4607      	mov	r7, r0
   424ea:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   424ec:	4828      	ldr	r0, [pc, #160]	; (42590 <bus_fault.isra.0+0xbc>)
   424ee:	4641      	mov	r1, r8
   424f0:	f005 fbd8 	bl	47ca4 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   424f4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   424f6:	04d1      	lsls	r1, r2, #19
   424f8:	d503      	bpl.n	42502 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
   424fa:	4641      	mov	r1, r8
   424fc:	4825      	ldr	r0, [pc, #148]	; (42594 <bus_fault.isra.0+0xc0>)
   424fe:	f005 fbd1 	bl	47ca4 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   42502:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42504:	051a      	lsls	r2, r3, #20
   42506:	d504      	bpl.n	42512 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   42508:	4823      	ldr	r0, [pc, #140]	; (42598 <bus_fault.isra.0+0xc4>)
   4250a:	f044 0101 	orr.w	r1, r4, #1
   4250e:	f005 fbc9 	bl	47ca4 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   42512:	4d1e      	ldr	r5, [pc, #120]	; (4258c <bus_fault.isra.0+0xb8>)
   42514:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42516:	059b      	lsls	r3, r3, #22
   42518:	d512      	bpl.n	42540 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
   4251a:	f044 0801 	orr.w	r8, r4, #1
   4251e:	4641      	mov	r1, r8
   42520:	481e      	ldr	r0, [pc, #120]	; (4259c <bus_fault.isra.0+0xc8>)
   42522:	f005 fbbf 	bl	47ca4 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   42526:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   42528:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4252a:	0418      	lsls	r0, r3, #16
   4252c:	d508      	bpl.n	42540 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   4252e:	4642      	mov	r2, r8
   42530:	481b      	ldr	r0, [pc, #108]	; (425a0 <bus_fault.isra.0+0xcc>)
   42532:	f005 fbc4 	bl	47cbe <log_1>
			if (from_hard_fault != 0) {
   42536:	b11f      	cbz	r7, 42540 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   42538:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4253a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   4253e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   42540:	4d12      	ldr	r5, [pc, #72]	; (4258c <bus_fault.isra.0+0xb8>)
   42542:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42544:	0559      	lsls	r1, r3, #21
   42546:	d504      	bpl.n	42552 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
   42548:	4816      	ldr	r0, [pc, #88]	; (425a4 <bus_fault.isra.0+0xd0>)
   4254a:	f044 0101 	orr.w	r1, r4, #1
   4254e:	f005 fba9 	bl	47ca4 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   42552:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42554:	05da      	lsls	r2, r3, #23
   42556:	d50d      	bpl.n	42574 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
   42558:	4813      	ldr	r0, [pc, #76]	; (425a8 <bus_fault.isra.0+0xd4>)
   4255a:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4255e:	f005 fba1 	bl	47ca4 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   42562:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   42564:	4a09      	ldr	r2, [pc, #36]	; (4258c <bus_fault.isra.0+0xb8>)
   42566:	6a93      	ldr	r3, [r2, #40]	; 0x28
   42568:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   4256c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   4256e:	7030      	strb	r0, [r6, #0]
}
   42570:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   42574:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42576:	049b      	lsls	r3, r3, #18
   42578:	d5f3      	bpl.n	42562 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   4257a:	480c      	ldr	r0, [pc, #48]	; (425ac <bus_fault.isra.0+0xd8>)
   4257c:	f044 0101 	orr.w	r1, r4, #1
   42580:	e7ed      	b.n	4255e <bus_fault.isra.0+0x8a>
   42582:	bf00      	nop
   42584:	00049038 	.word	0x00049038
   42588:	00049068 	.word	0x00049068
   4258c:	e000ed00 	.word	0xe000ed00
   42590:	0004970f 	.word	0x0004970f
   42594:	00049725 	.word	0x00049725
   42598:	00049680 	.word	0x00049680
   4259c:	00049736 	.word	0x00049736
   425a0:	0004974f 	.word	0x0004974f
   425a4:	00049764 	.word	0x00049764
   425a8:	0004977f 	.word	0x0004977f
   425ac:	000496e0 	.word	0x000496e0

000425b0 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   425b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   425b4:	4b68      	ldr	r3, [pc, #416]	; (42758 <z_arm_fault+0x1a8>)
{
   425b6:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   425b8:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   425bc:	4689      	mov	r9, r1
   425be:	4614      	mov	r4, r2
   425c0:	2700      	movs	r7, #0
   425c2:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   425c4:	f3c8 0608 	ubfx	r6, r8, #0, #9
   425c8:	f387 8811 	msr	BASEPRI, r7
   425cc:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   425d0:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   425d4:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   425d8:	d124      	bne.n	42624 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   425da:	07d0      	lsls	r0, r2, #31
   425dc:	d422      	bmi.n	42624 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   425de:	0651      	lsls	r1, r2, #25
   425e0:	d403      	bmi.n	425ea <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   425e2:	0722      	lsls	r2, r4, #28
   425e4:	d40e      	bmi.n	42604 <z_arm_fault+0x54>
			*nested_exc = true;
   425e6:	2701      	movs	r7, #1
   425e8:	e00e      	b.n	42608 <z_arm_fault+0x58>
   425ea:	495c      	ldr	r1, [pc, #368]	; (4275c <z_arm_fault+0x1ac>)
   425ec:	4b5c      	ldr	r3, [pc, #368]	; (42760 <z_arm_fault+0x1b0>)
		PR_FAULT_INFO("Exception occurred in Secure State");
   425ee:	485d      	ldr	r0, [pc, #372]	; (42764 <z_arm_fault+0x1b4>)
   425f0:	1a5b      	subs	r3, r3, r1
   425f2:	08db      	lsrs	r3, r3, #3
   425f4:	019b      	lsls	r3, r3, #6
   425f6:	f043 0101 	orr.w	r1, r3, #1
   425fa:	f005 fb53 	bl	47ca4 <log_0>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   425fe:	f014 0704 	ands.w	r7, r4, #4
   42602:	d001      	beq.n	42608 <z_arm_fault+0x58>
			ptr_esf = (z_arch_esf_t *)psp;
   42604:	464d      	mov	r5, r9
	*nested_exc = false;
   42606:	2700      	movs	r7, #0
	*recoverable = false;
   42608:	2300      	movs	r3, #0
   4260a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   4260e:	1ef3      	subs	r3, r6, #3
   42610:	2b09      	cmp	r3, #9
   42612:	f200 8088 	bhi.w	42726 <z_arm_fault+0x176>
   42616:	e8df f003 	tbb	[pc, r3]
   4261a:	7507      	.short	0x7507
   4261c:	86867279 	.word	0x86867279
   42620:	7d868686 	.word	0x7d868686
		return NULL;
   42624:	463d      	mov	r5, r7
   42626:	e7ef      	b.n	42608 <z_arm_fault+0x58>
	*recoverable = false;
   42628:	f04f 0800 	mov.w	r8, #0
   4262c:	4a4b      	ldr	r2, [pc, #300]	; (4275c <z_arm_fault+0x1ac>)
   4262e:	4e4c      	ldr	r6, [pc, #304]	; (42760 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** HARD FAULT *****");
   42630:	484d      	ldr	r0, [pc, #308]	; (42768 <z_arm_fault+0x1b8>)
   42632:	1ab6      	subs	r6, r6, r2
   42634:	08f6      	lsrs	r6, r6, #3
   42636:	01b6      	lsls	r6, r6, #6
   42638:	f046 0601 	orr.w	r6, r6, #1
   4263c:	4631      	mov	r1, r6
   4263e:	f005 fb31 	bl	47ca4 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42642:	4b45      	ldr	r3, [pc, #276]	; (42758 <z_arm_fault+0x1a8>)
	*recoverable = false;
   42644:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   42648:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   4264a:	f014 0402 	ands.w	r4, r4, #2
   4264e:	d005      	beq.n	4265c <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
   42650:	4631      	mov	r1, r6
   42652:	4846      	ldr	r0, [pc, #280]	; (4276c <z_arm_fault+0x1bc>)
	PR_FAULT_INFO(
   42654:	f005 fb26 	bl	47ca4 <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   42658:	2400      	movs	r4, #0
}
   4265a:	e006      	b.n	4266a <z_arm_fault+0xba>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   4265c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   4265e:	2a00      	cmp	r2, #0
   42660:	da1d      	bge.n	4269e <z_arm_fault+0xee>
		PR_EXC("  Debug event");
   42662:	4631      	mov	r1, r6
   42664:	4842      	ldr	r0, [pc, #264]	; (42770 <z_arm_fault+0x1c0>)
   42666:	f005 fb1d 	bl	47ca4 <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   4266a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   4266e:	b99b      	cbnz	r3, 42698 <z_arm_fault+0xe8>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   42670:	2220      	movs	r2, #32
   42672:	4629      	mov	r1, r5
   42674:	a802      	add	r0, sp, #8
   42676:	f005 fe28 	bl	482ca <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   4267a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   4267c:	2f00      	cmp	r7, #0
   4267e:	d066      	beq.n	4274e <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   42680:	f3c3 0208 	ubfx	r2, r3, #0, #9
   42684:	b922      	cbnz	r2, 42690 <z_arm_fault+0xe0>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   42686:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   4268a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4268e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   42690:	4620      	mov	r0, r4
   42692:	a902      	add	r1, sp, #8
   42694:	f7ff fcfa 	bl	4208c <z_arm_fatal_error>
}
   42698:	b00b      	add	sp, #44	; 0x2c
   4269a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   4269e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   426a0:	005b      	lsls	r3, r3, #1
   426a2:	d5e2      	bpl.n	4266a <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   426a4:	4631      	mov	r1, r6
   426a6:	4833      	ldr	r0, [pc, #204]	; (42774 <z_arm_fault+0x1c4>)
   426a8:	f005 fafc 	bl	47ca4 <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
   426ac:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   426ae:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   426b2:	f64d 7302 	movw	r3, #57090	; 0xdf02
   426b6:	429a      	cmp	r2, r3
   426b8:	d00c      	beq.n	426d4 <z_arm_fault+0x124>
		} else if (SCB_MMFSR != 0) {
   426ba:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   426be:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   426c2:	781b      	ldrb	r3, [r3, #0]
   426c4:	b16b      	cbz	r3, 426e2 <z_arm_fault+0x132>
			reason = mem_manage_fault(esf, 1, recoverable);
   426c6:	2001      	movs	r0, #1
   426c8:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   426cc:	f7ff fe9a 	bl	42404 <mem_manage_fault.isra.0>
   426d0:	4604      	mov	r4, r0
		break;
   426d2:	e7ca      	b.n	4266a <z_arm_fault+0xba>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   426d4:	4632      	mov	r2, r6
   426d6:	6829      	ldr	r1, [r5, #0]
   426d8:	4827      	ldr	r0, [pc, #156]	; (42778 <z_arm_fault+0x1c8>)
   426da:	f005 faf0 	bl	47cbe <log_1>
			reason = esf->basic.r0;
   426de:	682c      	ldr	r4, [r5, #0]
   426e0:	e7c3      	b.n	4266a <z_arm_fault+0xba>
		} else if (SCB_BFSR != 0) {
   426e2:	4b26      	ldr	r3, [pc, #152]	; (4277c <z_arm_fault+0x1cc>)
   426e4:	781b      	ldrb	r3, [r3, #0]
   426e6:	b12b      	cbz	r3, 426f4 <z_arm_fault+0x144>
			reason = bus_fault(esf, 1, recoverable);
   426e8:	2001      	movs	r0, #1
   426ea:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   426ee:	f7ff fef1 	bl	424d4 <bus_fault.isra.0>
   426f2:	e7ed      	b.n	426d0 <z_arm_fault+0x120>
		} else if (SCB_UFSR != 0) {
   426f4:	4b22      	ldr	r3, [pc, #136]	; (42780 <z_arm_fault+0x1d0>)
   426f6:	881b      	ldrh	r3, [r3, #0]
   426f8:	b29b      	uxth	r3, r3
   426fa:	2b00      	cmp	r3, #0
   426fc:	d0b5      	beq.n	4266a <z_arm_fault+0xba>
		reason = usage_fault(esf);
   426fe:	f7ff fe19 	bl	42334 <usage_fault.isra.0>
   42702:	e7e5      	b.n	426d0 <z_arm_fault+0x120>
		reason = mem_manage_fault(esf, 0, recoverable);
   42704:	2000      	movs	r0, #0
   42706:	f10d 0107 	add.w	r1, sp, #7
   4270a:	e7df      	b.n	426cc <z_arm_fault+0x11c>
		reason = bus_fault(esf, 0, recoverable);
   4270c:	2000      	movs	r0, #0
   4270e:	f10d 0107 	add.w	r1, sp, #7
   42712:	e7ec      	b.n	426ee <z_arm_fault+0x13e>
   42714:	4912      	ldr	r1, [pc, #72]	; (42760 <z_arm_fault+0x1b0>)
   42716:	4b11      	ldr	r3, [pc, #68]	; (4275c <z_arm_fault+0x1ac>)
	PR_FAULT_INFO(
   42718:	481a      	ldr	r0, [pc, #104]	; (42784 <z_arm_fault+0x1d4>)
   4271a:	1ac9      	subs	r1, r1, r3
   4271c:	08c9      	lsrs	r1, r1, #3
   4271e:	0189      	lsls	r1, r1, #6
   42720:	f041 0101 	orr.w	r1, r1, #1
   42724:	e796      	b.n	42654 <z_arm_fault+0xa4>
   42726:	4a0d      	ldr	r2, [pc, #52]	; (4275c <z_arm_fault+0x1ac>)
   42728:	4b0d      	ldr	r3, [pc, #52]	; (42760 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** %s %d) *****",
   4272a:	4817      	ldr	r0, [pc, #92]	; (42788 <z_arm_fault+0x1d8>)
   4272c:	1a9b      	subs	r3, r3, r2
   4272e:	08db      	lsrs	r3, r3, #3
   42730:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   42734:	ea4f 1383 	mov.w	r3, r3, lsl #6
   42738:	4914      	ldr	r1, [pc, #80]	; (4278c <z_arm_fault+0x1dc>)
   4273a:	f043 0301 	orr.w	r3, r3, #1
   4273e:	bf18      	it	ne
   42740:	4601      	movne	r1, r0
   42742:	f1a6 0210 	sub.w	r2, r6, #16
   42746:	4812      	ldr	r0, [pc, #72]	; (42790 <z_arm_fault+0x1e0>)
   42748:	f005 facd 	bl	47ce6 <log_2>
   4274c:	e784      	b.n	42658 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   4274e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   42752:	f023 0301 	bic.w	r3, r3, #1
   42756:	e79a      	b.n	4268e <z_arm_fault+0xde>
   42758:	e000ed00 	.word	0xe000ed00
   4275c:	00049038 	.word	0x00049038
   42760:	00049068 	.word	0x00049068
   42764:	00049797 	.word	0x00049797
   42768:	000497ba 	.word	0x000497ba
   4276c:	000497d1 	.word	0x000497d1
   42770:	000497f2 	.word	0x000497f2
   42774:	00049800 	.word	0x00049800
   42778:	0004981f 	.word	0x0004981f
   4277c:	e000ed29 	.word	0xe000ed29
   42780:	e000ed2a 	.word	0xe000ed2a
   42784:	0004983b 	.word	0x0004983b
   42788:	00049874 	.word	0x00049874
   4278c:	0004985f 	.word	0x0004985f
   42790:	0004988d 	.word	0x0004988d

00042794 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   42794:	4b04      	ldr	r3, [pc, #16]	; (427a8 <z_arm_fault_init+0x14>)
   42796:	695a      	ldr	r2, [r3, #20]
   42798:	f042 0210 	orr.w	r2, r2, #16
   4279c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   4279e:	695a      	ldr	r2, [r3, #20]
   427a0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   427a4:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   427a6:	4770      	bx	lr
   427a8:	e000ed00 	.word	0xe000ed00

000427ac <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   427ac:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   427b0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   427b4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   427b6:	4672      	mov	r2, lr
	bl z_arm_fault
   427b8:	f7ff fefa 	bl	425b0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   427bc:	bd01      	pop	{r0, pc}
   427be:	bf00      	nop

000427c0 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   427c0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   427c2:	2120      	movs	r1, #32
   427c4:	4803      	ldr	r0, [pc, #12]	; (427d4 <z_arm_interrupt_init+0x14>)
   427c6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   427c8:	3301      	adds	r3, #1
   427ca:	2b41      	cmp	r3, #65	; 0x41
   427cc:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   427d0:	d1f9      	bne.n	427c6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   427d2:	4770      	bx	lr
   427d4:	e000e100 	.word	0xe000e100

000427d8 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   427d8:	2000      	movs	r0, #0
    msr CONTROL, r0
   427da:	f380 8814 	msr	CONTROL, r0
    isb
   427de:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   427e2:	2000      	movs	r0, #0
    msr MSPLIM, r0
   427e4:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   427e8:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   427ec:	f006 fab2 	bl	48d54 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   427f0:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   427f2:	490e      	ldr	r1, [pc, #56]	; (4282c <__start+0x54>)
    str r0, [r1]
   427f4:	6008      	str	r0, [r1, #0]
    dsb
   427f6:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   427fa:	480d      	ldr	r0, [pc, #52]	; (42830 <__start+0x58>)
    msr msp, r0
   427fc:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   42800:	f000 f82a 	bl	42858 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   42804:	2020      	movs	r0, #32
    msr BASEPRI, r0
   42806:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   4280a:	480a      	ldr	r0, [pc, #40]	; (42834 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   4280c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   42810:	1840      	adds	r0, r0, r1
    msr PSP, r0
   42812:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   42816:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   4281a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   4281c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   4281e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   42822:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   42826:	f7ff fcaf 	bl	42188 <z_arm_prep_c>
   4282a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   4282c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42830:	20023240 	.word	0x20023240
    ldr r0, =z_interrupt_stacks
   42834:	20023380 	.word	0x20023380

00042838 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   42838:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   4283a:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   4283c:	4a05      	ldr	r2, [pc, #20]	; (42854 <z_arm_clear_arm_mpu_config+0x1c>)
   4283e:	6811      	ldr	r1, [r2, #0]
	int num_regions =
   42840:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
   42844:	428b      	cmp	r3, r1
   42846:	d100      	bne.n	4284a <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
   42848:	4770      	bx	lr
  mpu->RNR = rnr;
   4284a:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   4284c:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
   4284e:	3301      	adds	r3, #1
   42850:	e7f8      	b.n	42844 <z_arm_clear_arm_mpu_config+0xc>
   42852:	bf00      	nop
   42854:	e000ed90 	.word	0xe000ed90

00042858 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
   42858:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   4285a:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   4285c:	2400      	movs	r4, #0
   4285e:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   42862:	f7ff ffe9 	bl	42838 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   42866:	4a0e      	ldr	r2, [pc, #56]	; (428a0 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
   42868:	4623      	mov	r3, r4
   4286a:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
   4286c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   42870:	f103 0020 	add.w	r0, r3, #32
   42874:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   42876:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   42878:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   4287c:	d1f8      	bne.n	42870 <z_arm_init_arch_hw_at_boot+0x18>
   4287e:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   42880:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42884:	f103 0260 	add.w	r2, r3, #96	; 0x60
   42888:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   4288a:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   4288c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   42890:	d1f8      	bne.n	42884 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   42892:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   42894:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42898:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   4289c:	bd10      	pop	{r4, pc}
   4289e:	bf00      	nop
   428a0:	e000e100 	.word	0xe000e100

000428a4 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   428a4:	4b06      	ldr	r3, [pc, #24]	; (428c0 <z_impl_k_thread_abort+0x1c>)
   428a6:	689b      	ldr	r3, [r3, #8]
   428a8:	4283      	cmp	r3, r0
   428aa:	d107      	bne.n	428bc <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   428ac:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   428b0:	b123      	cbz	r3, 428bc <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   428b2:	4a04      	ldr	r2, [pc, #16]	; (428c4 <z_impl_k_thread_abort+0x20>)
   428b4:	6853      	ldr	r3, [r2, #4]
   428b6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   428ba:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   428bc:	f004 bac4 	b.w	46e48 <z_thread_abort>
   428c0:	2001ada0 	.word	0x2001ada0
   428c4:	e000ed00 	.word	0xe000ed00

000428c8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   428c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   428ca:	4c09      	ldr	r4, [pc, #36]	; (428f0 <z_arm_configure_static_mpu_regions+0x28>)
   428cc:	4a09      	ldr	r2, [pc, #36]	; (428f4 <z_arm_configure_static_mpu_regions+0x2c>)
   428ce:	4623      	mov	r3, r4
   428d0:	2101      	movs	r1, #1
   428d2:	4809      	ldr	r0, [pc, #36]	; (428f8 <z_arm_configure_static_mpu_regions+0x30>)
   428d4:	f000 f912 	bl	42afc <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   428d8:	2300      	movs	r3, #0
   428da:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   428dc:	4b07      	ldr	r3, [pc, #28]	; (428fc <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   428de:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   428e0:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   428e2:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   428e4:	9301      	str	r3, [sp, #4]
   428e6:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   428e8:	f000 f912 	bl	42b10 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   428ec:	b004      	add	sp, #16
   428ee:	bd10      	pop	{r4, pc}
   428f0:	20040000 	.word	0x20040000
   428f4:	2001a500 	.word	0x2001a500
   428f8:	0004916c 	.word	0x0004916c
   428fc:	2001a690 	.word	0x2001a690

00042900 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   42900:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42902:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   42904:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42906:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   4290a:	f004 031f 	and.w	r3, r4, #31
   4290e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42910:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42912:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42914:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   42918:	4904      	ldr	r1, [pc, #16]	; (4292c <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   4291a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   4291e:	f043 0301 	orr.w	r3, r3, #1
   42922:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   42924:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   42926:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   42928:	bd10      	pop	{r4, pc}
   4292a:	bf00      	nop
   4292c:	e000ed90 	.word	0xe000ed90

00042930 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   42930:	280f      	cmp	r0, #15
{
   42932:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
   42934:	d90d      	bls.n	42952 <region_allocate_and_init+0x22>
   42936:	4b08      	ldr	r3, [pc, #32]	; (42958 <region_allocate_and_init+0x28>)
   42938:	4a08      	ldr	r2, [pc, #32]	; (4295c <region_allocate_and_init+0x2c>)

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   4293a:	4601      	mov	r1, r0
   4293c:	1ad2      	subs	r2, r2, r3
   4293e:	08d2      	lsrs	r2, r2, #3
   42940:	0192      	lsls	r2, r2, #6
   42942:	4807      	ldr	r0, [pc, #28]	; (42960 <region_allocate_and_init+0x30>)
   42944:	f042 0201 	orr.w	r2, r2, #1
   42948:	f005 f9b9 	bl	47cbe <log_1>
		return -EINVAL;
   4294c:	f06f 0015 	mvn.w	r0, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   42950:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   42952:	f7ff ffd5 	bl	42900 <region_init>
	return index;
   42956:	e7fb      	b.n	42950 <region_allocate_and_init+0x20>
   42958:	00049038 	.word	0x00049038
   4295c:	00049058 	.word	0x00049058
   42960:	000498a4 	.word	0x000498a4

00042964 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42964:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42968:	4689      	mov	r9, r1
   4296a:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   4296c:	4606      	mov	r6, r0
   4296e:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
   42972:	4d54      	ldr	r5, [pc, #336]	; (42ac4 <mpu_configure_regions_and_partition.constprop.0+0x160>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42974:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   42976:	45c8      	cmp	r8, r9
   42978:	da33      	bge.n	429e2 <mpu_configure_regions_and_partition.constprop.0+0x7e>
		if (regions[i].size == 0U) {
   4297a:	f8d6 a004 	ldr.w	sl, [r6, #4]
   4297e:	f1ba 0f00 	cmp.w	sl, #0
   42982:	d04d      	beq.n	42a20 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		&&
   42984:	f1ba 0f1f 	cmp.w	sl, #31
   42988:	d91e      	bls.n	429c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		&&
   4298a:	f01a 0f1f 	tst.w	sl, #31
   4298e:	d11b      	bne.n	429c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
		((part->start &
   42990:	f8d6 b000 	ldr.w	fp, [r6]
		&&
   42994:	f01b 0f1f 	tst.w	fp, #31
   42998:	d116      	bne.n	429c8 <mpu_configure_regions_and_partition.constprop.0+0x64>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   4299a:	4658      	mov	r0, fp
   4299c:	f005 fc1b 	bl	481d6 <arm_cmse_mpu_region_get>
   429a0:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   429a2:	eb0a 000b 	add.w	r0, sl, fp
   429a6:	3801      	subs	r0, #1
   429a8:	f005 fc15 	bl	481d6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   429ac:	4287      	cmp	r7, r0
   429ae:	d01c      	beq.n	429ea <mpu_configure_regions_and_partition.constprop.0+0x86>
	return -EINVAL;
   429b0:	f06f 0715 	mvn.w	r7, #21
   429b4:	4a44      	ldr	r2, [pc, #272]	; (42ac8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   429b6:	4b45      	ldr	r3, [pc, #276]	; (42acc <mpu_configure_regions_and_partition.constprop.0+0x168>)
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   429b8:	4639      	mov	r1, r7
   429ba:	1ad2      	subs	r2, r2, r3
   429bc:	08d2      	lsrs	r2, r2, #3
   429be:	0192      	lsls	r2, r2, #6
   429c0:	4843      	ldr	r0, [pc, #268]	; (42ad0 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
   429c2:	f042 0201 	orr.w	r2, r2, #1
   429c6:	e008      	b.n	429da <mpu_configure_regions_and_partition.constprop.0+0x76>
			LOG_ERR("Partition %u: sanity check failed.", i);
   429c8:	4641      	mov	r1, r8
   429ca:	4a3f      	ldr	r2, [pc, #252]	; (42ac8 <mpu_configure_regions_and_partition.constprop.0+0x164>)
   429cc:	4b3f      	ldr	r3, [pc, #252]	; (42acc <mpu_configure_regions_and_partition.constprop.0+0x168>)
   429ce:	4841      	ldr	r0, [pc, #260]	; (42ad4 <mpu_configure_regions_and_partition.constprop.0+0x170>)
   429d0:	1ad2      	subs	r2, r2, r3
   429d2:	08d2      	lsrs	r2, r2, #3
   429d4:	0192      	lsls	r2, r2, #6
   429d6:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
   429da:	f005 f970 	bl	47cbe <log_1>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   429de:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   429e2:	4620      	mov	r0, r4
   429e4:	b005      	add	sp, #20
   429e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   429ea:	f117 0f16 	cmn.w	r7, #22
   429ee:	d0e1      	beq.n	429b4 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
   429f0:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   429f2:	42bb      	cmp	r3, r7
   429f4:	dbde      	blt.n	429b4 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
   429f6:	60af      	str	r7, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   429f8:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   429fa:	60af      	str	r7, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   429fc:	692b      	ldr	r3, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   429fe:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42a02:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42a06:	e9d6 3200 	ldrd	r3, r2, [r6]
   42a0a:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   42a0c:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42a0e:	f102 3aff 	add.w	sl, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   42a12:	d11a      	bne.n	42a4a <mpu_configure_regions_and_partition.constprop.0+0xe6>
   42a14:	45d3      	cmp	fp, sl
   42a16:	d107      	bne.n	42a28 <mpu_configure_regions_and_partition.constprop.0+0xc4>
			mpu_configure_region(u_reg_index, &regions[i]);
   42a18:	4631      	mov	r1, r6
   42a1a:	b2f8      	uxtb	r0, r7
   42a1c:	f005 fbe4 	bl	481e8 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   42a20:	f108 0801 	add.w	r8, r8, #1
   42a24:	360c      	adds	r6, #12
   42a26:	e7a6      	b.n	42976 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   42a28:	4631      	mov	r1, r6
	MPU->RNR = index;
   42a2a:	60af      	str	r7, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42a2c:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   42a2e:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42a32:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   42a36:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42a38:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   42a3a:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   42a3c:	f005 fbd4 	bl	481e8 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42a40:	f110 0f16 	cmn.w	r0, #22
   42a44:	d0cb      	beq.n	429de <mpu_configure_regions_and_partition.constprop.0+0x7a>
			reg_index++;
   42a46:	1c44      	adds	r4, r0, #1
   42a48:	e7ea      	b.n	42a20 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		} else if (reg_last == u_reg_last) {
   42a4a:	3b01      	subs	r3, #1
   42a4c:	45d3      	cmp	fp, sl
   42a4e:	b2e0      	uxtb	r0, r4
   42a50:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   42a54:	60af      	str	r7, [r5, #8]
		} else if (reg_last == u_reg_last) {
   42a56:	d106      	bne.n	42a66 <mpu_configure_regions_and_partition.constprop.0+0x102>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42a58:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42a5a:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42a5c:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42a60:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42a62:	612b      	str	r3, [r5, #16]
			reg_index =
   42a64:	e7ea      	b.n	42a3c <mpu_configure_regions_and_partition.constprop.0+0xd8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42a66:	6929      	ldr	r1, [r5, #16]
   42a68:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42a6c:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42a6e:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42a70:	4631      	mov	r1, r6
   42a72:	f005 fbb9 	bl	481e8 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42a76:	f110 0f16 	cmn.w	r0, #22
   42a7a:	d0b0      	beq.n	429de <mpu_configure_regions_and_partition.constprop.0+0x7a>
	MPU->RNR = index;
   42a7c:	60af      	str	r7, [r5, #8]
	attr->rbar = MPU->RBAR &
   42a7e:	68ea      	ldr	r2, [r5, #12]
   42a80:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   42a84:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
	attr->rbar = MPU->RBAR &
   42a88:	f362 0304 	bfi	r3, r2, #0, #5
   42a8c:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42a90:	692b      	ldr	r3, [r5, #16]
   42a92:	f89d 2008 	ldrb.w	r2, [sp, #8]
   42a96:	085b      	lsrs	r3, r3, #1
   42a98:	f363 1247 	bfi	r2, r3, #5, #3
   42a9c:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   42aa0:	e9d6 3200 	ldrd	r3, r2, [r6]
   42aa4:	4413      	add	r3, r2
   42aa6:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   42aa8:	f023 031f 	bic.w	r3, r3, #31
   42aac:	445b      	add	r3, fp
   42aae:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
   42ab2:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   42ab4:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   42ab8:	4669      	mov	r1, sp
   42aba:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   42abc:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   42abe:	f7ff ff37 	bl	42930 <region_allocate_and_init>
   42ac2:	e7bd      	b.n	42a40 <mpu_configure_regions_and_partition.constprop.0+0xdc>
   42ac4:	e000ed90 	.word	0xe000ed90
   42ac8:	00049058 	.word	0x00049058
   42acc:	00049038 	.word	0x00049038
   42ad0:	000498ed 	.word	0x000498ed
   42ad4:	000498ca 	.word	0x000498ca

00042ad8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   42ad8:	2205      	movs	r2, #5
   42ada:	4b03      	ldr	r3, [pc, #12]	; (42ae8 <arm_core_mpu_enable+0x10>)
   42adc:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   42ade:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42ae2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   42ae6:	4770      	bx	lr
   42ae8:	e000ed90 	.word	0xe000ed90

00042aec <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   42aec:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   42af0:	2200      	movs	r2, #0
   42af2:	4b01      	ldr	r3, [pc, #4]	; (42af8 <arm_core_mpu_disable+0xc>)
   42af4:	605a      	str	r2, [r3, #4]
}
   42af6:	4770      	bx	lr
   42af8:	e000ed90 	.word	0xe000ed90

00042afc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   42afc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   42afe:	4c03      	ldr	r4, [pc, #12]	; (42b0c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   42b00:	7822      	ldrb	r2, [r4, #0]
   42b02:	f7ff ff2f 	bl	42964 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   42b06:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   42b08:	bd10      	pop	{r4, pc}
   42b0a:	bf00      	nop
   42b0c:	2001adfc 	.word	0x2001adfc

00042b10 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   42b10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42b14:	4d26      	ldr	r5, [pc, #152]	; (42bb0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   42b16:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42b18:	4606      	mov	r6, r0
   42b1a:	f04f 0800 	mov.w	r8, #0
   42b1e:	46ab      	mov	fp, r5
	MPU->RNR = index;
   42b20:	4f24      	ldr	r7, [pc, #144]	; (42bb4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42b22:	45d0      	cmp	r8, sl
   42b24:	da1b      	bge.n	42b5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   42b26:	f8d6 9004 	ldr.w	r9, [r6, #4]
   42b2a:	f1b9 0f00 	cmp.w	r9, #0
   42b2e:	d039      	beq.n	42ba4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   42b30:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42b32:	4608      	mov	r0, r1
   42b34:	9101      	str	r1, [sp, #4]
   42b36:	f005 fb4e 	bl	481d6 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42b3a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42b3c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42b3e:	eb09 0001 	add.w	r0, r9, r1
   42b42:	3801      	subs	r0, #1
   42b44:	f005 fb47 	bl	481d6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   42b48:	4284      	cmp	r4, r0
   42b4a:	f04f 0214 	mov.w	r2, #20
   42b4e:	4b1a      	ldr	r3, [pc, #104]	; (42bb8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   42b50:	d008      	beq.n	42b64 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   42b52:	f06f 0315 	mvn.w	r3, #21
   42b56:	fb02 f808 	mul.w	r8, r2, r8
   42b5a:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   42b5e:	b003      	add	sp, #12
   42b60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   42b64:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   42b68:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   42b6a:	d0f8      	beq.n	42b5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   42b6c:	7819      	ldrb	r1, [r3, #0]
   42b6e:	42a1      	cmp	r1, r4
   42b70:	ddf5      	ble.n	42b5e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   42b72:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   42b76:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   42b78:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   42b7a:	68fc      	ldr	r4, [r7, #12]
   42b7c:	f100 0108 	add.w	r1, r0, #8
   42b80:	7b00      	ldrb	r0, [r0, #12]
   42b82:	f364 0004 	bfi	r0, r4, #0, #5
   42b86:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42b88:	6938      	ldr	r0, [r7, #16]
   42b8a:	790c      	ldrb	r4, [r1, #4]
   42b8c:	0840      	lsrs	r0, r0, #1
   42b8e:	f360 1447 	bfi	r4, r0, #5, #3
   42b92:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   42b94:	68f9      	ldr	r1, [r7, #12]
   42b96:	f021 011f 	bic.w	r1, r1, #31
   42b9a:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   42b9c:	6939      	ldr	r1, [r7, #16]
   42b9e:	f021 011f 	bic.w	r1, r1, #31
   42ba2:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42ba4:	f108 0801 	add.w	r8, r8, #1
   42ba8:	3514      	adds	r5, #20
   42baa:	360c      	adds	r6, #12
   42bac:	e7b9      	b.n	42b22 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   42bae:	bf00      	nop
   42bb0:	2001a92c 	.word	0x2001a92c
   42bb4:	e000ed90 	.word	0xe000ed90
   42bb8:	2001adfc 	.word	0x2001adfc

00042bbc <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   42bbc:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   42bbe:	4c0e      	ldr	r4, [pc, #56]	; (42bf8 <z_arm_mpu_init+0x3c>)
   42bc0:	6825      	ldr	r5, [r4, #0]
   42bc2:	2d10      	cmp	r5, #16
   42bc4:	d814      	bhi.n	42bf0 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   42bc6:	f7ff ff91 	bl	42aec <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42bca:	2000      	movs	r0, #0
	MPU->MAIR0 =
   42bcc:	4b0b      	ldr	r3, [pc, #44]	; (42bfc <z_arm_mpu_init+0x40>)
   42bce:	4a0c      	ldr	r2, [pc, #48]	; (42c00 <z_arm_mpu_init+0x44>)
   42bd0:	631a      	str	r2, [r3, #48]	; 0x30
   42bd2:	4285      	cmp	r5, r0
   42bd4:	d105      	bne.n	42be2 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   42bd6:	4b0b      	ldr	r3, [pc, #44]	; (42c04 <z_arm_mpu_init+0x48>)
   42bd8:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   42bda:	f7ff ff7d 	bl	42ad8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   42bde:	2000      	movs	r0, #0
}
   42be0:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   42be2:	6861      	ldr	r1, [r4, #4]
   42be4:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   42be8:	f7ff fe8a 	bl	42900 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42bec:	3001      	adds	r0, #1
   42bee:	e7f0      	b.n	42bd2 <z_arm_mpu_init+0x16>
		return -1;
   42bf0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42bf4:	e7f4      	b.n	42be0 <z_arm_mpu_init+0x24>
   42bf6:	bf00      	nop
   42bf8:	00049178 	.word	0x00049178
   42bfc:	e000ed90 	.word	0xe000ed90
   42c00:	0044ffaa 	.word	0x0044ffaa
   42c04:	2001adfc 	.word	0x2001adfc

00042c08 <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   42c08:	b508      	push	{r3, lr}
   42c0a:	4908      	ldr	r1, [pc, #32]	; (42c2c <malloc+0x24>)
   42c0c:	4b08      	ldr	r3, [pc, #32]	; (42c30 <malloc+0x28>)
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
   42c0e:	4809      	ldr	r0, [pc, #36]	; (42c34 <malloc+0x2c>)
   42c10:	1ac9      	subs	r1, r1, r3
   42c12:	08c9      	lsrs	r1, r1, #3
   42c14:	0189      	lsls	r1, r1, #6
   42c16:	f041 0101 	orr.w	r1, r1, #1
   42c1a:	f005 f843 	bl	47ca4 <log_0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   42c1e:	f003 fac7 	bl	461b0 <z_impl_z_errno>
	errno = ENOMEM;
   42c22:	230c      	movs	r3, #12
   42c24:	6003      	str	r3, [r0, #0]

	return NULL;
}
   42c26:	2000      	movs	r0, #0
   42c28:	bd08      	pop	{r3, pc}
   42c2a:	bf00      	nop
   42c2c:	00049068 	.word	0x00049068
   42c30:	00049038 	.word	0x00049038
   42c34:	00049910 	.word	0x00049910

00042c38 <_exit>:

#include <stdlib.h>
#include <zephyr.h>

void _exit(int status)
{
   42c38:	b508      	push	{r3, lr}
	printk("exit\n");
   42c3a:	4802      	ldr	r0, [pc, #8]	; (42c44 <_exit+0xc>)
   42c3c:	f004 fcdb 	bl	475f6 <printk>
	while (1) {
   42c40:	e7fe      	b.n	42c40 <_exit+0x8>
   42c42:	bf00      	nop
   42c44:	0004993b 	.word	0x0004993b

00042c48 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   42c48:	4b01      	ldr	r3, [pc, #4]	; (42c50 <__stdout_hook_install+0x8>)
   42c4a:	6018      	str	r0, [r3, #0]
}
   42c4c:	4770      	bx	lr
   42c4e:	bf00      	nop
   42c50:	2001a574 	.word	0x2001a574

00042c54 <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
   42c54:	3902      	subs	r1, #2
   42c56:	2901      	cmp	r1, #1
   42c58:	d802      	bhi.n	42c60 <z_impl_zephyr_fputc+0xc>
   42c5a:	4b03      	ldr	r3, [pc, #12]	; (42c68 <z_impl_zephyr_fputc+0x14>)
   42c5c:	681b      	ldr	r3, [r3, #0]
   42c5e:	4718      	bx	r3
}
   42c60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42c64:	4770      	bx	lr
   42c66:	bf00      	nop
   42c68:	2001a574 	.word	0x2001a574

00042c6c <sprintf>:
	*(p.ptr) = 0;
	return r;
}

int sprintf(char *ZRESTRICT str, const char *ZRESTRICT format, ...)
{
   42c6c:	b40e      	push	{r1, r2, r3}
   42c6e:	b50f      	push	{r0, r1, r2, r3, lr}

	struct emitter p;
	int     r;

	p.ptr = str;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   42c70:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
   42c74:	ab05      	add	r3, sp, #20
   42c76:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = str;
   42c7a:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   42c7c:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
   42c7e:	4806      	ldr	r0, [pc, #24]	; (42c98 <sprintf+0x2c>)
   42c80:	a902      	add	r1, sp, #8
	va_start(vargs, format);
   42c82:	9301      	str	r3, [sp, #4]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
   42c84:	f7fd ff2a 	bl	40adc <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
   42c88:	2200      	movs	r2, #0
   42c8a:	9b02      	ldr	r3, [sp, #8]
   42c8c:	701a      	strb	r2, [r3, #0]
	return r;
}
   42c8e:	b004      	add	sp, #16
   42c90:	f85d eb04 	ldr.w	lr, [sp], #4
   42c94:	b003      	add	sp, #12
   42c96:	4770      	bx	lr
   42c98:	000482fd 	.word	0x000482fd

00042c9c <printf>:

	return r;
}

int printf(const char *ZRESTRICT format, ...)
{
   42c9c:	b40f      	push	{r0, r1, r2, r3}
   42c9e:	b507      	push	{r0, r1, r2, lr}
   42ca0:	ab04      	add	r3, sp, #16
   42ca2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   42ca6:	2102      	movs	r1, #2
   42ca8:	4804      	ldr	r0, [pc, #16]	; (42cbc <printf+0x20>)
	va_start(vargs, format);
   42caa:	9301      	str	r3, [sp, #4]
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   42cac:	f7fd ff16 	bl	40adc <cbvprintf>
	va_end(vargs);

	return r;
}
   42cb0:	b003      	add	sp, #12
   42cb2:	f85d eb04 	ldr.w	lr, [sp], #4
   42cb6:	b004      	add	sp, #16
   42cb8:	4770      	bx	lr
   42cba:	bf00      	nop
   42cbc:	000482f9 	.word	0x000482f9

00042cc0 <onoff_stop>:
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42cc0:	b570      	push	{r4, r5, r6, lr}
   42cc2:	4604      	mov	r4, r0
	err = set_off_state(&subdata->flags, ctx);
   42cc4:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   42cc6:	480d      	ldr	r0, [pc, #52]	; (42cfc <onoff_stop+0x3c>)
{
   42cc8:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
   42cca:	1a23      	subs	r3, r4, r0
   42ccc:	109a      	asrs	r2, r3, #2
   42cce:	4b0c      	ldr	r3, [pc, #48]	; (42d00 <onoff_stop+0x40>)
	err = set_off_state(&subdata->flags, ctx);
   42cd0:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   42cd2:	4353      	muls	r3, r2
   42cd4:	b2db      	uxtb	r3, r3
	err = set_off_state(&subdata->flags, ctx);
   42cd6:	435d      	muls	r5, r3
   42cd8:	f105 0340 	add.w	r3, r5, #64	; 0x40
   42cdc:	4418      	add	r0, r3
   42cde:	f005 fb23 	bl	48328 <set_off_state>
	if (err < 0) {
   42ce2:	1e01      	subs	r1, r0, #0
   42ce4:	db04      	blt.n	42cf0 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   42ce6:	4b07      	ldr	r3, [pc, #28]	; (42d04 <onoff_stop+0x44>)
   42ce8:	442b      	add	r3, r5
   42cea:	685b      	ldr	r3, [r3, #4]
   42cec:	4798      	blx	r3
	return 0;
   42cee:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   42cf0:	4620      	mov	r0, r4
   42cf2:	4633      	mov	r3, r6
}
   42cf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   42cf8:	4718      	bx	r3
   42cfa:	bf00      	nop
   42cfc:	2001a950 	.word	0x2001a950
   42d00:	b6db6db7 	.word	0xb6db6db7
   42d04:	000491b8 	.word	0x000491b8

00042d08 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   42d08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   42d0c:	4c0f      	ldr	r4, [pc, #60]	; (42d4c <onoff_start+0x44>)
   42d0e:	4d10      	ldr	r5, [pc, #64]	; (42d50 <onoff_start+0x48>)
   42d10:	1b03      	subs	r3, r0, r4
   42d12:	109b      	asrs	r3, r3, #2
   42d14:	435d      	muls	r5, r3
   42d16:	b2eb      	uxtb	r3, r5
	err = set_starting_state(&subdata->flags, ctx);
   42d18:	250c      	movs	r5, #12
   42d1a:	435d      	muls	r5, r3
{
   42d1c:	4607      	mov	r7, r0
	err = set_starting_state(&subdata->flags, ctx);
   42d1e:	f105 0040 	add.w	r0, r5, #64	; 0x40
{
   42d22:	460e      	mov	r6, r1
	err = set_starting_state(&subdata->flags, ctx);
   42d24:	4420      	add	r0, r4
   42d26:	2140      	movs	r1, #64	; 0x40
   42d28:	f005 fb17 	bl	4835a <set_starting_state>
	if (err < 0) {
   42d2c:	1e01      	subs	r1, r0, #0
   42d2e:	db08      	blt.n	42d42 <onoff_start+0x3a>
	subdata->cb = cb;
   42d30:	4b08      	ldr	r3, [pc, #32]	; (42d54 <onoff_start+0x4c>)
   42d32:	442c      	add	r4, r5
	subdata->user_data = user_data;
   42d34:	e9c4 360e 	strd	r3, r6, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   42d38:	4b07      	ldr	r3, [pc, #28]	; (42d58 <onoff_start+0x50>)
   42d3a:	595b      	ldr	r3, [r3, r5]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   42d3c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   42d40:	4718      	bx	r3
		notify(mgr, err);
   42d42:	4638      	mov	r0, r7
   42d44:	4633      	mov	r3, r6
}
   42d46:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   42d4a:	4718      	bx	r3
   42d4c:	2001a950 	.word	0x2001a950
   42d50:	b6db6db7 	.word	0xb6db6db7
   42d54:	000483bd 	.word	0x000483bd
   42d58:	000491b8 	.word	0x000491b8

00042d5c <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   42d5c:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42d5e:	2200      	movs	r2, #0
   42d60:	2101      	movs	r1, #1
{
   42d62:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   42d64:	2005      	movs	r0, #5
   42d66:	f7ff f9e7 	bl	42138 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   42d6a:	2005      	movs	r0, #5
   42d6c:	f7ff f9c6 	bl	420fc <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   42d70:	480f      	ldr	r0, [pc, #60]	; (42db0 <clk_init+0x54>)
   42d72:	f001 f8ef 	bl	43f54 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   42d76:	4b0f      	ldr	r3, [pc, #60]	; (42db4 <clk_init+0x58>)
   42d78:	4298      	cmp	r0, r3
   42d7a:	d115      	bne.n	42da8 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   42d7c:	f005 fc58 	bl	48630 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   42d80:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   42d82:	490d      	ldr	r1, [pc, #52]	; (42db8 <clk_init+0x5c>)
   42d84:	4630      	mov	r0, r6
   42d86:	f004 fc9f 	bl	476c8 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   42d8a:	2800      	cmp	r0, #0
   42d8c:	db0b      	blt.n	42da6 <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42d8e:	2501      	movs	r5, #1
   42d90:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   42d92:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   42d94:	4908      	ldr	r1, [pc, #32]	; (42db8 <clk_init+0x5c>)
   42d96:	f104 001c 	add.w	r0, r4, #28
   42d9a:	f004 fc95 	bl	476c8 <onoff_manager_init>
		if (err < 0) {
   42d9e:	2800      	cmp	r0, #0
   42da0:	db01      	blt.n	42da6 <clk_init+0x4a>
	}

	return 0;
   42da2:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   42da4:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   42da6:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   42da8:	f06f 0004 	mvn.w	r0, #4
   42dac:	e7fb      	b.n	42da6 <clk_init+0x4a>
   42dae:	bf00      	nop
   42db0:	00042df1 	.word	0x00042df1
   42db4:	0bad0000 	.word	0x0bad0000
   42db8:	000491d0 	.word	0x000491d0

00042dbc <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   42dbc:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   42dbe:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   42dc0:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   42dc2:	434b      	muls	r3, r1
   42dc4:	4808      	ldr	r0, [pc, #32]	; (42de8 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   42dc6:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   42dc8:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   42dca:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   42dcc:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42dd0:	4418      	add	r0, r3
	sub_data->cb = NULL;
   42dd2:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   42dd4:	f005 fadf 	bl	48396 <set_on_state>
	if (callback) {
   42dd8:	b12d      	cbz	r5, 42de6 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   42dda:	4632      	mov	r2, r6
   42ddc:	462b      	mov	r3, r5
}
   42dde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   42de2:	4802      	ldr	r0, [pc, #8]	; (42dec <clkstarted_handle.constprop.0+0x30>)
   42de4:	4718      	bx	r3
}
   42de6:	bd70      	pop	{r4, r5, r6, pc}
   42de8:	2001a950 	.word	0x2001a950
   42dec:	00048dd0 	.word	0x00048dd0

00042df0 <clock_event_handler>:
	switch (event) {
   42df0:	b110      	cbz	r0, 42df8 <clock_event_handler+0x8>
   42df2:	2801      	cmp	r0, #1
   42df4:	d004      	beq.n	42e00 <clock_event_handler+0x10>
   42df6:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   42df8:	4b03      	ldr	r3, [pc, #12]	; (42e08 <clock_event_handler+0x18>)
   42dfa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   42dfc:	075b      	lsls	r3, r3, #29
   42dfe:	d101      	bne.n	42e04 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   42e00:	f7ff bfdc 	b.w	42dbc <clkstarted_handle.constprop.0>
}
   42e04:	4770      	bx	lr
   42e06:	bf00      	nop
   42e08:	2001a950 	.word	0x2001a950

00042e0c <generic_hfclk_start>:
{
   42e0c:	b508      	push	{r3, lr}
	__asm__ volatile(
   42e0e:	f04f 0320 	mov.w	r3, #32
   42e12:	f3ef 8111 	mrs	r1, BASEPRI
   42e16:	f383 8812 	msr	BASEPRI_MAX, r3
   42e1a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   42e1e:	4a11      	ldr	r2, [pc, #68]	; (42e64 <generic_hfclk_start+0x58>)
   42e20:	6813      	ldr	r3, [r2, #0]
   42e22:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   42e26:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   42e2a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   42e2c:	d00b      	beq.n	42e46 <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   42e2e:	4a0e      	ldr	r2, [pc, #56]	; (42e68 <generic_hfclk_start+0x5c>)
   42e30:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   42e34:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   42e38:	f013 0301 	ands.w	r3, r3, #1
   42e3c:	d003      	beq.n	42e46 <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   42e3e:	480b      	ldr	r0, [pc, #44]	; (42e6c <generic_hfclk_start+0x60>)
   42e40:	f005 faa9 	bl	48396 <set_on_state>
			already_started = true;
   42e44:	2301      	movs	r3, #1
	__asm__ volatile(
   42e46:	f381 8811 	msr	BASEPRI, r1
   42e4a:	f3bf 8f6f 	isb	sy
	if (already_started) {
   42e4e:	b123      	cbz	r3, 42e5a <generic_hfclk_start+0x4e>
}
   42e50:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   42e54:	2000      	movs	r0, #0
   42e56:	f7ff bfb1 	b.w	42dbc <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   42e5a:	2001      	movs	r0, #1
}
   42e5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   42e60:	f001 b888 	b.w	43f74 <nrfx_clock_start>
   42e64:	2001a9a0 	.word	0x2001a9a0
   42e68:	40005000 	.word	0x40005000
   42e6c:	2001a990 	.word	0x2001a990

00042e70 <generic_hfclk_stop>:
   42e70:	4b07      	ldr	r3, [pc, #28]	; (42e90 <generic_hfclk_stop+0x20>)
   42e72:	e8d3 2fef 	ldaex	r2, [r3]
   42e76:	f022 0102 	bic.w	r1, r2, #2
   42e7a:	e8c3 1fe0 	stlex	r0, r1, [r3]
   42e7e:	2800      	cmp	r0, #0
   42e80:	d1f7      	bne.n	42e72 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   42e82:	07d3      	lsls	r3, r2, #31
   42e84:	d402      	bmi.n	42e8c <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   42e86:	2001      	movs	r0, #1
   42e88:	f001 b8a6 	b.w	43fd8 <nrfx_clock_stop>
}
   42e8c:	4770      	bx	lr
   42e8e:	bf00      	nop
   42e90:	2001a9a0 	.word	0x2001a9a0

00042e94 <api_blocking_start>:
{
   42e94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42e96:	2200      	movs	r2, #0
   42e98:	2301      	movs	r3, #1
   42e9a:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42e9e:	466b      	mov	r3, sp
   42ea0:	4a08      	ldr	r2, [pc, #32]	; (42ec4 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   42ea2:	f8cd d000 	str.w	sp, [sp]
   42ea6:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   42eaa:	f005 faad 	bl	48408 <api_start>
	if (err < 0) {
   42eae:	2800      	cmp	r0, #0
   42eb0:	db05      	blt.n	42ebe <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   42eb2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   42eb6:	2300      	movs	r3, #0
   42eb8:	4668      	mov	r0, sp
   42eba:	f003 fca5 	bl	46808 <z_impl_k_sem_take>
}
   42ebe:	b005      	add	sp, #20
   42ec0:	f85d fb04 	ldr.w	pc, [sp], #4
   42ec4:	000483db 	.word	0x000483db

00042ec8 <z_nrf_clock_control_lf_on>:
{
   42ec8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   42ecc:	2201      	movs	r2, #1
   42ece:	4607      	mov	r7, r0
   42ed0:	4936      	ldr	r1, [pc, #216]	; (42fac <z_nrf_clock_control_lf_on+0xe4>)
   42ed2:	e8d1 3fef 	ldaex	r3, [r1]
   42ed6:	e8c1 2fe0 	stlex	r0, r2, [r1]
   42eda:	2800      	cmp	r0, #0
   42edc:	d1f9      	bne.n	42ed2 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   42ede:	b933      	cbnz	r3, 42eee <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   42ee0:	4933      	ldr	r1, [pc, #204]	; (42fb0 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   42ee2:	4834      	ldr	r0, [pc, #208]	; (42fb4 <z_nrf_clock_control_lf_on+0xec>)
   42ee4:	604b      	str	r3, [r1, #4]
   42ee6:	60cb      	str	r3, [r1, #12]
   42ee8:	608a      	str	r2, [r1, #8]
   42eea:	f004 fc00 	bl	476ee <onoff_request>
	switch (start_mode) {
   42eee:	1e7b      	subs	r3, r7, #1
   42ef0:	2b01      	cmp	r3, #1
   42ef2:	d82e      	bhi.n	42f52 <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   42ef4:	2f01      	cmp	r7, #1
   42ef6:	d106      	bne.n	42f06 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   42ef8:	4b2f      	ldr	r3, [pc, #188]	; (42fb8 <z_nrf_clock_control_lf_on+0xf0>)
   42efa:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   42efe:	f003 0303 	and.w	r3, r3, #3
   42f02:	2b02      	cmp	r3, #2
   42f04:	d025      	beq.n	42f52 <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   42f06:	f005 fd59 	bl	489bc <k_is_in_isr>
   42f0a:	4604      	mov	r4, r0
   42f0c:	b918      	cbnz	r0, 42f16 <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   42f0e:	4b2b      	ldr	r3, [pc, #172]	; (42fbc <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   42f10:	781b      	ldrb	r3, [r3, #0]
   42f12:	2b00      	cmp	r3, #0
   42f14:	d144      	bne.n	42fa0 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   42f16:	f04f 0320 	mov.w	r3, #32
   42f1a:	f3ef 8611 	mrs	r6, BASEPRI
   42f1e:	f383 8812 	msr	BASEPRI_MAX, r3
   42f22:	f3bf 8f6f 	isb	sy
   42f26:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42f28:	4d23      	ldr	r5, [pc, #140]	; (42fb8 <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42f2a:	f8df 809c 	ldr.w	r8, [pc, #156]	; 42fc8 <z_nrf_clock_control_lf_on+0x100>
   42f2e:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   42f30:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   42f34:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   42f38:	03d2      	lsls	r2, r2, #15
   42f3a:	d50c      	bpl.n	42f56 <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   42f3c:	f003 0303 	and.w	r3, r3, #3
   42f40:	2b02      	cmp	r3, #2
   42f42:	d001      	beq.n	42f48 <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   42f44:	2f01      	cmp	r7, #1
   42f46:	d106      	bne.n	42f56 <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   42f48:	b334      	cbz	r4, 42f98 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   42f4a:	f386 8811 	msr	BASEPRI, r6
   42f4e:	f3bf 8f6f 	isb	sy
}
   42f52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   42f56:	b1d4      	cbz	r4, 42f8e <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   42f58:	4630      	mov	r0, r6
   42f5a:	f7ff f88d 	bl	42078 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   42f5e:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   42f62:	b2db      	uxtb	r3, r3
   42f64:	2b01      	cmp	r3, #1
   42f66:	d1e3      	bne.n	42f30 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   42f68:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   42f6c:	2a00      	cmp	r2, #0
   42f6e:	d0df      	beq.n	42f30 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   42f70:	2200      	movs	r2, #0
   42f72:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   42f76:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   42f7a:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42f7c:	2120      	movs	r1, #32
   42f7e:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   42f82:	4a0f      	ldr	r2, [pc, #60]	; (42fc0 <z_nrf_clock_control_lf_on+0xf8>)
   42f84:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   42f88:	4a0e      	ldr	r2, [pc, #56]	; (42fc4 <z_nrf_clock_control_lf_on+0xfc>)
   42f8a:	6013      	str	r3, [r2, #0]
}
   42f8c:	e7d0      	b.n	42f30 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   42f8e:	2100      	movs	r1, #0
   42f90:	2001      	movs	r0, #1
   42f92:	f003 ff3f 	bl	46e14 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   42f96:	e7e2      	b.n	42f5e <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   42f98:	2302      	movs	r3, #2
   42f9a:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   42f9e:	e7d8      	b.n	42f52 <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   42fa0:	2202      	movs	r2, #2
   42fa2:	4b05      	ldr	r3, [pc, #20]	; (42fb8 <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   42fa4:	4606      	mov	r6, r0
   42fa6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   42faa:	e7bd      	b.n	42f28 <z_nrf_clock_control_lf_on+0x60>
   42fac:	2001a9a4 	.word	0x2001a9a4
   42fb0:	2001a940 	.word	0x2001a940
   42fb4:	2001a96c 	.word	0x2001a96c
   42fb8:	40005000 	.word	0x40005000
   42fbc:	20020b3e 	.word	0x20020b3e
   42fc0:	e000e100 	.word	0xe000e100
   42fc4:	40005008 	.word	0x40005008
   42fc8:	40005104 	.word	0x40005104

00042fcc <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   42fcc:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   42fce:	4808      	ldr	r0, [pc, #32]	; (42ff0 <uart_console_init+0x24>)
   42fd0:	4b08      	ldr	r3, [pc, #32]	; (42ff4 <uart_console_init+0x28>)
   42fd2:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   42fd4:	f005 fc2e 	bl	48834 <z_device_ready>
   42fd8:	b138      	cbz	r0, 42fea <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   42fda:	4807      	ldr	r0, [pc, #28]	; (42ff8 <uart_console_init+0x2c>)
   42fdc:	f7ff fe34 	bl	42c48 <__stdout_hook_install>
	__printk_hook_install(console_out);
   42fe0:	4805      	ldr	r0, [pc, #20]	; (42ff8 <uart_console_init+0x2c>)
   42fe2:	f7fd fc6d 	bl	408c0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   42fe6:	2000      	movs	r0, #0
}
   42fe8:	bd08      	pop	{r3, pc}
		return -ENODEV;
   42fea:	f06f 0012 	mvn.w	r0, #18
   42fee:	e7fb      	b.n	42fe8 <uart_console_init+0x1c>
   42ff0:	00048e18 	.word	0x00048e18
   42ff4:	2001a9a8 	.word	0x2001a9a8
   42ff8:	00042ffd 	.word	0x00042ffd

00042ffc <console_out>:
	if ('\n' == c) {
   42ffc:	280a      	cmp	r0, #10
{
   42ffe:	b538      	push	{r3, r4, r5, lr}
   43000:	4604      	mov	r4, r0
   43002:	4d07      	ldr	r5, [pc, #28]	; (43020 <console_out+0x24>)
	if ('\n' == c) {
   43004:	d104      	bne.n	43010 <console_out+0x14>
   43006:	6828      	ldr	r0, [r5, #0]
   43008:	6883      	ldr	r3, [r0, #8]
   4300a:	210d      	movs	r1, #13
   4300c:	685b      	ldr	r3, [r3, #4]
   4300e:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   43010:	6828      	ldr	r0, [r5, #0]
   43012:	6883      	ldr	r3, [r0, #8]
   43014:	b2e1      	uxtb	r1, r4
   43016:	685b      	ldr	r3, [r3, #4]
   43018:	4798      	blx	r3
}
   4301a:	4620      	mov	r0, r4
   4301c:	bd38      	pop	{r3, r4, r5, pc}
   4301e:	bf00      	nop
   43020:	2001a9a8 	.word	0x2001a9a8

00043024 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   43024:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   43026:	6840      	ldr	r0, [r0, #4]
   43028:	f001 051f 	and.w	r5, r1, #31
   4302c:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   4302e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   43032:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   43036:	b085      	sub	sp, #20
   43038:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   4303c:	d104      	bne.n	43048 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   4303e:	4628      	mov	r0, r5
   43040:	f001 fa88 	bl	44554 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   43044:	2000      	movs	r0, #0
   43046:	e02c      	b.n	430a2 <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   43048:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   4304c:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   43050:	d129      	bne.n	430a6 <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   43052:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   43056:	bf0c      	ite	eq
   43058:	2304      	moveq	r3, #4
   4305a:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   4305c:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   43060:	6883      	ldr	r3, [r0, #8]
   43062:	fa23 f101 	lsr.w	r1, r3, r1
   43066:	07c9      	lsls	r1, r1, #31
   43068:	d429      	bmi.n	430be <gpio_nrfx_pin_interrupt_configure+0x9a>
   4306a:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   4306e:	d126      	bne.n	430be <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   43070:	4a1b      	ldr	r2, [pc, #108]	; (430e0 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   43072:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   43076:	3380      	adds	r3, #128	; 0x80
   43078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   4307c:	07db      	lsls	r3, r3, #31
   4307e:	d41e      	bmi.n	430be <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   43080:	f10d 0407 	add.w	r4, sp, #7
   43084:	4621      	mov	r1, r4
   43086:	4628      	mov	r0, r5
   43088:	f001 f9d4 	bl	44434 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   4308c:	4b15      	ldr	r3, [pc, #84]	; (430e4 <gpio_nrfx_pin_interrupt_configure+0xc0>)
   4308e:	4298      	cmp	r0, r3
   43090:	d114      	bne.n	430bc <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   43092:	4620      	mov	r0, r4
   43094:	f001 fa18 	bl	444c8 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   43098:	4b13      	ldr	r3, [pc, #76]	; (430e8 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   4309a:	4298      	cmp	r0, r3
   4309c:	d00e      	beq.n	430bc <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   4309e:	f06f 000b 	mvn.w	r0, #11
}
   430a2:	b005      	add	sp, #20
   430a4:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   430a6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   430aa:	d005      	beq.n	430b8 <gpio_nrfx_pin_interrupt_configure+0x94>
   430ac:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   430b0:	bf0c      	ite	eq
   430b2:	2302      	moveq	r3, #2
   430b4:	2301      	movne	r3, #1
   430b6:	e7d1      	b.n	4305c <gpio_nrfx_pin_interrupt_configure+0x38>
   430b8:	2303      	movs	r3, #3
   430ba:	e7cf      	b.n	4305c <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   430bc:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   430be:	2300      	movs	r3, #0
   430c0:	4628      	mov	r0, r5
   430c2:	4619      	mov	r1, r3
   430c4:	aa02      	add	r2, sp, #8
   430c6:	f001 f875 	bl	441b4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   430ca:	4b07      	ldr	r3, [pc, #28]	; (430e8 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   430cc:	4298      	cmp	r0, r3
   430ce:	d104      	bne.n	430da <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   430d0:	2101      	movs	r1, #1
   430d2:	4628      	mov	r0, r5
   430d4:	f001 f9fe 	bl	444d4 <nrfx_gpiote_trigger_enable>
   430d8:	e7b4      	b.n	43044 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   430da:	f06f 0004 	mvn.w	r0, #4
   430de:	e7e0      	b.n	430a2 <gpio_nrfx_pin_interrupt_configure+0x7e>
   430e0:	40842500 	.word	0x40842500
   430e4:	0bad0004 	.word	0x0bad0004
   430e8:	0bad0000 	.word	0x0bad0000

000430ec <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   430ec:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   430ee:	f001 f9db 	bl	444a8 <nrfx_gpiote_is_init>
   430f2:	4604      	mov	r4, r0
   430f4:	b968      	cbnz	r0, 43112 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   430f6:	f001 f9af 	bl	44458 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   430fa:	4b08      	ldr	r3, [pc, #32]	; (4311c <gpio_nrfx_init+0x30>)
   430fc:	4298      	cmp	r0, r3
   430fe:	d10a      	bne.n	43116 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   43100:	4621      	mov	r1, r4
   43102:	4807      	ldr	r0, [pc, #28]	; (43120 <gpio_nrfx_init+0x34>)
   43104:	f001 f990 	bl	44428 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   43108:	4622      	mov	r2, r4
   4310a:	2105      	movs	r1, #5
   4310c:	2031      	movs	r0, #49	; 0x31
   4310e:	f7ff f813 	bl	42138 <z_arm_irq_priority_set>
		return 0;
   43112:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   43114:	bd10      	pop	{r4, pc}
		return -EIO;
   43116:	f06f 0004 	mvn.w	r0, #4
   4311a:	e7fb      	b.n	43114 <gpio_nrfx_init+0x28>
   4311c:	0bad0000 	.word	0x0bad0000
   43120:	00043125 	.word	0x00043125

00043124 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43124:	0943      	lsrs	r3, r0, #5
{
   43126:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43128:	d117      	bne.n	4315a <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   4312a:	4b0c      	ldr	r3, [pc, #48]	; (4315c <nrfx_gpio_handler+0x38>)
   4312c:	6859      	ldr	r1, [r3, #4]
   4312e:	b1a1      	cbz	r1, 4315a <nrfx_gpio_handler+0x36>
   43130:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   43132:	2501      	movs	r5, #1
   43134:	2c00      	cmp	r4, #0
   43136:	bf38      	it	cc
   43138:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   4313a:	4e09      	ldr	r6, [pc, #36]	; (43160 <nrfx_gpio_handler+0x3c>)
   4313c:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   4313e:	688a      	ldr	r2, [r1, #8]
   43140:	402a      	ands	r2, r5
   43142:	d002      	beq.n	4314a <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   43144:	4630      	mov	r0, r6
   43146:	684b      	ldr	r3, [r1, #4]
   43148:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   4314a:	b134      	cbz	r4, 4315a <nrfx_gpio_handler+0x36>
	return node->next;
   4314c:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   4314e:	4621      	mov	r1, r4
   43150:	2b00      	cmp	r3, #0
   43152:	bf38      	it	cc
   43154:	2300      	movcc	r3, #0
   43156:	461c      	mov	r4, r3
   43158:	e7f1      	b.n	4313e <nrfx_gpio_handler+0x1a>
}
   4315a:	bd70      	pop	{r4, r5, r6, pc}
   4315c:	2001a9ac 	.word	0x2001a9ac
   43160:	00048de8 	.word	0x00048de8

00043164 <gpio_nrfx_pin_configure>:
{
   43164:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   43168:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   4316a:	f001 051f 	and.w	r5, r1, #31
   4316e:	7b3b      	ldrb	r3, [r7, #12]
{
   43170:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   43172:	4614      	mov	r4, r2
{
   43174:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   43176:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   4317a:	b9ca      	cbnz	r2, 431b0 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   4317c:	a902      	add	r1, sp, #8
   4317e:	4628      	mov	r0, r5
   43180:	f001 f958 	bl	44434 <nrfx_gpiote_channel_get>
   43184:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   43186:	4628      	mov	r0, r5
   43188:	f001 fa06 	bl	44598 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   4318c:	4b47      	ldr	r3, [pc, #284]	; (432ac <gpio_nrfx_pin_configure+0x148>)
   4318e:	4298      	cmp	r0, r3
   43190:	d004      	beq.n	4319c <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   43192:	f06f 0004 	mvn.w	r0, #4
}
   43196:	b005      	add	sp, #20
   43198:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   4319c:	4284      	cmp	r4, r0
   4319e:	d105      	bne.n	431ac <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   431a0:	f89d 0008 	ldrb.w	r0, [sp, #8]
   431a4:	f001 f98a 	bl	444bc <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   431a8:	42a0      	cmp	r0, r4
   431aa:	d1f2      	bne.n	43192 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   431ac:	2000      	movs	r0, #0
   431ae:	e7f2      	b.n	43196 <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   431b0:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   431b4:	f10d 0103 	add.w	r1, sp, #3
   431b8:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   431ba:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   431be:	f001 f939 	bl	44434 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   431c2:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   431c4:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   431c6:	4649      	mov	r1, r9
   431c8:	4628      	mov	r0, r5
   431ca:	aa02      	add	r2, sp, #8
   431cc:	f000 fff2 	bl	441b4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   431d0:	4b36      	ldr	r3, [pc, #216]	; (432ac <gpio_nrfx_pin_configure+0x148>)
   431d2:	4298      	cmp	r0, r3
   431d4:	d002      	beq.n	431dc <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   431d6:	f06f 0015 	mvn.w	r0, #21
   431da:	e7dc      	b.n	43196 <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   431dc:	4580      	cmp	r8, r0
   431de:	d103      	bne.n	431e8 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   431e0:	f89d 0003 	ldrb.w	r0, [sp, #3]
   431e4:	f001 f96a 	bl	444bc <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   431e8:	05a3      	lsls	r3, r4, #22
   431ea:	d54c      	bpl.n	43286 <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   431ec:	4b30      	ldr	r3, [pc, #192]	; (432b0 <gpio_nrfx_pin_configure+0x14c>)
   431ee:	4a31      	ldr	r2, [pc, #196]	; (432b4 <gpio_nrfx_pin_configure+0x150>)
   431f0:	4023      	ands	r3, r4
   431f2:	4293      	cmp	r3, r2
   431f4:	d039      	beq.n	4326a <gpio_nrfx_pin_configure+0x106>
   431f6:	d80c      	bhi.n	43212 <gpio_nrfx_pin_configure+0xae>
   431f8:	2b06      	cmp	r3, #6
   431fa:	d014      	beq.n	43226 <gpio_nrfx_pin_configure+0xc2>
   431fc:	d804      	bhi.n	43208 <gpio_nrfx_pin_configure+0xa4>
   431fe:	b193      	cbz	r3, 43226 <gpio_nrfx_pin_configure+0xc2>
   43200:	2b02      	cmp	r3, #2
   43202:	d1e8      	bne.n	431d6 <gpio_nrfx_pin_configure+0x72>
   43204:	2304      	movs	r3, #4
   43206:	e00e      	b.n	43226 <gpio_nrfx_pin_configure+0xc2>
   43208:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   4320c:	d1e3      	bne.n	431d6 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   4320e:	2301      	movs	r3, #1
   43210:	e009      	b.n	43226 <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43212:	4a29      	ldr	r2, [pc, #164]	; (432b8 <gpio_nrfx_pin_configure+0x154>)
   43214:	4293      	cmp	r3, r2
   43216:	d02a      	beq.n	4326e <gpio_nrfx_pin_configure+0x10a>
   43218:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   4321c:	d029      	beq.n	43272 <gpio_nrfx_pin_configure+0x10e>
   4321e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   43222:	d1d8      	bne.n	431d6 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   43224:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   43226:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   4322a:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   4322e:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   43232:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   43234:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   43238:	bf4c      	ite	mi
   4323a:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   4323c:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43240:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   43242:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   43246:	d516      	bpl.n	43276 <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   43248:	2101      	movs	r1, #1
   4324a:	687b      	ldr	r3, [r7, #4]
   4324c:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   43250:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   43252:	2200      	movs	r2, #0
   43254:	4628      	mov	r0, r5
   43256:	a901      	add	r1, sp, #4
   43258:	f001 f852 	bl	44300 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   4325c:	4b13      	ldr	r3, [pc, #76]	; (432ac <gpio_nrfx_pin_configure+0x148>)
   4325e:	4298      	cmp	r0, r3
   43260:	bf14      	ite	ne
   43262:	f06f 0015 	mvnne.w	r0, #21
   43266:	2000      	moveq	r0, #0
   43268:	e795      	b.n	43196 <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   4326a:	2307      	movs	r3, #7
   4326c:	e7db      	b.n	43226 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   4326e:	2305      	movs	r3, #5
   43270:	e7d9      	b.n	43226 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   43272:	2303      	movs	r3, #3
   43274:	e7d7      	b.n	43226 <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   43276:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   43278:	bf41      	itttt	mi
   4327a:	2101      	movmi	r1, #1
   4327c:	687b      	ldrmi	r3, [r7, #4]
   4327e:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   43282:	60de      	strmi	r6, [r3, #12]
}
   43284:	e7e5      	b.n	43252 <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   43286:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43288:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   4328c:	bf4c      	ite	mi
   4328e:	2403      	movmi	r4, #3
   43290:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43294:	461a      	mov	r2, r3
   43296:	4628      	mov	r0, r5
   43298:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   4329a:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   4329e:	f000 ff89 	bl	441b4 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   432a2:	4b02      	ldr	r3, [pc, #8]	; (432ac <gpio_nrfx_pin_configure+0x148>)
   432a4:	4298      	cmp	r0, r3
   432a6:	d081      	beq.n	431ac <gpio_nrfx_pin_configure+0x48>
   432a8:	e795      	b.n	431d6 <gpio_nrfx_pin_configure+0x72>
   432aa:	bf00      	nop
   432ac:	0bad0000 	.word	0x0bad0000
   432b0:	00f00006 	.word	0x00f00006
   432b4:	00100006 	.word	0x00100006
   432b8:	00400002 	.word	0x00400002

000432bc <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   432bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   432be:	794b      	ldrb	r3, [r1, #5]
   432c0:	2b01      	cmp	r3, #1
   432c2:	d026      	beq.n	43312 <uarte_nrfx_configure+0x56>
   432c4:	2b03      	cmp	r3, #3
   432c6:	d121      	bne.n	4330c <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   432c8:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   432ca:	798b      	ldrb	r3, [r1, #6]
   432cc:	2b03      	cmp	r3, #3
   432ce:	d11d      	bne.n	4330c <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   432d0:	79cc      	ldrb	r4, [r1, #7]
   432d2:	b10c      	cbz	r4, 432d8 <uarte_nrfx_configure+0x1c>
   432d4:	2c01      	cmp	r4, #1
   432d6:	d119      	bne.n	4330c <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   432d8:	790a      	ldrb	r2, [r1, #4]
   432da:	b112      	cbz	r2, 432e2 <uarte_nrfx_configure+0x26>
   432dc:	2a02      	cmp	r2, #2
   432de:	d115      	bne.n	4330c <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   432e0:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   432e2:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   432e4:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   432e6:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   432ea:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   432ec:	d065      	beq.n	433ba <uarte_nrfx_configure+0xfe>
   432ee:	d82d      	bhi.n	4334c <uarte_nrfx_configure+0x90>
   432f0:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   432f4:	d064      	beq.n	433c0 <uarte_nrfx_configure+0x104>
   432f6:	d816      	bhi.n	43326 <uarte_nrfx_configure+0x6a>
   432f8:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   432fc:	d062      	beq.n	433c4 <uarte_nrfx_configure+0x108>
   432fe:	d80a      	bhi.n	43316 <uarte_nrfx_configure+0x5a>
   43300:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   43304:	d061      	beq.n	433ca <uarte_nrfx_configure+0x10e>
   43306:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   4330a:	d061      	beq.n	433d0 <uarte_nrfx_configure+0x114>
   4330c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   43310:	e052      	b.n	433b8 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   43312:	2600      	movs	r6, #0
   43314:	e7d9      	b.n	432ca <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   43316:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   4331a:	d05c      	beq.n	433d6 <uarte_nrfx_configure+0x11a>
   4331c:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   43320:	d1f4      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   43322:	4b37      	ldr	r3, [pc, #220]	; (43400 <uarte_nrfx_configure+0x144>)
   43324:	e03c      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43326:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   4332a:	d057      	beq.n	433dc <uarte_nrfx_configure+0x120>
   4332c:	d807      	bhi.n	4333e <uarte_nrfx_configure+0x82>
   4332e:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   43332:	d055      	beq.n	433e0 <uarte_nrfx_configure+0x124>
   43334:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   43338:	d1e8      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   4333a:	4b32      	ldr	r3, [pc, #200]	; (43404 <uarte_nrfx_configure+0x148>)
   4333c:	e030      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4333e:	f647 2712 	movw	r7, #31250	; 0x7a12
   43342:	42bb      	cmp	r3, r7
   43344:	d1e2      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   43346:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   4334a:	e029      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4334c:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   43350:	d048      	beq.n	433e4 <uarte_nrfx_configure+0x128>
   43352:	d813      	bhi.n	4337c <uarte_nrfx_configure+0xc0>
   43354:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   43358:	d047      	beq.n	433ea <uarte_nrfx_configure+0x12e>
   4335a:	d809      	bhi.n	43370 <uarte_nrfx_configure+0xb4>
   4335c:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   43360:	42bb      	cmp	r3, r7
   43362:	d044      	beq.n	433ee <uarte_nrfx_configure+0x132>
   43364:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   43368:	d1d0      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   4336a:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   4336e:	e017      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43370:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   43374:	d1ca      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   43376:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   4337a:	e011      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4337c:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   43380:	d038      	beq.n	433f4 <uarte_nrfx_configure+0x138>
   43382:	d808      	bhi.n	43396 <uarte_nrfx_configure+0xda>
   43384:	4f20      	ldr	r7, [pc, #128]	; (43408 <uarte_nrfx_configure+0x14c>)
   43386:	42bb      	cmp	r3, r7
   43388:	d037      	beq.n	433fa <uarte_nrfx_configure+0x13e>
   4338a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   4338e:	d1bd      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   43390:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   43394:	e004      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43396:	4f1d      	ldr	r7, [pc, #116]	; (4340c <uarte_nrfx_configure+0x150>)
   43398:	42bb      	cmp	r3, r7
   4339a:	d1b7      	bne.n	4330c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   4339c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   433a0:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   433a4:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   433a6:	4334      	orrs	r4, r6
   433a8:	4322      	orrs	r2, r4
   433aa:	3304      	adds	r3, #4
   433ac:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   433ae:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   433b2:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   433b6:	2000      	movs	r0, #0
}
   433b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   433ba:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   433be:	e7ef      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   433c0:	4b13      	ldr	r3, [pc, #76]	; (43410 <uarte_nrfx_configure+0x154>)
   433c2:	e7ed      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   433c4:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   433c8:	e7ea      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   433ca:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   433ce:	e7e7      	b.n	433a0 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   433d0:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   433d4:	e7e4      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   433d6:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   433da:	e7e1      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   433dc:	4b0d      	ldr	r3, [pc, #52]	; (43414 <uarte_nrfx_configure+0x158>)
   433de:	e7df      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   433e0:	4b0d      	ldr	r3, [pc, #52]	; (43418 <uarte_nrfx_configure+0x15c>)
   433e2:	e7dd      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   433e4:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   433e8:	e7da      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   433ea:	4b0c      	ldr	r3, [pc, #48]	; (4341c <uarte_nrfx_configure+0x160>)
   433ec:	e7d8      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   433ee:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   433f2:	e7d5      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   433f4:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   433f8:	e7d2      	b.n	433a0 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   433fa:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   433fe:	e7cf      	b.n	433a0 <uarte_nrfx_configure+0xe4>
   43400:	0013b000 	.word	0x0013b000
   43404:	004ea000 	.word	0x004ea000
   43408:	0003d090 	.word	0x0003d090
   4340c:	000f4240 	.word	0x000f4240
   43410:	00275000 	.word	0x00275000
   43414:	0075c000 	.word	0x0075c000
   43418:	003af000 	.word	0x003af000
   4341c:	013a9000 	.word	0x013a9000

00043420 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   43420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   43422:	4605      	mov	r5, r0
   43424:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   43426:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   43428:	f005 fac8 	bl	489bc <k_is_in_isr>
   4342c:	b910      	cbnz	r0, 43434 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   4342e:	4b2c      	ldr	r3, [pc, #176]	; (434e0 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   43430:	781b      	ldrb	r3, [r3, #0]
   43432:	b983      	cbnz	r3, 43456 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43434:	f04f 0320 	mov.w	r3, #32
   43438:	f3ef 8411 	mrs	r4, BASEPRI
   4343c:	f383 8812 	msr	BASEPRI_MAX, r3
   43440:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   43444:	4628      	mov	r0, r5
   43446:	f005 f88d 	bl	48564 <is_tx_ready>
   4344a:	bb28      	cbnz	r0, 43498 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   4344c:	f384 8811 	msr	BASEPRI, r4
   43450:	f3bf 8f6f 	isb	sy
}
   43454:	e7ee      	b.n	43434 <uarte_nrfx_poll_out+0x14>
{
   43456:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   43458:	4628      	mov	r0, r5
   4345a:	f005 f883 	bl	48564 <is_tx_ready>
   4345e:	b970      	cbnz	r0, 4347e <uarte_nrfx_poll_out+0x5e>
   43460:	2001      	movs	r0, #1
   43462:	f005 f8e3 	bl	4862c <nrfx_busy_wait>
   43466:	3c01      	subs	r4, #1
   43468:	d1f6      	bne.n	43458 <uarte_nrfx_poll_out+0x38>
   4346a:	2100      	movs	r1, #0
   4346c:	2001      	movs	r0, #1
   4346e:	f003 fcd1 	bl	46e14 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   43472:	e7f0      	b.n	43456 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43474:	f384 8811 	msr	BASEPRI, r4
   43478:	f3bf 8f6f 	isb	sy
}
   4347c:	e7f5      	b.n	4346a <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   4347e:	f04f 0320 	mov.w	r3, #32
   43482:	f3ef 8411 	mrs	r4, BASEPRI
   43486:	f383 8812 	msr	BASEPRI_MAX, r3
   4348a:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   4348e:	4628      	mov	r0, r5
   43490:	f005 f868 	bl	48564 <is_tx_ready>
   43494:	2800      	cmp	r0, #0
   43496:	d0ed      	beq.n	43474 <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   43498:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   4349a:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   4349e:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   434a0:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   434a2:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   434a6:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   434aa:	2200      	movs	r2, #0
   434ac:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   434b0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   434b4:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   434b8:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   434bc:	684a      	ldr	r2, [r1, #4]
   434be:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   434c0:	bf41      	itttt	mi
   434c2:	2208      	movmi	r2, #8
   434c4:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   434c8:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   434cc:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   434d0:	2201      	movs	r2, #1
   434d2:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   434d4:	f384 8811 	msr	BASEPRI, r4
   434d8:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   434dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   434de:	bf00      	nop
   434e0:	20020b3e 	.word	0x20020b3e

000434e4 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   434e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   434e8:	4606      	mov	r6, r0
   434ea:	2101      	movs	r1, #1
   434ec:	2200      	movs	r2, #0
   434ee:	2008      	movs	r0, #8
   434f0:	f7fe fe22 	bl	42138 <z_arm_irq_priority_set>
   434f4:	2008      	movs	r0, #8
   434f6:	f7fe fe01 	bl	420fc <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   434fa:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   434fc:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   434fe:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   43500:	683c      	ldr	r4, [r7, #0]
   43502:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   43506:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   43508:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4350a:	68d8      	ldr	r0, [r3, #12]
   4350c:	1c41      	adds	r1, r0, #1
   4350e:	d00b      	beq.n	43528 <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43510:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   43512:	f8df c154 	ldr.w	ip, [pc, #340]	; 43668 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   43516:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   4351a:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   4351c:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43520:	2103      	movs	r1, #3
   43522:	3280      	adds	r2, #128	; 0x80
   43524:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43528:	6919      	ldr	r1, [r3, #16]
   4352a:	1c4a      	adds	r2, r1, #1
   4352c:	d00d      	beq.n	4354a <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   4352e:	7f1a      	ldrb	r2, [r3, #28]
   43530:	f8df c134 	ldr.w	ip, [pc, #308]	; 43668 <uarte_0_init+0x184>
   43534:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43536:	bf14      	ite	ne
   43538:	f04f 0e0c 	movne.w	lr, #12
   4353c:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   43540:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   43544:	3280      	adds	r2, #128	; 0x80
   43546:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4354a:	f8d3 c014 	ldr.w	ip, [r3, #20]
   4354e:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   43552:	d00e      	beq.n	43572 <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43554:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   43558:	f8df 810c 	ldr.w	r8, [pc, #268]	; 43668 <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   4355c:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43560:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   43564:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43568:	f04f 0e03 	mov.w	lr, #3
   4356c:	3280      	adds	r2, #128	; 0x80
   4356e:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   43572:	f8d3 e018 	ldr.w	lr, [r3, #24]
   43576:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
   4357a:	d00d      	beq.n	43598 <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   4357c:	7f5a      	ldrb	r2, [r3, #29]
   4357e:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 43668 <uarte_0_init+0x184>
   43582:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   43584:	bf14      	ite	ne
   43586:	f04f 090c 	movne.w	r9, #12
   4358a:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   4358e:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   43592:	3280      	adds	r2, #128	; 0x80
   43594:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   43598:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   4359a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   4359e:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   435a2:	6931      	ldr	r1, [r6, #16]
   435a4:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   435a6:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   435aa:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   435ac:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   435b0:	f7ff fe84 	bl	432bc <uarte_nrfx_configure>
	if (err) {
   435b4:	4606      	mov	r6, r0
   435b6:	b9a8      	cbnz	r0, 435e4 <uarte_0_init+0x100>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   435b8:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   435ba:	0799      	lsls	r1, r3, #30
   435bc:	d522      	bpl.n	43604 <uarte_0_init+0x120>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   435be:	f105 0012 	add.w	r0, r5, #18
   435c2:	f000 fd7d 	bl	440c0 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   435c6:	4b23      	ldr	r3, [pc, #140]	; (43654 <uarte_0_init+0x170>)
   435c8:	4298      	cmp	r0, r3
   435ca:	d00e      	beq.n	435ea <uarte_0_init+0x106>
   435cc:	4b22      	ldr	r3, [pc, #136]	; (43658 <uarte_0_init+0x174>)
   435ce:	4923      	ldr	r1, [pc, #140]	; (4365c <uarte_0_init+0x178>)
		LOG_ERR("Failed to allocate PPI Channel");
   435d0:	4823      	ldr	r0, [pc, #140]	; (43660 <uarte_0_init+0x17c>)
   435d2:	1ac9      	subs	r1, r1, r3
   435d4:	08c9      	lsrs	r1, r1, #3
   435d6:	0189      	lsls	r1, r1, #6
   435d8:	f041 0101 	orr.w	r1, r1, #1
   435dc:	f004 fb62 	bl	47ca4 <log_0>
		return -EIO;
   435e0:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   435e4:	4630      	mov	r0, r6
   435e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   435ea:	7cab      	ldrb	r3, [r5, #18]
   435ec:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   435f0:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   435f4:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   435f8:	2301      	movs	r3, #1
   435fa:	7caa      	ldrb	r2, [r5, #18]
   435fc:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   435fe:	4a19      	ldr	r2, [pc, #100]	; (43664 <uarte_0_init+0x180>)
   43600:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43604:	2308      	movs	r3, #8
   43606:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   4360a:	7a3b      	ldrb	r3, [r7, #8]
   4360c:	b95b      	cbnz	r3, 43626 <uarte_0_init+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4360e:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   43612:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   43616:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   4361a:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   4361e:	2301      	movs	r3, #1
   43620:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43624:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   43626:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   43628:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   4362a:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   4362c:	bf5c      	itt	pl
   4362e:	f44f 7280 	movpl.w	r2, #256	; 0x100
   43632:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   43636:	06db      	lsls	r3, r3, #27
   43638:	bf44      	itt	mi
   4363a:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   4363e:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   43642:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43644:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   43648:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4364c:	2301      	movs	r3, #1
   4364e:	60a3      	str	r3, [r4, #8]
   43650:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   43652:	e7c7      	b.n	435e4 <uarte_0_init+0x100>
   43654:	0bad0000 	.word	0x0bad0000
   43658:	00049038 	.word	0x00049038
   4365c:	00049080 	.word	0x00049080
   43660:	00049977 	.word	0x00049977
   43664:	40017000 	.word	0x40017000
   43668:	40842500 	.word	0x40842500

0004366c <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   4366c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4366e:	4e20      	ldr	r6, [pc, #128]	; (436f0 <sys_clock_timeout_handler+0x84>)
	return absolute_time & COUNTER_MAX;
   43670:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43674:	e9d6 ce00 	ldrd	ip, lr, [r6]
   43678:	ebb2 020c 	subs.w	r2, r2, ip

	last_count += dticks * CYC_PER_TICK;
   4367c:	f022 011f 	bic.w	r1, r2, #31
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43680:	eb63 030e 	sbc.w	r3, r3, lr
{
   43684:	4604      	mov	r4, r0
	last_count += dticks * CYC_PER_TICK;
   43686:	eb11 010c 	adds.w	r1, r1, ip
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   4368a:	ea4f 1052 	mov.w	r0, r2, lsr #5
	last_count += dticks * CYC_PER_TICK;
   4368e:	eb43 070e 	adc.w	r7, r3, lr
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   43692:	ea40 60c3 	orr.w	r0, r0, r3, lsl #27
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   43696:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   4369a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
	last_count += dticks * CYC_PER_TICK;
   4369e:	e9c6 1700 	strd	r1, r7, [r6]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   436a2:	f04f 0600 	mov.w	r6, #0
	if (in_anchor_range(cc_value)) {
   436a6:	d20a      	bcs.n	436be <sys_clock_timeout_handler+0x52>
		return true;
   436a8:	2601      	movs	r6, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   436aa:	4b12      	ldr	r3, [pc, #72]	; (436f4 <sys_clock_timeout_handler+0x88>)
   436ac:	6819      	ldr	r1, [r3, #0]
   436ae:	060a      	lsls	r2, r1, #24
   436b0:	0a0b      	lsrs	r3, r1, #8
   436b2:	1952      	adds	r2, r2, r5
   436b4:	4910      	ldr	r1, [pc, #64]	; (436f8 <sys_clock_timeout_handler+0x8c>)
   436b6:	f143 0300 	adc.w	r3, r3, #0
   436ba:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   436be:	f003 fd07 	bl	470d0 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   436c2:	00a3      	lsls	r3, r4, #2
   436c4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   436c8:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   436cc:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   436d0:	42aa      	cmp	r2, r5
   436d2:	d10b      	bne.n	436ec <sys_clock_timeout_handler+0x80>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   436d4:	b91e      	cbnz	r6, 436de <sys_clock_timeout_handler+0x72>
    p_reg->CC[ch] = cc_val;
   436d6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   436da:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   436de:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   436e2:	4b06      	ldr	r3, [pc, #24]	; (436fc <sys_clock_timeout_handler+0x90>)
   436e4:	fa00 f404 	lsl.w	r4, r0, r4
   436e8:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   436ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   436ee:	bf00      	nop
   436f0:	2001a760 	.word	0x2001a760
   436f4:	2001a9c0 	.word	0x2001a9c0
   436f8:	2001a748 	.word	0x2001a748
   436fc:	40015000 	.word	0x40015000

00043700 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43700:	2301      	movs	r3, #1
   43702:	4083      	lsls	r3, r0
{
   43704:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43706:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43708:	4a0c      	ldr	r2, [pc, #48]	; (4373c <compare_int_lock+0x3c>)
   4370a:	e8d2 1fef 	ldaex	r1, [r2]
   4370e:	ea01 0c04 	and.w	ip, r1, r4
   43712:	e8c2 cfee 	stlex	lr, ip, [r2]
   43716:	f1be 0f00 	cmp.w	lr, #0
   4371a:	d1f6      	bne.n	4370a <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4371c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   43720:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   43724:	4a06      	ldr	r2, [pc, #24]	; (43740 <compare_int_lock+0x40>)
   43726:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   4372a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   4372e:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   43732:	420b      	tst	r3, r1
}
   43734:	bf14      	ite	ne
   43736:	2001      	movne	r0, #1
   43738:	2000      	moveq	r0, #0
   4373a:	bd10      	pop	{r4, pc}
   4373c:	2001a9bc 	.word	0x2001a9bc
   43740:	40015000 	.word	0x40015000

00043744 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   43744:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43746:	4a0e      	ldr	r2, [pc, #56]	; (43780 <compare_int_unlock.part.0+0x3c>)
   43748:	4083      	lsls	r3, r0
   4374a:	e8d2 1fef 	ldaex	r1, [r2]
   4374e:	4319      	orrs	r1, r3
   43750:	e8c2 1fec 	stlex	ip, r1, [r2]
   43754:	f1bc 0f00 	cmp.w	ip, #0
   43758:	d1f7      	bne.n	4374a <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   4375a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   4375e:	4a09      	ldr	r2, [pc, #36]	; (43784 <compare_int_unlock.part.0+0x40>)
   43760:	4083      	lsls	r3, r0
   43762:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   43766:	4b08      	ldr	r3, [pc, #32]	; (43788 <compare_int_unlock.part.0+0x44>)
   43768:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   4376c:	fa23 f000 	lsr.w	r0, r3, r0
   43770:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43772:	bf42      	ittt	mi
   43774:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   43778:	4b04      	ldrmi	r3, [pc, #16]	; (4378c <compare_int_unlock.part.0+0x48>)
   4377a:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   4377e:	4770      	bx	lr
   43780:	2001a9bc 	.word	0x2001a9bc
   43784:	40015000 	.word	0x40015000
   43788:	2001a9b8 	.word	0x2001a9b8
   4378c:	e000e100 	.word	0xe000e100

00043790 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   43790:	4b0d      	ldr	r3, [pc, #52]	; (437c8 <z_nrf_rtc_timer_read+0x38>)
   43792:	681b      	ldr	r3, [r3, #0]
   43794:	0a19      	lsrs	r1, r3, #8
   43796:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   43798:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   4379c:	4b0b      	ldr	r3, [pc, #44]	; (437cc <z_nrf_rtc_timer_read+0x3c>)
   4379e:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   437a2:	18c0      	adds	r0, r0, r3
   437a4:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   437a8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   437ac:	d20a      	bcs.n	437c4 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   437ae:	4b08      	ldr	r3, [pc, #32]	; (437d0 <z_nrf_rtc_timer_read+0x40>)
   437b0:	e9d3 2300 	ldrd	r2, r3, [r3]
   437b4:	4299      	cmp	r1, r3
   437b6:	bf08      	it	eq
   437b8:	4290      	cmpeq	r0, r2
   437ba:	d203      	bcs.n	437c4 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   437bc:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   437c0:	f141 0100 	adc.w	r1, r1, #0
}
   437c4:	4770      	bx	lr
   437c6:	bf00      	nop
   437c8:	2001a9c0 	.word	0x2001a9c0
   437cc:	40015000 	.word	0x40015000
   437d0:	2001a748 	.word	0x2001a748

000437d4 <compare_set>:
{
   437d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   437d8:	4616      	mov	r6, r2
   437da:	461f      	mov	r7, r3
   437dc:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   437de:	f7ff ff8f 	bl	43700 <compare_int_lock>
   437e2:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   437e4:	f7ff ffd4 	bl	43790 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   437e8:	42b9      	cmp	r1, r7
   437ea:	bf08      	it	eq
   437ec:	42b0      	cmpeq	r0, r6
   437ee:	d27b      	bcs.n	438e8 <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   437f0:	2300      	movs	r3, #0
   437f2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   437f6:	ebb6 0800 	subs.w	r8, r6, r0
   437fa:	eb67 0901 	sbc.w	r9, r7, r1
   437fe:	454b      	cmp	r3, r9
   43800:	bf08      	it	eq
   43802:	4542      	cmpeq	r2, r8
   43804:	d37d      	bcc.n	43902 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   43806:	4b40      	ldr	r3, [pc, #256]	; (43908 <compare_set+0x134>)
   43808:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   4380c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   43810:	429f      	cmp	r7, r3
   43812:	bf08      	it	eq
   43814:	4296      	cmpeq	r6, r2
   43816:	d051      	beq.n	438bc <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43818:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   4381c:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   43820:	4614      	mov	r4, r2
   43822:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   43826:	f105 0850 	add.w	r8, r5, #80	; 0x50
   4382a:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   4382e:	ea4f 0888 	mov.w	r8, r8, lsl #2
   43832:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43836:	fa1f f888 	uxth.w	r8, r8
   4383a:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   4383e:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   43842:	4b32      	ldr	r3, [pc, #200]	; (4390c <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43844:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43848:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   4384c:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   43850:	eba0 000a 	sub.w	r0, r0, sl
   43854:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43858:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   4385c:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   4385e:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   43862:	d105      	bne.n	43870 <compare_set+0x9c>
   43864:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   43866:	2013      	movs	r0, #19
   43868:	f005 fa05 	bl	48c76 <z_impl_k_busy_wait>
   4386c:	4b27      	ldr	r3, [pc, #156]	; (4390c <compare_set+0x138>)
   4386e:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   43870:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   43874:	eba4 000c 	sub.w	r0, r4, ip
   43878:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   4387c:	2100      	movs	r1, #0
			cc_val = now + 2;
   4387e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43882:	bf88      	it	hi
   43884:	4664      	movhi	r4, ip
   43886:	f8c8 1000 	str.w	r1, [r8]
   4388a:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   4388e:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   43892:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   43896:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   4389a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   4389e:	4582      	cmp	sl, r0
   438a0:	d006      	beq.n	438b0 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   438a2:	1a20      	subs	r0, r4, r0
   438a4:	3802      	subs	r0, #2
   438a6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   438aa:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   438ae:	d819      	bhi.n	438e4 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   438b0:	1aa4      	subs	r4, r4, r2
   438b2:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   438b6:	1932      	adds	r2, r6, r4
   438b8:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   438bc:	4c12      	ldr	r4, [pc, #72]	; (43908 <compare_set+0x134>)
   438be:	0129      	lsls	r1, r5, #4
   438c0:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   438c4:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   438c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   438ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   438cc:	5062      	str	r2, [r4, r1]
	return ret;
   438ce:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   438d0:	6043      	str	r3, [r0, #4]
	if (key) {
   438d2:	9b00      	ldr	r3, [sp, #0]
   438d4:	b113      	cbz	r3, 438dc <compare_set+0x108>
   438d6:	4628      	mov	r0, r5
   438d8:	f7ff ff34 	bl	43744 <compare_int_unlock.part.0>
}
   438dc:	4620      	mov	r0, r4
   438de:	b003      	add	sp, #12
   438e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   438e4:	4620      	mov	r0, r4
   438e6:	e7b1      	b.n	4384c <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   438e8:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   438ea:	4a09      	ldr	r2, [pc, #36]	; (43910 <compare_set+0x13c>)
   438ec:	40ab      	lsls	r3, r5
   438ee:	e8d2 1fef 	ldaex	r1, [r2]
   438f2:	4319      	orrs	r1, r3
   438f4:	e8c2 1fe0 	stlex	r0, r1, [r2]
   438f8:	2800      	cmp	r0, #0
   438fa:	d1f8      	bne.n	438ee <compare_set+0x11a>
   438fc:	4632      	mov	r2, r6
   438fe:	463b      	mov	r3, r7
   43900:	e7dc      	b.n	438bc <compare_set+0xe8>
			return -EINVAL;
   43902:	f06f 0415 	mvn.w	r4, #21
   43906:	e7e4      	b.n	438d2 <compare_set+0xfe>
   43908:	2001a750 	.word	0x2001a750
   4390c:	40015000 	.word	0x40015000
   43910:	2001a9b8 	.word	0x2001a9b8

00043914 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   43914:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   43916:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   43918:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   4391c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   43920:	4d16      	ldr	r5, [pc, #88]	; (4397c <sys_clock_driver_init+0x68>)
   43922:	4b17      	ldr	r3, [pc, #92]	; (43980 <sys_clock_driver_init+0x6c>)
   43924:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   43928:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   4392c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   43930:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43932:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   43936:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   4393a:	4b12      	ldr	r3, [pc, #72]	; (43984 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   4393c:	2101      	movs	r1, #1
   4393e:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   43942:	2015      	movs	r0, #21
   43944:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   43948:	4622      	mov	r2, r4
   4394a:	f7fe fbf5 	bl	42138 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   4394e:	2015      	movs	r0, #21
   43950:	f7fe fbd4 	bl	420fc <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   43954:	2301      	movs	r3, #1
   43956:	4a0c      	ldr	r2, [pc, #48]	; (43988 <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43958:	4620      	mov	r0, r4
   4395a:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   4395c:	4a0b      	ldr	r2, [pc, #44]	; (4398c <sys_clock_driver_init+0x78>)
   4395e:	602b      	str	r3, [r5, #0]
   43960:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43962:	4b0b      	ldr	r3, [pc, #44]	; (43990 <sys_clock_driver_init+0x7c>)
   43964:	4a0b      	ldr	r2, [pc, #44]	; (43994 <sys_clock_driver_init+0x80>)
   43966:	9300      	str	r3, [sp, #0]
   43968:	9401      	str	r4, [sp, #4]
   4396a:	2300      	movs	r3, #0
   4396c:	f7ff ff32 	bl	437d4 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   43970:	4630      	mov	r0, r6
   43972:	f7ff faa9 	bl	42ec8 <z_nrf_clock_control_lf_on>

	return 0;
}
   43976:	4620      	mov	r0, r4
   43978:	b002      	add	sp, #8
   4397a:	bd70      	pop	{r4, r5, r6, pc}
   4397c:	40015000 	.word	0x40015000
   43980:	2001a750 	.word	0x2001a750
   43984:	e000e100 	.word	0xe000e100
   43988:	40015008 	.word	0x40015008
   4398c:	2001a9bc 	.word	0x2001a9bc
   43990:	0004366d 	.word	0x0004366d
   43994:	007fffff 	.word	0x007fffff

00043998 <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   43998:	4b33      	ldr	r3, [pc, #204]	; (43a68 <rtc_nrf_isr+0xd0>)
{
   4399a:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   4399e:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   439a2:	079a      	lsls	r2, r3, #30
   439a4:	d509      	bpl.n	439ba <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   439a6:	4b31      	ldr	r3, [pc, #196]	; (43a6c <rtc_nrf_isr+0xd4>)
   439a8:	681a      	ldr	r2, [r3, #0]
   439aa:	b132      	cbz	r2, 439ba <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   439ac:	2200      	movs	r2, #0
   439ae:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   439b0:	4a2f      	ldr	r2, [pc, #188]	; (43a70 <rtc_nrf_isr+0xd8>)
   439b2:	681b      	ldr	r3, [r3, #0]
   439b4:	6813      	ldr	r3, [r2, #0]
   439b6:	3301      	adds	r3, #1
   439b8:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   439ba:	f04f 0320 	mov.w	r3, #32
   439be:	f3ef 8211 	mrs	r2, BASEPRI
   439c2:	f383 8812 	msr	BASEPRI_MAX, r3
   439c6:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   439ca:	4b27      	ldr	r3, [pc, #156]	; (43a68 <rtc_nrf_isr+0xd0>)
   439cc:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   439d0:	03db      	lsls	r3, r3, #15
   439d2:	d50e      	bpl.n	439f2 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   439d4:	4b27      	ldr	r3, [pc, #156]	; (43a74 <rtc_nrf_isr+0xdc>)
   439d6:	e8d3 1fef 	ldaex	r1, [r3]
   439da:	f021 0001 	bic.w	r0, r1, #1
   439de:	e8c3 0fe4 	stlex	r4, r0, [r3]
   439e2:	2c00      	cmp	r4, #0
   439e4:	d1f7      	bne.n	439d6 <rtc_nrf_isr+0x3e>
   439e6:	4b24      	ldr	r3, [pc, #144]	; (43a78 <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   439e8:	2900      	cmp	r1, #0
   439ea:	d136      	bne.n	43a5a <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   439ec:	6819      	ldr	r1, [r3, #0]
		if (result) {
   439ee:	2900      	cmp	r1, #0
   439f0:	d133      	bne.n	43a5a <rtc_nrf_isr+0xc2>
{
   439f2:	2300      	movs	r3, #0
	__asm__ volatile(
   439f4:	f382 8811 	msr	BASEPRI, r2
   439f8:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   439fc:	b353      	cbz	r3, 43a54 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   439fe:	f7ff fec7 	bl	43790 <z_nrf_rtc_timer_read>
   43a02:	4604      	mov	r4, r0
	__asm__ volatile(
   43a04:	f04f 0320 	mov.w	r3, #32
   43a08:	f3ef 8011 	mrs	r0, BASEPRI
   43a0c:	f383 8812 	msr	BASEPRI_MAX, r3
   43a10:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   43a14:	4b19      	ldr	r3, [pc, #100]	; (43a7c <rtc_nrf_isr+0xe4>)
   43a16:	2200      	movs	r2, #0
   43a18:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   43a1c:	4549      	cmp	r1, r9
   43a1e:	bf08      	it	eq
   43a20:	4544      	cmpeq	r4, r8
   43a22:	d31f      	bcc.n	43a64 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   43a24:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43a28:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   43a2c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   43a30:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   43a32:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43a36:	e9c3 4502 	strd	r4, r5, [r3, #8]
   43a3a:	4b0b      	ldr	r3, [pc, #44]	; (43a68 <rtc_nrf_isr+0xd0>)
   43a3c:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   43a40:	f380 8811 	msr	BASEPRI, r0
   43a44:	f3bf 8f6f 	isb	sy
		if (handler) {
   43a48:	b121      	cbz	r1, 43a54 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   43a4a:	4642      	mov	r2, r8
   43a4c:	464b      	mov	r3, r9
   43a4e:	2000      	movs	r0, #0
   43a50:	9600      	str	r6, [sp, #0]
   43a52:	4788      	blx	r1
}
   43a54:	b002      	add	sp, #8
   43a56:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43a5a:	2100      	movs	r1, #0
   43a5c:	6019      	str	r1, [r3, #0]
   43a5e:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43a60:	2301      	movs	r3, #1
}
   43a62:	e7c7      	b.n	439f4 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   43a64:	4611      	mov	r1, r2
   43a66:	e7eb      	b.n	43a40 <rtc_nrf_isr+0xa8>
   43a68:	40015000 	.word	0x40015000
   43a6c:	40015104 	.word	0x40015104
   43a70:	2001a9c0 	.word	0x2001a9c0
   43a74:	2001a9b8 	.word	0x2001a9b8
   43a78:	40015140 	.word	0x40015140
   43a7c:	2001a750 	.word	0x2001a750

00043a80 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43a80:	4b15      	ldr	r3, [pc, #84]	; (43ad8 <sys_clock_set_timeout+0x58>)
{
   43a82:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43a84:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   43a88:	bf08      	it	eq
   43a8a:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43a8c:	1e46      	subs	r6, r0, #1
   43a8e:	2e00      	cmp	r6, #0
   43a90:	dd20      	ble.n	43ad4 <sys_clock_set_timeout+0x54>
   43a92:	429e      	cmp	r6, r3
   43a94:	bfa8      	it	ge
   43a96:	461e      	movge	r6, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   43a98:	f7ff fe7a 	bl	43790 <z_nrf_rtc_timer_read>
   43a9c:	4b0f      	ldr	r3, [pc, #60]	; (43adc <sys_clock_set_timeout+0x5c>)
   43a9e:	e9d3 4500 	ldrd	r4, r5, [r3]
   43aa2:	1b00      	subs	r0, r0, r4
		ticks = 0;
   43aa4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43aa8:	bf28      	it	cs
   43aaa:	2600      	movcs	r6, #0
	cyc += (CYC_PER_TICK - 1);
   43aac:	3020      	adds	r0, #32
   43aae:	eb00 1246 	add.w	r2, r0, r6, lsl #5
	uint64_t target_time = cyc + last_count;
   43ab2:	480b      	ldr	r0, [pc, #44]	; (43ae0 <sys_clock_set_timeout+0x60>)
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
   43ab4:	f022 021f 	bic.w	r2, r2, #31
	uint64_t target_time = cyc + last_count;
   43ab8:	4282      	cmp	r2, r0
   43aba:	bf28      	it	cs
   43abc:	4602      	movcs	r2, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   43abe:	2000      	movs	r0, #0
   43ac0:	4b08      	ldr	r3, [pc, #32]	; (43ae4 <sys_clock_set_timeout+0x64>)
   43ac2:	18a2      	adds	r2, r4, r2
   43ac4:	9300      	str	r3, [sp, #0]
   43ac6:	9001      	str	r0, [sp, #4]
   43ac8:	f145 0300 	adc.w	r3, r5, #0
   43acc:	f7ff fe82 	bl	437d4 <compare_set>
}
   43ad0:	b002      	add	sp, #8
   43ad2:	bd70      	pop	{r4, r5, r6, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43ad4:	2600      	movs	r6, #0
   43ad6:	e7df      	b.n	43a98 <sys_clock_set_timeout+0x18>
   43ad8:	0003ffff 	.word	0x0003ffff
   43adc:	2001a760 	.word	0x2001a760
   43ae0:	007fffe0 	.word	0x007fffe0
   43ae4:	0004366d 	.word	0x0004366d

00043ae8 <sys_clock_elapsed>:
{
   43ae8:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   43aea:	f7ff fe51 	bl	43790 <z_nrf_rtc_timer_read>
   43aee:	4a05      	ldr	r2, [pc, #20]	; (43b04 <sys_clock_elapsed+0x1c>)
   43af0:	e9d2 3200 	ldrd	r3, r2, [r2]
   43af4:	1ac0      	subs	r0, r0, r3
   43af6:	eb61 0102 	sbc.w	r1, r1, r2
   43afa:	0940      	lsrs	r0, r0, #5
}
   43afc:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
   43b00:	bd08      	pop	{r3, pc}
   43b02:	bf00      	nop
   43b04:	2001a760 	.word	0x2001a760

00043b08 <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   43b08:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   43b0a:	4d19      	ldr	r5, [pc, #100]	; (43b70 <_nrf_modem_lib_init+0x68>)
   43b0c:	4c19      	ldr	r4, [pc, #100]	; (43b74 <_nrf_modem_lib_init+0x6c>)
   43b0e:	782b      	ldrb	r3, [r5, #0]
   43b10:	b933      	cbnz	r3, 43b20 <_nrf_modem_lib_init+0x18>
	list->tail = NULL;
   43b12:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   43b16:	4818      	ldr	r0, [pc, #96]	; (43b78 <_nrf_modem_lib_init+0x70>)
   43b18:	f004 ff62 	bl	489e0 <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   43b1c:	2301      	movs	r3, #1
   43b1e:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   43b20:	2200      	movs	r2, #0
   43b22:	202a      	movs	r0, #42	; 0x2a
   43b24:	4611      	mov	r1, r2
   43b26:	f7fe fb07 	bl	42138 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   43b2a:	2100      	movs	r1, #0
   43b2c:	4813      	ldr	r0, [pc, #76]	; (43b7c <_nrf_modem_lib_init+0x74>)
   43b2e:	f002 f965 	bl	45dfc <nrf_modem_init>
   43b32:	4b13      	ldr	r3, [pc, #76]	; (43b80 <_nrf_modem_lib_init+0x78>)
   43b34:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   43b36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43b3a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43b3e:	480e      	ldr	r0, [pc, #56]	; (43b78 <_nrf_modem_lib_init+0x70>)
   43b40:	f002 fd7e 	bl	46640 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   43b44:	6820      	ldr	r0, [r4, #0]
   43b46:	b170      	cbz	r0, 43b66 <_nrf_modem_lib_init+0x5e>
	return node->next;
   43b48:	6804      	ldr	r4, [r0, #0]
   43b4a:	2c00      	cmp	r4, #0
   43b4c:	bf38      	it	cc
   43b4e:	2400      	movcc	r4, #0
	z_impl_k_sem_give(sem);
   43b50:	3004      	adds	r0, #4
   43b52:	f002 fe39 	bl	467c8 <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   43b56:	b134      	cbz	r4, 43b66 <_nrf_modem_lib_init+0x5e>
   43b58:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43b5a:	4620      	mov	r0, r4
   43b5c:	2b00      	cmp	r3, #0
   43b5e:	bf38      	it	cc
   43b60:	2300      	movcc	r3, #0
   43b62:	461c      	mov	r4, r3
   43b64:	e7f4      	b.n	43b50 <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   43b66:	4804      	ldr	r0, [pc, #16]	; (43b78 <_nrf_modem_lib_init+0x70>)
   43b68:	f002 fde8 	bl	4673c <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   43b6c:	2000      	movs	r0, #0
   43b6e:	bd38      	pop	{r3, r4, r5, pc}
   43b70:	2001adfd 	.word	0x2001adfd
   43b74:	2001a9c8 	.word	0x2001a9c8
   43b78:	2001a9d0 	.word	0x2001a9d0
   43b7c:	0004924c 	.word	0x0004924c
   43b80:	2001a9c4 	.word	0x2001a9c4

00043b84 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   43b84:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   43b86:	4c0d      	ldr	r4, [pc, #52]	; (43bbc <thread_monitor_entry_get+0x38>)
{
   43b88:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   43b8a:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   43b8c:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   43b8e:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   43b90:	4b0b      	ldr	r3, [pc, #44]	; (43bc0 <thread_monitor_entry_get+0x3c>)
   43b92:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   43b94:	6801      	ldr	r1, [r0, #0]
   43b96:	4291      	cmp	r1, r2
   43b98:	d00e      	beq.n	43bb8 <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   43b9a:	b151      	cbz	r1, 43bb2 <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   43b9c:	6841      	ldr	r1, [r0, #4]
   43b9e:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   43ba0:	42b1      	cmp	r1, r6
   43ba2:	bfc4      	itt	gt
   43ba4:	4604      	movgt	r4, r0
   43ba6:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   43ba8:	3d01      	subs	r5, #1
   43baa:	f100 0008 	add.w	r0, r0, #8
   43bae:	d1f1      	bne.n	43b94 <thread_monitor_entry_get+0x10>
   43bb0:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   43bb2:	3b01      	subs	r3, #1
	new_entry->id = id;
   43bb4:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   43bb6:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   43bb8:	bd70      	pop	{r4, r5, r6, pc}
   43bba:	bf00      	nop
   43bbc:	2001aa3c 	.word	0x2001aa3c
   43bc0:	2001aa18 	.word	0x2001aa18

00043bc4 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43bc4:	4668      	mov	r0, sp
   43bc6:	f020 0107 	bic.w	r1, r0, #7
   43bca:	468d      	mov	sp, r1
   43bcc:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   43bce:	4b0f      	ldr	r3, [pc, #60]	; (43c0c <rpc_proxy_irq_handler+0x48>)
   43bd0:	e8d3 2fef 	ldaex	r2, [r3]
   43bd4:	3201      	adds	r2, #1
   43bd6:	e8c3 2fe1 	stlex	r1, r2, [r3]
   43bda:	2900      	cmp	r1, #0
   43bdc:	d1f8      	bne.n	43bd0 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   43bde:	f001 f951 	bl	44e84 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   43be2:	4b0b      	ldr	r3, [pc, #44]	; (43c10 <rpc_proxy_irq_handler+0x4c>)
   43be4:	681c      	ldr	r4, [r3, #0]
   43be6:	2c00      	cmp	r4, #0
   43be8:	bf38      	it	cc
   43bea:	2400      	movcc	r4, #0
   43bec:	b12c      	cbz	r4, 43bfa <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   43bee:	1d20      	adds	r0, r4, #4
   43bf0:	f002 fdea 	bl	467c8 <z_impl_k_sem_give>
   43bf4:	6824      	ldr	r4, [r4, #0]
   43bf6:	2c00      	cmp	r4, #0
   43bf8:	d1f8      	bne.n	43bec <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   43bfa:	f7fe fab3 	bl	42164 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   43bfe:	f7fe fb8b 	bl	42318 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43c02:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   43c06:	4685      	mov	sp, r0
   43c08:	4770      	bx	lr
   43c0a:	bf00      	nop
   43c0c:	2001aa18 	.word	0x2001aa18
   43c10:	2001aa34 	.word	0x2001aa34

00043c14 <nrf_modem_os_timedwait>:
{
   43c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43c18:	4688      	mov	r8, r1
   43c1a:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   43c1c:	f005 f829 	bl	48c72 <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   43c20:	f8d8 3000 	ldr.w	r3, [r8]
   43c24:	4604      	mov	r4, r0
   43c26:	2b00      	cmp	r3, #0
   43c28:	460d      	mov	r5, r1
   43c2a:	d103      	bne.n	43c34 <nrf_modem_os_timedwait+0x20>
	z_impl_k_yield();
   43c2c:	f003 f864 	bl	46cf8 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   43c30:	2074      	movs	r0, #116	; 0x74
   43c32:	e077      	b.n	43d24 <nrf_modem_os_timedwait+0x110>
		*timeout = SYS_FOREVER_MS;
   43c34:	bfbc      	itt	lt
   43c36:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   43c3a:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   43c3e:	2201      	movs	r2, #1
   43c40:	2100      	movs	r1, #0
   43c42:	a802      	add	r0, sp, #8
   43c44:	f004 fed3 	bl	489ee <z_impl_k_sem_init>
   43c48:	f10d 0904 	add.w	r9, sp, #4
	__asm__ volatile(
   43c4c:	f04f 0320 	mov.w	r3, #32
   43c50:	f3ef 8b11 	mrs	fp, BASEPRI
   43c54:	f383 8812 	msr	BASEPRI_MAX, r3
   43c58:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   43c5c:	f003 f8ee 	bl	46e3c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43c60:	f7ff ff90 	bl	43b84 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   43c64:	4938      	ldr	r1, [pc, #224]	; (43d48 <nrf_modem_os_timedwait+0x134>)
   43c66:	6843      	ldr	r3, [r0, #4]
   43c68:	680a      	ldr	r2, [r1, #0]
   43c6a:	468a      	mov	sl, r1
   43c6c:	4293      	cmp	r3, r2
   43c6e:	f04f 0300 	mov.w	r3, #0
   43c72:	d108      	bne.n	43c86 <nrf_modem_os_timedwait+0x72>
	parent->next = child;
   43c74:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   43c76:	4b35      	ldr	r3, [pc, #212]	; (43d4c <nrf_modem_os_timedwait+0x138>)
   43c78:	685a      	ldr	r2, [r3, #4]
   43c7a:	2a00      	cmp	r2, #0
   43c7c:	d155      	bne.n	43d2a <nrf_modem_os_timedwait+0x116>
	list->head = node;
   43c7e:	e9c3 9900 	strd	r9, r9, [r3]
		allow_to_sleep = true;
   43c82:	2301      	movs	r3, #1
}
   43c84:	e000      	b.n	43c88 <nrf_modem_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   43c86:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   43c88:	f38b 8811 	msr	BASEPRI, fp
   43c8c:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   43c90:	2b00      	cmp	r3, #0
   43c92:	d046      	beq.n	43d22 <nrf_modem_os_timedwait+0x10e>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   43c94:	f8d8 2000 	ldr.w	r2, [r8]
   43c98:	1c53      	adds	r3, r2, #1
   43c9a:	bf19      	ittee	ne
   43c9c:	ea22 72e2 	bicne.w	r2, r2, r2, asr #31
   43ca0:	17d3      	asrne	r3, r2, #31
   43ca2:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   43ca6:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
	return z_impl_k_sem_take(sem, timeout);
   43caa:	a802      	add	r0, sp, #8
   43cac:	f002 fdac 	bl	46808 <z_impl_k_sem_take>
	__asm__ volatile(
   43cb0:	f04f 0320 	mov.w	r3, #32
   43cb4:	f3ef 8b11 	mrs	fp, BASEPRI
   43cb8:	f383 8812 	msr	BASEPRI_MAX, r3
   43cbc:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43cc0:	2000      	movs	r0, #0
   43cc2:	4b22      	ldr	r3, [pc, #136]	; (43d4c <nrf_modem_os_timedwait+0x138>)
   43cc4:	681a      	ldr	r2, [r3, #0]
   43cc6:	b152      	cbz	r2, 43cde <nrf_modem_os_timedwait+0xca>
   43cc8:	454a      	cmp	r2, r9
   43cca:	d139      	bne.n	43d40 <nrf_modem_os_timedwait+0x12c>
Z_GENLIST_REMOVE(slist, snode)
   43ccc:	9901      	ldr	r1, [sp, #4]
   43cce:	bb88      	cbnz	r0, 43d34 <nrf_modem_os_timedwait+0x120>
   43cd0:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   43cd2:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   43cd4:	4290      	cmp	r0, r2
   43cd6:	d100      	bne.n	43cda <nrf_modem_os_timedwait+0xc6>
	list->tail = node;
   43cd8:	6059      	str	r1, [r3, #4]
	parent->next = child;
   43cda:	2300      	movs	r3, #0
   43cdc:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   43cde:	f003 f8ad 	bl	46e3c <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43ce2:	f7ff ff4f 	bl	43b84 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   43ce6:	f8da 3000 	ldr.w	r3, [sl]
   43cea:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   43cec:	f38b 8811 	msr	BASEPRI, fp
   43cf0:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   43cf4:	f8d8 9000 	ldr.w	r9, [r8]
   43cf8:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   43cfc:	d011      	beq.n	43d22 <nrf_modem_os_timedwait+0x10e>
	return z_impl_k_uptime_ticks();
   43cfe:	f004 ffb8 	bl	48c72 <z_impl_k_uptime_ticks>
	remaining = *timeout - k_uptime_delta(&start);
   43d02:	eb14 0409 	adds.w	r4, r4, r9
   43d06:	eb45 75e9 	adc.w	r5, r5, r9, asr #31
   43d0a:	1a26      	subs	r6, r4, r0
   43d0c:	eb65 0701 	sbc.w	r7, r5, r1
	*timeout = remaining > 0 ? remaining : 0;
   43d10:	2e00      	cmp	r6, #0
   43d12:	f177 0300 	sbcs.w	r3, r7, #0
   43d16:	bfb8      	it	lt
   43d18:	2600      	movlt	r6, #0
   43d1a:	f8c8 6000 	str.w	r6, [r8]
	if (*timeout == 0) {
   43d1e:	2e00      	cmp	r6, #0
   43d20:	d086      	beq.n	43c30 <nrf_modem_os_timedwait+0x1c>
	return 0;
   43d22:	2000      	movs	r0, #0
}
   43d24:	b007      	add	sp, #28
   43d26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43d2a:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   43d2e:	f8c3 9004 	str.w	r9, [r3, #4]
   43d32:	e7a6      	b.n	43c82 <nrf_modem_os_timedwait+0x6e>
	parent->next = child;
   43d34:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   43d36:	6859      	ldr	r1, [r3, #4]
   43d38:	4291      	cmp	r1, r2
	list->tail = node;
   43d3a:	bf08      	it	eq
   43d3c:	6058      	streq	r0, [r3, #4]
}
   43d3e:	e7cc      	b.n	43cda <nrf_modem_os_timedwait+0xc6>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43d40:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   43d42:	6812      	ldr	r2, [r2, #0]
   43d44:	e7bf      	b.n	43cc6 <nrf_modem_os_timedwait+0xb2>
   43d46:	bf00      	nop
   43d48:	2001aa18 	.word	0x2001aa18
   43d4c:	2001aa34 	.word	0x2001aa34

00043d50 <nrf_modem_os_sem_init>:
{
   43d50:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   43d52:	6804      	ldr	r4, [r0, #0]
   43d54:	4b09      	ldr	r3, [pc, #36]	; (43d7c <nrf_modem_os_sem_init+0x2c>)
   43d56:	b12c      	cbz	r4, 43d64 <nrf_modem_os_sem_init+0x14>
   43d58:	429c      	cmp	r4, r3
   43d5a:	d303      	bcc.n	43d64 <nrf_modem_os_sem_init+0x14>
   43d5c:	f103 0530 	add.w	r5, r3, #48	; 0x30
   43d60:	42ac      	cmp	r4, r5
   43d62:	d306      	bcc.n	43d72 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   43d64:	4d06      	ldr	r5, [pc, #24]	; (43d80 <nrf_modem_os_sem_init+0x30>)
   43d66:	782c      	ldrb	r4, [r5, #0]
   43d68:	1c66      	adds	r6, r4, #1
   43d6a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   43d6e:	702e      	strb	r6, [r5, #0]
   43d70:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   43d72:	6800      	ldr	r0, [r0, #0]
}
   43d74:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   43d76:	f004 be3a 	b.w	489ee <z_impl_k_sem_init>
   43d7a:	bf00      	nop
   43d7c:	2001a9e8 	.word	0x2001a9e8
   43d80:	2001adfe 	.word	0x2001adfe

00043d84 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43d84:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43d88:	4b01      	ldr	r3, [pc, #4]	; (43d90 <nrf_modem_os_application_irq_set+0xc>)
   43d8a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43d8e:	4770      	bx	lr
   43d90:	e000e100 	.word	0xe000e100

00043d94 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43d94:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   43d98:	4b01      	ldr	r3, [pc, #4]	; (43da0 <nrf_modem_os_application_irq_clear+0xc>)
   43d9a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43d9e:	4770      	bx	lr
   43da0:	e000e100 	.word	0xe000e100

00043da4 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43da4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43da8:	4b01      	ldr	r3, [pc, #4]	; (43db0 <nrf_modem_os_trace_irq_set+0xc>)
   43daa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   43dae:	4770      	bx	lr
   43db0:	e000e100 	.word	0xe000e100

00043db4 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43db4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   43db8:	4b01      	ldr	r3, [pc, #4]	; (43dc0 <nrf_modem_os_trace_irq_clear+0xc>)
   43dba:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   43dbe:	4770      	bx	lr
   43dc0:	e000e100 	.word	0xe000e100

00043dc4 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   43dc4:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   43dc6:	2200      	movs	r2, #0
   43dc8:	2300      	movs	r3, #0
   43dca:	4801      	ldr	r0, [pc, #4]	; (43dd0 <nrf_modem_os_alloc+0xc>)
   43dcc:	f004 bd8b 	b.w	488e6 <k_heap_alloc>
   43dd0:	2001a640 	.word	0x2001a640

00043dd4 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   43dd4:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   43dd6:	4801      	ldr	r0, [pc, #4]	; (43ddc <nrf_modem_os_free+0x8>)
   43dd8:	f004 bd8f 	b.w	488fa <k_heap_free>
   43ddc:	2001a640 	.word	0x2001a640

00043de0 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   43de0:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   43de2:	2200      	movs	r2, #0
   43de4:	2300      	movs	r3, #0
   43de6:	4801      	ldr	r0, [pc, #4]	; (43dec <nrf_modem_os_shm_tx_alloc+0xc>)
   43de8:	f004 bd7d 	b.w	488e6 <k_heap_alloc>
   43dec:	2001aa20 	.word	0x2001aa20

00043df0 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   43df0:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   43df2:	4801      	ldr	r0, [pc, #4]	; (43df8 <nrf_modem_os_shm_tx_free+0x8>)
   43df4:	f004 bd81 	b.w	488fa <k_heap_free>
   43df8:	2001aa20 	.word	0x2001aa20

00043dfc <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   43dfc:	b510      	push	{r4, lr}
	list->head = NULL;
   43dfe:	2400      	movs	r4, #0
   43e00:	4b0e      	ldr	r3, [pc, #56]	; (43e3c <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   43e02:	e9c3 4400 	strd	r4, r4, [r3]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43e06:	4b0e      	ldr	r3, [pc, #56]	; (43e40 <nrf_modem_os_init+0x44>)
   43e08:	e8d3 2fef 	ldaex	r2, [r3]
   43e0c:	e8c3 4fe1 	stlex	r1, r4, [r3]
   43e10:	2900      	cmp	r1, #0
   43e12:	d1f9      	bne.n	43e08 <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   43e14:	f004 fbf8 	bl	48608 <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   43e18:	4621      	mov	r1, r4
   43e1a:	2204      	movs	r2, #4
   43e1c:	4809      	ldr	r0, [pc, #36]	; (43e44 <nrf_modem_os_init+0x48>)
   43e1e:	f004 fa5f 	bl	482e0 <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   43e22:	4621      	mov	r1, r4
   43e24:	2204      	movs	r2, #4
   43e26:	4808      	ldr	r0, [pc, #32]	; (43e48 <nrf_modem_os_init+0x4c>)
   43e28:	f004 fa5a 	bl	482e0 <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   43e2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   43e30:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   43e34:	4905      	ldr	r1, [pc, #20]	; (43e4c <nrf_modem_os_init+0x50>)
   43e36:	4806      	ldr	r0, [pc, #24]	; (43e50 <nrf_modem_os_init+0x54>)
   43e38:	f004 bd06 	b.w	48848 <k_heap_init>
   43e3c:	2001aa34 	.word	0x2001aa34
   43e40:	2001aa18 	.word	0x2001aa18
   43e44:	2001a9e4 	.word	0x2001a9e4
   43e48:	2001aa1c 	.word	0x2001aa1c
   43e4c:	200164e8 	.word	0x200164e8
   43e50:	2001aa20 	.word	0x2001aa20

00043e54 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   43e54:	b508      	push	{r3, lr}
	z_impl_log_panic();
   43e56:	f7fd fc61 	bl	4171c <z_impl_log_panic>
   43e5a:	4b06      	ldr	r3, [pc, #24]	; (43e74 <k_sys_fatal_error_handler+0x20>)
   43e5c:	4906      	ldr	r1, [pc, #24]	; (43e78 <k_sys_fatal_error_handler+0x24>)
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   43e5e:	4807      	ldr	r0, [pc, #28]	; (43e7c <k_sys_fatal_error_handler+0x28>)
   43e60:	1ac9      	subs	r1, r1, r3
   43e62:	08c9      	lsrs	r1, r1, #3
   43e64:	0189      	lsls	r1, r1, #6
   43e66:	f041 0101 	orr.w	r1, r1, #1
   43e6a:	f003 ff1b 	bl	47ca4 <log_0>
		sys_arch_reboot(0);
   43e6e:	2000      	movs	r0, #0
   43e70:	f004 fbd9 	bl	48626 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   43e74:	00049038 	.word	0x00049038
   43e78:	00049040 	.word	0x00049040
   43e7c:	000499c9 	.word	0x000499c9

00043e80 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   43e80:	b5f0      	push	{r4, r5, r6, r7, lr}
   43e82:	4604      	mov	r4, r0
   43e84:	b0a3      	sub	sp, #140	; 0x8c
   43e86:	460d      	mov	r5, r1
   43e88:	4616      	mov	r6, r2
   43e8a:	461f      	mov	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   43e8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43e90:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43e94:	480b      	ldr	r0, [pc, #44]	; (43ec4 <tfm_ns_interface_dispatch+0x44>)
   43e96:	f002 fbd3 	bl	46640 <z_impl_k_mutex_lock>
	int32_t result;

	/* TF-M request protected by NS lock */
	if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   43e9a:	b988      	cbnz	r0, 43ec0 <tfm_ns_interface_dispatch+0x40>
#endif

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   43e9c:	4668      	mov	r0, sp
   43e9e:	f004 f998 	bl	481d2 <z_arm_save_fp_context>
#endif

	result = fn(arg0, arg1, arg2, arg3);
   43ea2:	463a      	mov	r2, r7
   43ea4:	4631      	mov	r1, r6
   43ea6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   43ea8:	4628      	mov	r0, r5
   43eaa:	47a0      	blx	r4
   43eac:	4604      	mov	r4, r0

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	z_arm_restore_fp_context(&context_buffer);
   43eae:	4668      	mov	r0, sp
   43eb0:	f004 f990 	bl	481d4 <z_arm_restore_fp_context>
	return z_impl_k_mutex_unlock(mutex);
   43eb4:	4803      	ldr	r0, [pc, #12]	; (43ec4 <tfm_ns_interface_dispatch+0x44>)
   43eb6:	f002 fc41 	bl	4673c <z_impl_k_mutex_unlock>
#endif

	k_mutex_unlock(&tfm_mutex);

	return result;
}
   43eba:	4620      	mov	r0, r4
   43ebc:	b023      	add	sp, #140	; 0x8c
   43ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (int32_t)TFM_ERROR_GENERIC;
   43ec0:	241f      	movs	r4, #31
   43ec2:	e7fa      	b.n	43eba <tfm_ns_interface_dispatch+0x3a>
   43ec4:	2001a668 	.word	0x2001a668

00043ec8 <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   43ec8:	4b01      	ldr	r3, [pc, #4]	; (43ed0 <SystemInit+0x8>)
   43eca:	4a02      	ldr	r2, [pc, #8]	; (43ed4 <SystemInit+0xc>)
   43ecc:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   43ece:	4770      	bx	lr
   43ed0:	2001a58c 	.word	0x2001a58c
   43ed4:	03d09000 	.word	0x03d09000

00043ed8 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   43ed8:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   43eda:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   43edc:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   43ede:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   43ee2:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   43ee4:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   43ee8:	d010      	beq.n	43f0c <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   43eea:	fa05 f204 	lsl.w	r2, r5, r4
   43eee:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   43ef2:	e8d0 6fef 	ldaex	r6, [r0]
   43ef6:	429e      	cmp	r6, r3
   43ef8:	d104      	bne.n	43f04 <nrfx_flag32_alloc+0x2c>
   43efa:	e8c0 2fec 	stlex	ip, r2, [r0]
   43efe:	f1bc 0f00 	cmp.w	ip, #0
   43f02:	d1f6      	bne.n	43ef2 <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43f04:	d1ea      	bne.n	43edc <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   43f06:	4802      	ldr	r0, [pc, #8]	; (43f10 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   43f08:	700c      	strb	r4, [r1, #0]
}
   43f0a:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   43f0c:	4801      	ldr	r0, [pc, #4]	; (43f14 <nrfx_flag32_alloc+0x3c>)
   43f0e:	e7fc      	b.n	43f0a <nrfx_flag32_alloc+0x32>
   43f10:	0bad0000 	.word	0x0bad0000
   43f14:	0bad0002 	.word	0x0bad0002

00043f18 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   43f18:	6803      	ldr	r3, [r0, #0]
{
   43f1a:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   43f1c:	40cb      	lsrs	r3, r1
   43f1e:	07db      	lsls	r3, r3, #31
   43f20:	d411      	bmi.n	43f46 <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   43f22:	2301      	movs	r3, #1
   43f24:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   43f28:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   43f2a:	ea41 0203 	orr.w	r2, r1, r3
   43f2e:	e8d0 4fef 	ldaex	r4, [r0]
   43f32:	429c      	cmp	r4, r3
   43f34:	d104      	bne.n	43f40 <nrfx_flag32_free+0x28>
   43f36:	e8c0 2fec 	stlex	ip, r2, [r0]
   43f3a:	f1bc 0f00 	cmp.w	ip, #0
   43f3e:	d1f6      	bne.n	43f2e <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   43f40:	d1f2      	bne.n	43f28 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   43f42:	4802      	ldr	r0, [pc, #8]	; (43f4c <nrfx_flag32_free+0x34>)
}
   43f44:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   43f46:	4802      	ldr	r0, [pc, #8]	; (43f50 <nrfx_flag32_free+0x38>)
   43f48:	e7fc      	b.n	43f44 <nrfx_flag32_free+0x2c>
   43f4a:	bf00      	nop
   43f4c:	0bad0000 	.word	0x0bad0000
   43f50:	0bad0004 	.word	0x0bad0004

00043f54 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   43f54:	4b04      	ldr	r3, [pc, #16]	; (43f68 <nrfx_clock_init+0x14>)
   43f56:	791a      	ldrb	r2, [r3, #4]
   43f58:	b922      	cbnz	r2, 43f64 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   43f5a:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   43f5c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   43f5e:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   43f60:	4802      	ldr	r0, [pc, #8]	; (43f6c <nrfx_clock_init+0x18>)
   43f62:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   43f64:	4802      	ldr	r0, [pc, #8]	; (43f70 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   43f66:	4770      	bx	lr
   43f68:	2001aa8c 	.word	0x2001aa8c
   43f6c:	0bad0000 	.word	0x0bad0000
   43f70:	0bad000c 	.word	0x0bad000c

00043f74 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43f74:	b110      	cbz	r0, 43f7c <nrfx_clock_start+0x8>
   43f76:	2801      	cmp	r0, #1
   43f78:	d01e      	beq.n	43fb8 <nrfx_clock_start+0x44>
   43f7a:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43f7c:	4b13      	ldr	r3, [pc, #76]	; (43fcc <nrfx_clock_start+0x58>)
   43f7e:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43f82:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   43f86:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   43f8a:	4619      	mov	r1, r3
   43f8c:	d010      	beq.n	43fb0 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   43f8e:	f002 0203 	and.w	r2, r2, #3
   43f92:	2a02      	cmp	r2, #2
   43f94:	d10c      	bne.n	43fb0 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   43f96:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43f9a:	2200      	movs	r2, #0
   43f9c:	4b0c      	ldr	r3, [pc, #48]	; (43fd0 <nrfx_clock_start+0x5c>)
   43f9e:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   43fa0:	2202      	movs	r2, #2
   43fa2:	681b      	ldr	r3, [r3, #0]
   43fa4:	4b09      	ldr	r3, [pc, #36]	; (43fcc <nrfx_clock_start+0x58>)
   43fa6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43faa:	2201      	movs	r2, #1
   43fac:	609a      	str	r2, [r3, #8]
}
   43fae:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   43fb0:	2301      	movs	r3, #1
   43fb2:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   43fb6:	e7f0      	b.n	43f9a <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43fb8:	2200      	movs	r2, #0
   43fba:	4b06      	ldr	r3, [pc, #24]	; (43fd4 <nrfx_clock_start+0x60>)
   43fbc:	601a      	str	r2, [r3, #0]
   43fbe:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   43fc0:	4b02      	ldr	r3, [pc, #8]	; (43fcc <nrfx_clock_start+0x58>)
   43fc2:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43fc6:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   43fc8:	4770      	bx	lr
   43fca:	bf00      	nop
   43fcc:	40005000 	.word	0x40005000
   43fd0:	40005104 	.word	0x40005104
   43fd4:	40005100 	.word	0x40005100

00043fd8 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   43fd8:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   43fda:	b110      	cbz	r0, 43fe2 <nrfx_clock_stop+0xa>
   43fdc:	2801      	cmp	r0, #1
   43fde:	d016      	beq.n	4400e <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   43fe0:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   43fe2:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43fe4:	2101      	movs	r1, #1
   43fe6:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   43fea:	4c16      	ldr	r4, [pc, #88]	; (44044 <nrfx_clock_stop+0x6c>)
   43fec:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43ff0:	4a15      	ldr	r2, [pc, #84]	; (44048 <nrfx_clock_stop+0x70>)
   43ff2:	6010      	str	r0, [r2, #0]
   43ff4:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43ff6:	4a15      	ldr	r2, [pc, #84]	; (4404c <nrfx_clock_stop+0x74>)
   43ff8:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43ffa:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   43ffe:	03db      	lsls	r3, r3, #15
   44000:	d5ee      	bpl.n	43fe0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   44002:	2001      	movs	r0, #1
   44004:	f004 fb12 	bl	4862c <nrfx_busy_wait>
   44008:	3d01      	subs	r5, #1
   4400a:	d1f6      	bne.n	43ffa <nrfx_clock_stop+0x22>
   4400c:	e7e8      	b.n	43fe0 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4400e:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44010:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44014:	4b0e      	ldr	r3, [pc, #56]	; (44050 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   44016:	4c0b      	ldr	r4, [pc, #44]	; (44044 <nrfx_clock_stop+0x6c>)
   44018:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4401c:	601a      	str	r2, [r3, #0]
   4401e:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44020:	4b0c      	ldr	r3, [pc, #48]	; (44054 <nrfx_clock_stop+0x7c>)
   44022:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   44024:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   44028:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   4402c:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   44030:	03d2      	lsls	r2, r2, #15
   44032:	d5d5      	bpl.n	43fe0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   44034:	2b00      	cmp	r3, #0
   44036:	d0d3      	beq.n	43fe0 <nrfx_clock_stop+0x8>
   44038:	2001      	movs	r0, #1
   4403a:	f004 faf7 	bl	4862c <nrfx_busy_wait>
   4403e:	3d01      	subs	r5, #1
   44040:	d1f0      	bne.n	44024 <nrfx_clock_stop+0x4c>
   44042:	e7cd      	b.n	43fe0 <nrfx_clock_stop+0x8>
   44044:	40005000 	.word	0x40005000
   44048:	40005104 	.word	0x40005104
   4404c:	4000500c 	.word	0x4000500c
   44050:	40005100 	.word	0x40005100
   44054:	40005004 	.word	0x40005004

00044058 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   44058:	4b15      	ldr	r3, [pc, #84]	; (440b0 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   4405a:	b510      	push	{r4, lr}
   4405c:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   4405e:	b14a      	cbz	r2, 44074 <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44060:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   44062:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44064:	6018      	str	r0, [r3, #0]
   44066:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   44068:	4b12      	ldr	r3, [pc, #72]	; (440b4 <nrfx_power_clock_irq_handler+0x5c>)
   4406a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   4406e:	4b12      	ldr	r3, [pc, #72]	; (440b8 <nrfx_power_clock_irq_handler+0x60>)
   44070:	681b      	ldr	r3, [r3, #0]
   44072:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   44074:	4b11      	ldr	r3, [pc, #68]	; (440bc <nrfx_power_clock_irq_handler+0x64>)
   44076:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   44078:	b182      	cbz	r2, 4409c <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4407a:	2200      	movs	r2, #0
   4407c:	601a      	str	r2, [r3, #0]
   4407e:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   44080:	4b0c      	ldr	r3, [pc, #48]	; (440b4 <nrfx_power_clock_irq_handler+0x5c>)
   44082:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   44086:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   4408a:	f002 0203 	and.w	r2, r2, #3
   4408e:	2a01      	cmp	r2, #1
   44090:	f04f 0102 	mov.w	r1, #2
   44094:	d103      	bne.n	4409e <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   44096:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4409a:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   4409c:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   4409e:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   440a2:	4b05      	ldr	r3, [pc, #20]	; (440b8 <nrfx_power_clock_irq_handler+0x60>)
   440a4:	2001      	movs	r0, #1
}
   440a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   440aa:	681b      	ldr	r3, [r3, #0]
   440ac:	4718      	bx	r3
   440ae:	bf00      	nop
   440b0:	40005100 	.word	0x40005100
   440b4:	40005000 	.word	0x40005000
   440b8:	2001aa8c 	.word	0x2001aa8c
   440bc:	40005104 	.word	0x40005104

000440c0 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   440c0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   440c2:	4801      	ldr	r0, [pc, #4]	; (440c8 <nrfx_dppi_channel_alloc+0x8>)
   440c4:	f7ff bf08 	b.w	43ed8 <nrfx_flag32_alloc>
   440c8:	2001a590 	.word	0x2001a590

000440cc <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   440cc:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   440ce:	4c0d      	ldr	r4, [pc, #52]	; (44104 <call_handler+0x38>)
   440d0:	f100 0308 	add.w	r3, r0, #8
   440d4:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   440d8:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   440da:	05da      	lsls	r2, r3, #23
{
   440dc:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   440de:	d507      	bpl.n	440f0 <call_handler+0x24>
   440e0:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   440e4:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   440e8:	6852      	ldr	r2, [r2, #4]
   440ea:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   440ee:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   440f0:	68a3      	ldr	r3, [r4, #8]
   440f2:	b12b      	cbz	r3, 44100 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   440f4:	4631      	mov	r1, r6
   440f6:	4628      	mov	r0, r5
   440f8:	68e2      	ldr	r2, [r4, #12]
    }
}
   440fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   440fe:	4718      	bx	r3
}
   44100:	bd70      	pop	{r4, r5, r6, pc}
   44102:	bf00      	nop
   44104:	2001a594 	.word	0x2001a594

00044108 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   44108:	4b12      	ldr	r3, [pc, #72]	; (44154 <release_handler+0x4c>)
   4410a:	3008      	adds	r0, #8
   4410c:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   44110:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   44112:	05d1      	lsls	r1, r2, #23
   44114:	d51b      	bpl.n	4414e <release_handler+0x46>
   44116:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   4411a:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   4411e:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   44122:	2000      	movs	r0, #0
   44124:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   44128:	f834 2b02 	ldrh.w	r2, [r4], #2
   4412c:	f412 7f80 	tst.w	r2, #256	; 0x100
   44130:	d003      	beq.n	4413a <release_handler+0x32>
   44132:	f3c2 2243 	ubfx	r2, r2, #9, #4
   44136:	4291      	cmp	r1, r2
   44138:	d009      	beq.n	4414e <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   4413a:	3001      	adds	r0, #1
   4413c:	2820      	cmp	r0, #32
   4413e:	d1f3      	bne.n	44128 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   44140:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   44142:	4805      	ldr	r0, [pc, #20]	; (44158 <release_handler+0x50>)
}
   44144:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   44146:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   4414a:	f7ff bee5 	b.w	43f18 <nrfx_flag32_free>
}
   4414e:	bc10      	pop	{r4}
   44150:	4770      	bx	lr
   44152:	bf00      	nop
   44154:	2001a594 	.word	0x2001a594
   44158:	2001a5e8 	.word	0x2001a5e8

0004415c <pin_handler_trigger_uninit>:
{
   4415c:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   4415e:	4c0c      	ldr	r4, [pc, #48]	; (44190 <pin_handler_trigger_uninit+0x34>)
   44160:	f100 0508 	add.w	r5, r0, #8
   44164:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   44168:	069a      	lsls	r2, r3, #26
   4416a:	d50a      	bpl.n	44182 <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   4416c:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   4416e:	0b5b      	lsrs	r3, r3, #13
   44170:	009b      	lsls	r3, r3, #2
   44172:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44176:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   4417a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   4417e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   44182:	f7ff ffc1 	bl	44108 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   44186:	2300      	movs	r3, #0
   44188:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   4418c:	bd38      	pop	{r3, r4, r5, pc}
   4418e:	bf00      	nop
   44190:	2001a594 	.word	0x2001a594

00044194 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   44194:	f000 021f 	and.w	r2, r0, #31
   44198:	4805      	ldr	r0, [pc, #20]	; (441b0 <nrf_gpio_cfg_sense_set+0x1c>)
   4419a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4419e:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   441a2:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   441a6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   441aa:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   441ae:	4770      	bx	lr
   441b0:	40842500 	.word	0x40842500

000441b4 <nrfx_gpiote_input_configure>:
{
   441b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   441b6:	4604      	mov	r4, r0
    if (p_input_config)
   441b8:	b1f9      	cbz	r1, 441fa <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   441ba:	4f4c      	ldr	r7, [pc, #304]	; (442ec <nrfx_gpiote_input_configure+0x138>)
   441bc:	f100 0c08 	add.w	ip, r0, #8
   441c0:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   441c4:	f000 0522 	and.w	r5, r0, #34	; 0x22
   441c8:	2d22      	cmp	r5, #34	; 0x22
   441ca:	d102      	bne.n	441d2 <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   441cc:	4848      	ldr	r0, [pc, #288]	; (442f0 <nrfx_gpiote_input_configure+0x13c>)
}
   441ce:	b003      	add	sp, #12
   441d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   441d2:	4d48      	ldr	r5, [pc, #288]	; (442f4 <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   441d4:	f004 061f 	and.w	r6, r4, #31
   441d8:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   441dc:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   441e0:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   441e2:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   441e6:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   441ea:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   441ee:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   441f2:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   441f6:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   441fa:	b192      	cbz	r2, 44222 <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   441fc:	483b      	ldr	r0, [pc, #236]	; (442ec <nrfx_gpiote_input_configure+0x138>)
   441fe:	f104 0608 	add.w	r6, r4, #8
   44202:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   44206:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   44208:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   4420a:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   4420c:	d50c      	bpl.n	44228 <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   4420e:	2a00      	cmp	r2, #0
   44210:	d1dc      	bne.n	441cc <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   44212:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   44216:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   4421a:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   4421e:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   44222:	bbd3      	cbnz	r3, 4429a <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   44224:	4834      	ldr	r0, [pc, #208]	; (442f8 <nrfx_gpiote_input_configure+0x144>)
   44226:	e7d2      	b.n	441ce <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   44228:	f021 0120 	bic.w	r1, r1, #32
   4422c:	04c9      	lsls	r1, r1, #19
   4422e:	0cc9      	lsrs	r1, r1, #19
   44230:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   44234:	2a00      	cmp	r2, #0
   44236:	d0ec      	beq.n	44212 <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   44238:	2d03      	cmp	r5, #3
   4423a:	d8c7      	bhi.n	441cc <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   4423c:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   44240:	4662      	mov	r2, ip
   44242:	0092      	lsls	r2, r2, #2
   44244:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   44248:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   4424c:	b925      	cbnz	r5, 44258 <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   4424e:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   44252:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   44256:	e7dc      	b.n	44212 <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44258:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4425c:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44260:	f027 0703 	bic.w	r7, r7, #3
   44264:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   44268:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4426c:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   44270:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   44274:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   44278:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4427c:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44280:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   44284:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   44288:	ea47 070e 	orr.w	r7, r7, lr
   4428c:	f041 0120 	orr.w	r1, r1, #32
   44290:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   44294:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   44298:	e7bb      	b.n	44212 <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   4429a:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   4429c:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   442a0:	f7ff ff32 	bl	44108 <release_handler>
    if (!handler)
   442a4:	2e00      	cmp	r6, #0
   442a6:	d0bd      	beq.n	44224 <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   442a8:	4d10      	ldr	r5, [pc, #64]	; (442ec <nrfx_gpiote_input_configure+0x138>)
   442aa:	682b      	ldr	r3, [r5, #0]
   442ac:	429e      	cmp	r6, r3
   442ae:	d104      	bne.n	442ba <nrfx_gpiote_input_configure+0x106>
   442b0:	686b      	ldr	r3, [r5, #4]
   442b2:	429f      	cmp	r7, r3
   442b4:	d101      	bne.n	442ba <nrfx_gpiote_input_configure+0x106>
   442b6:	2200      	movs	r2, #0
   442b8:	e009      	b.n	442ce <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   442ba:	4810      	ldr	r0, [pc, #64]	; (442fc <nrfx_gpiote_input_configure+0x148>)
   442bc:	f10d 0107 	add.w	r1, sp, #7
   442c0:	f7ff fe0a 	bl	43ed8 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   442c4:	4b0c      	ldr	r3, [pc, #48]	; (442f8 <nrfx_gpiote_input_configure+0x144>)
   442c6:	4298      	cmp	r0, r3
   442c8:	d181      	bne.n	441ce <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   442ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   442ce:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   442d2:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   442d4:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   442d6:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   442da:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   442de:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   442e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   442e6:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   442ea:	e79b      	b.n	44224 <nrfx_gpiote_input_configure+0x70>
   442ec:	2001a594 	.word	0x2001a594
   442f0:	0bad0004 	.word	0x0bad0004
   442f4:	40842500 	.word	0x40842500
   442f8:	0bad0000 	.word	0x0bad0000
   442fc:	2001a5e8 	.word	0x2001a5e8

00044300 <nrfx_gpiote_output_configure>:
{
   44300:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   44304:	2900      	cmp	r1, #0
   44306:	d044      	beq.n	44392 <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44308:	4e43      	ldr	r6, [pc, #268]	; (44418 <nrfx_gpiote_output_configure+0x118>)
   4430a:	f100 0c08 	add.w	ip, r0, #8
   4430e:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   44312:	07ab      	lsls	r3, r5, #30
   44314:	d404      	bmi.n	44320 <nrfx_gpiote_output_configure+0x20>
   44316:	06af      	lsls	r7, r5, #26
   44318:	d502      	bpl.n	44320 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4431a:	4840      	ldr	r0, [pc, #256]	; (4441c <nrfx_gpiote_output_configure+0x11c>)
}
   4431c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   44320:	f015 0f1c 	tst.w	r5, #28
   44324:	d002      	beq.n	4432c <nrfx_gpiote_output_configure+0x2c>
   44326:	784b      	ldrb	r3, [r1, #1]
   44328:	2b01      	cmp	r3, #1
   4432a:	d0f6      	beq.n	4431a <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   4432c:	4b3c      	ldr	r3, [pc, #240]	; (44420 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4432e:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   44332:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   44336:	bf14      	ite	ne
   44338:	2402      	movne	r4, #2
   4433a:	2400      	moveq	r4, #0
   4433c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44340:	1c8b      	adds	r3, r1, #2
   44342:	bf14      	ite	ne
   44344:	f04f 090c 	movne.w	r9, #12
   44348:	f04f 0900 	moveq.w	r9, #0
   4434c:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44350:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   44354:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   44358:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   4435c:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   44360:	f1be 0f00 	cmp.w	lr, #0
   44364:	d003      	beq.n	4436e <nrfx_gpiote_output_configure+0x6e>
   44366:	f891 e001 	ldrb.w	lr, [r1, #1]
   4436a:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4436e:	b10b      	cbz	r3, 44374 <nrfx_gpiote_output_configure+0x74>
   44370:	788c      	ldrb	r4, [r1, #2]
   44372:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   44374:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   44376:	f045 0503 	orr.w	r5, r5, #3
   4437a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   4437e:	ea43 0308 	orr.w	r3, r3, r8
   44382:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   44386:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   4438a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   4438e:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   44392:	b90a      	cbnz	r2, 44398 <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   44394:	4823      	ldr	r0, [pc, #140]	; (44424 <nrfx_gpiote_output_configure+0x124>)
   44396:	e7c1      	b.n	4431c <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44398:	4d1f      	ldr	r5, [pc, #124]	; (44418 <nrfx_gpiote_output_configure+0x118>)
   4439a:	f100 0608 	add.w	r6, r0, #8
   4439e:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   443a2:	07a3      	lsls	r3, r4, #30
   443a4:	d5b9      	bpl.n	4431a <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   443a6:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   443a8:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   443aa:	f024 0420 	bic.w	r4, r4, #32
   443ae:	00b9      	lsls	r1, r7, #2
   443b0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   443b4:	04e4      	lsls	r4, r4, #19
   443b6:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   443ba:	0ce4      	lsrs	r4, r4, #19
   443bc:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   443c0:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   443c4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   443c8:	f892 c001 	ldrb.w	ip, [r2, #1]
   443cc:	f1bc 0f00 	cmp.w	ip, #0
   443d0:	d0e0      	beq.n	44394 <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   443d2:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   443d6:	7892      	ldrb	r2, [r2, #2]
   443d8:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   443dc:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   443e0:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   443e4:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   443e8:	0203      	lsls	r3, r0, #8
   443ea:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   443ee:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   443f2:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   443f6:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   443fa:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   443fc:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   443fe:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44402:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44406:	4313      	orrs	r3, r2
   44408:	f044 0420 	orr.w	r4, r4, #32
   4440c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44410:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   44414:	e7be      	b.n	44394 <nrfx_gpiote_output_configure+0x94>
   44416:	bf00      	nop
   44418:	2001a594 	.word	0x2001a594
   4441c:	0bad0004 	.word	0x0bad0004
   44420:	40842500 	.word	0x40842500
   44424:	0bad0000 	.word	0x0bad0000

00044428 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   44428:	4b01      	ldr	r3, [pc, #4]	; (44430 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   4442a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   4442e:	4770      	bx	lr
   44430:	2001a594 	.word	0x2001a594

00044434 <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44434:	4b05      	ldr	r3, [pc, #20]	; (4444c <nrfx_gpiote_channel_get+0x18>)
   44436:	3008      	adds	r0, #8
   44438:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   4443c:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   4443e:	bf43      	ittte	mi
   44440:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   44442:	4803      	ldrmi	r0, [pc, #12]	; (44450 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44444:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   44446:	4803      	ldrpl	r0, [pc, #12]	; (44454 <nrfx_gpiote_channel_get+0x20>)
}
   44448:	4770      	bx	lr
   4444a:	bf00      	nop
   4444c:	2001a594 	.word	0x2001a594
   44450:	0bad0000 	.word	0x0bad0000
   44454:	0bad0004 	.word	0x0bad0004

00044458 <nrfx_gpiote_init>:
{
   44458:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4445a:	4c0e      	ldr	r4, [pc, #56]	; (44494 <nrfx_gpiote_init+0x3c>)
   4445c:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   44460:	b9b5      	cbnz	r5, 44490 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   44462:	2240      	movs	r2, #64	; 0x40
   44464:	4629      	mov	r1, r5
   44466:	f104 0010 	add.w	r0, r4, #16
   4446a:	f003 ff39 	bl	482e0 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   4446e:	2031      	movs	r0, #49	; 0x31
   44470:	f7fd fe44 	bl	420fc <arch_irq_enable>
    p_reg->INTENSET = mask;
   44474:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44478:	4b07      	ldr	r3, [pc, #28]	; (44498 <nrfx_gpiote_init+0x40>)
    return err_code;
   4447a:	4808      	ldr	r0, [pc, #32]	; (4449c <nrfx_gpiote_init+0x44>)
   4447c:	601d      	str	r5, [r3, #0]
   4447e:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   44480:	4b07      	ldr	r3, [pc, #28]	; (444a0 <nrfx_gpiote_init+0x48>)
   44482:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44486:	2301      	movs	r3, #1
   44488:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   4448c:	6563      	str	r3, [r4, #84]	; 0x54
}
   4448e:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   44490:	4804      	ldr	r0, [pc, #16]	; (444a4 <nrfx_gpiote_init+0x4c>)
   44492:	e7fc      	b.n	4448e <nrfx_gpiote_init+0x36>
   44494:	2001a594 	.word	0x2001a594
   44498:	4003117c 	.word	0x4003117c
   4449c:	0bad0000 	.word	0x0bad0000
   444a0:	40031000 	.word	0x40031000
   444a4:	0bad0005 	.word	0x0bad0005

000444a8 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   444a8:	4b03      	ldr	r3, [pc, #12]	; (444b8 <nrfx_gpiote_is_init+0x10>)
   444aa:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   444ae:	3800      	subs	r0, #0
   444b0:	bf18      	it	ne
   444b2:	2001      	movne	r0, #1
   444b4:	4770      	bx	lr
   444b6:	bf00      	nop
   444b8:	2001a594 	.word	0x2001a594

000444bc <nrfx_gpiote_channel_free>:
{
   444bc:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   444be:	4801      	ldr	r0, [pc, #4]	; (444c4 <nrfx_gpiote_channel_free+0x8>)
   444c0:	f7ff bd2a 	b.w	43f18 <nrfx_flag32_free>
   444c4:	2001a5e4 	.word	0x2001a5e4

000444c8 <nrfx_gpiote_channel_alloc>:
{
   444c8:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   444ca:	4801      	ldr	r0, [pc, #4]	; (444d0 <nrfx_gpiote_channel_alloc+0x8>)
   444cc:	f7ff bd04 	b.w	43ed8 <nrfx_flag32_alloc>
   444d0:	2001a5e4 	.word	0x2001a5e4

000444d4 <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   444d4:	4b1b      	ldr	r3, [pc, #108]	; (44544 <nrfx_gpiote_trigger_enable+0x70>)
   444d6:	f100 0208 	add.w	r2, r0, #8
   444da:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   444de:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   444e0:	069a      	lsls	r2, r3, #26
   444e2:	d51a      	bpl.n	4451a <nrfx_gpiote_trigger_enable+0x46>
   444e4:	f013 0402 	ands.w	r4, r3, #2
   444e8:	d117      	bne.n	4451a <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   444ea:	4817      	ldr	r0, [pc, #92]	; (44548 <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   444ec:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   444ee:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   444f0:	5084      	str	r4, [r0, r2]
   444f2:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   444f4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   444f8:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   444fc:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   44500:	f040 0001 	orr.w	r0, r0, #1
   44504:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   44508:	b129      	cbz	r1, 44516 <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   4450a:	2201      	movs	r2, #1
   4450c:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   44510:	4a0e      	ldr	r2, [pc, #56]	; (4454c <nrfx_gpiote_trigger_enable+0x78>)
   44512:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44516:	bc10      	pop	{r4}
   44518:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4451a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   4451e:	2b04      	cmp	r3, #4
   44520:	d00c      	beq.n	4453c <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   44522:	2b05      	cmp	r3, #5
   44524:	d00c      	beq.n	44540 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   44526:	4b0a      	ldr	r3, [pc, #40]	; (44550 <nrfx_gpiote_trigger_enable+0x7c>)
   44528:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   4452a:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   4452e:	40d9      	lsrs	r1, r3
   44530:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44534:	3102      	adds	r1, #2
}
   44536:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   44538:	f7ff be2c 	b.w	44194 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   4453c:	2103      	movs	r1, #3
   4453e:	e7fa      	b.n	44536 <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   44540:	2102      	movs	r1, #2
   44542:	e7f8      	b.n	44536 <nrfx_gpiote_trigger_enable+0x62>
   44544:	2001a594 	.word	0x2001a594
   44548:	40031100 	.word	0x40031100
   4454c:	40031000 	.word	0x40031000
   44550:	40842500 	.word	0x40842500

00044554 <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44554:	4b0e      	ldr	r3, [pc, #56]	; (44590 <nrfx_gpiote_trigger_disable+0x3c>)
   44556:	f100 0208 	add.w	r2, r0, #8
   4455a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   4455e:	0699      	lsls	r1, r3, #26
   44560:	d513      	bpl.n	4458a <nrfx_gpiote_trigger_disable+0x36>
   44562:	079a      	lsls	r2, r3, #30
   44564:	d411      	bmi.n	4458a <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   44566:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44568:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   4456a:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   4456c:	4909      	ldr	r1, [pc, #36]	; (44594 <nrfx_gpiote_trigger_disable+0x40>)
   4456e:	009b      	lsls	r3, r3, #2
   44570:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44574:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   44578:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   4457c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   44580:	f022 0203 	bic.w	r2, r2, #3
   44584:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   44588:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   4458a:	2100      	movs	r1, #0
   4458c:	f7ff be02 	b.w	44194 <nrf_gpio_cfg_sense_set>
   44590:	2001a594 	.word	0x2001a594
   44594:	40031000 	.word	0x40031000

00044598 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   44598:	4b0c      	ldr	r3, [pc, #48]	; (445cc <nrfx_gpiote_pin_uninit+0x34>)
   4459a:	f100 0208 	add.w	r2, r0, #8
   4459e:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   445a2:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   445a4:	07db      	lsls	r3, r3, #31
{
   445a6:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   445a8:	d50d      	bpl.n	445c6 <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   445aa:	f7ff ffd3 	bl	44554 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   445ae:	4620      	mov	r0, r4
   445b0:	f7ff fdd4 	bl	4415c <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   445b4:	2202      	movs	r2, #2
   445b6:	4b06      	ldr	r3, [pc, #24]	; (445d0 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   445b8:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   445bc:	3480      	adds	r4, #128	; 0x80
   445be:	4805      	ldr	r0, [pc, #20]	; (445d4 <nrfx_gpiote_pin_uninit+0x3c>)
   445c0:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   445c4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   445c6:	4804      	ldr	r0, [pc, #16]	; (445d8 <nrfx_gpiote_pin_uninit+0x40>)
   445c8:	e7fc      	b.n	445c4 <nrfx_gpiote_pin_uninit+0x2c>
   445ca:	bf00      	nop
   445cc:	2001a594 	.word	0x2001a594
   445d0:	40842500 	.word	0x40842500
   445d4:	0bad0000 	.word	0x0bad0000
   445d8:	0bad0004 	.word	0x0bad0004

000445dc <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   445dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   445e0:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   445e2:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   445e4:	4634      	mov	r4, r6
{
   445e6:	4b4b      	ldr	r3, [pc, #300]	; (44714 <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   445e8:	484b      	ldr	r0, [pc, #300]	; (44718 <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   445ea:	494c      	ldr	r1, [pc, #304]	; (4471c <nrfx_gpiote_irq_handler+0x140>)
{
   445ec:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   445ee:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   445f0:	b135      	cbz	r5, 44600 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   445f2:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   445f6:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   445f8:	bf1e      	ittt	ne
   445fa:	601c      	strne	r4, [r3, #0]
   445fc:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   445fe:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   44600:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44602:	428b      	cmp	r3, r1
        mask <<= 1;
   44604:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44608:	d1f1      	bne.n	445ee <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4460a:	4f45      	ldr	r7, [pc, #276]	; (44720 <nrfx_gpiote_irq_handler+0x144>)
   4460c:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   4460e:	b183      	cbz	r3, 44632 <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   44610:	4d44      	ldr	r5, [pc, #272]	; (44724 <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   44612:	f10d 080c 	add.w	r8, sp, #12
   44616:	6a2b      	ldr	r3, [r5, #32]
   44618:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4461a:	622b      	str	r3, [r5, #32]
   4461c:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   44620:	9803      	ldr	r0, [sp, #12]
   44622:	b940      	cbnz	r0, 44636 <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44624:	6038      	str	r0, [r7, #0]
   44626:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   44628:	6a2b      	ldr	r3, [r5, #32]
   4462a:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4462c:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   4462e:	2b00      	cmp	r3, #0
   44630:	d1f4      	bne.n	4461c <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   44632:	2401      	movs	r4, #1
   44634:	e069      	b.n	4470a <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   44636:	fa90 faa0 	rbit	sl, r0
   4463a:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4463e:	4a3a      	ldr	r2, [pc, #232]	; (44728 <nrfx_gpiote_irq_handler+0x14c>)
   44640:	f10a 0308 	add.w	r3, sl, #8
   44644:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   44648:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   4464c:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   44650:	fa09 f403 	lsl.w	r4, r9, r3
   44654:	f818 300c 	ldrb.w	r3, [r8, ip]
   44658:	f3c1 0282 	ubfx	r2, r1, #2, #3
   4465c:	ea23 0304 	bic.w	r3, r3, r4
   44660:	f808 300c 	strb.w	r3, [r8, ip]
   44664:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44668:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   4466c:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4466e:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   44670:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   44674:	d518      	bpl.n	446a8 <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   44676:	4611      	mov	r1, r2
   44678:	4650      	mov	r0, sl
   4467a:	9301      	str	r3, [sp, #4]
   4467c:	f7ff fd26 	bl	440cc <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   44680:	9b01      	ldr	r3, [sp, #4]
   44682:	b2e4      	uxtb	r4, r4
   44684:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   44688:	f3c3 4301 	ubfx	r3, r3, #16, #2
   4468c:	429c      	cmp	r4, r3
   4468e:	d107      	bne.n	446a0 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   44690:	2100      	movs	r1, #0
   44692:	4650      	mov	r0, sl
   44694:	f7ff fd7e 	bl	44194 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   44698:	4621      	mov	r1, r4
   4469a:	4650      	mov	r0, sl
   4469c:	f7ff fd7a 	bl	44194 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   446a0:	fa09 f00a 	lsl.w	r0, r9, sl
   446a4:	6228      	str	r0, [r5, #32]
}
   446a6:	e7bb      	b.n	44620 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   446a8:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   446aa:	bf0c      	ite	eq
   446ac:	2103      	moveq	r1, #3
   446ae:	2102      	movne	r1, #2
   446b0:	4650      	mov	r0, sl
   446b2:	9201      	str	r2, [sp, #4]
   446b4:	f7ff fd6e 	bl	44194 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   446b8:	9a01      	ldr	r2, [sp, #4]
   446ba:	2a03      	cmp	r2, #3
   446bc:	d004      	beq.n	446c8 <nrfx_gpiote_irq_handler+0xec>
   446be:	2c02      	cmp	r4, #2
   446c0:	d107      	bne.n	446d2 <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   446c2:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   446c6:	d1eb      	bne.n	446a0 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   446c8:	4659      	mov	r1, fp
   446ca:	4650      	mov	r0, sl
   446cc:	f7ff fcfe 	bl	440cc <call_handler>
   446d0:	e7e6      	b.n	446a0 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   446d2:	2c03      	cmp	r4, #3
   446d4:	d1e4      	bne.n	446a0 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   446d6:	f1bb 0f02 	cmp.w	fp, #2
   446da:	e7f4      	b.n	446c6 <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   446dc:	fa96 f3a6 	rbit	r3, r6
   446e0:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   446e4:	fa04 f203 	lsl.w	r2, r4, r3
   446e8:	009b      	lsls	r3, r3, #2
   446ea:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   446ee:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   446f2:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   446f6:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   446fa:	f3c0 2004 	ubfx	r0, r0, #8, #5
   446fe:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   44702:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   44706:	f7ff fce1 	bl	440cc <call_handler>
    while (mask)
   4470a:	2e00      	cmp	r6, #0
   4470c:	d1e6      	bne.n	446dc <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   4470e:	b005      	add	sp, #20
   44710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44714:	40031100 	.word	0x40031100
   44718:	40031000 	.word	0x40031000
   4471c:	40031120 	.word	0x40031120
   44720:	4003117c 	.word	0x4003117c
   44724:	40842500 	.word	0x40842500
   44728:	2001a594 	.word	0x2001a594

0004472c <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   4472c:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   4472e:	4c08      	ldr	r4, [pc, #32]	; (44750 <nrfx_ipc_init+0x24>)
{
   44730:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44732:	7923      	ldrb	r3, [r4, #4]
{
   44734:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44736:	b943      	cbnz	r3, 4474a <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   44738:	202a      	movs	r0, #42	; 0x2a
   4473a:	f7fd fcdf 	bl	420fc <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   4473e:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   44740:	4804      	ldr	r0, [pc, #16]	; (44754 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44742:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   44744:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   44746:	60a5      	str	r5, [r4, #8]
}
   44748:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   4474a:	4803      	ldr	r0, [pc, #12]	; (44758 <nrfx_ipc_init+0x2c>)
   4474c:	e7fc      	b.n	44748 <nrfx_ipc_init+0x1c>
   4474e:	bf00      	nop
   44750:	2001aa94 	.word	0x2001aa94
   44754:	0bad0000 	.word	0x0bad0000
   44758:	0bad000c 	.word	0x0bad000c

0004475c <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4475c:	2300      	movs	r3, #0
{
   4475e:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   44760:	4a0d      	ldr	r2, [pc, #52]	; (44798 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   44762:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   44766:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   4476a:	3301      	adds	r3, #1
   4476c:	2b08      	cmp	r3, #8
   4476e:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   44772:	d1f6      	bne.n	44762 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   44774:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   44776:	4a08      	ldr	r2, [pc, #32]	; (44798 <nrfx_ipc_config_load+0x3c>)
   44778:	f100 0120 	add.w	r1, r0, #32
   4477c:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   44780:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44784:	3301      	adds	r3, #1
   44786:	2b08      	cmp	r3, #8
   44788:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   4478c:	d1f6      	bne.n	4477c <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   4478e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   44790:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44794:	bd30      	pop	{r4, r5, pc}
   44796:	bf00      	nop
   44798:	4002a000 	.word	0x4002a000

0004479c <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   4479c:	2300      	movs	r3, #0
   4479e:	4a14      	ldr	r2, [pc, #80]	; (447f0 <nrfx_ipc_uninit+0x54>)
   447a0:	4914      	ldr	r1, [pc, #80]	; (447f4 <nrfx_ipc_uninit+0x58>)
   447a2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   447a6:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   447aa:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   447ae:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   447b2:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   447b6:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   447ba:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   447be:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   447c2:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   447c6:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   447ca:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   447ce:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   447d2:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   447d6:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   447da:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   447de:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   447e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   447e6:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   447ea:	4a03      	ldr	r2, [pc, #12]	; (447f8 <nrfx_ipc_uninit+0x5c>)
   447ec:	7113      	strb	r3, [r2, #4]
}
   447ee:	4770      	bx	lr
   447f0:	4002a004 	.word	0x4002a004
   447f4:	4002a000 	.word	0x4002a000
   447f8:	2001aa94 	.word	0x2001aa94

000447fc <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   447fc:	4b0c      	ldr	r3, [pc, #48]	; (44830 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   447fe:	b430      	push	{r4, r5}
   44800:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   44804:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   44806:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44808:	2500      	movs	r5, #0
    while (bitmask)
   4480a:	b923      	cbnz	r3, 44816 <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   4480c:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   4480e:	4b09      	ldr	r3, [pc, #36]	; (44834 <nrfx_ipc_irq_handler+0x38>)
   44810:	681a      	ldr	r2, [r3, #0]
   44812:	6899      	ldr	r1, [r3, #8]
   44814:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   44816:	fa93 f2a3 	rbit	r2, r3
   4481a:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   4481e:	fa04 f102 	lsl.w	r1, r4, r2
   44822:	ea23 0301 	bic.w	r3, r3, r1
   44826:	4904      	ldr	r1, [pc, #16]	; (44838 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   44828:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4482a:	508d      	str	r5, [r1, r2]
}
   4482c:	e7ed      	b.n	4480a <nrfx_ipc_irq_handler+0xe>
   4482e:	bf00      	nop
   44830:	4002a000 	.word	0x4002a000
   44834:	2001aa94 	.word	0x2001aa94
   44838:	4002a100 	.word	0x4002a100

0004483c <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   4483c:	2303      	movs	r3, #3
static void _DoInit(void) {
   4483e:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44840:	4c10      	ldr	r4, [pc, #64]	; (44884 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   44842:	4a11      	ldr	r2, [pc, #68]	; (44888 <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44844:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   44846:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   44848:	4b10      	ldr	r3, [pc, #64]	; (4488c <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   4484a:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   4484c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   4484e:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
   44852:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   44854:	2300      	movs	r3, #0
   44856:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   44858:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4485a:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   4485c:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   4485e:	4a0c      	ldr	r2, [pc, #48]	; (44890 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   44860:	490c      	ldr	r1, [pc, #48]	; (44894 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
   44862:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44864:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
   44866:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44868:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   4486a:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   4486c:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   4486e:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   44870:	f003 fcea 	bl	48248 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   44874:	4620      	mov	r0, r4
   44876:	4908      	ldr	r1, [pc, #32]	; (44898 <_DoInit+0x5c>)
   44878:	f003 fce6 	bl	48248 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   4487c:	2320      	movs	r3, #32
   4487e:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   44880:	bd10      	pop	{r4, pc}
   44882:	bf00      	nop
   44884:	2001aaa0 	.word	0x2001aaa0
   44888:	000499e6 	.word	0x000499e6
   4488c:	2001ae0f 	.word	0x2001ae0f
   44890:	2001adff 	.word	0x2001adff
   44894:	000499ef 	.word	0x000499ef
   44898:	000499f3 	.word	0x000499f3

0004489c <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   4489c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   448a0:	f04f 0b18 	mov.w	fp, #24
   448a4:	4f22      	ldr	r7, [pc, #136]	; (44930 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   448a6:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   448a8:	fb0b 7200 	mla	r2, fp, r0, r7
   448ac:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   448ae:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   448b0:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   448b2:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   448b4:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   448b6:	d834      	bhi.n	44922 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   448b8:	f8d2 a020 	ldr.w	sl, [r2, #32]
   448bc:	ebaa 0905 	sub.w	r9, sl, r5
   448c0:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
   448c4:	4294      	cmp	r4, r2
   448c6:	d811      	bhi.n	448ec <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   448c8:	f04f 0918 	mov.w	r9, #24
   448cc:	fb06 9309 	mla	r3, r6, r9, r9
   448d0:	443b      	add	r3, r7
   448d2:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   448d4:	4622      	mov	r2, r4
   448d6:	4641      	mov	r1, r8
   448d8:	4428      	add	r0, r5
   448da:	f003 fcf6 	bl	482ca <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   448de:	fb09 7606 	mla	r6, r9, r6, r7
   448e2:	442c      	add	r4, r5
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
   448e4:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   448e6:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   448e8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   448ec:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   448ee:	429c      	cmp	r4, r3
   448f0:	d81b      	bhi.n	4492a <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   448f2:	fb00 bb0b 	mla	fp, r0, fp, fp
   448f6:	44bb      	add	fp, r7
   448f8:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   448fc:	464a      	mov	r2, r9
   448fe:	4428      	add	r0, r5
   44900:	442c      	add	r4, r5
   44902:	f003 fce2 	bl	482ca <memcpy>
      if (NumBytes) {
   44906:	ebb4 040a 	subs.w	r4, r4, sl
   4490a:	d006      	beq.n	4491a <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   4490c:	4622      	mov	r2, r4
   4490e:	f8db 0004 	ldr.w	r0, [fp, #4]
   44912:	eb08 0109 	add.w	r1, r8, r9
   44916:	f003 fcd8 	bl	482ca <memcpy>
      pRing->WrOff = NumBytes;
   4491a:	2018      	movs	r0, #24
   4491c:	fb00 7606 	mla	r6, r0, r6, r7
   44920:	e7e0      	b.n	448e4 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   44922:	3b01      	subs	r3, #1
   44924:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   44926:	42a3      	cmp	r3, r4
   44928:	d2ce      	bcs.n	448c8 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   4492a:	2000      	movs	r0, #0
   4492c:	e7dc      	b.n	448e8 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   4492e:	bf00      	nop
   44930:	2001aaa0 	.word	0x2001aaa0

00044934 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   44934:	2218      	movs	r2, #24
   44936:	4b03      	ldr	r3, [pc, #12]	; (44944 <SEGGER_RTT_HasDataUp+0x10>)
   44938:	fb02 3300 	mla	r3, r2, r0, r3
   4493c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   4493e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   44940:	1a80      	subs	r0, r0, r2
   44942:	4770      	bx	lr
   44944:	2001aaa0 	.word	0x2001aaa0

00044948 <rpc_handle_data_message>:
   44948:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4494c:	4680      	mov	r8, r0
   4494e:	4604      	mov	r4, r0
   44950:	2700      	movs	r7, #0
   44952:	f858 6b08 	ldr.w	r6, [r8], #8
   44956:	4d0c      	ldr	r5, [pc, #48]	; (44988 <rpc_handle_data_message+0x40>)
   44958:	b2f6      	uxtb	r6, r6
   4495a:	782b      	ldrb	r3, [r5, #0]
   4495c:	42b3      	cmp	r3, r6
   4495e:	d00a      	beq.n	44976 <rpc_handle_data_message+0x2e>
   44960:	3701      	adds	r7, #1
   44962:	2f04      	cmp	r7, #4
   44964:	f105 050c 	add.w	r5, r5, #12
   44968:	d1f7      	bne.n	4495a <rpc_handle_data_message+0x12>
   4496a:	68a0      	ldr	r0, [r4, #8]
   4496c:	b150      	cbz	r0, 44984 <rpc_handle_data_message+0x3c>
   4496e:	f003 feb3 	bl	486d8 <rpc_transport_peer_data_free>
   44972:	2000      	movs	r0, #0
   44974:	e006      	b.n	44984 <rpc_handle_data_message+0x3c>
   44976:	6821      	ldr	r1, [r4, #0]
   44978:	4640      	mov	r0, r8
   4497a:	686b      	ldr	r3, [r5, #4]
   4497c:	0c09      	lsrs	r1, r1, #16
   4497e:	4798      	blx	r3
   44980:	2802      	cmp	r0, #2
   44982:	d0ed      	beq.n	44960 <rpc_handle_data_message+0x18>
   44984:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44988:	00049270 	.word	0x00049270

0004498c <trace_write>:
   4498c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44990:	4f53      	ldr	r7, [pc, #332]	; (44ae0 <trace_write+0x154>)
   44992:	4605      	mov	r5, r0
   44994:	2100      	movs	r1, #0
   44996:	6838      	ldr	r0, [r7, #0]
   44998:	f003 fe24 	bl	485e4 <nrf_modem_os_sem_take>
   4499c:	4604      	mov	r4, r0
   4499e:	2800      	cmp	r0, #0
   449a0:	d14c      	bne.n	44a3c <trace_write+0xb0>
   449a2:	782b      	ldrb	r3, [r5, #0]
   449a4:	f8d5 8008 	ldr.w	r8, [r5, #8]
   449a8:	2b62      	cmp	r3, #98	; 0x62
   449aa:	d043      	beq.n	44a34 <trace_write+0xa8>
   449ac:	2b63      	cmp	r3, #99	; 0x63
   449ae:	d043      	beq.n	44a38 <trace_write+0xac>
   449b0:	2b61      	cmp	r3, #97	; 0x61
   449b2:	d102      	bne.n	449ba <trace_write+0x2e>
   449b4:	4b4b      	ldr	r3, [pc, #300]	; (44ae4 <trace_write+0x158>)
   449b6:	881c      	ldrh	r4, [r3, #0]
   449b8:	b2a4      	uxth	r4, r4
   449ba:	6838      	ldr	r0, [r7, #0]
   449bc:	f003 fe10 	bl	485e0 <nrf_modem_os_sem_give>
   449c0:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   449c4:	6929      	ldr	r1, [r5, #16]
   449c6:	eba8 080a 	sub.w	r8, r8, sl
   449ca:	eba1 030a 	sub.w	r3, r1, sl
   449ce:	b29b      	uxth	r3, r3
   449d0:	fa14 f488 	uxtah	r4, r4, r8
   449d4:	fbb4 f2f3 	udiv	r2, r4, r3
   449d8:	fb03 4412 	mls	r4, r3, r2, r4
   449dc:	686a      	ldr	r2, [r5, #4]
   449de:	eba2 020a 	sub.w	r2, r2, sl
   449e2:	fa13 f282 	uxtah	r2, r3, r2
   449e6:	1b12      	subs	r2, r2, r4
   449e8:	fb92 f0f3 	sdiv	r0, r2, r3
   449ec:	fb03 2210 	mls	r2, r3, r0, r2
   449f0:	fa1f f982 	uxth.w	r9, r2
   449f4:	fa14 f282 	uxtah	r2, r4, r2
   449f8:	4293      	cmp	r3, r2
   449fa:	44a2      	add	sl, r4
   449fc:	da22      	bge.n	44a44 <trace_write+0xb8>
   449fe:	eba1 030a 	sub.w	r3, r1, sl
   44a02:	b29b      	uxth	r3, r3
   44a04:	eba9 0403 	sub.w	r4, r9, r3
   44a08:	4699      	mov	r9, r3
   44a0a:	b2a4      	uxth	r4, r4
   44a0c:	f1b9 0f00 	cmp.w	r9, #0
   44a10:	d064      	beq.n	44adc <trace_write+0x150>
   44a12:	2005      	movs	r0, #5
   44a14:	f7ff f9d6 	bl	43dc4 <nrf_modem_os_alloc>
   44a18:	4680      	mov	r8, r0
   44a1a:	2800      	cmp	r0, #0
   44a1c:	d05e      	beq.n	44adc <trace_write+0x150>
   44a1e:	b19c      	cbz	r4, 44a48 <trace_write+0xbc>
   44a20:	2005      	movs	r0, #5
   44a22:	f7ff f9cf 	bl	43dc4 <nrf_modem_os_alloc>
   44a26:	4606      	mov	r6, r0
   44a28:	b970      	cbnz	r0, 44a48 <trace_write+0xbc>
   44a2a:	4640      	mov	r0, r8
   44a2c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44a30:	f7ff b9d0 	b.w	43dd4 <nrf_modem_os_free>
   44a34:	4b2c      	ldr	r3, [pc, #176]	; (44ae8 <trace_write+0x15c>)
   44a36:	e7be      	b.n	449b6 <trace_write+0x2a>
   44a38:	4b2c      	ldr	r3, [pc, #176]	; (44aec <trace_write+0x160>)
   44a3a:	e7bc      	b.n	449b6 <trace_write+0x2a>
   44a3c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44a40:	f7ff b9b0 	b.w	43da4 <nrf_modem_os_trace_irq_set>
   44a44:	2400      	movs	r4, #0
   44a46:	e7e1      	b.n	44a0c <trace_write+0x80>
   44a48:	2100      	movs	r1, #0
   44a4a:	6838      	ldr	r0, [r7, #0]
   44a4c:	f003 fdca 	bl	485e4 <nrf_modem_os_sem_take>
   44a50:	b140      	cbz	r0, 44a64 <trace_write+0xd8>
   44a52:	f7ff f9a7 	bl	43da4 <nrf_modem_os_trace_irq_set>
   44a56:	4640      	mov	r0, r8
   44a58:	f7ff f9bc 	bl	43dd4 <nrf_modem_os_free>
   44a5c:	2c00      	cmp	r4, #0
   44a5e:	d03d      	beq.n	44adc <trace_write+0x150>
   44a60:	4630      	mov	r0, r6
   44a62:	e7e3      	b.n	44a2c <trace_write+0xa0>
   44a64:	782b      	ldrb	r3, [r5, #0]
   44a66:	2b62      	cmp	r3, #98	; 0x62
   44a68:	d034      	beq.n	44ad4 <trace_write+0x148>
   44a6a:	2b63      	cmp	r3, #99	; 0x63
   44a6c:	d034      	beq.n	44ad8 <trace_write+0x14c>
   44a6e:	2b61      	cmp	r3, #97	; 0x61
   44a70:	d107      	bne.n	44a82 <trace_write+0xf6>
   44a72:	4a1c      	ldr	r2, [pc, #112]	; (44ae4 <trace_write+0x158>)
   44a74:	8813      	ldrh	r3, [r2, #0]
   44a76:	eb04 0109 	add.w	r1, r4, r9
   44a7a:	fa11 f383 	uxtah	r3, r1, r3
   44a7e:	b29b      	uxth	r3, r3
   44a80:	8013      	strh	r3, [r2, #0]
   44a82:	6838      	ldr	r0, [r7, #0]
   44a84:	f06f 0b10 	mvn.w	fp, #16
   44a88:	f06f 0741 	mvn.w	r7, #65	; 0x41
   44a8c:	f003 fda8 	bl	485e0 <nrf_modem_os_sem_give>
   44a90:	f888 b000 	strb.w	fp, [r8]
   44a94:	f888 7001 	strb.w	r7, [r8, #1]
   44a98:	782b      	ldrb	r3, [r5, #0]
   44a9a:	2105      	movs	r1, #5
   44a9c:	4640      	mov	r0, r8
   44a9e:	f888 3004 	strb.w	r3, [r8, #4]
   44aa2:	f8a8 9002 	strh.w	r9, [r8, #2]
   44aa6:	f003 fdba 	bl	4861e <nrf_modem_os_trace_put>
   44aaa:	4649      	mov	r1, r9
   44aac:	4650      	mov	r0, sl
   44aae:	f003 fdb6 	bl	4861e <nrf_modem_os_trace_put>
   44ab2:	b19c      	cbz	r4, 44adc <trace_write+0x150>
   44ab4:	f886 b000 	strb.w	fp, [r6]
   44ab8:	7077      	strb	r7, [r6, #1]
   44aba:	782b      	ldrb	r3, [r5, #0]
   44abc:	2105      	movs	r1, #5
   44abe:	4630      	mov	r0, r6
   44ac0:	7133      	strb	r3, [r6, #4]
   44ac2:	8074      	strh	r4, [r6, #2]
   44ac4:	f003 fdab 	bl	4861e <nrf_modem_os_trace_put>
   44ac8:	4621      	mov	r1, r4
   44aca:	68e8      	ldr	r0, [r5, #12]
   44acc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44ad0:	f003 bda5 	b.w	4861e <nrf_modem_os_trace_put>
   44ad4:	4a04      	ldr	r2, [pc, #16]	; (44ae8 <trace_write+0x15c>)
   44ad6:	e7cd      	b.n	44a74 <trace_write+0xe8>
   44ad8:	4a04      	ldr	r2, [pc, #16]	; (44aec <trace_write+0x160>)
   44ada:	e7cb      	b.n	44a74 <trace_write+0xe8>
   44adc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44ae0:	2001ab58 	.word	0x2001ab58
   44ae4:	2001addc 	.word	0x2001addc
   44ae8:	2001add8 	.word	0x2001add8
   44aec:	2001adda 	.word	0x2001adda

00044af0 <ipc_trace_init>:
   44af0:	2300      	movs	r3, #0
   44af2:	4a08      	ldr	r2, [pc, #32]	; (44b14 <ipc_trace_init+0x24>)
   44af4:	b510      	push	{r4, lr}
   44af6:	8013      	strh	r3, [r2, #0]
   44af8:	4a07      	ldr	r2, [pc, #28]	; (44b18 <ipc_trace_init+0x28>)
   44afa:	4604      	mov	r4, r0
   44afc:	8013      	strh	r3, [r2, #0]
   44afe:	4a07      	ldr	r2, [pc, #28]	; (44b1c <ipc_trace_init+0x2c>)
   44b00:	4807      	ldr	r0, [pc, #28]	; (44b20 <ipc_trace_init+0x30>)
   44b02:	8013      	strh	r3, [r2, #0]
   44b04:	2201      	movs	r2, #1
   44b06:	4611      	mov	r1, r2
   44b08:	f7ff f922 	bl	43d50 <nrf_modem_os_sem_init>
   44b0c:	4b05      	ldr	r3, [pc, #20]	; (44b24 <ipc_trace_init+0x34>)
   44b0e:	601c      	str	r4, [r3, #0]
   44b10:	bd10      	pop	{r4, pc}
   44b12:	bf00      	nop
   44b14:	2001addc 	.word	0x2001addc
   44b18:	2001add8 	.word	0x2001add8
   44b1c:	2001adda 	.word	0x2001adda
   44b20:	2001ab58 	.word	0x2001ab58
   44b24:	2001ab54 	.word	0x2001ab54

00044b28 <nrf_modem_trace_irq_handler>:
   44b28:	b508      	push	{r3, lr}
   44b2a:	4b10      	ldr	r3, [pc, #64]	; (44b6c <nrf_modem_trace_irq_handler+0x44>)
   44b2c:	781b      	ldrb	r3, [r3, #0]
   44b2e:	b90b      	cbnz	r3, 44b34 <nrf_modem_trace_irq_handler+0xc>
   44b30:	f7ff f940 	bl	43db4 <nrf_modem_os_trace_irq_clear>
   44b34:	4b0e      	ldr	r3, [pc, #56]	; (44b70 <nrf_modem_trace_irq_handler+0x48>)
   44b36:	6818      	ldr	r0, [r3, #0]
   44b38:	6842      	ldr	r2, [r0, #4]
   44b3a:	6883      	ldr	r3, [r0, #8]
   44b3c:	429a      	cmp	r2, r3
   44b3e:	d001      	beq.n	44b44 <nrf_modem_trace_irq_handler+0x1c>
   44b40:	f7ff ff24 	bl	4498c <trace_write>
   44b44:	4b0b      	ldr	r3, [pc, #44]	; (44b74 <nrf_modem_trace_irq_handler+0x4c>)
   44b46:	6818      	ldr	r0, [r3, #0]
   44b48:	6882      	ldr	r2, [r0, #8]
   44b4a:	6843      	ldr	r3, [r0, #4]
   44b4c:	429a      	cmp	r2, r3
   44b4e:	d001      	beq.n	44b54 <nrf_modem_trace_irq_handler+0x2c>
   44b50:	f7ff ff1c 	bl	4498c <trace_write>
   44b54:	4b08      	ldr	r3, [pc, #32]	; (44b78 <nrf_modem_trace_irq_handler+0x50>)
   44b56:	6818      	ldr	r0, [r3, #0]
   44b58:	6882      	ldr	r2, [r0, #8]
   44b5a:	6843      	ldr	r3, [r0, #4]
   44b5c:	429a      	cmp	r2, r3
   44b5e:	d003      	beq.n	44b68 <nrf_modem_trace_irq_handler+0x40>
   44b60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   44b64:	f7ff bf12 	b.w	4498c <trace_write>
   44b68:	bd08      	pop	{r3, pc}
   44b6a:	bf00      	nop
   44b6c:	2001ea0f 	.word	0x2001ea0f
   44b70:	2001ab50 	.word	0x2001ab50
   44b74:	2001ab48 	.word	0x2001ab48
   44b78:	2001ab4c 	.word	0x2001ab4c

00044b7c <ipc_trace_handle>:
   44b7c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44b80:	4b43      	ldr	r3, [pc, #268]	; (44c90 <ipc_trace_handle+0x114>)
   44b82:	681b      	ldr	r3, [r3, #0]
   44b84:	6919      	ldr	r1, [r3, #16]
   44b86:	f8d3 a014 	ldr.w	sl, [r3, #20]
   44b8a:	7c1a      	ldrb	r2, [r3, #16]
   44b8c:	2200      	movs	r2, #0
   44b8e:	741a      	strb	r2, [r3, #16]
   44b90:	7c58      	ldrb	r0, [r3, #17]
   44b92:	745a      	strb	r2, [r3, #17]
   44b94:	7c98      	ldrb	r0, [r3, #18]
   44b96:	749a      	strb	r2, [r3, #18]
   44b98:	7cd8      	ldrb	r0, [r3, #19]
   44b9a:	74da      	strb	r2, [r3, #19]
   44b9c:	7d18      	ldrb	r0, [r3, #20]
   44b9e:	751a      	strb	r2, [r3, #20]
   44ba0:	7d58      	ldrb	r0, [r3, #21]
   44ba2:	755a      	strb	r2, [r3, #21]
   44ba4:	7d98      	ldrb	r0, [r3, #22]
   44ba6:	759a      	strb	r2, [r3, #22]
   44ba8:	7dd8      	ldrb	r0, [r3, #23]
   44baa:	75da      	strb	r2, [r3, #23]
   44bac:	2900      	cmp	r1, #0
   44bae:	d033      	beq.n	44c18 <ipc_trace_handle+0x9c>
   44bb0:	3901      	subs	r1, #1
   44bb2:	2903      	cmp	r1, #3
   44bb4:	d830      	bhi.n	44c18 <ipc_trace_handle+0x9c>
   44bb6:	e8df f001 	tbb	[pc, r1]
   44bba:	6502      	.short	0x6502
   44bbc:	534c      	.short	0x534c
   44bbe:	4a35      	ldr	r2, [pc, #212]	; (44c94 <ipc_trace_handle+0x118>)
   44bc0:	7811      	ldrb	r1, [r2, #0]
   44bc2:	b109      	cbz	r1, 44bc8 <ipc_trace_handle+0x4c>
   44bc4:	2100      	movs	r1, #0
   44bc6:	7011      	strb	r1, [r2, #0]
   44bc8:	2200      	movs	r2, #0
   44bca:	4691      	mov	r9, r2
   44bcc:	4617      	mov	r7, r2
   44bce:	4614      	mov	r4, r2
   44bd0:	4d31      	ldr	r5, [pc, #196]	; (44c98 <ipc_trace_handle+0x11c>)
   44bd2:	4932      	ldr	r1, [pc, #200]	; (44c9c <ipc_trace_handle+0x120>)
   44bd4:	4832      	ldr	r0, [pc, #200]	; (44ca0 <ipc_trace_handle+0x124>)
   44bd6:	f8d5 e000 	ldr.w	lr, [r5]
   44bda:	f8d1 8000 	ldr.w	r8, [r1]
   44bde:	6806      	ldr	r6, [r0, #0]
   44be0:	f8da b008 	ldr.w	fp, [sl, #8]
   44be4:	9501      	str	r5, [sp, #4]
   44be6:	45a3      	cmp	fp, r4
   44be8:	d119      	bne.n	44c1e <ipc_trace_handle+0xa2>
   44bea:	b107      	cbz	r7, 44bee <ipc_trace_handle+0x72>
   44bec:	6006      	str	r6, [r0, #0]
   44bee:	f1b9 0f00 	cmp.w	r9, #0
   44bf2:	d001      	beq.n	44bf8 <ipc_trace_handle+0x7c>
   44bf4:	f8c1 8000 	str.w	r8, [r1]
   44bf8:	b112      	cbz	r2, 44c00 <ipc_trace_handle+0x84>
   44bfa:	9a01      	ldr	r2, [sp, #4]
   44bfc:	f8c2 e000 	str.w	lr, [r2]
   44c00:	7a1a      	ldrb	r2, [r3, #8]
   44c02:	2101      	movs	r1, #1
   44c04:	2200      	movs	r2, #0
   44c06:	7219      	strb	r1, [r3, #8]
   44c08:	7a59      	ldrb	r1, [r3, #9]
   44c0a:	725a      	strb	r2, [r3, #9]
   44c0c:	7a99      	ldrb	r1, [r3, #10]
   44c0e:	729a      	strb	r2, [r3, #10]
   44c10:	7ada      	ldrb	r2, [r3, #11]
   44c12:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   44c16:	72da      	strb	r2, [r3, #11]
   44c18:	b003      	add	sp, #12
   44c1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44c1e:	1ca5      	adds	r5, r4, #2
   44c20:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   44c24:	686d      	ldr	r5, [r5, #4]
   44c26:	f895 c000 	ldrb.w	ip, [r5]
   44c2a:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   44c2e:	d009      	beq.n	44c44 <ipc_trace_handle+0xc8>
   44c30:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   44c34:	d00a      	beq.n	44c4c <ipc_trace_handle+0xd0>
   44c36:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   44c3a:	bf04      	itt	eq
   44c3c:	462e      	moveq	r6, r5
   44c3e:	2701      	moveq	r7, #1
   44c40:	3401      	adds	r4, #1
   44c42:	e7d0      	b.n	44be6 <ipc_trace_handle+0x6a>
   44c44:	46a8      	mov	r8, r5
   44c46:	f04f 0901 	mov.w	r9, #1
   44c4a:	e7f9      	b.n	44c40 <ipc_trace_handle+0xc4>
   44c4c:	46ae      	mov	lr, r5
   44c4e:	2201      	movs	r2, #1
   44c50:	e7f6      	b.n	44c40 <ipc_trace_handle+0xc4>
   44c52:	2101      	movs	r1, #1
   44c54:	4a0f      	ldr	r2, [pc, #60]	; (44c94 <ipc_trace_handle+0x118>)
   44c56:	7011      	strb	r1, [r2, #0]
   44c58:	7a1a      	ldrb	r2, [r3, #8]
   44c5a:	2103      	movs	r1, #3
   44c5c:	2200      	movs	r2, #0
   44c5e:	e7d2      	b.n	44c06 <ipc_trace_handle+0x8a>
   44c60:	7a19      	ldrb	r1, [r3, #8]
   44c62:	2104      	movs	r1, #4
   44c64:	7219      	strb	r1, [r3, #8]
   44c66:	7a59      	ldrb	r1, [r3, #9]
   44c68:	725a      	strb	r2, [r3, #9]
   44c6a:	7a99      	ldrb	r1, [r3, #10]
   44c6c:	729a      	strb	r2, [r3, #10]
   44c6e:	7ad9      	ldrb	r1, [r3, #11]
   44c70:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   44c74:	72d9      	strb	r1, [r3, #11]
   44c76:	4b07      	ldr	r3, [pc, #28]	; (44c94 <ipc_trace_handle+0x118>)
   44c78:	701a      	strb	r2, [r3, #0]
   44c7a:	b003      	add	sp, #12
   44c7c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44c80:	f7ff bf52 	b.w	44b28 <nrf_modem_trace_irq_handler>
   44c84:	b003      	add	sp, #12
   44c86:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44c8a:	f7ff b88b 	b.w	43da4 <nrf_modem_os_trace_irq_set>
   44c8e:	bf00      	nop
   44c90:	2001ab54 	.word	0x2001ab54
   44c94:	2001ea0f 	.word	0x2001ea0f
   44c98:	2001ab4c 	.word	0x2001ab4c
   44c9c:	2001ab48 	.word	0x2001ab48
   44ca0:	2001ab50 	.word	0x2001ab50

00044ca4 <rpc_trace_coredump_in_progress>:
   44ca4:	4b01      	ldr	r3, [pc, #4]	; (44cac <rpc_trace_coredump_in_progress+0x8>)
   44ca6:	7818      	ldrb	r0, [r3, #0]
   44ca8:	4770      	bx	lr
   44caa:	bf00      	nop
   44cac:	2001ea0f 	.word	0x2001ea0f

00044cb0 <handle_modem_rpc_msg>:
   44cb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44cb4:	4606      	mov	r6, r0
   44cb6:	460f      	mov	r7, r1
   44cb8:	2500      	movs	r5, #0
   44cba:	f8df 8074 	ldr.w	r8, [pc, #116]	; 44d30 <handle_modem_rpc_msg+0x80>
   44cbe:	6833      	ldr	r3, [r6, #0]
   44cc0:	42ab      	cmp	r3, r5
   44cc2:	d801      	bhi.n	44cc8 <handle_modem_rpc_msg+0x18>
   44cc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44cc8:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   44ccc:	68a3      	ldr	r3, [r4, #8]
   44cce:	b1fb      	cbz	r3, 44d10 <handle_modem_rpc_msg+0x60>
   44cd0:	6863      	ldr	r3, [r4, #4]
   44cd2:	b2db      	uxtb	r3, r3
   44cd4:	2b01      	cmp	r3, #1
   44cd6:	d11b      	bne.n	44d10 <handle_modem_rpc_msg+0x60>
   44cd8:	6862      	ldr	r2, [r4, #4]
   44cda:	f8b8 3000 	ldrh.w	r3, [r8]
   44cde:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   44ce2:	d115      	bne.n	44d10 <handle_modem_rpc_msg+0x60>
   44ce4:	2f02      	cmp	r7, #2
   44ce6:	68a0      	ldr	r0, [r4, #8]
   44ce8:	d114      	bne.n	44d14 <handle_modem_rpc_msg+0x64>
   44cea:	f7ff fe2d 	bl	44948 <rpc_handle_data_message>
   44cee:	2802      	cmp	r0, #2
   44cf0:	d00e      	beq.n	44d10 <handle_modem_rpc_msg+0x60>
   44cf2:	2801      	cmp	r0, #1
   44cf4:	d113      	bne.n	44d1e <handle_modem_rpc_msg+0x6e>
   44cf6:	6863      	ldr	r3, [r4, #4]
   44cf8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44cfc:	f043 0302 	orr.w	r3, r3, #2
   44d00:	6063      	str	r3, [r4, #4]
   44d02:	f8b8 3000 	ldrh.w	r3, [r8]
   44d06:	3301      	adds	r3, #1
   44d08:	f8a8 3000 	strh.w	r3, [r8]
   44d0c:	f7ff f83a 	bl	43d84 <nrf_modem_os_application_irq_set>
   44d10:	3501      	adds	r5, #1
   44d12:	e7d4      	b.n	44cbe <handle_modem_rpc_msg+0xe>
   44d14:	6801      	ldr	r1, [r0, #0]
   44d16:	0c09      	lsrs	r1, r1, #16
   44d18:	f003 fc9c 	bl	48654 <rpc_handle_ctrl_message>
   44d1c:	e7e7      	b.n	44cee <handle_modem_rpc_msg+0x3e>
   44d1e:	2800      	cmp	r0, #0
   44d20:	d1ef      	bne.n	44d02 <handle_modem_rpc_msg+0x52>
   44d22:	6863      	ldr	r3, [r4, #4]
   44d24:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44d28:	f043 0303 	orr.w	r3, r3, #3
   44d2c:	e7e8      	b.n	44d00 <handle_modem_rpc_msg+0x50>
   44d2e:	bf00      	nop
   44d30:	2001adde 	.word	0x2001adde

00044d34 <rpc_transport_ipc_msg_alloc>:
   44d34:	b570      	push	{r4, r5, r6, lr}
   44d36:	4616      	mov	r6, r2
   44d38:	2400      	movs	r4, #0
   44d3a:	6803      	ldr	r3, [r0, #0]
   44d3c:	42a3      	cmp	r3, r4
   44d3e:	d101      	bne.n	44d44 <rpc_transport_ipc_msg_alloc+0x10>
   44d40:	2300      	movs	r3, #0
   44d42:	e01c      	b.n	44d7e <rpc_transport_ipc_msg_alloc+0x4a>
   44d44:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   44d48:	6855      	ldr	r5, [r2, #4]
   44d4a:	b2ed      	uxtb	r5, r5
   44d4c:	2d03      	cmp	r5, #3
   44d4e:	d118      	bne.n	44d82 <rpc_transport_ipc_msg_alloc+0x4e>
   44d50:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   44d54:	6093      	str	r3, [r2, #8]
   44d56:	6851      	ldr	r1, [r2, #4]
   44d58:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   44d5c:	6051      	str	r1, [r2, #4]
   44d5e:	490c      	ldr	r1, [pc, #48]	; (44d90 <rpc_transport_ipc_msg_alloc+0x5c>)
   44d60:	8808      	ldrh	r0, [r1, #0]
   44d62:	1c44      	adds	r4, r0, #1
   44d64:	800c      	strh	r4, [r1, #0]
   44d66:	6851      	ldr	r1, [r2, #4]
   44d68:	b289      	uxth	r1, r1
   44d6a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   44d6e:	6051      	str	r1, [r2, #4]
   44d70:	4618      	mov	r0, r3
   44d72:	2240      	movs	r2, #64	; 0x40
   44d74:	2100      	movs	r1, #0
   44d76:	f003 fab3 	bl	482e0 <memset>
   44d7a:	4603      	mov	r3, r0
   44d7c:	6046      	str	r6, [r0, #4]
   44d7e:	4618      	mov	r0, r3
   44d80:	bd70      	pop	{r4, r5, r6, pc}
   44d82:	b915      	cbnz	r5, 44d8a <rpc_transport_ipc_msg_alloc+0x56>
   44d84:	6895      	ldr	r5, [r2, #8]
   44d86:	2d00      	cmp	r5, #0
   44d88:	d0e2      	beq.n	44d50 <rpc_transport_ipc_msg_alloc+0x1c>
   44d8a:	3401      	adds	r4, #1
   44d8c:	e7d6      	b.n	44d3c <rpc_transport_ipc_msg_alloc+0x8>
   44d8e:	bf00      	nop
   44d90:	2001ade0 	.word	0x2001ade0

00044d94 <rpc_transport_ipc_data_msg_send>:
   44d94:	b508      	push	{r3, lr}
   44d96:	4b0b      	ldr	r3, [pc, #44]	; (44dc4 <rpc_transport_ipc_data_msg_send+0x30>)
   44d98:	681b      	ldr	r3, [r3, #0]
   44d9a:	1ac0      	subs	r0, r0, r3
   44d9c:	4b0a      	ldr	r3, [pc, #40]	; (44dc8 <rpc_transport_ipc_data_msg_send+0x34>)
   44d9e:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44da2:	681b      	ldr	r3, [r3, #0]
   44da4:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44da8:	6843      	ldr	r3, [r0, #4]
   44daa:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44dae:	f043 0301 	orr.w	r3, r3, #1
   44db2:	6043      	str	r3, [r0, #4]
   44db4:	2003      	movs	r0, #3
   44db6:	f003 fc0f 	bl	485d8 <nrf_modem_os_busywait>
   44dba:	2201      	movs	r2, #1
   44dbc:	4b03      	ldr	r3, [pc, #12]	; (44dcc <rpc_transport_ipc_data_msg_send+0x38>)
   44dbe:	601a      	str	r2, [r3, #0]
   44dc0:	bd08      	pop	{r3, pc}
   44dc2:	bf00      	nop
   44dc4:	2001ab74 	.word	0x2001ab74
   44dc8:	2001ab78 	.word	0x2001ab78
   44dcc:	4002a00c 	.word	0x4002a00c

00044dd0 <rpc_transport_ipc_ctrl_msg_send>:
   44dd0:	b508      	push	{r3, lr}
   44dd2:	4b0b      	ldr	r3, [pc, #44]	; (44e00 <rpc_transport_ipc_ctrl_msg_send+0x30>)
   44dd4:	681b      	ldr	r3, [r3, #0]
   44dd6:	1ac0      	subs	r0, r0, r3
   44dd8:	4b0a      	ldr	r3, [pc, #40]	; (44e04 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   44dda:	f3c0 1089 	ubfx	r0, r0, #6, #10
   44dde:	681b      	ldr	r3, [r3, #0]
   44de0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   44de4:	6843      	ldr	r3, [r0, #4]
   44de6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   44dea:	f043 0301 	orr.w	r3, r3, #1
   44dee:	6043      	str	r3, [r0, #4]
   44df0:	2003      	movs	r0, #3
   44df2:	f003 fbf1 	bl	485d8 <nrf_modem_os_busywait>
   44df6:	2201      	movs	r2, #1
   44df8:	4b03      	ldr	r3, [pc, #12]	; (44e08 <rpc_transport_ipc_ctrl_msg_send+0x38>)
   44dfa:	601a      	str	r2, [r3, #0]
   44dfc:	bd08      	pop	{r3, pc}
   44dfe:	bf00      	nop
   44e00:	2001ab6c 	.word	0x2001ab6c
   44e04:	2001ab70 	.word	0x2001ab70
   44e08:	4002a004 	.word	0x4002a004

00044e0c <rpc_transport_ipc_data_msg_alloc>:
   44e0c:	4b05      	ldr	r3, [pc, #20]	; (44e24 <rpc_transport_ipc_data_msg_alloc+0x18>)
   44e0e:	781b      	ldrb	r3, [r3, #0]
   44e10:	b933      	cbnz	r3, 44e20 <rpc_transport_ipc_data_msg_alloc+0x14>
   44e12:	4b05      	ldr	r3, [pc, #20]	; (44e28 <rpc_transport_ipc_data_msg_alloc+0x1c>)
   44e14:	2202      	movs	r2, #2
   44e16:	6819      	ldr	r1, [r3, #0]
   44e18:	4b04      	ldr	r3, [pc, #16]	; (44e2c <rpc_transport_ipc_data_msg_alloc+0x20>)
   44e1a:	6818      	ldr	r0, [r3, #0]
   44e1c:	f7ff bf8a 	b.w	44d34 <rpc_transport_ipc_msg_alloc>
   44e20:	2000      	movs	r0, #0
   44e22:	4770      	bx	lr
   44e24:	2001ea11 	.word	0x2001ea11
   44e28:	2001ab74 	.word	0x2001ab74
   44e2c:	2001ab78 	.word	0x2001ab78

00044e30 <rpc_transport_ipc_ctrl_msg_alloc>:
   44e30:	230a      	movs	r3, #10
   44e32:	b537      	push	{r0, r1, r2, r4, r5, lr}
   44e34:	4c0c      	ldr	r4, [pc, #48]	; (44e68 <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   44e36:	4d0d      	ldr	r5, [pc, #52]	; (44e6c <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   44e38:	9301      	str	r3, [sp, #4]
   44e3a:	2201      	movs	r2, #1
   44e3c:	6821      	ldr	r1, [r4, #0]
   44e3e:	6828      	ldr	r0, [r5, #0]
   44e40:	f7ff ff78 	bl	44d34 <rpc_transport_ipc_msg_alloc>
   44e44:	b968      	cbnz	r0, 44e62 <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   44e46:	f003 fbc9 	bl	485dc <nrf_modem_os_is_in_isr>
   44e4a:	b918      	cbnz	r0, 44e54 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   44e4c:	a901      	add	r1, sp, #4
   44e4e:	f7fe fee1 	bl	43c14 <nrf_modem_os_timedwait>
   44e52:	e7f2      	b.n	44e3a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44e54:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   44e58:	9b01      	ldr	r3, [sp, #4]
   44e5a:	4358      	muls	r0, r3
   44e5c:	f003 fbbc 	bl	485d8 <nrf_modem_os_busywait>
   44e60:	e7eb      	b.n	44e3a <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   44e62:	b003      	add	sp, #12
   44e64:	bd30      	pop	{r4, r5, pc}
   44e66:	bf00      	nop
   44e68:	2001ab6c 	.word	0x2001ab6c
   44e6c:	2001ab70 	.word	0x2001ab70

00044e70 <rpc_transport_ipc_data_alloc>:
   44e70:	4b03      	ldr	r3, [pc, #12]	; (44e80 <rpc_transport_ipc_data_alloc+0x10>)
   44e72:	781b      	ldrb	r3, [r3, #0]
   44e74:	b90b      	cbnz	r3, 44e7a <rpc_transport_ipc_data_alloc+0xa>
   44e76:	f7fe bfb3 	b.w	43de0 <nrf_modem_os_shm_tx_alloc>
   44e7a:	2000      	movs	r0, #0
   44e7c:	4770      	bx	lr
   44e7e:	bf00      	nop
   44e80:	2001ea11 	.word	0x2001ea11

00044e84 <nrf_modem_application_irq_handler>:
   44e84:	b510      	push	{r4, lr}
   44e86:	4c06      	ldr	r4, [pc, #24]	; (44ea0 <nrf_modem_application_irq_handler+0x1c>)
   44e88:	f7fe ff84 	bl	43d94 <nrf_modem_os_application_irq_clear>
   44e8c:	6820      	ldr	r0, [r4, #0]
   44e8e:	2101      	movs	r1, #1
   44e90:	f7ff ff0e 	bl	44cb0 <handle_modem_rpc_msg>
   44e94:	6860      	ldr	r0, [r4, #4]
   44e96:	2102      	movs	r1, #2
   44e98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   44e9c:	f7ff bf08 	b.w	44cb0 <handle_modem_rpc_msg>
   44ea0:	2001ab60 	.word	0x2001ab60

00044ea4 <rpc_transport_ipc_msg_free>:
   44ea4:	2300      	movs	r3, #0
   44ea6:	4911      	ldr	r1, [pc, #68]	; (44eec <rpc_transport_ipc_msg_free+0x48>)
   44ea8:	b530      	push	{r4, r5, lr}
   44eaa:	680a      	ldr	r2, [r1, #0]
   44eac:	6814      	ldr	r4, [r2, #0]
   44eae:	42a3      	cmp	r3, r4
   44eb0:	d10b      	bne.n	44eca <rpc_transport_ipc_msg_free+0x26>
   44eb2:	2300      	movs	r3, #0
   44eb4:	684a      	ldr	r2, [r1, #4]
   44eb6:	6811      	ldr	r1, [r2, #0]
   44eb8:	428b      	cmp	r3, r1
   44eba:	d015      	beq.n	44ee8 <rpc_transport_ipc_msg_free+0x44>
   44ebc:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   44ec0:	68a4      	ldr	r4, [r4, #8]
   44ec2:	42a0      	cmp	r0, r4
   44ec4:	d008      	beq.n	44ed8 <rpc_transport_ipc_msg_free+0x34>
   44ec6:	3301      	adds	r3, #1
   44ec8:	e7f6      	b.n	44eb8 <rpc_transport_ipc_msg_free+0x14>
   44eca:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   44ece:	68ad      	ldr	r5, [r5, #8]
   44ed0:	42a8      	cmp	r0, r5
   44ed2:	d001      	beq.n	44ed8 <rpc_transport_ipc_msg_free+0x34>
   44ed4:	3301      	adds	r3, #1
   44ed6:	e7ea      	b.n	44eae <rpc_transport_ipc_msg_free+0xa>
   44ed8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   44edc:	685a      	ldr	r2, [r3, #4]
   44ede:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   44ee2:	f042 0203 	orr.w	r2, r2, #3
   44ee6:	605a      	str	r2, [r3, #4]
   44ee8:	bd30      	pop	{r4, r5, pc}
   44eea:	bf00      	nop
   44eec:	2001ab60 	.word	0x2001ab60

00044ef0 <rpc_transport_ipc_init>:
   44ef0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44ef4:	2200      	movs	r2, #0
   44ef6:	b095      	sub	sp, #84	; 0x54
   44ef8:	4605      	mov	r5, r0
   44efa:	494d      	ldr	r1, [pc, #308]	; (45030 <rpc_transport_ipc_init+0x140>)
   44efc:	7900      	ldrb	r0, [r0, #4]
   44efe:	f7ff fc15 	bl	4472c <nrfx_ipc_init>
   44f02:	2238      	movs	r2, #56	; 0x38
   44f04:	2100      	movs	r1, #0
   44f06:	a803      	add	r0, sp, #12
   44f08:	f003 f9ea 	bl	482e0 <memset>
   44f0c:	2302      	movs	r3, #2
   44f0e:	9304      	str	r3, [sp, #16]
   44f10:	2308      	movs	r3, #8
   44f12:	9306      	str	r3, [sp, #24]
   44f14:	2320      	movs	r3, #32
   44f16:	9308      	str	r3, [sp, #32]
   44f18:	2301      	movs	r3, #1
   44f1a:	930b      	str	r3, [sp, #44]	; 0x2c
   44f1c:	2304      	movs	r3, #4
   44f1e:	930d      	str	r3, [sp, #52]	; 0x34
   44f20:	2310      	movs	r3, #16
   44f22:	f04f 0c40 	mov.w	ip, #64	; 0x40
   44f26:	930f      	str	r3, [sp, #60]	; 0x3c
   44f28:	2380      	movs	r3, #128	; 0x80
   44f2a:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   44f2e:	23d5      	movs	r3, #213	; 0xd5
   44f30:	a803      	add	r0, sp, #12
   44f32:	9313      	str	r3, [sp, #76]	; 0x4c
   44f34:	f7ff fc12 	bl	4475c <nrfx_ipc_config_load>
   44f38:	682b      	ldr	r3, [r5, #0]
   44f3a:	2100      	movs	r1, #0
   44f3c:	685a      	ldr	r2, [r3, #4]
   44f3e:	6818      	ldr	r0, [r3, #0]
   44f40:	f003 f9ce 	bl	482e0 <memset>
   44f44:	682a      	ldr	r2, [r5, #0]
   44f46:	6814      	ldr	r4, [r2, #0]
   44f48:	69d3      	ldr	r3, [r2, #28]
   44f4a:	f104 0660 	add.w	r6, r4, #96	; 0x60
   44f4e:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   44f52:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   44f56:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   44f5a:	f104 0920 	add.w	r9, r4, #32
   44f5e:	2b00      	cmp	r3, #0
   44f60:	d060      	beq.n	45024 <rpc_transport_ipc_init+0x134>
   44f62:	f104 0840 	add.w	r8, r4, #64	; 0x40
   44f66:	4933      	ldr	r1, [pc, #204]	; (45034 <rpc_transport_ipc_init+0x144>)
   44f68:	f8c1 9000 	str.w	r9, [r1]
   44f6c:	b13b      	cbz	r3, 44f7e <rpc_transport_ipc_init+0x8e>
   44f6e:	6992      	ldr	r2, [r2, #24]
   44f70:	4640      	mov	r0, r8
   44f72:	f8c8 2004 	str.w	r2, [r8, #4]
   44f76:	f8c8 3000 	str.w	r3, [r8]
   44f7a:	f7ff fdb9 	bl	44af0 <ipc_trace_init>
   44f7e:	6828      	ldr	r0, [r5, #0]
   44f80:	2300      	movs	r3, #0
   44f82:	6902      	ldr	r2, [r0, #16]
   44f84:	2101      	movs	r1, #1
   44f86:	6062      	str	r2, [r4, #4]
   44f88:	6942      	ldr	r2, [r0, #20]
   44f8a:	70a1      	strb	r1, [r4, #2]
   44f8c:	60a2      	str	r2, [r4, #8]
   44f8e:	4a2a      	ldr	r2, [pc, #168]	; (45038 <rpc_transport_ipc_init+0x148>)
   44f90:	7023      	strb	r3, [r4, #0]
   44f92:	6017      	str	r7, [r2, #0]
   44f94:	4a29      	ldr	r2, [pc, #164]	; (4503c <rpc_transport_ipc_init+0x14c>)
   44f96:	7063      	strb	r3, [r4, #1]
   44f98:	6016      	str	r6, [r2, #0]
   44f9a:	2208      	movs	r2, #8
   44f9c:	70e3      	strb	r3, [r4, #3]
   44f9e:	60e6      	str	r6, [r4, #12]
   44fa0:	6127      	str	r7, [r4, #16]
   44fa2:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   44fa6:	f8c4 9014 	str.w	r9, [r4, #20]
   44faa:	f8c4 8018 	str.w	r8, [r4, #24]
   44fae:	707b      	strb	r3, [r7, #1]
   44fb0:	70bb      	strb	r3, [r7, #2]
   44fb2:	70fb      	strb	r3, [r7, #3]
   44fb4:	2714      	movs	r7, #20
   44fb6:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   44fba:	4a21      	ldr	r2, [pc, #132]	; (45040 <rpc_transport_ipc_init+0x150>)
   44fbc:	4d21      	ldr	r5, [pc, #132]	; (45044 <rpc_transport_ipc_init+0x154>)
   44fbe:	f8c2 b000 	str.w	fp, [r2]
   44fc2:	4a21      	ldr	r2, [pc, #132]	; (45048 <rpc_transport_ipc_init+0x158>)
   44fc4:	7073      	strb	r3, [r6, #1]
   44fc6:	f8c2 a000 	str.w	sl, [r2]
   44fca:	4a20      	ldr	r2, [pc, #128]	; (4504c <rpc_transport_ipc_init+0x15c>)
   44fcc:	70b3      	strb	r3, [r6, #2]
   44fce:	70f3      	strb	r3, [r6, #3]
   44fd0:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   44fd4:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   44fd8:	4c1d      	ldr	r4, [pc, #116]	; (45050 <rpc_transport_ipc_init+0x160>)
   44fda:	7029      	strb	r1, [r5, #0]
   44fdc:	491d      	ldr	r1, [pc, #116]	; (45054 <rpc_transport_ipc_init+0x164>)
   44fde:	6023      	str	r3, [r4, #0]
   44fe0:	9302      	str	r3, [sp, #8]
   44fe2:	600b      	str	r3, [r1, #0]
   44fe4:	680b      	ldr	r3, [r1, #0]
   44fe6:	4e1c      	ldr	r6, [pc, #112]	; (45058 <rpc_transport_ipc_init+0x168>)
   44fe8:	9302      	str	r3, [sp, #8]
   44fea:	9b02      	ldr	r3, [sp, #8]
   44fec:	2000      	movs	r0, #0
   44fee:	a901      	add	r1, sp, #4
   44ff0:	9701      	str	r7, [sp, #4]
   44ff2:	f7fe fe0f 	bl	43c14 <nrf_modem_os_timedwait>
   44ff6:	9b01      	ldr	r3, [sp, #4]
   44ff8:	3b14      	subs	r3, #20
   44ffa:	441e      	add	r6, r3
   44ffc:	782b      	ldrb	r3, [r5, #0]
   44ffe:	2b01      	cmp	r3, #1
   45000:	d104      	bne.n	4500c <rpc_transport_ipc_init+0x11c>
   45002:	2e00      	cmp	r6, #0
   45004:	d1f2      	bne.n	44fec <rpc_transport_ipc_init+0xfc>
   45006:	f06f 0373 	mvn.w	r3, #115	; 0x73
   4500a:	6023      	str	r3, [r4, #0]
   4500c:	6824      	ldr	r4, [r4, #0]
   4500e:	b95c      	cbnz	r4, 45028 <rpc_transport_ipc_init+0x138>
   45010:	4b12      	ldr	r3, [pc, #72]	; (4505c <rpc_transport_ipc_init+0x16c>)
   45012:	701c      	strb	r4, [r3, #0]
   45014:	4b12      	ldr	r3, [pc, #72]	; (45060 <rpc_transport_ipc_init+0x170>)
   45016:	801c      	strh	r4, [r3, #0]
   45018:	4b12      	ldr	r3, [pc, #72]	; (45064 <rpc_transport_ipc_init+0x174>)
   4501a:	801c      	strh	r4, [r3, #0]
   4501c:	4620      	mov	r0, r4
   4501e:	b015      	add	sp, #84	; 0x54
   45020:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45024:	4698      	mov	r8, r3
   45026:	e79e      	b.n	44f66 <rpc_transport_ipc_init+0x76>
   45028:	f7ff fbb8 	bl	4479c <nrfx_ipc_uninit>
   4502c:	e7f6      	b.n	4501c <rpc_transport_ipc_init+0x12c>
   4502e:	bf00      	nop
   45030:	00045069 	.word	0x00045069
   45034:	2001ab68 	.word	0x2001ab68
   45038:	2001ab78 	.word	0x2001ab78
   4503c:	2001ab70 	.word	0x2001ab70
   45040:	2001ab74 	.word	0x2001ab74
   45044:	2001ea10 	.word	0x2001ea10
   45048:	2001ab6c 	.word	0x2001ab6c
   4504c:	4002a000 	.word	0x4002a000
   45050:	2001ab5c 	.word	0x2001ab5c
   45054:	40005610 	.word	0x40005610
   45058:	000249f0 	.word	0x000249f0
   4505c:	2001ea11 	.word	0x2001ea11
   45060:	2001ade0 	.word	0x2001ade0
   45064:	2001adde 	.word	0x2001adde

00045068 <ipc_irq_handler>:
   45068:	b570      	push	{r4, r5, r6, lr}
   4506a:	4604      	mov	r4, r0
   4506c:	0620      	lsls	r0, r4, #24
   4506e:	d50c      	bpl.n	4508a <ipc_irq_handler+0x22>
   45070:	f7ff fd84 	bl	44b7c <ipc_trace_handle>
   45074:	f7ff fe16 	bl	44ca4 <rpc_trace_coredump_in_progress>
   45078:	b138      	cbz	r0, 4508a <ipc_irq_handler+0x22>
   4507a:	22e0      	movs	r2, #224	; 0xe0
   4507c:	4b3e      	ldr	r3, [pc, #248]	; (45178 <ipc_irq_handler+0x110>)
   4507e:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   45082:	f44f 6280 	mov.w	r2, #1024	; 0x400
   45086:	605a      	str	r2, [r3, #4]
   45088:	bd70      	pop	{r4, r5, r6, pc}
   4508a:	07e1      	lsls	r1, r4, #31
   4508c:	d548      	bpl.n	45120 <ipc_irq_handler+0xb8>
   4508e:	f248 0202 	movw	r2, #32770	; 0x8002
   45092:	4b3a      	ldr	r3, [pc, #232]	; (4517c <ipc_irq_handler+0x114>)
   45094:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   45098:	4293      	cmp	r3, r2
   4509a:	d035      	beq.n	45108 <ipc_irq_handler+0xa0>
   4509c:	d81b      	bhi.n	450d6 <ipc_irq_handler+0x6e>
   4509e:	f243 0232 	movw	r2, #12338	; 0x3032
   450a2:	4293      	cmp	r3, r2
   450a4:	d036      	beq.n	45114 <ipc_irq_handler+0xac>
   450a6:	d80b      	bhi.n	450c0 <ipc_irq_handler+0x58>
   450a8:	3b01      	subs	r3, #1
   450aa:	2b01      	cmp	r3, #1
   450ac:	d8ec      	bhi.n	45088 <ipc_irq_handler+0x20>
   450ae:	2203      	movs	r2, #3
   450b0:	200e      	movs	r0, #14
   450b2:	4b33      	ldr	r3, [pc, #204]	; (45180 <ipc_irq_handler+0x118>)
   450b4:	701a      	strb	r2, [r3, #0]
   450b6:	4b33      	ldr	r3, [pc, #204]	; (45184 <ipc_irq_handler+0x11c>)
   450b8:	6018      	str	r0, [r3, #0]
   450ba:	f003 fb99 	bl	487f0 <rpc_transport_ipc_fault_handler>
   450be:	e7e3      	b.n	45088 <ipc_irq_handler+0x20>
   450c0:	f248 0201 	movw	r2, #32769	; 0x8001
   450c4:	4293      	cmp	r3, r2
   450c6:	d1df      	bne.n	45088 <ipc_irq_handler+0x20>
   450c8:	2203      	movs	r2, #3
   450ca:	4b2d      	ldr	r3, [pc, #180]	; (45180 <ipc_irq_handler+0x118>)
   450cc:	701a      	strb	r2, [r3, #0]
   450ce:	2216      	movs	r2, #22
   450d0:	4b2c      	ldr	r3, [pc, #176]	; (45184 <ipc_irq_handler+0x11c>)
   450d2:	601a      	str	r2, [r3, #0]
   450d4:	e7d8      	b.n	45088 <ipc_irq_handler+0x20>
   450d6:	4a2c      	ldr	r2, [pc, #176]	; (45188 <ipc_irq_handler+0x120>)
   450d8:	4293      	cmp	r3, r2
   450da:	d80c      	bhi.n	450f6 <ipc_irq_handler+0x8e>
   450dc:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   450e0:	d80c      	bhi.n	450fc <ipc_irq_handler+0x94>
   450e2:	f248 0203 	movw	r2, #32771	; 0x8003
   450e6:	4293      	cmp	r3, r2
   450e8:	d1ce      	bne.n	45088 <ipc_irq_handler+0x20>
   450ea:	2203      	movs	r2, #3
   450ec:	4b24      	ldr	r3, [pc, #144]	; (45180 <ipc_irq_handler+0x118>)
   450ee:	701a      	strb	r2, [r3, #0]
   450f0:	220c      	movs	r2, #12
   450f2:	4b24      	ldr	r3, [pc, #144]	; (45184 <ipc_irq_handler+0x11c>)
   450f4:	e7ed      	b.n	450d2 <ipc_irq_handler+0x6a>
   450f6:	4a25      	ldr	r2, [pc, #148]	; (4518c <ipc_irq_handler+0x124>)
   450f8:	4293      	cmp	r3, r2
   450fa:	d1c5      	bne.n	45088 <ipc_irq_handler+0x20>
   450fc:	2103      	movs	r1, #3
   450fe:	4a20      	ldr	r2, [pc, #128]	; (45180 <ipc_irq_handler+0x118>)
   45100:	7011      	strb	r1, [r2, #0]
   45102:	4a20      	ldr	r2, [pc, #128]	; (45184 <ipc_irq_handler+0x11c>)
   45104:	6013      	str	r3, [r2, #0]
   45106:	e7bf      	b.n	45088 <ipc_irq_handler+0x20>
   45108:	2203      	movs	r2, #3
   4510a:	4b1d      	ldr	r3, [pc, #116]	; (45180 <ipc_irq_handler+0x118>)
   4510c:	701a      	strb	r2, [r3, #0]
   4510e:	225f      	movs	r2, #95	; 0x5f
   45110:	4b1c      	ldr	r3, [pc, #112]	; (45184 <ipc_irq_handler+0x11c>)
   45112:	e7de      	b.n	450d2 <ipc_irq_handler+0x6a>
   45114:	2203      	movs	r2, #3
   45116:	4b1a      	ldr	r3, [pc, #104]	; (45180 <ipc_irq_handler+0x118>)
   45118:	701a      	strb	r2, [r3, #0]
   4511a:	2205      	movs	r2, #5
   4511c:	4b19      	ldr	r3, [pc, #100]	; (45184 <ipc_irq_handler+0x11c>)
   4511e:	e7d8      	b.n	450d2 <ipc_irq_handler+0x6a>
   45120:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   45124:	d003      	beq.n	4512e <ipc_irq_handler+0xc6>
   45126:	2202      	movs	r2, #2
   45128:	4b15      	ldr	r3, [pc, #84]	; (45180 <ipc_irq_handler+0x118>)
   4512a:	701a      	strb	r2, [r3, #0]
   4512c:	e7ac      	b.n	45088 <ipc_irq_handler+0x20>
   4512e:	0762      	lsls	r2, r4, #29
   45130:	d505      	bpl.n	4513e <ipc_irq_handler+0xd6>
   45132:	4b13      	ldr	r3, [pc, #76]	; (45180 <ipc_irq_handler+0x118>)
   45134:	781a      	ldrb	r2, [r3, #0]
   45136:	461e      	mov	r6, r3
   45138:	b93a      	cbnz	r2, 4514a <ipc_irq_handler+0xe2>
   4513a:	f7fe fe23 	bl	43d84 <nrf_modem_os_application_irq_set>
   4513e:	06e3      	lsls	r3, r4, #27
   45140:	d5a2      	bpl.n	45088 <ipc_irq_handler+0x20>
   45142:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   45146:	f7fe be1d 	b.w	43d84 <nrf_modem_os_application_irq_set>
   4514a:	2a01      	cmp	r2, #1
   4514c:	d1f7      	bne.n	4513e <ipc_irq_handler+0xd6>
   4514e:	4a10      	ldr	r2, [pc, #64]	; (45190 <ipc_irq_handler+0x128>)
   45150:	4810      	ldr	r0, [pc, #64]	; (45194 <ipc_irq_handler+0x12c>)
   45152:	6812      	ldr	r2, [r2, #0]
   45154:	6891      	ldr	r1, [r2, #8]
   45156:	6041      	str	r1, [r0, #4]
   45158:	6852      	ldr	r2, [r2, #4]
   4515a:	6002      	str	r2, [r0, #0]
   4515c:	b121      	cbz	r1, 45168 <ipc_irq_handler+0x100>
   4515e:	b11a      	cbz	r2, 45168 <ipc_irq_handler+0x100>
   45160:	6809      	ldr	r1, [r1, #0]
   45162:	b109      	cbz	r1, 45168 <ipc_irq_handler+0x100>
   45164:	6812      	ldr	r2, [r2, #0]
   45166:	b92a      	cbnz	r2, 45174 <ipc_irq_handler+0x10c>
   45168:	2303      	movs	r3, #3
   4516a:	2205      	movs	r2, #5
   4516c:	7033      	strb	r3, [r6, #0]
   4516e:	4b05      	ldr	r3, [pc, #20]	; (45184 <ipc_irq_handler+0x11c>)
   45170:	601a      	str	r2, [r3, #0]
   45172:	e7e4      	b.n	4513e <ipc_irq_handler+0xd6>
   45174:	701d      	strb	r5, [r3, #0]
   45176:	e7e2      	b.n	4513e <ipc_irq_handler+0xd6>
   45178:	e000e100 	.word	0xe000e100
   4517c:	4002a000 	.word	0x4002a000
   45180:	2001ea10 	.word	0x2001ea10
   45184:	2001ab5c 	.word	0x2001ab5c
   45188:	04400004 	.word	0x04400004
   4518c:	05500001 	.word	0x05500001
   45190:	2001ab68 	.word	0x2001ab68
   45194:	2001ab60 	.word	0x2001ab60

00045198 <interface_init>:
   45198:	b508      	push	{r3, lr}
   4519a:	f44f 72b0 	mov.w	r2, #352	; 0x160
   4519e:	2100      	movs	r1, #0
   451a0:	4802      	ldr	r0, [pc, #8]	; (451ac <interface_init+0x14>)
   451a2:	f003 f89d 	bl	482e0 <memset>
   451a6:	2000      	movs	r0, #0
   451a8:	bd08      	pop	{r3, pc}
   451aa:	bf00      	nop
   451ac:	2001ab7c 	.word	0x2001ab7c

000451b0 <interface_socket_wait>:
   451b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   451b4:	4615      	mov	r5, r2
   451b6:	222c      	movs	r2, #44	; 0x2c
   451b8:	4350      	muls	r0, r2
   451ba:	461e      	mov	r6, r3
   451bc:	4b0e      	ldr	r3, [pc, #56]	; (451f8 <interface_socket_wait+0x48>)
   451be:	460c      	mov	r4, r1
   451c0:	181f      	adds	r7, r3, r0
   451c2:	581b      	ldr	r3, [r3, r0]
   451c4:	402b      	ands	r3, r5
   451c6:	428b      	cmp	r3, r1
   451c8:	d102      	bne.n	451d0 <interface_socket_wait+0x20>
   451ca:	2000      	movs	r0, #0
   451cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   451d0:	687b      	ldr	r3, [r7, #4]
   451d2:	2b00      	cmp	r3, #0
   451d4:	d1f9      	bne.n	451ca <interface_socket_wait+0x1a>
   451d6:	46b8      	mov	r8, r7
   451d8:	f8d8 3000 	ldr.w	r3, [r8]
   451dc:	402b      	ands	r3, r5
   451de:	42a3      	cmp	r3, r4
   451e0:	d0f3      	beq.n	451ca <interface_socket_wait+0x1a>
   451e2:	f8d8 3004 	ldr.w	r3, [r8, #4]
   451e6:	2b00      	cmp	r3, #0
   451e8:	d1ef      	bne.n	451ca <interface_socket_wait+0x1a>
   451ea:	4631      	mov	r1, r6
   451ec:	4638      	mov	r0, r7
   451ee:	f7fe fd11 	bl	43c14 <nrf_modem_os_timedwait>
   451f2:	2800      	cmp	r0, #0
   451f4:	d0f0      	beq.n	451d8 <interface_socket_wait+0x28>
   451f6:	e7e9      	b.n	451cc <interface_socket_wait+0x1c>
   451f8:	2001ab7c 	.word	0x2001ab7c

000451fc <interface_sockets_aux_state_set>:
   451fc:	4a0d      	ldr	r2, [pc, #52]	; (45234 <interface_sockets_aux_state_set+0x38>)
   451fe:	b570      	push	{r4, r5, r6, lr}
   45200:	2300      	movs	r3, #0
   45202:	4611      	mov	r1, r2
   45204:	252c      	movs	r5, #44	; 0x2c
   45206:	fb05 f403 	mul.w	r4, r5, r3
   4520a:	590c      	ldr	r4, [r1, r4]
   4520c:	b15c      	cbz	r4, 45226 <interface_sockets_aux_state_set+0x2a>
   4520e:	68d4      	ldr	r4, [r2, #12]
   45210:	f024 0608 	bic.w	r6, r4, #8
   45214:	2e02      	cmp	r6, #2
   45216:	d001      	beq.n	4521c <interface_sockets_aux_state_set+0x20>
   45218:	2c05      	cmp	r4, #5
   4521a:	d104      	bne.n	45226 <interface_sockets_aux_state_set+0x2a>
   4521c:	fb05 f603 	mul.w	r6, r5, r3
   45220:	598c      	ldr	r4, [r1, r6]
   45222:	4304      	orrs	r4, r0
   45224:	518c      	str	r4, [r1, r6]
   45226:	3301      	adds	r3, #1
   45228:	2b08      	cmp	r3, #8
   4522a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   4522e:	d1ea      	bne.n	45206 <interface_sockets_aux_state_set+0xa>
   45230:	bd70      	pop	{r4, r5, r6, pc}
   45232:	bf00      	nop
   45234:	2001ab7c 	.word	0x2001ab7c

00045238 <interface_sockets_aux_state_clear>:
   45238:	4a0d      	ldr	r2, [pc, #52]	; (45270 <interface_sockets_aux_state_clear+0x38>)
   4523a:	b570      	push	{r4, r5, r6, lr}
   4523c:	2300      	movs	r3, #0
   4523e:	4611      	mov	r1, r2
   45240:	252c      	movs	r5, #44	; 0x2c
   45242:	43c0      	mvns	r0, r0
   45244:	fb05 f403 	mul.w	r4, r5, r3
   45248:	590c      	ldr	r4, [r1, r4]
   4524a:	b15c      	cbz	r4, 45264 <interface_sockets_aux_state_clear+0x2c>
   4524c:	68d4      	ldr	r4, [r2, #12]
   4524e:	f024 0608 	bic.w	r6, r4, #8
   45252:	2e02      	cmp	r6, #2
   45254:	d001      	beq.n	4525a <interface_sockets_aux_state_clear+0x22>
   45256:	2c05      	cmp	r4, #5
   45258:	d104      	bne.n	45264 <interface_sockets_aux_state_clear+0x2c>
   4525a:	fb05 f603 	mul.w	r6, r5, r3
   4525e:	598c      	ldr	r4, [r1, r6]
   45260:	4004      	ands	r4, r0
   45262:	518c      	str	r4, [r1, r6]
   45264:	3301      	adds	r3, #1
   45266:	2b08      	cmp	r3, #8
   45268:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   4526c:	d1ea      	bne.n	45244 <interface_sockets_aux_state_clear+0xc>
   4526e:	bd70      	pop	{r4, r5, r6, pc}
   45270:	2001ab7c 	.word	0x2001ab7c

00045274 <interface_from_internal_id_search>:
   45274:	4b0a      	ldr	r3, [pc, #40]	; (452a0 <interface_from_internal_id_search+0x2c>)
   45276:	4602      	mov	r2, r0
   45278:	b530      	push	{r4, r5, lr}
   4527a:	2000      	movs	r0, #0
   4527c:	461c      	mov	r4, r3
   4527e:	212c      	movs	r1, #44	; 0x2c
   45280:	fb01 f500 	mul.w	r5, r1, r0
   45284:	5965      	ldr	r5, [r4, r5]
   45286:	b115      	cbz	r5, 4528e <interface_from_internal_id_search+0x1a>
   45288:	699d      	ldr	r5, [r3, #24]
   4528a:	4295      	cmp	r5, r2
   4528c:	d006      	beq.n	4529c <interface_from_internal_id_search+0x28>
   4528e:	3001      	adds	r0, #1
   45290:	2808      	cmp	r0, #8
   45292:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   45296:	d1f3      	bne.n	45280 <interface_from_internal_id_search+0xc>
   45298:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   4529c:	bd30      	pop	{r4, r5, pc}
   4529e:	bf00      	nop
   452a0:	2001ab7c 	.word	0x2001ab7c

000452a4 <interface_socket_from_handle_get>:
   452a4:	2807      	cmp	r0, #7
   452a6:	d808      	bhi.n	452ba <interface_socket_from_handle_get+0x16>
   452a8:	232c      	movs	r3, #44	; 0x2c
   452aa:	4343      	muls	r3, r0
   452ac:	4a04      	ldr	r2, [pc, #16]	; (452c0 <interface_socket_from_handle_get+0x1c>)
   452ae:	18d0      	adds	r0, r2, r3
   452b0:	58d3      	ldr	r3, [r2, r3]
   452b2:	2b00      	cmp	r3, #0
   452b4:	bf08      	it	eq
   452b6:	2000      	moveq	r0, #0
   452b8:	4770      	bx	lr
   452ba:	2000      	movs	r0, #0
   452bc:	4770      	bx	lr
   452be:	bf00      	nop
   452c0:	2001ab7c 	.word	0x2001ab7c

000452c4 <rpc_error_to_nrf_errno>:
   452c4:	286a      	cmp	r0, #106	; 0x6a
   452c6:	bf9a      	itte	ls
   452c8:	4b01      	ldrls	r3, [pc, #4]	; (452d0 <rpc_error_to_nrf_errno+0xc>)
   452ca:	5c18      	ldrbls	r0, [r3, r0]
   452cc:	205f      	movhi	r0, #95	; 0x5f
   452ce:	4770      	bx	lr
   452d0:	000499ff 	.word	0x000499ff

000452d4 <rpc_error_to_nrf_gai_errno>:
   452d4:	2805      	cmp	r0, #5
   452d6:	d013      	beq.n	45300 <rpc_error_to_nrf_gai_errno+0x2c>
   452d8:	d807      	bhi.n	452ea <rpc_error_to_nrf_gai_errno+0x16>
   452da:	b170      	cbz	r0, 452fa <rpc_error_to_nrf_gai_errno+0x26>
   452dc:	4b0b      	ldr	r3, [pc, #44]	; (4530c <rpc_error_to_nrf_gai_errno+0x38>)
   452de:	5c1b      	ldrb	r3, [r3, r0]
   452e0:	4a0b      	ldr	r2, [pc, #44]	; (45310 <rpc_error_to_nrf_gai_errno+0x3c>)
   452e2:	f240 1015 	movw	r0, #277	; 0x115
   452e6:	6013      	str	r3, [r2, #0]
   452e8:	4770      	bx	lr
   452ea:	2806      	cmp	r0, #6
   452ec:	d00b      	beq.n	45306 <rpc_error_to_nrf_gai_errno+0x32>
   452ee:	280d      	cmp	r0, #13
   452f0:	d009      	beq.n	45306 <rpc_error_to_nrf_gai_errno+0x32>
   452f2:	286a      	cmp	r0, #106	; 0x6a
   452f4:	d9f2      	bls.n	452dc <rpc_error_to_nrf_gai_errno+0x8>
   452f6:	235f      	movs	r3, #95	; 0x5f
   452f8:	e7f2      	b.n	452e0 <rpc_error_to_nrf_gai_errno+0xc>
   452fa:	4b05      	ldr	r3, [pc, #20]	; (45310 <rpc_error_to_nrf_gai_errno+0x3c>)
   452fc:	6018      	str	r0, [r3, #0]
   452fe:	4770      	bx	lr
   45300:	f44f 708a 	mov.w	r0, #276	; 0x114
   45304:	4770      	bx	lr
   45306:	f240 1011 	movw	r0, #273	; 0x111
   4530a:	4770      	bx	lr
   4530c:	000499ff 	.word	0x000499ff
   45310:	2001ace4 	.word	0x2001ace4

00045314 <ip_interface_init>:
   45314:	b510      	push	{r4, lr}
   45316:	2400      	movs	r4, #0
   45318:	4b06      	ldr	r3, [pc, #24]	; (45334 <ip_interface_init+0x20>)
   4531a:	2220      	movs	r2, #32
   4531c:	601c      	str	r4, [r3, #0]
   4531e:	4b06      	ldr	r3, [pc, #24]	; (45338 <ip_interface_init+0x24>)
   45320:	4621      	mov	r1, r4
   45322:	4806      	ldr	r0, [pc, #24]	; (4533c <ip_interface_init+0x28>)
   45324:	601c      	str	r4, [r3, #0]
   45326:	f002 ffdb 	bl	482e0 <memset>
   4532a:	2201      	movs	r2, #1
   4532c:	4b04      	ldr	r3, [pc, #16]	; (45340 <ip_interface_init+0x2c>)
   4532e:	4620      	mov	r0, r4
   45330:	701a      	strb	r2, [r3, #0]
   45332:	bd10      	pop	{r4, pc}
   45334:	2001acf0 	.word	0x2001acf0
   45338:	2001acec 	.word	0x2001acec
   4533c:	2001acf4 	.word	0x2001acf4
   45340:	2001ea13 	.word	0x2001ea13

00045344 <rpc_ip_event_handler>:
   45344:	f248 030f 	movw	r3, #32783	; 0x800f
   45348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4534c:	4299      	cmp	r1, r3
   4534e:	4604      	mov	r4, r0
   45350:	460e      	mov	r6, r1
   45352:	b089      	sub	sp, #36	; 0x24
   45354:	f000 80a4 	beq.w	454a0 <rpc_ip_event_handler+0x15c>
   45358:	f249 0304 	movw	r3, #36868	; 0x9004
   4535c:	4299      	cmp	r1, r3
   4535e:	f000 80ab 	beq.w	454b8 <rpc_ip_event_handler+0x174>
   45362:	f248 030d 	movw	r3, #32781	; 0x800d
   45366:	4299      	cmp	r1, r3
   45368:	f040 80b8 	bne.w	454dc <rpc_ip_event_handler+0x198>
   4536c:	4bbc      	ldr	r3, [pc, #752]	; (45660 <rpc_ip_event_handler+0x31c>)
   4536e:	681a      	ldr	r2, [r3, #0]
   45370:	9303      	str	r3, [sp, #12]
   45372:	2a01      	cmp	r2, #1
   45374:	d12d      	bne.n	453d2 <rpc_ip_event_handler+0x8e>
   45376:	6940      	ldr	r0, [r0, #20]
   45378:	2800      	cmp	r0, #0
   4537a:	f040 808c 	bne.w	45496 <rpc_ip_event_handler+0x152>
   4537e:	f8d4 a018 	ldr.w	sl, [r4, #24]
   45382:	f8d4 8000 	ldr.w	r8, [r4]
   45386:	ea4f 134a 	mov.w	r3, sl, lsl #5
   4538a:	4618      	mov	r0, r3
   4538c:	9301      	str	r3, [sp, #4]
   4538e:	f7fe fd19 	bl	43dc4 <nrf_modem_os_alloc>
   45392:	4607      	mov	r7, r0
   45394:	b310      	cbz	r0, 453dc <rpc_ip_event_handler+0x98>
   45396:	2024      	movs	r0, #36	; 0x24
   45398:	fb00 f00a 	mul.w	r0, r0, sl
   4539c:	f7fe fd12 	bl	43dc4 <nrf_modem_os_alloc>
   453a0:	4605      	mov	r5, r0
   453a2:	b1e8      	cbz	r0, 453e0 <rpc_ip_event_handler+0x9c>
   453a4:	2604      	movs	r6, #4
   453a6:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   453aa:	f107 0920 	add.w	r9, r7, #32
   453ae:	9302      	str	r3, [sp, #8]
   453b0:	9b02      	ldr	r3, [sp, #8]
   453b2:	42ab      	cmp	r3, r5
   453b4:	d118      	bne.n	453e8 <rpc_ip_event_handler+0xa4>
   453b6:	f1ba 0f00 	cmp.w	sl, #0
   453ba:	d005      	beq.n	453c8 <rpc_ip_event_handler+0x84>
   453bc:	9b01      	ldr	r3, [sp, #4]
   453be:	443b      	add	r3, r7
   453c0:	4699      	mov	r9, r3
   453c2:	2300      	movs	r3, #0
   453c4:	f849 3c04 	str.w	r3, [r9, #-4]
   453c8:	4ba6      	ldr	r3, [pc, #664]	; (45664 <rpc_ip_event_handler+0x320>)
   453ca:	601f      	str	r7, [r3, #0]
   453cc:	2302      	movs	r3, #2
   453ce:	9a03      	ldr	r2, [sp, #12]
   453d0:	6013      	str	r3, [r2, #0]
   453d2:	6820      	ldr	r0, [r4, #0]
   453d4:	2800      	cmp	r0, #0
   453d6:	f040 81c7 	bne.w	45768 <rpc_ip_event_handler+0x424>
   453da:	e1c7      	b.n	4576c <rpc_ip_event_handler+0x428>
   453dc:	f7fe fcfa 	bl	43dd4 <nrf_modem_os_free>
   453e0:	220c      	movs	r2, #12
   453e2:	4ba1      	ldr	r3, [pc, #644]	; (45668 <rpc_ip_event_handler+0x324>)
   453e4:	601a      	str	r2, [r3, #0]
   453e6:	e7ef      	b.n	453c8 <rpc_ip_event_handler+0x84>
   453e8:	f858 2006 	ldr.w	r2, [r8, r6]
   453ec:	eb08 0106 	add.w	r1, r8, r6
   453f0:	f849 2c20 	str.w	r2, [r9, #-32]
   453f4:	eb08 0206 	add.w	r2, r8, r6
   453f8:	6852      	ldr	r2, [r2, #4]
   453fa:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   453fe:	3a01      	subs	r2, #1
   45400:	2a04      	cmp	r2, #4
   45402:	bf8c      	ite	hi
   45404:	2200      	movhi	r2, #0
   45406:	4b99      	ldrls	r3, [pc, #612]	; (4566c <rpc_ip_event_handler+0x328>)
   45408:	f106 0614 	add.w	r6, r6, #20
   4540c:	bf98      	it	ls
   4540e:	569a      	ldrsbls	r2, [r3, r2]
   45410:	4b97      	ldr	r3, [pc, #604]	; (45670 <rpc_ip_event_handler+0x32c>)
   45412:	f849 2c1c 	str.w	r2, [r9, #-28]
   45416:	681a      	ldr	r2, [r3, #0]
   45418:	4b96      	ldr	r3, [pc, #600]	; (45674 <rpc_ip_event_handler+0x330>)
   4541a:	f849 2c18 	str.w	r2, [r9, #-24]
   4541e:	681a      	ldr	r2, [r3, #0]
   45420:	f849 2c14 	str.w	r2, [r9, #-20]
   45424:	8a0a      	ldrh	r2, [r1, #16]
   45426:	4994      	ldr	r1, [pc, #592]	; (45678 <rpc_ip_event_handler+0x334>)
   45428:	2a04      	cmp	r2, #4
   4542a:	8808      	ldrh	r0, [r1, #0]
   4542c:	f849 2c10 	str.w	r2, [r9, #-16]
   45430:	f849 5c0c 	str.w	r5, [r9, #-12]
   45434:	eb08 0106 	add.w	r1, r8, r6
   45438:	d121      	bne.n	4547e <rpc_ip_event_handler+0x13a>
   4543a:	2202      	movs	r2, #2
   4543c:	606a      	str	r2, [r5, #4]
   4543e:	2210      	movs	r2, #16
   45440:	8128      	strh	r0, [r5, #8]
   45442:	702a      	strb	r2, [r5, #0]
   45444:	680a      	ldr	r2, [r1, #0]
   45446:	60ea      	str	r2, [r5, #12]
   45448:	f859 2c10 	ldr.w	r2, [r9, #-16]
   4544c:	f10b 0001 	add.w	r0, fp, #1
   45450:	4416      	add	r6, r2
   45452:	f7fe fcb7 	bl	43dc4 <nrf_modem_os_alloc>
   45456:	f849 0c08 	str.w	r0, [r9, #-8]
   4545a:	b148      	cbz	r0, 45470 <rpc_ip_event_handler+0x12c>
   4545c:	465a      	mov	r2, fp
   4545e:	eb08 0106 	add.w	r1, r8, r6
   45462:	f002 ff32 	bl	482ca <memcpy>
   45466:	2100      	movs	r1, #0
   45468:	f859 2c08 	ldr.w	r2, [r9, #-8]
   4546c:	f802 100b 	strb.w	r1, [r2, fp]
   45470:	f849 9c04 	str.w	r9, [r9, #-4]
   45474:	445e      	add	r6, fp
   45476:	f109 0920 	add.w	r9, r9, #32
   4547a:	3508      	adds	r5, #8
   4547c:	e798      	b.n	453b0 <rpc_ip_event_handler+0x6c>
   4547e:	230a      	movs	r3, #10
   45480:	f04f 0c24 	mov.w	ip, #36	; 0x24
   45484:	8128      	strh	r0, [r5, #8]
   45486:	606b      	str	r3, [r5, #4]
   45488:	f885 c000 	strb.w	ip, [r5]
   4548c:	f105 0010 	add.w	r0, r5, #16
   45490:	f002 ff1b 	bl	482ca <memcpy>
   45494:	e7d8      	b.n	45448 <rpc_ip_event_handler+0x104>
   45496:	f7ff ff1d 	bl	452d4 <rpc_error_to_nrf_gai_errno>
   4549a:	4b73      	ldr	r3, [pc, #460]	; (45668 <rpc_ip_event_handler+0x324>)
   4549c:	6018      	str	r0, [r3, #0]
   4549e:	e795      	b.n	453cc <rpc_ip_event_handler+0x88>
   454a0:	6943      	ldr	r3, [r0, #20]
   454a2:	2b6a      	cmp	r3, #106	; 0x6a
   454a4:	bf8e      	itee	hi
   454a6:	235f      	movhi	r3, #95	; 0x5f
   454a8:	4a74      	ldrls	r2, [pc, #464]	; (4567c <rpc_ip_event_handler+0x338>)
   454aa:	5cd3      	ldrbls	r3, [r2, r3]
   454ac:	4a74      	ldr	r2, [pc, #464]	; (45680 <rpc_ip_event_handler+0x33c>)
   454ae:	6013      	str	r3, [r2, #0]
   454b0:	4b74      	ldr	r3, [pc, #464]	; (45684 <rpc_ip_event_handler+0x340>)
   454b2:	2201      	movs	r2, #1
   454b4:	701a      	strb	r2, [r3, #0]
   454b6:	e159      	b.n	4576c <rpc_ip_event_handler+0x428>
   454b8:	6903      	ldr	r3, [r0, #16]
   454ba:	2b03      	cmp	r3, #3
   454bc:	d807      	bhi.n	454ce <rpc_ip_event_handler+0x18a>
   454be:	e8df f003 	tbb	[pc, r3]
   454c2:	0802      	.short	0x0802
   454c4:	0802      	.short	0x0802
   454c6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   454ca:	f7ff fe97 	bl	451fc <interface_sockets_aux_state_set>
   454ce:	4b6e      	ldr	r3, [pc, #440]	; (45688 <rpc_ip_event_handler+0x344>)
   454d0:	e7ef      	b.n	454b2 <rpc_ip_event_handler+0x16e>
   454d2:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   454d6:	f7ff feaf 	bl	45238 <interface_sockets_aux_state_clear>
   454da:	e7f8      	b.n	454ce <rpc_ip_event_handler+0x18a>
   454dc:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   454e0:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   454e4:	68c0      	ldr	r0, [r0, #12]
   454e6:	d13b      	bne.n	45560 <rpc_ip_event_handler+0x21c>
   454e8:	f7ff fec4 	bl	45274 <interface_from_internal_id_search>
   454ec:	4607      	mov	r7, r0
   454ee:	4638      	mov	r0, r7
   454f0:	f7ff fed8 	bl	452a4 <interface_socket_from_handle_get>
   454f4:	4605      	mov	r5, r0
   454f6:	2800      	cmp	r0, #0
   454f8:	f43f af6b 	beq.w	453d2 <rpc_ip_event_handler+0x8e>
   454fc:	4601      	mov	r1, r0
   454fe:	4633      	mov	r3, r6
   45500:	4622      	mov	r2, r4
   45502:	4638      	mov	r0, r7
   45504:	f000 f9f4 	bl	458f0 <tls_rpc_ip_event_handler>
   45508:	2800      	cmp	r0, #0
   4550a:	f000 812f 	beq.w	4576c <rpc_ip_event_handler+0x428>
   4550e:	f248 030c 	movw	r3, #32780	; 0x800c
   45512:	429e      	cmp	r6, r3
   45514:	d826      	bhi.n	45564 <rpc_ip_event_handler+0x220>
   45516:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   4551a:	f67f af5a 	bls.w	453d2 <rpc_ip_event_handler+0x8e>
   4551e:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   45522:	3e01      	subs	r6, #1
   45524:	2e0b      	cmp	r6, #11
   45526:	f63f af54 	bhi.w	453d2 <rpc_ip_event_handler+0x8e>
   4552a:	a301      	add	r3, pc, #4	; (adr r3, 45530 <rpc_ip_event_handler+0x1ec>)
   4552c:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   45530:	000455f5 	.word	0x000455f5
   45534:	000456a9 	.word	0x000456a9
   45538:	000457c5 	.word	0x000457c5
   4553c:	000457e3 	.word	0x000457e3
   45540:	0004568d 	.word	0x0004568d
   45544:	00045775 	.word	0x00045775
   45548:	00045775 	.word	0x00045775
   4554c:	000456ed 	.word	0x000456ed
   45550:	0004560f 	.word	0x0004560f
   45554:	000453d3 	.word	0x000453d3
   45558:	000453d3 	.word	0x000453d3
   4555c:	00045717 	.word	0x00045717
   45560:	0c07      	lsrs	r7, r0, #16
   45562:	e7c4      	b.n	454ee <rpc_ip_event_handler+0x1aa>
   45564:	f249 0302 	movw	r3, #36866	; 0x9002
   45568:	429e      	cmp	r6, r3
   4556a:	f000 80cc 	beq.w	45706 <rpc_ip_event_handler+0x3c2>
   4556e:	f249 0303 	movw	r3, #36867	; 0x9003
   45572:	429e      	cmp	r6, r3
   45574:	d05b      	beq.n	4562e <rpc_ip_event_handler+0x2ea>
   45576:	f249 0301 	movw	r3, #36865	; 0x9001
   4557a:	429e      	cmp	r6, r3
   4557c:	f47f af29 	bne.w	453d2 <rpc_ip_event_handler+0x8e>
   45580:	682e      	ldr	r6, [r5, #0]
   45582:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   45586:	f000 80ee 	beq.w	45766 <rpc_ip_event_handler+0x422>
   4558a:	68a3      	ldr	r3, [r4, #8]
   4558c:	2b04      	cmp	r3, #4
   4558e:	f240 80e7 	bls.w	45760 <rpc_ip_event_handler+0x41c>
   45592:	8a63      	ldrh	r3, [r4, #18]
   45594:	2b00      	cmp	r3, #0
   45596:	f000 80e4 	beq.w	45762 <rpc_ip_event_handler+0x41e>
   4559a:	2b10      	cmp	r3, #16
   4559c:	f040 80cc 	bne.w	45738 <rpc_ip_event_handler+0x3f4>
   455a0:	2024      	movs	r0, #36	; 0x24
   455a2:	f7fe fc0f 	bl	43dc4 <nrf_modem_os_alloc>
   455a6:	b318      	cbz	r0, 455f0 <rpc_ip_event_handler+0x2ac>
   455a8:	230a      	movs	r3, #10
   455aa:	6043      	str	r3, [r0, #4]
   455ac:	2324      	movs	r3, #36	; 0x24
   455ae:	7003      	strb	r3, [r0, #0]
   455b0:	7c62      	ldrb	r2, [r4, #17]
   455b2:	7c23      	ldrb	r3, [r4, #16]
   455b4:	f104 0124 	add.w	r1, r4, #36	; 0x24
   455b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   455bc:	8103      	strh	r3, [r0, #8]
   455be:	f100 0210 	add.w	r2, r0, #16
   455c2:	f104 0314 	add.w	r3, r4, #20
   455c6:	f853 6b04 	ldr.w	r6, [r3], #4
   455ca:	428b      	cmp	r3, r1
   455cc:	f842 6b04 	str.w	r6, [r2], #4
   455d0:	d1f9      	bne.n	455c6 <rpc_ip_event_handler+0x282>
   455d2:	2324      	movs	r3, #36	; 0x24
   455d4:	6822      	ldr	r2, [r4, #0]
   455d6:	9307      	str	r3, [sp, #28]
   455d8:	9204      	str	r2, [sp, #16]
   455da:	6862      	ldr	r2, [r4, #4]
   455dc:	a904      	add	r1, sp, #16
   455de:	e9cd 2005 	strd	r2, r0, [sp, #20]
   455e2:	69e8      	ldr	r0, [r5, #28]
   455e4:	6803      	ldr	r3, [r0, #0]
   455e6:	685b      	ldr	r3, [r3, #4]
   455e8:	4798      	blx	r3
   455ea:	3001      	adds	r0, #1
   455ec:	f040 808f 	bne.w	4570e <rpc_ip_event_handler+0x3ca>
   455f0:	2002      	movs	r0, #2
   455f2:	e0bc      	b.n	4576e <rpc_ip_event_handler+0x42a>
   455f4:	682b      	ldr	r3, [r5, #0]
   455f6:	2b01      	cmp	r3, #1
   455f8:	f040 80b8 	bne.w	4576c <rpc_ip_event_handler+0x428>
   455fc:	6960      	ldr	r0, [r4, #20]
   455fe:	2800      	cmp	r0, #0
   45600:	f040 80e9 	bne.w	457d6 <rpc_ip_event_handler+0x492>
   45604:	2302      	movs	r3, #2
   45606:	602b      	str	r3, [r5, #0]
   45608:	69a3      	ldr	r3, [r4, #24]
   4560a:	61ab      	str	r3, [r5, #24]
   4560c:	e0af      	b.n	4576e <rpc_ip_event_handler+0x42a>
   4560e:	682b      	ldr	r3, [r5, #0]
   45610:	b29b      	uxth	r3, r3
   45612:	2b0d      	cmp	r3, #13
   45614:	f040 80aa 	bne.w	4576c <rpc_ip_event_handler+0x428>
   45618:	6960      	ldr	r0, [r4, #20]
   4561a:	2800      	cmp	r0, #0
   4561c:	f040 80db 	bne.w	457d6 <rpc_ip_event_handler+0x492>
   45620:	682b      	ldr	r3, [r5, #0]
   45622:	0c1b      	lsrs	r3, r3, #16
   45624:	041b      	lsls	r3, r3, #16
   45626:	f043 030e 	orr.w	r3, r3, #14
   4562a:	602b      	str	r3, [r5, #0]
   4562c:	e09f      	b.n	4576e <rpc_ip_event_handler+0x42a>
   4562e:	682b      	ldr	r3, [r5, #0]
   45630:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   45634:	602b      	str	r3, [r5, #0]
   45636:	682b      	ldr	r3, [r5, #0]
   45638:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   4563c:	602b      	str	r3, [r5, #0]
   4563e:	6923      	ldr	r3, [r4, #16]
   45640:	2b6c      	cmp	r3, #108	; 0x6c
   45642:	d107      	bne.n	45654 <rpc_ip_event_handler+0x310>
   45644:	682b      	ldr	r3, [r5, #0]
   45646:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   4564a:	602b      	str	r3, [r5, #0]
   4564c:	2380      	movs	r3, #128	; 0x80
   4564e:	606b      	str	r3, [r5, #4]
   45650:	60ab      	str	r3, [r5, #8]
   45652:	e08b      	b.n	4576c <rpc_ip_event_handler+0x428>
   45654:	2b6a      	cmp	r3, #106	; 0x6a
   45656:	bf96      	itet	ls
   45658:	4a08      	ldrls	r2, [pc, #32]	; (4567c <rpc_ip_event_handler+0x338>)
   4565a:	235f      	movhi	r3, #95	; 0x5f
   4565c:	5cd3      	ldrbls	r3, [r2, r3]
   4565e:	e7f6      	b.n	4564e <rpc_ip_event_handler+0x30a>
   45660:	2001acec 	.word	0x2001acec
   45664:	2001acf0 	.word	0x2001acf0
   45668:	2001ace8 	.word	0x2001ace8
   4566c:	000499fa 	.word	0x000499fa
   45670:	2001ace0 	.word	0x2001ace0
   45674:	2001acdc 	.word	0x2001acdc
   45678:	2001ade2 	.word	0x2001ade2
   4567c:	000499ff 	.word	0x000499ff
   45680:	2001ad14 	.word	0x2001ad14
   45684:	2001ea14 	.word	0x2001ea14
   45688:	2001ea12 	.word	0x2001ea12
   4568c:	682b      	ldr	r3, [r5, #0]
   4568e:	b29b      	uxth	r3, r3
   45690:	2b03      	cmp	r3, #3
   45692:	d16b      	bne.n	4576c <rpc_ip_event_handler+0x428>
   45694:	6960      	ldr	r0, [r4, #20]
   45696:	2800      	cmp	r0, #0
   45698:	f040 809d 	bne.w	457d6 <rpc_ip_event_handler+0x492>
   4569c:	682b      	ldr	r3, [r5, #0]
   4569e:	0c1b      	lsrs	r3, r3, #16
   456a0:	041b      	lsls	r3, r3, #16
   456a2:	f043 0304 	orr.w	r3, r3, #4
   456a6:	e7c0      	b.n	4562a <rpc_ip_event_handler+0x2e6>
   456a8:	682b      	ldr	r3, [r5, #0]
   456aa:	0099      	lsls	r1, r3, #2
   456ac:	d55e      	bpl.n	4576c <rpc_ip_event_handler+0x428>
   456ae:	682b      	ldr	r3, [r5, #0]
   456b0:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   456b4:	602b      	str	r3, [r5, #0]
   456b6:	6960      	ldr	r0, [r4, #20]
   456b8:	b968      	cbnz	r0, 456d6 <rpc_ip_event_handler+0x392>
   456ba:	682b      	ldr	r3, [r5, #0]
   456bc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   456c0:	602b      	str	r3, [r5, #0]
   456c2:	682b      	ldr	r3, [r5, #0]
   456c4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   456c8:	602b      	str	r3, [r5, #0]
   456ca:	682b      	ldr	r3, [r5, #0]
   456cc:	0c1b      	lsrs	r3, r3, #16
   456ce:	041b      	lsls	r3, r3, #16
   456d0:	f043 0305 	orr.w	r3, r3, #5
   456d4:	e7a9      	b.n	4562a <rpc_ip_event_handler+0x2e6>
   456d6:	286a      	cmp	r0, #106	; 0x6a
   456d8:	bf8e      	itee	hi
   456da:	235f      	movhi	r3, #95	; 0x5f
   456dc:	4b4c      	ldrls	r3, [pc, #304]	; (45810 <rpc_ip_event_handler+0x4cc>)
   456de:	5c1b      	ldrbls	r3, [r3, r0]
   456e0:	606b      	str	r3, [r5, #4]
   456e2:	682b      	ldr	r3, [r5, #0]
   456e4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   456e8:	602b      	str	r3, [r5, #0]
   456ea:	e03f      	b.n	4576c <rpc_ip_event_handler+0x428>
   456ec:	682b      	ldr	r3, [r5, #0]
   456ee:	b29b      	uxth	r3, r3
   456f0:	2b06      	cmp	r3, #6
   456f2:	d13b      	bne.n	4576c <rpc_ip_event_handler+0x428>
   456f4:	6960      	ldr	r0, [r4, #20]
   456f6:	2800      	cmp	r0, #0
   456f8:	d16d      	bne.n	457d6 <rpc_ip_event_handler+0x492>
   456fa:	682b      	ldr	r3, [r5, #0]
   456fc:	0c1b      	lsrs	r3, r3, #16
   456fe:	041b      	lsls	r3, r3, #16
   45700:	f043 0307 	orr.w	r3, r3, #7
   45704:	e791      	b.n	4562a <rpc_ip_event_handler+0x2e6>
   45706:	682b      	ldr	r3, [r5, #0]
   45708:	b29b      	uxth	r3, r3
   4570a:	2b07      	cmp	r3, #7
   4570c:	d12e      	bne.n	4576c <rpc_ip_event_handler+0x428>
   4570e:	682b      	ldr	r3, [r5, #0]
   45710:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   45714:	e7e8      	b.n	456e8 <rpc_ip_event_handler+0x3a4>
   45716:	682b      	ldr	r3, [r5, #0]
   45718:	b29b      	uxth	r3, r3
   4571a:	2b08      	cmp	r3, #8
   4571c:	d126      	bne.n	4576c <rpc_ip_event_handler+0x428>
   4571e:	6963      	ldr	r3, [r4, #20]
   45720:	2b00      	cmp	r3, #0
   45722:	d16d      	bne.n	45800 <rpc_ip_event_handler+0x4bc>
   45724:	4b3b      	ldr	r3, [pc, #236]	; (45814 <rpc_ip_event_handler+0x4d0>)
   45726:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4572a:	682b      	ldr	r3, [r5, #0]
   4572c:	0c1b      	lsrs	r3, r3, #16
   4572e:	041b      	lsls	r3, r3, #16
   45730:	f043 0309 	orr.w	r3, r3, #9
   45734:	602b      	str	r3, [r5, #0]
   45736:	e032      	b.n	4579e <rpc_ip_event_handler+0x45a>
   45738:	2b04      	cmp	r3, #4
   4573a:	d114      	bne.n	45766 <rpc_ip_event_handler+0x422>
   4573c:	2010      	movs	r0, #16
   4573e:	f7fe fb41 	bl	43dc4 <nrf_modem_os_alloc>
   45742:	2800      	cmp	r0, #0
   45744:	f43f af54 	beq.w	455f0 <rpc_ip_event_handler+0x2ac>
   45748:	2302      	movs	r3, #2
   4574a:	6043      	str	r3, [r0, #4]
   4574c:	2310      	movs	r3, #16
   4574e:	7003      	strb	r3, [r0, #0]
   45750:	7c22      	ldrb	r2, [r4, #16]
   45752:	7c61      	ldrb	r1, [r4, #17]
   45754:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   45758:	8102      	strh	r2, [r0, #8]
   4575a:	6962      	ldr	r2, [r4, #20]
   4575c:	60c2      	str	r2, [r0, #12]
   4575e:	e739      	b.n	455d4 <rpc_ip_event_handler+0x290>
   45760:	2300      	movs	r3, #0
   45762:	4618      	mov	r0, r3
   45764:	e736      	b.n	455d4 <rpc_ip_event_handler+0x290>
   45766:	6820      	ldr	r0, [r4, #0]
   45768:	f002 ffe0 	bl	4872c <rpc_client_data_free>
   4576c:	2000      	movs	r0, #0
   4576e:	b009      	add	sp, #36	; 0x24
   45770:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45774:	4b27      	ldr	r3, [pc, #156]	; (45814 <rpc_ip_event_handler+0x4d0>)
   45776:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   4577a:	6963      	ldr	r3, [r4, #20]
   4577c:	b17b      	cbz	r3, 4579e <rpc_ip_event_handler+0x45a>
   4577e:	2b6b      	cmp	r3, #107	; 0x6b
   45780:	d10f      	bne.n	457a2 <rpc_ip_event_handler+0x45e>
   45782:	6928      	ldr	r0, [r5, #16]
   45784:	220c      	movs	r2, #12
   45786:	2801      	cmp	r0, #1
   45788:	682b      	ldr	r3, [r5, #0]
   4578a:	d104      	bne.n	45796 <rpc_ip_event_handler+0x452>
   4578c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   45790:	602b      	str	r3, [r5, #0]
   45792:	606a      	str	r2, [r5, #4]
   45794:	e7eb      	b.n	4576e <rpc_ip_event_handler+0x42a>
   45796:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   4579a:	602b      	str	r3, [r5, #0]
   4579c:	606a      	str	r2, [r5, #4]
   4579e:	2001      	movs	r0, #1
   457a0:	e7e5      	b.n	4576e <rpc_ip_event_handler+0x42a>
   457a2:	f023 0002 	bic.w	r0, r3, #2
   457a6:	2801      	cmp	r0, #1
   457a8:	d102      	bne.n	457b0 <rpc_ip_event_handler+0x46c>
   457aa:	230c      	movs	r3, #12
   457ac:	606b      	str	r3, [r5, #4]
   457ae:	e7de      	b.n	4576e <rpc_ip_event_handler+0x42a>
   457b0:	2b6a      	cmp	r3, #106	; 0x6a
   457b2:	bf8e      	itee	hi
   457b4:	235f      	movhi	r3, #95	; 0x5f
   457b6:	4a16      	ldrls	r2, [pc, #88]	; (45810 <rpc_ip_event_handler+0x4cc>)
   457b8:	5cd3      	ldrbls	r3, [r2, r3]
   457ba:	606b      	str	r3, [r5, #4]
   457bc:	682b      	ldr	r3, [r5, #0]
   457be:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   457c2:	e7b7      	b.n	45734 <rpc_ip_event_handler+0x3f0>
   457c4:	682b      	ldr	r3, [r5, #0]
   457c6:	025a      	lsls	r2, r3, #9
   457c8:	d5d0      	bpl.n	4576c <rpc_ip_event_handler+0x428>
   457ca:	6960      	ldr	r0, [r4, #20]
   457cc:	b918      	cbnz	r0, 457d6 <rpc_ip_event_handler+0x492>
   457ce:	682b      	ldr	r3, [r5, #0]
   457d0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   457d4:	e729      	b.n	4562a <rpc_ip_event_handler+0x2e6>
   457d6:	286a      	cmp	r0, #106	; 0x6a
   457d8:	d817      	bhi.n	4580a <rpc_ip_event_handler+0x4c6>
   457da:	4b0d      	ldr	r3, [pc, #52]	; (45810 <rpc_ip_event_handler+0x4cc>)
   457dc:	5c1b      	ldrb	r3, [r3, r0]
   457de:	606b      	str	r3, [r5, #4]
   457e0:	e7c4      	b.n	4576c <rpc_ip_event_handler+0x428>
   457e2:	682b      	ldr	r3, [r5, #0]
   457e4:	01db      	lsls	r3, r3, #7
   457e6:	d5c1      	bpl.n	4576c <rpc_ip_event_handler+0x428>
   457e8:	6963      	ldr	r3, [r4, #20]
   457ea:	b94b      	cbnz	r3, 45800 <rpc_ip_event_handler+0x4bc>
   457ec:	6820      	ldr	r0, [r4, #0]
   457ee:	b118      	cbz	r0, 457f8 <rpc_ip_event_handler+0x4b4>
   457f0:	2001      	movs	r0, #1
   457f2:	4b08      	ldr	r3, [pc, #32]	; (45814 <rpc_ip_event_handler+0x4d0>)
   457f4:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   457f8:	682b      	ldr	r3, [r5, #0]
   457fa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   457fe:	e714      	b.n	4562a <rpc_ip_event_handler+0x2e6>
   45800:	2b6a      	cmp	r3, #106	; 0x6a
   45802:	d802      	bhi.n	4580a <rpc_ip_event_handler+0x4c6>
   45804:	4a02      	ldr	r2, [pc, #8]	; (45810 <rpc_ip_event_handler+0x4cc>)
   45806:	5cd3      	ldrb	r3, [r2, r3]
   45808:	e7e9      	b.n	457de <rpc_ip_event_handler+0x49a>
   4580a:	235f      	movs	r3, #95	; 0x5f
   4580c:	e7e7      	b.n	457de <rpc_ip_event_handler+0x49a>
   4580e:	bf00      	nop
   45810:	000499ff 	.word	0x000499ff
   45814:	2001acf4 	.word	0x2001acf4

00045818 <hostname_free>:
   45818:	b538      	push	{r3, r4, r5, lr}
   4581a:	4c07      	ldr	r4, [pc, #28]	; (45838 <hostname_free+0x20>)
   4581c:	4605      	mov	r5, r0
   4581e:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   45822:	b138      	cbz	r0, 45834 <hostname_free+0x1c>
   45824:	f7fe fad6 	bl	43dd4 <nrf_modem_os_free>
   45828:	2300      	movs	r3, #0
   4582a:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   4582e:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   45832:	6063      	str	r3, [r4, #4]
   45834:	bd38      	pop	{r3, r4, r5, pc}
   45836:	bf00      	nop
   45838:	2001ad18 	.word	0x2001ad18

0004583c <secure_socket_attach_initiate>:
   4583c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   45840:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   45844:	f8df 8094 	ldr.w	r8, [pc, #148]	; 458dc <secure_socket_attach_initiate+0xa0>
   45848:	9301      	str	r3, [sp, #4]
   4584a:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   4584e:	460d      	mov	r5, r1
   45850:	4616      	mov	r6, r2
   45852:	f8d9 3004 	ldr.w	r3, [r9, #4]
   45856:	f247 0281 	movw	r2, #28801	; 0x7081
   4585a:	6989      	ldr	r1, [r1, #24]
   4585c:	4607      	mov	r7, r0
   4585e:	f002 ff67 	bl	48730 <ip_interface_request_create>
   45862:	4604      	mov	r4, r0
   45864:	b398      	cbz	r0, 458ce <secure_socket_attach_initiate+0x92>
   45866:	f8d9 2004 	ldr.w	r2, [r9, #4]
   4586a:	b122      	cbz	r2, 45876 <secure_socket_attach_initiate+0x3a>
   4586c:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   45870:	6800      	ldr	r0, [r0, #0]
   45872:	f002 fd2a 	bl	482ca <memcpy>
   45876:	2324      	movs	r3, #36	; 0x24
   45878:	4a17      	ldr	r2, [pc, #92]	; (458d8 <secure_socket_attach_initiate+0x9c>)
   4587a:	fb03 2307 	mla	r3, r3, r7, r2
   4587e:	f104 0214 	add.w	r2, r4, #20
   45882:	f103 0124 	add.w	r1, r3, #36	; 0x24
   45886:	f853 0b04 	ldr.w	r0, [r3], #4
   4588a:	428b      	cmp	r3, r1
   4588c:	f842 0b04 	str.w	r0, [r2], #4
   45890:	d1f9      	bne.n	45886 <secure_socket_attach_initiate+0x4a>
   45892:	68a3      	ldr	r3, [r4, #8]
   45894:	4622      	mov	r2, r4
   45896:	3324      	adds	r3, #36	; 0x24
   45898:	60a3      	str	r3, [r4, #8]
   4589a:	682b      	ldr	r3, [r5, #0]
   4589c:	f247 0181 	movw	r1, #28801	; 0x7081
   458a0:	0c1b      	lsrs	r3, r3, #16
   458a2:	041b      	lsls	r3, r3, #16
   458a4:	f043 030a 	orr.w	r3, r3, #10
   458a8:	602b      	str	r3, [r5, #0]
   458aa:	2004      	movs	r0, #4
   458ac:	f002 ff37 	bl	4871e <rpc_client_request_send>
   458b0:	682b      	ldr	r3, [r5, #0]
   458b2:	00db      	lsls	r3, r3, #3
   458b4:	d40d      	bmi.n	458d2 <secure_socket_attach_initiate+0x96>
   458b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   458ba:	210b      	movs	r1, #11
   458bc:	4638      	mov	r0, r7
   458be:	ab01      	add	r3, sp, #4
   458c0:	f002 ff49 	bl	48756 <ip_interface_wait>
   458c4:	b100      	cbz	r0, 458c8 <secure_socket_attach_initiate+0x8c>
   458c6:	602e      	str	r6, [r5, #0]
   458c8:	b003      	add	sp, #12
   458ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   458ce:	200c      	movs	r0, #12
   458d0:	e7fa      	b.n	458c8 <secure_socket_attach_initiate+0x8c>
   458d2:	2077      	movs	r0, #119	; 0x77
   458d4:	e7f8      	b.n	458c8 <secure_socket_attach_initiate+0x8c>
   458d6:	bf00      	nop
   458d8:	2001ea16 	.word	0x2001ea16
   458dc:	2001ad18 	.word	0x2001ad18

000458e0 <tls_interface_init>:
   458e0:	2201      	movs	r2, #1
   458e2:	4b02      	ldr	r3, [pc, #8]	; (458ec <tls_interface_init+0xc>)
   458e4:	2000      	movs	r0, #0
   458e6:	701a      	strb	r2, [r3, #0]
   458e8:	4770      	bx	lr
   458ea:	bf00      	nop
   458ec:	2001ea15 	.word	0x2001ea15

000458f0 <tls_rpc_ip_event_handler>:
   458f0:	b570      	push	{r4, r5, r6, lr}
   458f2:	460c      	mov	r4, r1
   458f4:	f248 0181 	movw	r1, #32897	; 0x8081
   458f8:	428b      	cmp	r3, r1
   458fa:	4606      	mov	r6, r0
   458fc:	d035      	beq.n	4596a <tls_rpc_ip_event_handler+0x7a>
   458fe:	f249 0182 	movw	r1, #36994	; 0x9082
   45902:	428b      	cmp	r3, r1
   45904:	d040      	beq.n	45988 <tls_rpc_ip_event_handler+0x98>
   45906:	f248 0102 	movw	r1, #32770	; 0x8002
   4590a:	428b      	cmp	r3, r1
   4590c:	d161      	bne.n	459d2 <tls_rpc_ip_event_handler+0xe2>
   4590e:	2c00      	cmp	r4, #0
   45910:	d05f      	beq.n	459d2 <tls_rpc_ip_event_handler+0xe2>
   45912:	6963      	ldr	r3, [r4, #20]
   45914:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   45918:	d002      	beq.n	45920 <tls_rpc_ip_event_handler+0x30>
   4591a:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   4591e:	d158      	bne.n	459d2 <tls_rpc_ip_event_handler+0xe2>
   45920:	6823      	ldr	r3, [r4, #0]
   45922:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45926:	6023      	str	r3, [r4, #0]
   45928:	6955      	ldr	r5, [r2, #20]
   4592a:	2d00      	cmp	r5, #0
   4592c:	d14d      	bne.n	459ca <tls_rpc_ip_event_handler+0xda>
   4592e:	6823      	ldr	r3, [r4, #0]
   45930:	0c1b      	lsrs	r3, r3, #16
   45932:	041b      	lsls	r3, r3, #16
   45934:	f043 0305 	orr.w	r3, r3, #5
   45938:	6023      	str	r3, [r4, #0]
   4593a:	6823      	ldr	r3, [r4, #0]
   4593c:	00db      	lsls	r3, r3, #3
   4593e:	d401      	bmi.n	45944 <tls_rpc_ip_event_handler+0x54>
   45940:	2000      	movs	r0, #0
   45942:	e020      	b.n	45986 <tls_rpc_ip_event_handler+0x96>
   45944:	2324      	movs	r3, #36	; 0x24
   45946:	4373      	muls	r3, r6
   45948:	4a23      	ldr	r2, [pc, #140]	; (459d8 <tls_rpc_ip_event_handler+0xe8>)
   4594a:	5cd3      	ldrb	r3, [r2, r3]
   4594c:	2b02      	cmp	r3, #2
   4594e:	d1f7      	bne.n	45940 <tls_rpc_ip_event_handler+0x50>
   45950:	4621      	mov	r1, r4
   45952:	4630      	mov	r0, r6
   45954:	f002 ff0f 	bl	48776 <secure_client_socket>
   45958:	2800      	cmp	r0, #0
   4595a:	d0f1      	beq.n	45940 <tls_rpc_ip_event_handler+0x50>
   4595c:	2877      	cmp	r0, #119	; 0x77
   4595e:	d0ef      	beq.n	45940 <tls_rpc_ip_event_handler+0x50>
   45960:	6060      	str	r0, [r4, #4]
   45962:	6823      	ldr	r3, [r4, #0]
   45964:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45968:	e02d      	b.n	459c6 <tls_rpc_ip_event_handler+0xd6>
   4596a:	2c00      	cmp	r4, #0
   4596c:	d0e8      	beq.n	45940 <tls_rpc_ip_event_handler+0x50>
   4596e:	6823      	ldr	r3, [r4, #0]
   45970:	b29b      	uxth	r3, r3
   45972:	2b0a      	cmp	r3, #10
   45974:	d1e4      	bne.n	45940 <tls_rpc_ip_event_handler+0x50>
   45976:	6950      	ldr	r0, [r2, #20]
   45978:	bb40      	cbnz	r0, 459cc <tls_rpc_ip_event_handler+0xdc>
   4597a:	6823      	ldr	r3, [r4, #0]
   4597c:	0c1b      	lsrs	r3, r3, #16
   4597e:	041b      	lsls	r3, r3, #16
   45980:	f043 030b 	orr.w	r3, r3, #11
   45984:	6023      	str	r3, [r4, #0]
   45986:	bd70      	pop	{r4, r5, r6, pc}
   45988:	2c00      	cmp	r4, #0
   4598a:	d0d9      	beq.n	45940 <tls_rpc_ip_event_handler+0x50>
   4598c:	6823      	ldr	r3, [r4, #0]
   4598e:	b29b      	uxth	r3, r3
   45990:	2b0b      	cmp	r3, #11
   45992:	d1d5      	bne.n	45940 <tls_rpc_ip_event_handler+0x50>
   45994:	6915      	ldr	r5, [r2, #16]
   45996:	b9c5      	cbnz	r5, 459ca <tls_rpc_ip_event_handler+0xda>
   45998:	6823      	ldr	r3, [r4, #0]
   4599a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   4599e:	6023      	str	r3, [r4, #0]
   459a0:	f7ff ff3a 	bl	45818 <hostname_free>
   459a4:	6823      	ldr	r3, [r4, #0]
   459a6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   459aa:	6023      	str	r3, [r4, #0]
   459ac:	6823      	ldr	r3, [r4, #0]
   459ae:	0c1b      	lsrs	r3, r3, #16
   459b0:	041b      	lsls	r3, r3, #16
   459b2:	f043 030c 	orr.w	r3, r3, #12
   459b6:	6023      	str	r3, [r4, #0]
   459b8:	6823      	ldr	r3, [r4, #0]
   459ba:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   459be:	6023      	str	r3, [r4, #0]
   459c0:	6823      	ldr	r3, [r4, #0]
   459c2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   459c6:	6023      	str	r3, [r4, #0]
   459c8:	e7ba      	b.n	45940 <tls_rpc_ip_event_handler+0x50>
   459ca:	4628      	mov	r0, r5
   459cc:	f7ff fc7a 	bl	452c4 <rpc_error_to_nrf_errno>
   459d0:	e7c6      	b.n	45960 <tls_rpc_ip_event_handler+0x70>
   459d2:	2001      	movs	r0, #1
   459d4:	e7d7      	b.n	45986 <tls_rpc_ip_event_handler+0x96>
   459d6:	bf00      	nop
   459d8:	2001ea16 	.word	0x2001ea16

000459dc <at_cmd_send>:
   459dc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   459de:	4615      	mov	r5, r2
   459e0:	f06f 0258 	mvn.w	r2, #88	; 0x58
   459e4:	2300      	movs	r3, #0
   459e6:	7302      	strb	r2, [r0, #12]
   459e8:	2204      	movs	r2, #4
   459ea:	4c0d      	ldr	r4, [pc, #52]	; (45a20 <at_cmd_send+0x44>)
   459ec:	7343      	strb	r3, [r0, #13]
   459ee:	7383      	strb	r3, [r0, #14]
   459f0:	73c3      	strb	r3, [r0, #15]
   459f2:	7202      	strb	r2, [r0, #8]
   459f4:	7243      	strb	r3, [r0, #9]
   459f6:	7283      	strb	r3, [r0, #10]
   459f8:	72c3      	strb	r3, [r0, #11]
   459fa:	4602      	mov	r2, r0
   459fc:	b289      	uxth	r1, r1
   459fe:	2003      	movs	r0, #3
   45a00:	7023      	strb	r3, [r4, #0]
   45a02:	f002 fe8c 	bl	4871e <rpc_client_request_send>
   45a06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   45a0a:	9301      	str	r3, [sp, #4]
   45a0c:	7823      	ldrb	r3, [r4, #0]
   45a0e:	42ab      	cmp	r3, r5
   45a10:	d101      	bne.n	45a16 <at_cmd_send+0x3a>
   45a12:	b003      	add	sp, #12
   45a14:	bd30      	pop	{r4, r5, pc}
   45a16:	a901      	add	r1, sp, #4
   45a18:	2000      	movs	r0, #0
   45a1a:	f7fe f8fb 	bl	43c14 <nrf_modem_os_timedwait>
   45a1e:	e7f5      	b.n	45a0c <at_cmd_send+0x30>
   45a20:	2001eb36 	.word	0x2001eb36

00045a24 <nrf_modem_at_init>:
   45a24:	2201      	movs	r2, #1
   45a26:	b508      	push	{r3, lr}
   45a28:	4611      	mov	r1, r2
   45a2a:	4808      	ldr	r0, [pc, #32]	; (45a4c <nrf_modem_at_init+0x28>)
   45a2c:	f7fe f990 	bl	43d50 <nrf_modem_os_sem_init>
   45a30:	2000      	movs	r0, #0
   45a32:	f002 fe6e 	bl	48712 <rpc_client_request_alloc>
   45a36:	b128      	cbz	r0, 45a44 <nrf_modem_at_init+0x20>
   45a38:	2201      	movs	r2, #1
   45a3a:	2105      	movs	r1, #5
   45a3c:	f7ff ffce 	bl	459dc <at_cmd_send>
   45a40:	2000      	movs	r0, #0
   45a42:	bd08      	pop	{r3, pc}
   45a44:	f06f 000b 	mvn.w	r0, #11
   45a48:	e7fb      	b.n	45a42 <nrf_modem_at_init+0x1e>
   45a4a:	bf00      	nop
   45a4c:	2001ad58 	.word	0x2001ad58

00045a50 <rpc_at_event_handler>:
   45a50:	b570      	push	{r4, r5, r6, lr}
   45a52:	68c3      	ldr	r3, [r0, #12]
   45a54:	4605      	mov	r5, r0
   45a56:	2ba7      	cmp	r3, #167	; 0xa7
   45a58:	d003      	beq.n	45a62 <rpc_at_event_handler+0x12>
   45a5a:	6828      	ldr	r0, [r5, #0]
   45a5c:	f002 fe66 	bl	4872c <rpc_client_data_free>
   45a60:	e008      	b.n	45a74 <rpc_at_event_handler+0x24>
   45a62:	2903      	cmp	r1, #3
   45a64:	d008      	beq.n	45a78 <rpc_at_event_handler+0x28>
   45a66:	2904      	cmp	r1, #4
   45a68:	d019      	beq.n	45a9e <rpc_at_event_handler+0x4e>
   45a6a:	2902      	cmp	r1, #2
   45a6c:	d102      	bne.n	45a74 <rpc_at_event_handler+0x24>
   45a6e:	2201      	movs	r2, #1
   45a70:	4b0e      	ldr	r3, [pc, #56]	; (45aac <rpc_at_event_handler+0x5c>)
   45a72:	701a      	strb	r2, [r3, #0]
   45a74:	2000      	movs	r0, #0
   45a76:	e00a      	b.n	45a8e <rpc_at_event_handler+0x3e>
   45a78:	4e0d      	ldr	r6, [pc, #52]	; (45ab0 <rpc_at_event_handler+0x60>)
   45a7a:	6833      	ldr	r3, [r6, #0]
   45a7c:	b143      	cbz	r3, 45a90 <rpc_at_event_handler+0x40>
   45a7e:	2400      	movs	r4, #0
   45a80:	6800      	ldr	r0, [r0, #0]
   45a82:	4798      	blx	r3
   45a84:	6828      	ldr	r0, [r5, #0]
   45a86:	6034      	str	r4, [r6, #0]
   45a88:	f002 fe50 	bl	4872c <rpc_client_data_free>
   45a8c:	b2e0      	uxtb	r0, r4
   45a8e:	bd70      	pop	{r4, r5, r6, pc}
   45a90:	2202      	movs	r2, #2
   45a92:	4b08      	ldr	r3, [pc, #32]	; (45ab4 <rpc_at_event_handler+0x64>)
   45a94:	2401      	movs	r4, #1
   45a96:	6018      	str	r0, [r3, #0]
   45a98:	4b04      	ldr	r3, [pc, #16]	; (45aac <rpc_at_event_handler+0x5c>)
   45a9a:	701a      	strb	r2, [r3, #0]
   45a9c:	e7f6      	b.n	45a8c <rpc_at_event_handler+0x3c>
   45a9e:	4b06      	ldr	r3, [pc, #24]	; (45ab8 <rpc_at_event_handler+0x68>)
   45aa0:	681b      	ldr	r3, [r3, #0]
   45aa2:	2b00      	cmp	r3, #0
   45aa4:	d0d9      	beq.n	45a5a <rpc_at_event_handler+0xa>
   45aa6:	6800      	ldr	r0, [r0, #0]
   45aa8:	4798      	blx	r3
   45aaa:	e7d6      	b.n	45a5a <rpc_at_event_handler+0xa>
   45aac:	2001eb36 	.word	0x2001eb36
   45ab0:	2001ad64 	.word	0x2001ad64
   45ab4:	2001ad60 	.word	0x2001ad60
   45ab8:	2001ad5c 	.word	0x2001ad5c

00045abc <rpc_dfu_event_handler>:
   45abc:	b510      	push	{r4, lr}
   45abe:	4604      	mov	r4, r0
   45ac0:	6800      	ldr	r0, [r0, #0]
   45ac2:	b108      	cbz	r0, 45ac8 <rpc_dfu_event_handler+0xc>
   45ac4:	f002 fe32 	bl	4872c <rpc_client_data_free>
   45ac8:	4b05      	ldr	r3, [pc, #20]	; (45ae0 <rpc_dfu_event_handler+0x24>)
   45aca:	68e2      	ldr	r2, [r4, #12]
   45acc:	429a      	cmp	r2, r3
   45ace:	bf05      	ittet	eq
   45ad0:	2001      	moveq	r0, #1
   45ad2:	4b04      	ldreq	r3, [pc, #16]	; (45ae4 <rpc_dfu_event_handler+0x28>)
   45ad4:	2000      	movne	r0, #0
   45ad6:	7018      	strbeq	r0, [r3, #0]
   45ad8:	bf04      	itt	eq
   45ada:	4b03      	ldreq	r3, [pc, #12]	; (45ae8 <rpc_dfu_event_handler+0x2c>)
   45adc:	601c      	streq	r4, [r3, #0]
   45ade:	bd10      	pop	{r4, pc}
   45ae0:	15abe11a 	.word	0x15abe11a
   45ae4:	2001eb37 	.word	0x2001eb37
   45ae8:	2001ad68 	.word	0x2001ad68

00045aec <rpc_gnss_event_handler>:
   45aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45af0:	6804      	ldr	r4, [r0, #0]
   45af2:	4607      	mov	r7, r0
   45af4:	460d      	mov	r5, r1
   45af6:	2c00      	cmp	r4, #0
   45af8:	f000 8086 	beq.w	45c08 <rpc_gnss_event_handler+0x11c>
   45afc:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   45b00:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   45b04:	d142      	bne.n	45b8c <rpc_gnss_event_handler+0xa0>
   45b06:	4b5f      	ldr	r3, [pc, #380]	; (45c84 <rpc_gnss_event_handler+0x198>)
   45b08:	781a      	ldrb	r2, [r3, #0]
   45b0a:	4698      	mov	r8, r3
   45b0c:	2a01      	cmp	r2, #1
   45b0e:	d131      	bne.n	45b74 <rpc_gnss_event_handler+0x88>
   45b10:	4a5d      	ldr	r2, [pc, #372]	; (45c88 <rpc_gnss_event_handler+0x19c>)
   45b12:	6821      	ldr	r1, [r4, #0]
   45b14:	8812      	ldrh	r2, [r2, #0]
   45b16:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   45b1a:	d12b      	bne.n	45b74 <rpc_gnss_event_handler+0x88>
   45b1c:	6862      	ldr	r2, [r4, #4]
   45b1e:	bb6a      	cbnz	r2, 45b7c <rpc_gnss_event_handler+0x90>
   45b20:	4b5a      	ldr	r3, [pc, #360]	; (45c8c <rpc_gnss_event_handler+0x1a0>)
   45b22:	681e      	ldr	r6, [r3, #0]
   45b24:	b31e      	cbz	r6, 45b6e <rpc_gnss_event_handler+0x82>
   45b26:	f242 0309 	movw	r3, #8201	; 0x2009
   45b2a:	429d      	cmp	r5, r3
   45b2c:	d11f      	bne.n	45b6e <rpc_gnss_event_handler+0x82>
   45b2e:	4630      	mov	r0, r6
   45b30:	8923      	ldrh	r3, [r4, #8]
   45b32:	2280      	movs	r2, #128	; 0x80
   45b34:	f840 3b04 	str.w	r3, [r0], #4
   45b38:	f104 010a 	add.w	r1, r4, #10
   45b3c:	f002 fbc5 	bl	482ca <memcpy>
   45b40:	2280      	movs	r2, #128	; 0x80
   45b42:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   45b46:	f106 0084 	add.w	r0, r6, #132	; 0x84
   45b4a:	f002 fbbe 	bl	482ca <memcpy>
   45b4e:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   45b52:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   45b56:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   45b5a:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   45b5e:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   45b62:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   45b66:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   45b6a:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   45b6e:	2300      	movs	r3, #0
   45b70:	f888 3000 	strb.w	r3, [r8]
   45b74:	6838      	ldr	r0, [r7, #0]
   45b76:	f002 fdd9 	bl	4872c <rpc_client_data_free>
   45b7a:	e045      	b.n	45c08 <rpc_gnss_event_handler+0x11c>
   45b7c:	f647 71ff 	movw	r1, #32767	; 0x7fff
   45b80:	428a      	cmp	r2, r1
   45b82:	bf0c      	ite	eq
   45b84:	2203      	moveq	r2, #3
   45b86:	2202      	movne	r2, #2
   45b88:	701a      	strb	r2, [r3, #0]
   45b8a:	e7f3      	b.n	45b74 <rpc_gnss_event_handler+0x88>
   45b8c:	4e40      	ldr	r6, [pc, #256]	; (45c90 <rpc_gnss_event_handler+0x1a4>)
   45b8e:	6833      	ldr	r3, [r6, #0]
   45b90:	2b00      	cmp	r3, #0
   45b92:	d0ef      	beq.n	45b74 <rpc_gnss_event_handler+0x88>
   45b94:	f244 0204 	movw	r2, #16388	; 0x4004
   45b98:	4291      	cmp	r1, r2
   45b9a:	d80b      	bhi.n	45bb4 <rpc_gnss_event_handler+0xc8>
   45b9c:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   45ba0:	d9e8      	bls.n	45b74 <rpc_gnss_event_handler+0x88>
   45ba2:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   45ba6:	3a02      	subs	r2, #2
   45ba8:	2a02      	cmp	r2, #2
   45baa:	d80b      	bhi.n	45bc4 <rpc_gnss_event_handler+0xd8>
   45bac:	e8df f002 	tbb	[pc, r2]
   45bb0:	4f45      	.short	0x4f45
   45bb2:	59          	.byte	0x59
   45bb3:	00          	.byte	0x00
   45bb4:	f244 1301 	movw	r3, #16641	; 0x4101
   45bb8:	4299      	cmp	r1, r3
   45bba:	d003      	beq.n	45bc4 <rpc_gnss_event_handler+0xd8>
   45bbc:	f244 2301 	movw	r3, #16897	; 0x4201
   45bc0:	4299      	cmp	r1, r3
   45bc2:	d1d7      	bne.n	45b74 <rpc_gnss_event_handler+0x88>
   45bc4:	4f33      	ldr	r7, [pc, #204]	; (45c94 <rpc_gnss_event_handler+0x1a8>)
   45bc6:	6838      	ldr	r0, [r7, #0]
   45bc8:	b108      	cbz	r0, 45bce <rpc_gnss_event_handler+0xe2>
   45bca:	f002 fdaf 	bl	4872c <rpc_client_data_free>
   45bce:	f244 2301 	movw	r3, #16897	; 0x4201
   45bd2:	429d      	cmp	r5, r3
   45bd4:	4b30      	ldr	r3, [pc, #192]	; (45c98 <rpc_gnss_event_handler+0x1ac>)
   45bd6:	d11a      	bne.n	45c0e <rpc_gnss_event_handler+0x122>
   45bd8:	2202      	movs	r2, #2
   45bda:	603c      	str	r4, [r7, #0]
   45bdc:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   45be0:	701a      	strb	r2, [r3, #0]
   45be2:	07e3      	lsls	r3, r4, #31
   45be4:	d502      	bpl.n	45bec <rpc_gnss_event_handler+0x100>
   45be6:	2002      	movs	r0, #2
   45be8:	6833      	ldr	r3, [r6, #0]
   45bea:	4798      	blx	r3
   45bec:	4d2b      	ldr	r5, [pc, #172]	; (45c9c <rpc_gnss_event_handler+0x1b0>)
   45bee:	f014 0418 	ands.w	r4, r4, #24
   45bf2:	6833      	ldr	r3, [r6, #0]
   45bf4:	782a      	ldrb	r2, [r5, #0]
   45bf6:	d01a      	beq.n	45c2e <rpc_gnss_event_handler+0x142>
   45bf8:	b91a      	cbnz	r2, 45c02 <rpc_gnss_event_handler+0x116>
   45bfa:	2005      	movs	r0, #5
   45bfc:	4798      	blx	r3
   45bfe:	2301      	movs	r3, #1
   45c00:	702b      	strb	r3, [r5, #0]
   45c02:	2001      	movs	r0, #1
   45c04:	6833      	ldr	r3, [r6, #0]
   45c06:	4798      	blx	r3
   45c08:	2000      	movs	r0, #0
   45c0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45c0e:	f244 1201 	movw	r2, #16641	; 0x4101
   45c12:	4295      	cmp	r5, r2
   45c14:	bf0b      	itete	eq
   45c16:	2201      	moveq	r2, #1
   45c18:	2200      	movne	r2, #0
   45c1a:	603c      	streq	r4, [r7, #0]
   45c1c:	603c      	strne	r4, [r7, #0]
   45c1e:	bf0b      	itete	eq
   45c20:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   45c24:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   45c28:	701a      	strbeq	r2, [r3, #0]
   45c2a:	701a      	strbne	r2, [r3, #0]
   45c2c:	e7d9      	b.n	45be2 <rpc_gnss_event_handler+0xf6>
   45c2e:	2a00      	cmp	r2, #0
   45c30:	d0e7      	beq.n	45c02 <rpc_gnss_event_handler+0x116>
   45c32:	2006      	movs	r0, #6
   45c34:	4798      	blx	r3
   45c36:	702c      	strb	r4, [r5, #0]
   45c38:	e7e3      	b.n	45c02 <rpc_gnss_event_handler+0x116>
   45c3a:	4c19      	ldr	r4, [pc, #100]	; (45ca0 <rpc_gnss_event_handler+0x1b4>)
   45c3c:	6820      	ldr	r0, [r4, #0]
   45c3e:	b108      	cbz	r0, 45c44 <rpc_gnss_event_handler+0x158>
   45c40:	f002 fd74 	bl	4872c <rpc_client_data_free>
   45c44:	683b      	ldr	r3, [r7, #0]
   45c46:	2003      	movs	r0, #3
   45c48:	6023      	str	r3, [r4, #0]
   45c4a:	6833      	ldr	r3, [r6, #0]
   45c4c:	e7db      	b.n	45c06 <rpc_gnss_event_handler+0x11a>
   45c4e:	4c15      	ldr	r4, [pc, #84]	; (45ca4 <rpc_gnss_event_handler+0x1b8>)
   45c50:	6820      	ldr	r0, [r4, #0]
   45c52:	b108      	cbz	r0, 45c58 <rpc_gnss_event_handler+0x16c>
   45c54:	f002 fd6a 	bl	4872c <rpc_client_data_free>
   45c58:	683b      	ldr	r3, [r7, #0]
   45c5a:	2004      	movs	r0, #4
   45c5c:	6023      	str	r3, [r4, #0]
   45c5e:	6833      	ldr	r3, [r6, #0]
   45c60:	e7d1      	b.n	45c06 <rpc_gnss_event_handler+0x11a>
   45c62:	7822      	ldrb	r2, [r4, #0]
   45c64:	2a03      	cmp	r2, #3
   45c66:	d885      	bhi.n	45b74 <rpc_gnss_event_handler+0x88>
   45c68:	e8df f002 	tbb	[pc, r2]
   45c6c:	09070502 	.word	0x09070502
   45c70:	2007      	movs	r0, #7
   45c72:	4798      	blx	r3
   45c74:	e77e      	b.n	45b74 <rpc_gnss_event_handler+0x88>
   45c76:	2008      	movs	r0, #8
   45c78:	e7fb      	b.n	45c72 <rpc_gnss_event_handler+0x186>
   45c7a:	2009      	movs	r0, #9
   45c7c:	e7f9      	b.n	45c72 <rpc_gnss_event_handler+0x186>
   45c7e:	200a      	movs	r0, #10
   45c80:	e7f7      	b.n	45c72 <rpc_gnss_event_handler+0x186>
   45c82:	bf00      	nop
   45c84:	2001eb3a 	.word	0x2001eb3a
   45c88:	2001ade4 	.word	0x2001ade4
   45c8c:	2001ad7c 	.word	0x2001ad7c
   45c90:	2001ad6c 	.word	0x2001ad6c
   45c94:	2001ad70 	.word	0x2001ad70
   45c98:	2001eb39 	.word	0x2001eb39
   45c9c:	2001eb38 	.word	0x2001eb38
   45ca0:	2001ad78 	.word	0x2001ad78
   45ca4:	2001ad74 	.word	0x2001ad74

00045ca8 <full_dfu_ipc_irq_handler>:
   45ca8:	2301      	movs	r3, #1
   45caa:	4a03      	ldr	r2, [pc, #12]	; (45cb8 <full_dfu_ipc_irq_handler+0x10>)
   45cac:	6013      	str	r3, [r2, #0]
   45cae:	07c2      	lsls	r2, r0, #31
   45cb0:	bf44      	itt	mi
   45cb2:	4a02      	ldrmi	r2, [pc, #8]	; (45cbc <full_dfu_ipc_irq_handler+0x14>)
   45cb4:	7013      	strbmi	r3, [r2, #0]
   45cb6:	4770      	bx	lr
   45cb8:	2001ad80 	.word	0x2001ad80
   45cbc:	2001eb3b 	.word	0x2001eb3b

00045cc0 <modem_ipc_wait_for_event>:
   45cc0:	b538      	push	{r3, r4, r5, lr}
   45cc2:	2300      	movs	r3, #0
   45cc4:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   45cc8:	4c0b      	ldr	r4, [pc, #44]	; (45cf8 <modem_ipc_wait_for_event+0x38>)
   45cca:	6023      	str	r3, [r4, #0]
   45ccc:	6823      	ldr	r3, [r4, #0]
   45cce:	b92b      	cbnz	r3, 45cdc <modem_ipc_wait_for_event+0x1c>
   45cd0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   45cd4:	f002 fc80 	bl	485d8 <nrf_modem_os_busywait>
   45cd8:	3d01      	subs	r5, #1
   45cda:	d1f7      	bne.n	45ccc <modem_ipc_wait_for_event+0xc>
   45cdc:	6823      	ldr	r3, [r4, #0]
   45cde:	b913      	cbnz	r3, 45ce6 <modem_ipc_wait_for_event+0x26>
   45ce0:	f06f 0073 	mvn.w	r0, #115	; 0x73
   45ce4:	e006      	b.n	45cf4 <modem_ipc_wait_for_event+0x34>
   45ce6:	4b05      	ldr	r3, [pc, #20]	; (45cfc <modem_ipc_wait_for_event+0x3c>)
   45ce8:	781b      	ldrb	r3, [r3, #0]
   45cea:	2b01      	cmp	r3, #1
   45cec:	bf14      	ite	ne
   45cee:	2000      	movne	r0, #0
   45cf0:	f06f 0004 	mvneq.w	r0, #4
   45cf4:	bd38      	pop	{r3, r4, r5, pc}
   45cf6:	bf00      	nop
   45cf8:	2001ad80 	.word	0x2001ad80
   45cfc:	2001eb3b 	.word	0x2001eb3b

00045d00 <nrf_modem_full_dfu_setup>:
   45d00:	2200      	movs	r2, #0
   45d02:	2300      	movs	r3, #0
   45d04:	b5f0      	push	{r4, r5, r6, r7, lr}
   45d06:	4d2b      	ldr	r5, [pc, #172]	; (45db4 <nrf_modem_full_dfu_setup+0xb4>)
   45d08:	4e2b      	ldr	r6, [pc, #172]	; (45db8 <nrf_modem_full_dfu_setup+0xb8>)
   45d0a:	e9c5 2302 	strd	r2, r3, [r5, #8]
   45d0e:	e9c5 2304 	strd	r2, r3, [r5, #16]
   45d12:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   45d16:	4b29      	ldr	r3, [pc, #164]	; (45dbc <nrf_modem_full_dfu_setup+0xbc>)
   45d18:	2400      	movs	r4, #0
   45d1a:	601a      	str	r2, [r3, #0]
   45d1c:	f100 031c 	add.w	r3, r0, #28
   45d20:	6033      	str	r3, [r6, #0]
   45d22:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   45d26:	6043      	str	r3, [r0, #4]
   45d28:	231c      	movs	r3, #28
   45d2a:	7203      	strb	r3, [r0, #8]
   45d2c:	2320      	movs	r3, #32
   45d2e:	2701      	movs	r7, #1
   45d30:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   45d34:	7243      	strb	r3, [r0, #9]
   45d36:	4b22      	ldr	r3, [pc, #136]	; (45dc0 <nrf_modem_full_dfu_setup+0xc0>)
   45d38:	7004      	strb	r4, [r0, #0]
   45d3a:	7044      	strb	r4, [r0, #1]
   45d3c:	70c2      	strb	r2, [r0, #3]
   45d3e:	7284      	strb	r4, [r0, #10]
   45d40:	72c4      	strb	r4, [r0, #11]
   45d42:	7087      	strb	r7, [r0, #2]
   45d44:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   45d48:	702c      	strb	r4, [r5, #0]
   45d4a:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   45d4e:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   45d52:	4b1c      	ldr	r3, [pc, #112]	; (45dc4 <nrf_modem_full_dfu_setup+0xc4>)
   45d54:	b093      	sub	sp, #76	; 0x4c
   45d56:	4622      	mov	r2, r4
   45d58:	4620      	mov	r0, r4
   45d5a:	491b      	ldr	r1, [pc, #108]	; (45dc8 <nrf_modem_full_dfu_setup+0xc8>)
   45d5c:	701c      	strb	r4, [r3, #0]
   45d5e:	f7fe fce5 	bl	4472c <nrfx_ipc_init>
   45d62:	4621      	mov	r1, r4
   45d64:	2240      	movs	r2, #64	; 0x40
   45d66:	a801      	add	r0, sp, #4
   45d68:	f002 faba 	bl	482e0 <memset>
   45d6c:	2302      	movs	r3, #2
   45d6e:	9302      	str	r3, [sp, #8]
   45d70:	2304      	movs	r3, #4
   45d72:	930b      	str	r3, [sp, #44]	; 0x2c
   45d74:	2305      	movs	r3, #5
   45d76:	a801      	add	r0, sp, #4
   45d78:	9311      	str	r3, [sp, #68]	; 0x44
   45d7a:	9709      	str	r7, [sp, #36]	; 0x24
   45d7c:	f7fe fcee 	bl	4475c <nrfx_ipc_config_load>
   45d80:	4b12      	ldr	r3, [pc, #72]	; (45dcc <nrf_modem_full_dfu_setup+0xcc>)
   45d82:	9400      	str	r4, [sp, #0]
   45d84:	6836      	ldr	r6, [r6, #0]
   45d86:	601c      	str	r4, [r3, #0]
   45d88:	681b      	ldr	r3, [r3, #0]
   45d8a:	9300      	str	r3, [sp, #0]
   45d8c:	9b00      	ldr	r3, [sp, #0]
   45d8e:	f7ff ff97 	bl	45cc0 <modem_ipc_wait_for_event>
   45d92:	4604      	mov	r4, r0
   45d94:	b130      	cbz	r0, 45da4 <nrf_modem_full_dfu_setup+0xa4>
   45d96:	2303      	movs	r3, #3
   45d98:	702b      	strb	r3, [r5, #0]
   45d9a:	f7fe fcff 	bl	4479c <nrfx_ipc_uninit>
   45d9e:	4620      	mov	r0, r4
   45da0:	b013      	add	sp, #76	; 0x4c
   45da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   45da4:	6832      	ldr	r2, [r6, #0]
   45da6:	4b0a      	ldr	r3, [pc, #40]	; (45dd0 <nrf_modem_full_dfu_setup+0xd0>)
   45da8:	429a      	cmp	r2, r3
   45daa:	d0f8      	beq.n	45d9e <nrf_modem_full_dfu_setup+0x9e>
   45dac:	f06f 0404 	mvn.w	r4, #4
   45db0:	e7f3      	b.n	45d9a <nrf_modem_full_dfu_setup+0x9a>
   45db2:	bf00      	nop
   45db4:	2001a768 	.word	0x2001a768
   45db8:	2001ad84 	.word	0x2001ad84
   45dbc:	2001ad88 	.word	0x2001ad88
   45dc0:	4002a000 	.word	0x4002a000
   45dc4:	2001eb3b 	.word	0x2001eb3b
   45dc8:	00045ca9 	.word	0x00045ca9
   45dcc:	40005610 	.word	0x40005610
   45dd0:	a5000001 	.word	0xa5000001

00045dd4 <modem_off>:
   45dd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45dd6:	2501      	movs	r5, #1
   45dd8:	4c07      	ldr	r4, [pc, #28]	; (45df8 <modem_off+0x24>)
   45dda:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   45dde:	6065      	str	r5, [r4, #4]
   45de0:	f002 fbfa 	bl	485d8 <nrf_modem_os_busywait>
   45de4:	2300      	movs	r3, #0
   45de6:	6063      	str	r3, [r4, #4]
   45de8:	9301      	str	r3, [sp, #4]
   45dea:	6025      	str	r5, [r4, #0]
   45dec:	6823      	ldr	r3, [r4, #0]
   45dee:	9301      	str	r3, [sp, #4]
   45df0:	9b01      	ldr	r3, [sp, #4]
   45df2:	b003      	add	sp, #12
   45df4:	bd30      	pop	{r4, r5, pc}
   45df6:	bf00      	nop
   45df8:	40005610 	.word	0x40005610

00045dfc <nrf_modem_init>:
   45dfc:	b570      	push	{r4, r5, r6, lr}
   45dfe:	460d      	mov	r5, r1
   45e00:	b300      	cbz	r0, 45e44 <nrf_modem_init+0x48>
   45e02:	4e15      	ldr	r6, [pc, #84]	; (45e58 <nrf_modem_init+0x5c>)
   45e04:	7832      	ldrb	r2, [r6, #0]
   45e06:	bb02      	cbnz	r2, 45e4a <nrf_modem_init+0x4e>
   45e08:	2901      	cmp	r1, #1
   45e0a:	d113      	bne.n	45e34 <nrf_modem_init+0x38>
   45e0c:	68c1      	ldr	r1, [r0, #12]
   45e0e:	6842      	ldr	r2, [r0, #4]
   45e10:	440a      	add	r2, r1
   45e12:	6941      	ldr	r1, [r0, #20]
   45e14:	440a      	add	r2, r1
   45e16:	69c1      	ldr	r1, [r0, #28]
   45e18:	440a      	add	r2, r1
   45e1a:	f242 011b 	movw	r1, #8219	; 0x201b
   45e1e:	428a      	cmp	r2, r1
   45e20:	d916      	bls.n	45e50 <nrf_modem_init+0x54>
   45e22:	6800      	ldr	r0, [r0, #0]
   45e24:	f7ff ff6c 	bl	45d00 <nrf_modem_full_dfu_setup>
   45e28:	4604      	mov	r4, r0
   45e2a:	b130      	cbz	r0, 45e3a <nrf_modem_init+0x3e>
   45e2c:	f7ff ffd2 	bl	45dd4 <modem_off>
   45e30:	4620      	mov	r0, r4
   45e32:	bd70      	pop	{r4, r5, r6, pc}
   45e34:	f002 fcde 	bl	487f4 <nrf_modem_platform_init>
   45e38:	e7f6      	b.n	45e28 <nrf_modem_init+0x2c>
   45e3a:	4b08      	ldr	r3, [pc, #32]	; (45e5c <nrf_modem_init+0x60>)
   45e3c:	701d      	strb	r5, [r3, #0]
   45e3e:	2301      	movs	r3, #1
   45e40:	7033      	strb	r3, [r6, #0]
   45e42:	e7f5      	b.n	45e30 <nrf_modem_init+0x34>
   45e44:	f06f 040d 	mvn.w	r4, #13
   45e48:	e7f2      	b.n	45e30 <nrf_modem_init+0x34>
   45e4a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   45e4e:	e7ef      	b.n	45e30 <nrf_modem_init+0x34>
   45e50:	f06f 040b 	mvn.w	r4, #11
   45e54:	e7ec      	b.n	45e30 <nrf_modem_init+0x34>
   45e56:	bf00      	nop
   45e58:	2001eb3c 	.word	0x2001eb3c
   45e5c:	2001eb3d 	.word	0x2001eb3d

00045e60 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
   45e60:	4b02      	ldr	r3, [pc, #8]	; (45e6c <mbedtls_platform_set_calloc_free+0xc>)
   45e62:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
   45e64:	4b02      	ldr	r3, [pc, #8]	; (45e70 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
   45e66:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
   45e68:	6019      	str	r1, [r3, #0]
}
   45e6a:	4770      	bx	lr
   45e6c:	2001a5f0 	.word	0x2001a5f0
   45e70:	2001a5f4 	.word	0x2001a5f4

00045e74 <_heap_init>:
 *
 * Not static in order to allow extern use.
 */
void _heap_init(void)
{
	mbedtls_memory_buffer_alloc_init(mbedtls_heap, sizeof(mbedtls_heap));
   45e74:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   45e78:	4801      	ldr	r0, [pc, #4]	; (45e80 <_heap_init+0xc>)
   45e7a:	f000 b947 	b.w	4610c <mbedtls_memory_buffer_alloc_init>
   45e7e:	bf00      	nop
   45e80:	2001eb3e 	.word	0x2001eb3e

00045e84 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
   45e84:	6801      	ldr	r1, [r0, #0]
   45e86:	4a0e      	ldr	r2, [pc, #56]	; (45ec0 <verify_header+0x3c>)
{
   45e88:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
   45e8a:	4291      	cmp	r1, r2
   45e8c:	d115      	bne.n	45eba <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
   45e8e:	69c1      	ldr	r1, [r0, #28]
   45e90:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
   45e94:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
   45e98:	4291      	cmp	r1, r2
   45e9a:	d10e      	bne.n	45eba <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
   45e9c:	6882      	ldr	r2, [r0, #8]
   45e9e:	2a01      	cmp	r2, #1
   45ea0:	d80b      	bhi.n	45eba <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
   45ea2:	68c2      	ldr	r2, [r0, #12]
   45ea4:	b112      	cbz	r2, 45eac <verify_header+0x28>
   45ea6:	6901      	ldr	r1, [r0, #16]
   45ea8:	428a      	cmp	r2, r1
   45eaa:	d006      	beq.n	45eba <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
   45eac:	6958      	ldr	r0, [r3, #20]
   45eae:	b128      	cbz	r0, 45ebc <verify_header+0x38>
   45eb0:	699b      	ldr	r3, [r3, #24]
   45eb2:	1a1b      	subs	r3, r3, r0
   45eb4:	4258      	negs	r0, r3
   45eb6:	4158      	adcs	r0, r3
   45eb8:	4770      	bx	lr
        return( 1 );
   45eba:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
   45ebc:	4770      	bx	lr
   45ebe:	bf00      	nop
   45ec0:	ff00aa55 	.word	0xff00aa55

00045ec4 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
   45ec4:	4b0d      	ldr	r3, [pc, #52]	; (45efc <verify_chain+0x38>)
{
   45ec6:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
   45ec8:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
   45eca:	b1a6      	cbz	r6, 45ef6 <verify_chain+0x32>
   45ecc:	4630      	mov	r0, r6
   45ece:	f7ff ffd9 	bl	45e84 <verify_header>
   45ed2:	4604      	mov	r4, r0
   45ed4:	b978      	cbnz	r0, 45ef6 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
   45ed6:	68f3      	ldr	r3, [r6, #12]
   45ed8:	b96b      	cbnz	r3, 45ef6 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
   45eda:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
   45edc:	b90d      	cbnz	r5, 45ee2 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
   45ede:	4620      	mov	r0, r4
   45ee0:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
   45ee2:	4628      	mov	r0, r5
   45ee4:	f7ff ffce 	bl	45e84 <verify_header>
   45ee8:	b928      	cbnz	r0, 45ef6 <verify_chain+0x32>
        if( cur->prev != prv )
   45eea:	68eb      	ldr	r3, [r5, #12]
   45eec:	42b3      	cmp	r3, r6
   45eee:	d102      	bne.n	45ef6 <verify_chain+0x32>
        cur = cur->next;
   45ef0:	462e      	mov	r6, r5
   45ef2:	692d      	ldr	r5, [r5, #16]
   45ef4:	e7f2      	b.n	45edc <verify_chain+0x18>
        return( 1 );
   45ef6:	2401      	movs	r4, #1
   45ef8:	e7f1      	b.n	45ede <verify_chain+0x1a>
   45efa:	bf00      	nop
   45efc:	2001ad8c 	.word	0x2001ad8c

00045f00 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
   45f00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
   45f04:	4d3e      	ldr	r5, [pc, #248]	; (46000 <buffer_alloc_calloc+0x100>)
   45f06:	682c      	ldr	r4, [r5, #0]
   45f08:	b1d4      	cbz	r4, 45f40 <buffer_alloc_calloc+0x40>
   45f0a:	68ac      	ldr	r4, [r5, #8]
   45f0c:	b1c4      	cbz	r4, 45f40 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
   45f0e:	2800      	cmp	r0, #0
   45f10:	d04b      	beq.n	45faa <buffer_alloc_calloc+0xaa>
   45f12:	2900      	cmp	r1, #0
   45f14:	d049      	beq.n	45faa <buffer_alloc_calloc+0xaa>
    original_len = len = n * size;
   45f16:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
   45f1a:	fbb6 f0f0 	udiv	r0, r6, r0
   45f1e:	4288      	cmp	r0, r1
   45f20:	d143      	bne.n	45faa <buffer_alloc_calloc+0xaa>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45f22:	1d30      	adds	r0, r6, #4
   45f24:	d841      	bhi.n	45faa <buffer_alloc_calloc+0xaa>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   45f26:	07b1      	lsls	r1, r6, #30
   45f28:	d00d      	beq.n	45f46 <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45f2a:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   45f2e:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
   45f30:	68ec      	ldr	r4, [r5, #12]
   45f32:	e003      	b.n	45f3c <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
   45f34:	6863      	ldr	r3, [r4, #4]
   45f36:	42bb      	cmp	r3, r7
   45f38:	d239      	bcs.n	45fae <buffer_alloc_calloc+0xae>
            break;

        cur = cur->next_free;
   45f3a:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
   45f3c:	2c00      	cmp	r4, #0
   45f3e:	d1f9      	bne.n	45f34 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
   45f40:	4620      	mov	r0, r4
   45f42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   45f46:	4637      	mov	r7, r6
   45f48:	e7f2      	b.n	45f30 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
   45f4a:	60e8      	str	r0, [r5, #12]
   45f4c:	e041      	b.n	45fd2 <buffer_alloc_calloc+0xd2>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
   45f4e:	f107 0c20 	add.w	ip, r7, #32
   45f52:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
   45f56:	3920      	subs	r1, #32
   45f58:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
   45f5a:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
   45f5c:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 46004 <buffer_alloc_calloc+0x104>
    new->prev = cur;
   45f60:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
   45f64:	6921      	ldr	r1, [r4, #16]
   45f66:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
   45f68:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
   45f6c:	f8df c098 	ldr.w	ip, [pc, #152]	; 46008 <buffer_alloc_calloc+0x108>
   45f70:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
   45f74:	b101      	cbz	r1, 45f78 <buffer_alloc_calloc+0x78>
        new->next->prev = new;
   45f76:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
   45f78:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
   45f7c:	b19a      	cbz	r2, 45fa6 <buffer_alloc_calloc+0xa6>
        new->prev_free->next_free = new;
   45f7e:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
   45f80:	699a      	ldr	r2, [r3, #24]
   45f82:	b102      	cbz	r2, 45f86 <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
   45f84:	6153      	str	r3, [r2, #20]
    cur->next = new;
   45f86:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
   45f88:	2300      	movs	r3, #0
    cur->alloc = 1;
   45f8a:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
   45f8e:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45f92:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
   45f94:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45f98:	07db      	lsls	r3, r3, #31
   45f9a:	d529      	bpl.n	45ff0 <buffer_alloc_calloc+0xf0>
   45f9c:	f7ff ff92 	bl	45ec4 <verify_chain>
   45fa0:	b330      	cbz	r0, 45ff0 <buffer_alloc_calloc+0xf0>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void _exit(int status);
static inline void exit(int status)
{
	_exit(status);
   45fa2:	4648      	mov	r0, r9
   45fa4:	e022      	b.n	45fec <buffer_alloc_calloc+0xec>
        heap.first_free = new;
   45fa6:	60eb      	str	r3, [r5, #12]
   45fa8:	e7ea      	b.n	45f80 <buffer_alloc_calloc+0x80>
        return( NULL );
   45faa:	2400      	movs	r4, #0
   45fac:	e7c8      	b.n	45f40 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
   45fae:	68a3      	ldr	r3, [r4, #8]
   45fb0:	b113      	cbz	r3, 45fb8 <buffer_alloc_calloc+0xb8>
   45fb2:	2001      	movs	r0, #1
   45fb4:	f7fc fe40 	bl	42c38 <_exit>
    if( cur->size - len < sizeof(memory_header) +
   45fb8:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
   45fbc:	6861      	ldr	r1, [r4, #4]
   45fbe:	f104 0820 	add.w	r8, r4, #32
   45fc2:	1bc9      	subs	r1, r1, r7
   45fc4:	2923      	cmp	r1, #35	; 0x23
   45fc6:	d8c2      	bhi.n	45f4e <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
   45fc8:	2301      	movs	r3, #1
   45fca:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
   45fcc:	2a00      	cmp	r2, #0
   45fce:	d0bc      	beq.n	45f4a <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
   45fd0:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
   45fd2:	69a3      	ldr	r3, [r4, #24]
   45fd4:	b103      	cbz	r3, 45fd8 <buffer_alloc_calloc+0xd8>
            cur->next_free->prev_free = cur->prev_free;
   45fd6:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
   45fd8:	2300      	movs	r3, #0
        cur->next_free = NULL;
   45fda:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   45fde:	692b      	ldr	r3, [r5, #16]
   45fe0:	07da      	lsls	r2, r3, #31
   45fe2:	d505      	bpl.n	45ff0 <buffer_alloc_calloc+0xf0>
   45fe4:	f7ff ff6e 	bl	45ec4 <verify_chain>
   45fe8:	b110      	cbz	r0, 45ff0 <buffer_alloc_calloc+0xf0>
   45fea:	2001      	movs	r0, #1
   45fec:	f7fc fe24 	bl	42c38 <_exit>
    memset( ret, 0, original_len );
   45ff0:	4632      	mov	r2, r6
   45ff2:	2100      	movs	r1, #0
   45ff4:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
   45ff6:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
   45ff8:	f002 f972 	bl	482e0 <memset>
    return( ret );
   45ffc:	e7a0      	b.n	45f40 <buffer_alloc_calloc+0x40>
   45ffe:	bf00      	nop
   46000:	2001ad8c 	.word	0x2001ad8c
   46004:	ff00aa55 	.word	0xff00aa55
   46008:	ee119966 	.word	0xee119966

0004600c <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
   4600c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
   4600e:	4605      	mov	r5, r0
   46010:	2800      	cmp	r0, #0
   46012:	d078      	beq.n	46106 <buffer_alloc_free+0xfa>
   46014:	4e3c      	ldr	r6, [pc, #240]	; (46108 <buffer_alloc_free+0xfc>)
   46016:	6833      	ldr	r3, [r6, #0]
   46018:	2b00      	cmp	r3, #0
   4601a:	d074      	beq.n	46106 <buffer_alloc_free+0xfa>
   4601c:	68b2      	ldr	r2, [r6, #8]
   4601e:	2a00      	cmp	r2, #0
   46020:	d071      	beq.n	46106 <buffer_alloc_free+0xfa>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
   46022:	4283      	cmp	r3, r0
   46024:	d803      	bhi.n	4602e <buffer_alloc_free+0x22>
   46026:	6872      	ldr	r2, [r6, #4]
   46028:	4413      	add	r3, r2
   4602a:	4298      	cmp	r0, r3
   4602c:	d302      	bcc.n	46034 <buffer_alloc_free+0x28>
   4602e:	2001      	movs	r0, #1
   46030:	f7fc fe02 	bl	42c38 <_exit>
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
    }

    p -= sizeof(memory_header);
   46034:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
   46038:	4620      	mov	r0, r4
   4603a:	f7ff ff23 	bl	45e84 <verify_header>
   4603e:	b110      	cbz	r0, 46046 <buffer_alloc_free+0x3a>
   46040:	2001      	movs	r0, #1
   46042:	f7fc fdf9 	bl	42c38 <_exit>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
   46046:	f855 3c18 	ldr.w	r3, [r5, #-24]
   4604a:	2b01      	cmp	r3, #1
   4604c:	d002      	beq.n	46054 <buffer_alloc_free+0x48>
   4604e:	2001      	movs	r0, #1
   46050:	f7fc fdf2 	bl	42c38 <_exit>
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
    }

    hdr->alloc = 0;
   46054:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   46056:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
   4605a:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   4605e:	b1af      	cbz	r7, 4608c <buffer_alloc_free+0x80>
   46060:	68ba      	ldr	r2, [r7, #8]
   46062:	b992      	cbnz	r2, 4608a <buffer_alloc_free+0x7e>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
   46064:	f855 3c1c 	ldr.w	r3, [r5, #-28]
   46068:	f103 0220 	add.w	r2, r3, #32
   4606c:	687b      	ldr	r3, [r7, #4]
   4606e:	4413      	add	r3, r2
   46070:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
   46072:	f855 3c10 	ldr.w	r3, [r5, #-16]
   46076:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
   46078:	b103      	cbz	r3, 4607c <buffer_alloc_free+0x70>
            hdr->next->prev = hdr;
   4607a:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   4607c:	4620      	mov	r0, r4
   4607e:	2220      	movs	r2, #32
   46080:	2100      	movs	r1, #0
   46082:	f002 f92d 	bl	482e0 <memset>
   46086:	4623      	mov	r3, r4
   46088:	463c      	mov	r4, r7
    memory_header *hdr, *old = NULL;
   4608a:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
   4608c:	6920      	ldr	r0, [r4, #16]
   4608e:	2800      	cmp	r0, #0
   46090:	d031      	beq.n	460f6 <buffer_alloc_free+0xea>
   46092:	6883      	ldr	r3, [r0, #8]
   46094:	2b00      	cmp	r3, #0
   46096:	d12e      	bne.n	460f6 <buffer_alloc_free+0xea>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
   46098:	6863      	ldr	r3, [r4, #4]
   4609a:	6842      	ldr	r2, [r0, #4]
   4609c:	3320      	adds	r3, #32
   4609e:	4413      	add	r3, r2
   460a0:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
   460a2:	6903      	ldr	r3, [r0, #16]
   460a4:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
   460a8:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
   460aa:	b9d2      	cbnz	r2, 460e2 <buffer_alloc_free+0xd6>
   460ac:	b9f9      	cbnz	r1, 460ee <buffer_alloc_free+0xe2>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
   460ae:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
   460b0:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
   460b2:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
   460b4:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
   460b6:	b1e2      	cbz	r2, 460f2 <buffer_alloc_free+0xe6>
            hdr->prev_free->next_free = hdr;
   460b8:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
   460ba:	69a2      	ldr	r2, [r4, #24]
   460bc:	b102      	cbz	r2, 460c0 <buffer_alloc_free+0xb4>
            hdr->next_free->prev_free = hdr;
   460be:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
   460c0:	b103      	cbz	r3, 460c4 <buffer_alloc_free+0xb8>
            hdr->next->prev = hdr;
   460c2:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   460c4:	2220      	movs	r2, #32
   460c6:	2100      	movs	r1, #0
   460c8:	f002 f90a 	bl	482e0 <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
   460cc:	6933      	ldr	r3, [r6, #16]
   460ce:	079b      	lsls	r3, r3, #30
   460d0:	d519      	bpl.n	46106 <buffer_alloc_free+0xfa>
   460d2:	f7ff fef7 	bl	45ec4 <verify_chain>
   460d6:	b1b0      	cbz	r0, 46106 <buffer_alloc_free+0xfa>
        mbedtls_exit( 1 );
}
   460d8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   460dc:	2001      	movs	r0, #1
   460de:	f7fc bdab 	b.w	42c38 <_exit>
                hdr->prev_free->next_free = hdr->next_free;
   460e2:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
   460e4:	69a1      	ldr	r1, [r4, #24]
   460e6:	2900      	cmp	r1, #0
   460e8:	d0e1      	beq.n	460ae <buffer_alloc_free+0xa2>
                hdr->next_free->prev_free = hdr->prev_free;
   460ea:	614a      	str	r2, [r1, #20]
   460ec:	e7df      	b.n	460ae <buffer_alloc_free+0xa2>
                heap.first_free = hdr->next_free;
   460ee:	60f1      	str	r1, [r6, #12]
   460f0:	e7f8      	b.n	460e4 <buffer_alloc_free+0xd8>
            heap.first_free = hdr;
   460f2:	60f4      	str	r4, [r6, #12]
   460f4:	e7e1      	b.n	460ba <buffer_alloc_free+0xae>
    if( old == NULL )
   460f6:	2f00      	cmp	r7, #0
   460f8:	d1e8      	bne.n	460cc <buffer_alloc_free+0xc0>
        hdr->next_free = heap.first_free;
   460fa:	68f3      	ldr	r3, [r6, #12]
   460fc:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
   460fe:	b103      	cbz	r3, 46102 <buffer_alloc_free+0xf6>
            heap.first_free->prev_free = hdr;
   46100:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
   46102:	60f4      	str	r4, [r6, #12]
   46104:	e7e2      	b.n	460cc <buffer_alloc_free+0xc0>
}
   46106:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   46108:	2001ad8c 	.word	0x2001ad8c

0004610c <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
   4610c:	b538      	push	{r3, r4, r5, lr}
   4610e:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   46110:	2214      	movs	r2, #20
   46112:	2100      	movs	r1, #0
{
   46114:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   46116:	4812      	ldr	r0, [pc, #72]	; (46160 <mbedtls_memory_buffer_alloc_init+0x54>)
   46118:	f002 f8e2 	bl	482e0 <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
   4611c:	4911      	ldr	r1, [pc, #68]	; (46164 <mbedtls_memory_buffer_alloc_init+0x58>)
   4611e:	4812      	ldr	r0, [pc, #72]	; (46168 <mbedtls_memory_buffer_alloc_init+0x5c>)
   46120:	f7ff fe9e 	bl	45e60 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   46124:	2d23      	cmp	r5, #35	; 0x23
   46126:	d91a      	bls.n	4615e <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   46128:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   4612c:	bf1f      	itttt	ne
   4612e:	3d04      	subne	r5, #4
   46130:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   46132:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   46136:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
   46138:	462a      	mov	r2, r5
   4613a:	2100      	movs	r1, #0
   4613c:	4620      	mov	r0, r4
   4613e:	f002 f8cf 	bl	482e0 <memset>

    heap.buf = buf;
   46142:	4b07      	ldr	r3, [pc, #28]	; (46160 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
   46144:	4a09      	ldr	r2, [pc, #36]	; (4616c <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
   46146:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
   4614a:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
   4614c:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
   4614e:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
   46152:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
   46154:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
   46158:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
   4615a:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
   4615c:	60dc      	str	r4, [r3, #12]
}
   4615e:	bd38      	pop	{r3, r4, r5, pc}
   46160:	2001ad8c 	.word	0x2001ad8c
   46164:	0004600d 	.word	0x0004600d
   46168:	00045f01 	.word	0x00045f01
   4616c:	ff00aa55 	.word	0xff00aa55

00046170 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   46170:	4b0e      	ldr	r3, [pc, #56]	; (461ac <z_sys_init_run_level+0x3c>)
{
   46172:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   46174:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   46178:	3001      	adds	r0, #1
   4617a:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   4617e:	42a6      	cmp	r6, r4
   46180:	d800      	bhi.n	46184 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   46182:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   46184:	e9d4 3500 	ldrd	r3, r5, [r4]
   46188:	4628      	mov	r0, r5
   4618a:	4798      	blx	r3
		if (dev != NULL) {
   4618c:	b165      	cbz	r5, 461a8 <z_sys_init_run_level+0x38>
			if (rc != 0) {
   4618e:	68eb      	ldr	r3, [r5, #12]
   46190:	b130      	cbz	r0, 461a0 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   46192:	2800      	cmp	r0, #0
   46194:	bfb8      	it	lt
   46196:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   46198:	28ff      	cmp	r0, #255	; 0xff
   4619a:	bfa8      	it	ge
   4619c:	20ff      	movge	r0, #255	; 0xff
   4619e:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   461a0:	785a      	ldrb	r2, [r3, #1]
   461a2:	f042 0201 	orr.w	r2, r2, #1
   461a6:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   461a8:	3408      	adds	r4, #8
   461aa:	e7e8      	b.n	4617e <z_sys_init_run_level+0xe>
   461ac:	000492a0 	.word	0x000492a0

000461b0 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   461b0:	4b01      	ldr	r3, [pc, #4]	; (461b8 <z_impl_z_errno+0x8>)
   461b2:	6898      	ldr	r0, [r3, #8]
}
   461b4:	3060      	adds	r0, #96	; 0x60
   461b6:	4770      	bx	lr
   461b8:	2001ada0 	.word	0x2001ada0

000461bc <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   461bc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   461c0:	4606      	mov	r6, r0
   461c2:	460f      	mov	r7, r1
	__asm__ volatile(
   461c4:	f04f 0320 	mov.w	r3, #32
   461c8:	f3ef 8811 	mrs	r8, BASEPRI
   461cc:	f383 8812 	msr	BASEPRI_MAX, r3
   461d0:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   461d4:	f000 fe32 	bl	46e3c <z_impl_z_current_get>
   461d8:	4c21      	ldr	r4, [pc, #132]	; (46260 <z_fatal_error+0xa4>)
   461da:	4b22      	ldr	r3, [pc, #136]	; (46264 <z_fatal_error+0xa8>)
   461dc:	2e04      	cmp	r6, #4
   461de:	eba4 0403 	sub.w	r4, r4, r3
   461e2:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   461e6:	bf98      	it	ls
   461e8:	4a1f      	ldrls	r2, [pc, #124]	; (46268 <z_fatal_error+0xac>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   461ea:	ea4f 1484 	mov.w	r4, r4, lsl #6
   461ee:	f044 0301 	orr.w	r3, r4, #1
   461f2:	4605      	mov	r5, r0
	switch (reason) {
   461f4:	bf94      	ite	ls
   461f6:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   461fa:	4a1c      	ldrhi	r2, [pc, #112]	; (4626c <z_fatal_error+0xb0>)
   461fc:	f8ad 3000 	strh.w	r3, [sp]
   46200:	4631      	mov	r1, r6
   46202:	2300      	movs	r3, #0
   46204:	481a      	ldr	r0, [pc, #104]	; (46270 <z_fatal_error+0xb4>)
   46206:	f001 fd87 	bl	47d18 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   4620a:	b147      	cbz	r7, 4621e <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   4620c:	69fb      	ldr	r3, [r7, #28]
   4620e:	f3c3 0308 	ubfx	r3, r3, #0, #9
   46212:	b123      	cbz	r3, 4621e <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
   46214:	4817      	ldr	r0, [pc, #92]	; (46274 <z_fatal_error+0xb8>)
   46216:	f044 0101 	orr.w	r1, r4, #1
   4621a:	f001 fd43 	bl	47ca4 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   4621e:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   46222:	b12d      	cbz	r5, 46230 <z_fatal_error+0x74>
   46224:	4628      	mov	r0, r5
   46226:	f002 fbd2 	bl	489ce <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   4622a:	b108      	cbz	r0, 46230 <z_fatal_error+0x74>
   4622c:	7803      	ldrb	r3, [r0, #0]
   4622e:	b903      	cbnz	r3, 46232 <z_fatal_error+0x76>
		thread_name = "unknown";
   46230:	4811      	ldr	r0, [pc, #68]	; (46278 <z_fatal_error+0xbc>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
   46232:	f7fb f915 	bl	41460 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
   46236:	4623      	mov	r3, r4
   46238:	4602      	mov	r2, r0
   4623a:	4629      	mov	r1, r5
   4623c:	480f      	ldr	r0, [pc, #60]	; (4627c <z_fatal_error+0xc0>)
   4623e:	f001 fd52 	bl	47ce6 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   46242:	4639      	mov	r1, r7
   46244:	4630      	mov	r0, r6
   46246:	f7fd fe05 	bl	43e54 <k_sys_fatal_error_handler>
	__asm__ volatile(
   4624a:	f388 8811 	msr	BASEPRI, r8
   4624e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   46252:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   46254:	b002      	add	sp, #8
   46256:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   4625a:	f7fc bb23 	b.w	428a4 <z_impl_k_thread_abort>
   4625e:	bf00      	nop
   46260:	00049068 	.word	0x00049068
   46264:	00049038 	.word	0x00049038
   46268:	000492b8 	.word	0x000492b8
   4626c:	00049a6a 	.word	0x00049a6a
   46270:	00049a80 	.word	0x00049a80
   46274:	00049aa8 	.word	0x00049aa8
   46278:	00049a78 	.word	0x00049a78
   4627c:	00049ac9 	.word	0x00049ac9

00046280 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   46280:	2300      	movs	r3, #0
   46282:	2201      	movs	r2, #1
{
   46284:	b510      	push	{r4, lr}
   46286:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   46288:	e9cd 2304 	strd	r2, r3, [sp, #16]
   4628c:	220f      	movs	r2, #15
   4628e:	9301      	str	r3, [sp, #4]
   46290:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   46294:	2318      	movs	r3, #24
   46296:	4a0b      	ldr	r2, [pc, #44]	; (462c4 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   46298:	4c0b      	ldr	r4, [pc, #44]	; (462c8 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   4629a:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   4629e:	f44f 72a0 	mov.w	r2, #320	; 0x140
   462a2:	490a      	ldr	r1, [pc, #40]	; (462cc <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   462a4:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   462a8:	fb02 1100 	mla	r1, r2, r0, r1
   462ac:	9300      	str	r3, [sp, #0]
   462ae:	4620      	mov	r0, r4
   462b0:	4b07      	ldr	r3, [pc, #28]	; (462d0 <init_idle_thread+0x50>)
   462b2:	f000 f90b 	bl	464cc <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   462b6:	7b63      	ldrb	r3, [r4, #13]
   462b8:	f023 0304 	bic.w	r3, r3, #4
   462bc:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   462be:	b006      	add	sp, #24
   462c0:	bd10      	pop	{r4, pc}
   462c2:	bf00      	nop
   462c4:	2001ada0 	.word	0x2001ada0
   462c8:	2001a780 	.word	0x2001a780
   462cc:	20023240 	.word	0x20023240
   462d0:	00046615 	.word	0x00046615

000462d4 <bg_thread_main>:
	z_sys_post_kernel = true;
   462d4:	2201      	movs	r2, #1
{
   462d6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   462d8:	4b09      	ldr	r3, [pc, #36]	; (46300 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   462da:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   462dc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   462de:	f7ff ff47 	bl	46170 <z_sys_init_run_level>
	boot_banner();
   462e2:	f001 f825 	bl	47330 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   462e6:	2003      	movs	r0, #3
   462e8:	f7ff ff42 	bl	46170 <z_sys_init_run_level>
	z_init_static_threads();
   462ec:	f000 f94a 	bl	46584 <z_init_static_threads>
	main();
   462f0:	f7fa f8cc 	bl	4048c <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   462f4:	4a03      	ldr	r2, [pc, #12]	; (46304 <bg_thread_main+0x30>)
   462f6:	7b13      	ldrb	r3, [r2, #12]
   462f8:	f023 0301 	bic.w	r3, r3, #1
   462fc:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   462fe:	bd08      	pop	{r3, pc}
   46300:	20020b3e 	.word	0x20020b3e
   46304:	2001a800 	.word	0x2001a800

00046308 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   46308:	4802      	ldr	r0, [pc, #8]	; (46314 <z_bss_zero+0xc>)
   4630a:	4a03      	ldr	r2, [pc, #12]	; (46318 <z_bss_zero+0x10>)
   4630c:	2100      	movs	r1, #0
   4630e:	1a12      	subs	r2, r2, r0
   46310:	f001 bfe6 	b.w	482e0 <memset>
   46314:	2001a690 	.word	0x2001a690
   46318:	20020b40 	.word	0x20020b40

0004631c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   4631c:	b580      	push	{r7, lr}
   4631e:	b0a6      	sub	sp, #152	; 0x98
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   46320:	f7fa ffee 	bl	41300 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   46324:	4b2f      	ldr	r3, [pc, #188]	; (463e4 <z_cstart+0xc8>)
	uint32_t msp =
   46326:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   4632a:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   4632e:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   46332:	2400      	movs	r4, #0
   46334:	23e0      	movs	r3, #224	; 0xe0
   46336:	4d2c      	ldr	r5, [pc, #176]	; (463e8 <z_cstart+0xcc>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   46338:	4e2c      	ldr	r6, [pc, #176]	; (463ec <z_cstart+0xd0>)
   4633a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   4633e:	77ec      	strb	r4, [r5, #31]
   46340:	762c      	strb	r4, [r5, #24]
   46342:	766c      	strb	r4, [r5, #25]
   46344:	76ac      	strb	r4, [r5, #26]
   46346:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   4634a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4634c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 46400 <z_cstart+0xe4>
   46350:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   46354:	626b      	str	r3, [r5, #36]	; 0x24
   46356:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   4635a:	f7fc fa1b 	bl	42794 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   4635e:	f7fb fe77 	bl	42050 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   46362:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   46366:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   46368:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   4636a:	f7fc fc27 	bl	42bbc <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   4636e:	f7fc faab 	bl	428c8 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   46372:	f240 1301 	movw	r3, #257	; 0x101
   46376:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   4637a:	ab06      	add	r3, sp, #24
   4637c:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   4637e:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   46382:	f002 fa56 	bl	48832 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   46386:	4620      	mov	r0, r4
   46388:	f7ff fef2 	bl	46170 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   4638c:	2001      	movs	r0, #1
   4638e:	f7ff feef 	bl	46170 <z_sys_init_run_level>
	z_sched_init();
   46392:	f000 fca5 	bl	46ce0 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46396:	4b16      	ldr	r3, [pc, #88]	; (463f0 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   46398:	4d16      	ldr	r5, [pc, #88]	; (463f4 <z_cstart+0xd8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   4639a:	9305      	str	r3, [sp, #20]
   4639c:	2301      	movs	r3, #1
   4639e:	4916      	ldr	r1, [pc, #88]	; (463f8 <z_cstart+0xdc>)
   463a0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   463a4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   463a8:	4628      	mov	r0, r5
   463aa:	464b      	mov	r3, r9
   463ac:	e9cd 4401 	strd	r4, r4, [sp, #4]
   463b0:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   463b2:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   463b4:	f000 f88a 	bl	464cc <z_setup_new_thread>
   463b8:	4607      	mov	r7, r0
   463ba:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   463bc:	4628      	mov	r0, r5
   463be:	f022 0204 	bic.w	r2, r2, #4
   463c2:	736a      	strb	r2, [r5, #13]
   463c4:	f002 fb75 	bl	48ab2 <z_ready_thread>
		init_idle_thread(i);
   463c8:	4620      	mov	r0, r4
   463ca:	f7ff ff59 	bl	46280 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   463ce:	4b0b      	ldr	r3, [pc, #44]	; (463fc <z_cstart+0xe0>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   463d0:	464a      	mov	r2, r9
   463d2:	4639      	mov	r1, r7
   463d4:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   463d6:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   463d8:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   463da:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   463de:	f7fb ff67 	bl	422b0 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   463e2:	bf00      	nop
   463e4:	20023380 	.word	0x20023380
   463e8:	e000ed00 	.word	0xe000ed00
   463ec:	2001ada0 	.word	0x2001ada0
   463f0:	00049b2b 	.word	0x00049b2b
   463f4:	2001a800 	.word	0x2001a800
   463f8:	20021240 	.word	0x20021240
   463fc:	2001a780 	.word	0x2001a780
   46400:	000462d5 	.word	0x000462d5

00046404 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   46404:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   46406:	4c06      	ldr	r4, [pc, #24]	; (46420 <statics_init+0x1c>)
   46408:	4d06      	ldr	r5, [pc, #24]	; (46424 <statics_init+0x20>)
   4640a:	42ac      	cmp	r4, r5
   4640c:	d301      	bcc.n	46412 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   4640e:	2000      	movs	r0, #0
   46410:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   46412:	4620      	mov	r0, r4
   46414:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   46418:	f002 fa16 	bl	48848 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   4641c:	3414      	adds	r4, #20
   4641e:	e7f4      	b.n	4640a <statics_init+0x6>
   46420:	2001a62c 	.word	0x2001a62c
   46424:	2001a654 	.word	0x2001a654

00046428 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   46428:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4642a:	4b0e      	ldr	r3, [pc, #56]	; (46464 <init_mem_slab_module+0x3c>)
   4642c:	4c0e      	ldr	r4, [pc, #56]	; (46468 <init_mem_slab_module+0x40>)
   4642e:	42a3      	cmp	r3, r4
   46430:	d301      	bcc.n	46436 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   46432:	2000      	movs	r0, #0
	return rc;
}
   46434:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   46436:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   4643a:	ea41 0200 	orr.w	r2, r1, r0
   4643e:	f012 0203 	ands.w	r2, r2, #3
   46442:	d10b      	bne.n	4645c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   46444:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   46446:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46448:	42aa      	cmp	r2, r5
   4644a:	d101      	bne.n	46450 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4644c:	331c      	adds	r3, #28
   4644e:	e7ee      	b.n	4642e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   46450:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   46452:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   46454:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   46456:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   46458:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   4645a:	e7f5      	b.n	46448 <init_mem_slab_module+0x20>
		return -EINVAL;
   4645c:	f06f 0015 	mvn.w	r0, #21
	return rc;
   46460:	e7e8      	b.n	46434 <init_mem_slab_module+0xc>
   46462:	bf00      	nop
   46464:	2001a62c 	.word	0x2001a62c
   46468:	2001a62c 	.word	0x2001a62c

0004646c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   4646c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   4646e:	460c      	mov	r4, r1
   46470:	4616      	mov	r6, r2
   46472:	461f      	mov	r7, r3
	__asm__ volatile(
   46474:	f04f 0320 	mov.w	r3, #32
   46478:	f3ef 8111 	mrs	r1, BASEPRI
   4647c:	f383 8812 	msr	BASEPRI_MAX, r3
   46480:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   46484:	6943      	ldr	r3, [r0, #20]
   46486:	b15b      	cbz	r3, 464a0 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   46488:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   4648a:	681b      	ldr	r3, [r3, #0]
   4648c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   4648e:	6983      	ldr	r3, [r0, #24]
   46490:	3301      	adds	r3, #1
   46492:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   46494:	2000      	movs	r0, #0
	__asm__ volatile(
   46496:	f381 8811 	msr	BASEPRI, r1
   4649a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   4649e:	e011      	b.n	464c4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   464a0:	ea56 0207 	orrs.w	r2, r6, r7
   464a4:	d103      	bne.n	464ae <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   464a6:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   464aa:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   464ac:	e7f3      	b.n	46496 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   464ae:	4602      	mov	r2, r0
   464b0:	e9cd 6700 	strd	r6, r7, [sp]
   464b4:	3008      	adds	r0, #8
   464b6:	f000 fb65 	bl	46b84 <z_pend_curr>
		if (result == 0) {
   464ba:	b918      	cbnz	r0, 464c4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   464bc:	4b02      	ldr	r3, [pc, #8]	; (464c8 <k_mem_slab_alloc+0x5c>)
   464be:	689b      	ldr	r3, [r3, #8]
   464c0:	695b      	ldr	r3, [r3, #20]
   464c2:	6023      	str	r3, [r4, #0]
}
   464c4:	b002      	add	sp, #8
   464c6:	bdd0      	pop	{r4, r6, r7, pc}
   464c8:	2001ada0 	.word	0x2001ada0

000464cc <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   464cc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   464d0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   464d2:	f100 0558 	add.w	r5, r0, #88	; 0x58
   464d6:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   464d8:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   464da:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   464de:	2500      	movs	r5, #0
{
   464e0:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   464e2:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   464e4:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   464e6:	e9c0 5506 	strd	r5, r5, [r0, #24]
   464ea:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   464ec:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   464ee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   464f0:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   464f4:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   464f8:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   464fa:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   464fc:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   464fe:	9202      	str	r2, [sp, #8]
   46500:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   46502:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46506:	9201      	str	r2, [sp, #4]
   46508:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   4650a:	9200      	str	r2, [sp, #0]
   4650c:	4642      	mov	r2, r8
   4650e:	f7fb feb1 	bl	42274 <arch_new_thread>
	if (!_current) {
   46512:	4b05      	ldr	r3, [pc, #20]	; (46528 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   46514:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   46516:	689b      	ldr	r3, [r3, #8]
   46518:	b103      	cbz	r3, 4651c <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   4651a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   4651c:	4640      	mov	r0, r8
   4651e:	6723      	str	r3, [r4, #112]	; 0x70
   46520:	b004      	add	sp, #16
   46522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46526:	bf00      	nop
   46528:	2001ada0 	.word	0x2001ada0

0004652c <z_impl_k_thread_create>:
{
   4652c:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4652e:	2500      	movs	r5, #0
{
   46530:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46532:	9505      	str	r5, [sp, #20]
   46534:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   46536:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4653a:	9504      	str	r5, [sp, #16]
   4653c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   4653e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46540:	9503      	str	r5, [sp, #12]
   46542:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   46544:	9502      	str	r5, [sp, #8]
   46546:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   46548:	9501      	str	r5, [sp, #4]
   4654a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   4654c:	9500      	str	r5, [sp, #0]
   4654e:	f7ff ffbd 	bl	464cc <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   46552:	1c7b      	adds	r3, r7, #1
   46554:	bf08      	it	eq
   46556:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   4655a:	d005      	beq.n	46568 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   4655c:	ea56 0307 	orrs.w	r3, r6, r7
   46560:	d105      	bne.n	4656e <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   46562:	4620      	mov	r0, r4
   46564:	f000 fab2 	bl	46acc <z_sched_start>
}
   46568:	4620      	mov	r0, r4
   4656a:	b007      	add	sp, #28
   4656c:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   4656e:	4632      	mov	r2, r6
   46570:	463b      	mov	r3, r7
   46572:	4903      	ldr	r1, [pc, #12]	; (46580 <z_impl_k_thread_create+0x54>)
   46574:	f104 0018 	add.w	r0, r4, #24
   46578:	f000 fd22 	bl	46fc0 <z_add_timeout>
   4657c:	e7f4      	b.n	46568 <z_impl_k_thread_create+0x3c>
   4657e:	bf00      	nop
   46580:	00048ad3 	.word	0x00048ad3

00046584 <z_init_static_threads>:
{
   46584:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   46586:	4e20      	ldr	r6, [pc, #128]	; (46608 <z_init_static_threads+0x84>)
   46588:	4d20      	ldr	r5, [pc, #128]	; (4660c <z_init_static_threads+0x88>)
   4658a:	4637      	mov	r7, r6
{
   4658c:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   4658e:	42b5      	cmp	r5, r6
   46590:	f105 0430 	add.w	r4, r5, #48	; 0x30
   46594:	d30a      	bcc.n	465ac <z_init_static_threads+0x28>
	k_sched_lock();
   46596:	f000 f9ad 	bl	468f4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   4659a:	4c1c      	ldr	r4, [pc, #112]	; (4660c <z_init_static_threads+0x88>)
   4659c:	4d1c      	ldr	r5, [pc, #112]	; (46610 <z_init_static_threads+0x8c>)
   4659e:	42bc      	cmp	r4, r7
   465a0:	d321      	bcc.n	465e6 <z_init_static_threads+0x62>
}
   465a2:	b007      	add	sp, #28
   465a4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   465a8:	f000 bb7e 	b.w	46ca8 <k_sched_unlock>
		z_setup_new_thread(
   465ac:	f854 3c04 	ldr.w	r3, [r4, #-4]
   465b0:	9305      	str	r3, [sp, #20]
   465b2:	f854 3c10 	ldr.w	r3, [r4, #-16]
   465b6:	9304      	str	r3, [sp, #16]
   465b8:	f854 3c14 	ldr.w	r3, [r4, #-20]
   465bc:	9303      	str	r3, [sp, #12]
   465be:	f854 3c18 	ldr.w	r3, [r4, #-24]
   465c2:	9302      	str	r3, [sp, #8]
   465c4:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   465c8:	9301      	str	r3, [sp, #4]
   465ca:	f854 3c20 	ldr.w	r3, [r4, #-32]
   465ce:	9300      	str	r3, [sp, #0]
   465d0:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   465d4:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   465d8:	f7ff ff78 	bl	464cc <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   465dc:	f854 3c30 	ldr.w	r3, [r4, #-48]
   465e0:	655d      	str	r5, [r3, #84]	; 0x54
   465e2:	4625      	mov	r5, r4
   465e4:	e7d3      	b.n	4658e <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   465e6:	6a62      	ldr	r2, [r4, #36]	; 0x24
   465e8:	1c53      	adds	r3, r2, #1
   465ea:	d004      	beq.n	465f6 <z_init_static_threads+0x72>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   465ec:	2a00      	cmp	r2, #0
			schedule_new_thread(thread_data->init_thread,
   465ee:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   465f0:	dc03      	bgt.n	465fa <z_init_static_threads+0x76>
	z_sched_start(thread);
   465f2:	f000 fa6b 	bl	46acc <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   465f6:	3430      	adds	r4, #48	; 0x30
   465f8:	e7d1      	b.n	4659e <z_init_static_threads+0x1a>
   465fa:	4629      	mov	r1, r5
   465fc:	17d3      	asrs	r3, r2, #31
   465fe:	3018      	adds	r0, #24
   46600:	f000 fcde 	bl	46fc0 <z_add_timeout>
   46604:	e7f7      	b.n	465f6 <z_init_static_threads+0x72>
   46606:	bf00      	nop
   46608:	2001a62c 	.word	0x2001a62c
   4660c:	2001a62c 	.word	0x2001a62c
   46610:	00048ad3 	.word	0x00048ad3

00046614 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   46614:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   46616:	4c09      	ldr	r4, [pc, #36]	; (4663c <idle+0x28>)
	__asm__ volatile(
   46618:	f04f 0220 	mov.w	r2, #32
   4661c:	f3ef 8311 	mrs	r3, BASEPRI
   46620:	f382 8812 	msr	BASEPRI_MAX, r2
   46624:	f3bf 8f6f 	isb	sy
   46628:	f002 faf5 	bl	48c16 <z_get_next_timeout_expiry>
   4662c:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   4662e:	f7fb fc8f 	bl	41f50 <pm_system_suspend>
   46632:	2800      	cmp	r0, #0
   46634:	d1f0      	bne.n	46618 <idle+0x4>
	arch_cpu_idle();
   46636:	f7fb fd11 	bl	4205c <arch_cpu_idle>
}
   4663a:	e7ed      	b.n	46618 <idle+0x4>
   4663c:	2001ada0 	.word	0x2001ada0

00046640 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   46640:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46644:	4604      	mov	r4, r0
   46646:	4616      	mov	r6, r2
   46648:	461f      	mov	r7, r3
   4664a:	f04f 0320 	mov.w	r3, #32
   4664e:	f3ef 8811 	mrs	r8, BASEPRI
   46652:	f383 8812 	msr	BASEPRI_MAX, r3
   46656:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   4665a:	68c3      	ldr	r3, [r0, #12]
   4665c:	4a35      	ldr	r2, [pc, #212]	; (46734 <z_impl_k_mutex_lock+0xf4>)
   4665e:	b16b      	cbz	r3, 4667c <z_impl_k_mutex_lock+0x3c>
   46660:	6880      	ldr	r0, [r0, #8]
   46662:	6891      	ldr	r1, [r2, #8]
   46664:	4288      	cmp	r0, r1
   46666:	d019      	beq.n	4669c <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   46668:	ea56 0307 	orrs.w	r3, r6, r7
   4666c:	d118      	bne.n	466a0 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   4666e:	f388 8811 	msr	BASEPRI, r8
   46672:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   46676:	f06f 000f 	mvn.w	r0, #15
   4667a:	e00c      	b.n	46696 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   4667c:	6891      	ldr	r1, [r2, #8]
   4667e:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   46682:	3301      	adds	r3, #1
   46684:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   46686:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   46688:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   4668a:	60a3      	str	r3, [r4, #8]
   4668c:	f388 8811 	msr	BASEPRI, r8
   46690:	f3bf 8f6f 	isb	sy
		return 0;
   46694:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   46696:	b002      	add	sp, #8
   46698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   4669c:	6921      	ldr	r1, [r4, #16]
   4669e:	e7f0      	b.n	46682 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   466a0:	f991 100e 	ldrsb.w	r1, [r1, #14]
   466a4:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   466a8:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   466ac:	4299      	cmp	r1, r3
   466ae:	bfa8      	it	ge
   466b0:	4619      	movge	r1, r3
   466b2:	4291      	cmp	r1, r2
   466b4:	bfb8      	it	lt
   466b6:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   466b8:	428b      	cmp	r3, r1
   466ba:	dd2f      	ble.n	4671c <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   466bc:	f000 fa76 	bl	46bac <z_set_prio>
   466c0:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   466c2:	4622      	mov	r2, r4
   466c4:	4641      	mov	r1, r8
   466c6:	e9cd 6700 	strd	r6, r7, [sp]
   466ca:	481b      	ldr	r0, [pc, #108]	; (46738 <z_impl_k_mutex_lock+0xf8>)
   466cc:	f000 fa5a 	bl	46b84 <z_pend_curr>
	if (got_mutex == 0) {
   466d0:	2800      	cmp	r0, #0
   466d2:	d0e0      	beq.n	46696 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   466d4:	f04f 0320 	mov.w	r3, #32
   466d8:	f3ef 8611 	mrs	r6, BASEPRI
   466dc:	f383 8812 	msr	BASEPRI_MAX, r3
   466e0:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   466e4:	6823      	ldr	r3, [r4, #0]
   466e6:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   466e8:	429c      	cmp	r4, r3
   466ea:	d00a      	beq.n	46702 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   466ec:	b14b      	cbz	r3, 46702 <z_impl_k_mutex_lock+0xc2>
   466ee:	f993 300e 	ldrsb.w	r3, [r3, #14]
   466f2:	4299      	cmp	r1, r3
   466f4:	bfa8      	it	ge
   466f6:	4619      	movge	r1, r3
   466f8:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   466fc:	4299      	cmp	r1, r3
   466fe:	bfb8      	it	lt
   46700:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46702:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   46704:	f990 300e 	ldrsb.w	r3, [r0, #14]
   46708:	4299      	cmp	r1, r3
   4670a:	d109      	bne.n	46720 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   4670c:	b16d      	cbz	r5, 4672a <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   4670e:	4631      	mov	r1, r6
   46710:	4809      	ldr	r0, [pc, #36]	; (46738 <z_impl_k_mutex_lock+0xf8>)
   46712:	f000 f8dd 	bl	468d0 <z_reschedule>
	return -EAGAIN;
   46716:	f06f 000a 	mvn.w	r0, #10
   4671a:	e7bc      	b.n	46696 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   4671c:	2500      	movs	r5, #0
   4671e:	e7d0      	b.n	466c2 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   46720:	f000 fa44 	bl	46bac <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46724:	2800      	cmp	r0, #0
   46726:	d1f2      	bne.n	4670e <z_impl_k_mutex_lock+0xce>
   46728:	e7f0      	b.n	4670c <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   4672a:	f386 8811 	msr	BASEPRI, r6
   4672e:	f3bf 8f6f 	isb	sy
   46732:	e7f0      	b.n	46716 <z_impl_k_mutex_lock+0xd6>
   46734:	2001ada0 	.word	0x2001ada0
   46738:	20020b3f 	.word	0x20020b3f

0004673c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   4673c:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   4673e:	6883      	ldr	r3, [r0, #8]
{
   46740:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   46742:	2b00      	cmp	r3, #0
   46744:	d036      	beq.n	467b4 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   46746:	4a1e      	ldr	r2, [pc, #120]	; (467c0 <z_impl_k_mutex_unlock+0x84>)
   46748:	6892      	ldr	r2, [r2, #8]
   4674a:	4293      	cmp	r3, r2
   4674c:	d135      	bne.n	467ba <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   4674e:	7bda      	ldrb	r2, [r3, #15]
   46750:	3a01      	subs	r2, #1
   46752:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   46754:	68c3      	ldr	r3, [r0, #12]
   46756:	2b01      	cmp	r3, #1
   46758:	d905      	bls.n	46766 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   4675a:	3b01      	subs	r3, #1
   4675c:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   4675e:	f000 faa3 	bl	46ca8 <k_sched_unlock>

	return 0;
   46762:	2000      	movs	r0, #0
}
   46764:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   46766:	f04f 0320 	mov.w	r3, #32
   4676a:	f3ef 8511 	mrs	r5, BASEPRI
   4676e:	f383 8812 	msr	BASEPRI_MAX, r3
   46772:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   46776:	6901      	ldr	r1, [r0, #16]
   46778:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   4677a:	f990 300e 	ldrsb.w	r3, [r0, #14]
   4677e:	4299      	cmp	r1, r3
   46780:	d001      	beq.n	46786 <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   46782:	f000 fa13 	bl	46bac <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   46786:	4620      	mov	r0, r4
   46788:	f002 fa07 	bl	48b9a <z_unpend_first_thread>
	mutex->owner = new_owner;
   4678c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   4678e:	b158      	cbz	r0, 467a8 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   46790:	f990 200e 	ldrsb.w	r2, [r0, #14]
   46794:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   46796:	2200      	movs	r2, #0
   46798:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   4679a:	f002 f98a 	bl	48ab2 <z_ready_thread>
		z_reschedule(&lock, key);
   4679e:	4629      	mov	r1, r5
   467a0:	4808      	ldr	r0, [pc, #32]	; (467c4 <z_impl_k_mutex_unlock+0x88>)
   467a2:	f000 f895 	bl	468d0 <z_reschedule>
   467a6:	e7da      	b.n	4675e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   467a8:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   467aa:	f385 8811 	msr	BASEPRI, r5
   467ae:	f3bf 8f6f 	isb	sy
   467b2:	e7d4      	b.n	4675e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   467b4:	f06f 0015 	mvn.w	r0, #21
   467b8:	e7d4      	b.n	46764 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   467ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   467be:	e7d1      	b.n	46764 <z_impl_k_mutex_unlock+0x28>
   467c0:	2001ada0 	.word	0x2001ada0
   467c4:	20020b3f 	.word	0x20020b3f

000467c8 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   467c8:	b538      	push	{r3, r4, r5, lr}
   467ca:	4604      	mov	r4, r0
	__asm__ volatile(
   467cc:	f04f 0320 	mov.w	r3, #32
   467d0:	f3ef 8511 	mrs	r5, BASEPRI
   467d4:	f383 8812 	msr	BASEPRI_MAX, r3
   467d8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   467dc:	f002 f9dd 	bl	48b9a <z_unpend_first_thread>

	if (thread != NULL) {
   467e0:	b148      	cbz	r0, 467f6 <z_impl_k_sem_give+0x2e>
   467e2:	2200      	movs	r2, #0
   467e4:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   467e6:	f002 f964 	bl	48ab2 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   467ea:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   467ec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   467f0:	4804      	ldr	r0, [pc, #16]	; (46804 <z_impl_k_sem_give+0x3c>)
   467f2:	f000 b86d 	b.w	468d0 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   467f6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   467fa:	429a      	cmp	r2, r3
   467fc:	bf18      	it	ne
   467fe:	3301      	addne	r3, #1
   46800:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   46802:	e7f2      	b.n	467ea <z_impl_k_sem_give+0x22>
   46804:	20020b3f 	.word	0x20020b3f

00046808 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   46808:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4680a:	4614      	mov	r4, r2
   4680c:	461d      	mov	r5, r3
   4680e:	f04f 0320 	mov.w	r3, #32
   46812:	f3ef 8111 	mrs	r1, BASEPRI
   46816:	f383 8812 	msr	BASEPRI_MAX, r3
   4681a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   4681e:	6883      	ldr	r3, [r0, #8]
   46820:	b143      	cbz	r3, 46834 <z_impl_k_sem_take+0x2c>
		sem->count--;
   46822:	3b01      	subs	r3, #1
   46824:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   46826:	f381 8811 	msr	BASEPRI, r1
   4682a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   4682e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   46830:	b003      	add	sp, #12
   46832:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46834:	ea54 0305 	orrs.w	r3, r4, r5
   46838:	d106      	bne.n	46848 <z_impl_k_sem_take+0x40>
   4683a:	f381 8811 	msr	BASEPRI, r1
   4683e:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   46842:	f06f 000f 	mvn.w	r0, #15
   46846:	e7f3      	b.n	46830 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   46848:	4602      	mov	r2, r0
   4684a:	e9cd 4500 	strd	r4, r5, [sp]
   4684e:	4802      	ldr	r0, [pc, #8]	; (46858 <z_impl_k_sem_take+0x50>)
   46850:	f000 f998 	bl	46b84 <z_pend_curr>
	return ret;
   46854:	e7ec      	b.n	46830 <z_impl_k_sem_take+0x28>
   46856:	bf00      	nop
   46858:	20020b3f 	.word	0x20020b3f

0004685c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   4685c:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   4685e:	4c08      	ldr	r4, [pc, #32]	; (46880 <z_reset_time_slice+0x24>)
   46860:	6823      	ldr	r3, [r4, #0]
   46862:	b15b      	cbz	r3, 4687c <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46864:	f7fd f940 	bl	43ae8 <sys_clock_elapsed>
   46868:	4603      	mov	r3, r0
   4686a:	6820      	ldr	r0, [r4, #0]
   4686c:	4a05      	ldr	r2, [pc, #20]	; (46884 <z_reset_time_slice+0x28>)
   4686e:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   46870:	2100      	movs	r1, #0
	}
}
   46872:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46876:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   46878:	f002 b9dd 	b.w	48c36 <z_set_timeout_expiry>
}
   4687c:	bd10      	pop	{r4, pc}
   4687e:	bf00      	nop
   46880:	2001add0 	.word	0x2001add0
   46884:	2001ada0 	.word	0x2001ada0

00046888 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   46888:	b510      	push	{r4, lr}
	__asm__ volatile(
   4688a:	f04f 0320 	mov.w	r3, #32
   4688e:	f3ef 8411 	mrs	r4, BASEPRI
   46892:	f383 8812 	msr	BASEPRI_MAX, r3
   46896:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   4689a:	2200      	movs	r2, #0
   4689c:	4b09      	ldr	r3, [pc, #36]	; (468c4 <k_sched_time_slice_set+0x3c>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   4689e:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
   468a0:	611a      	str	r2, [r3, #16]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   468a2:	4b09      	ldr	r3, [pc, #36]	; (468c8 <k_sched_time_slice_set+0x40>)
   468a4:	dc09      	bgt.n	468ba <k_sched_time_slice_set+0x32>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   468a6:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   468a8:	4b08      	ldr	r3, [pc, #32]	; (468cc <k_sched_time_slice_set+0x44>)
   468aa:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
   468ac:	f7ff ffd6 	bl	4685c <z_reset_time_slice>
	__asm__ volatile(
   468b0:	f384 8811 	msr	BASEPRI, r4
   468b4:	f3bf 8f6f 	isb	sy
	}
}
   468b8:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
   468ba:	2802      	cmp	r0, #2
   468bc:	bfb8      	it	lt
   468be:	2002      	movlt	r0, #2
   468c0:	e7f1      	b.n	468a6 <k_sched_time_slice_set+0x1e>
   468c2:	bf00      	nop
   468c4:	2001ada0 	.word	0x2001ada0
   468c8:	2001add0 	.word	0x2001add0
   468cc:	2001adcc 	.word	0x2001adcc

000468d0 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   468d0:	b949      	cbnz	r1, 468e6 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   468d2:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   468d6:	b930      	cbnz	r0, 468e6 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   468d8:	4b05      	ldr	r3, [pc, #20]	; (468f0 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   468da:	69da      	ldr	r2, [r3, #28]
   468dc:	689b      	ldr	r3, [r3, #8]
   468de:	429a      	cmp	r2, r3
   468e0:	d001      	beq.n	468e6 <z_reschedule+0x16>
	ret = arch_swap(key);
   468e2:	f7fb bc6d 	b.w	421c0 <arch_swap>
   468e6:	f381 8811 	msr	BASEPRI, r1
   468ea:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   468ee:	4770      	bx	lr
   468f0:	2001ada0 	.word	0x2001ada0

000468f4 <k_sched_lock>:
	__asm__ volatile(
   468f4:	f04f 0320 	mov.w	r3, #32
   468f8:	f3ef 8111 	mrs	r1, BASEPRI
   468fc:	f383 8812 	msr	BASEPRI_MAX, r3
   46900:	f3bf 8f6f 	isb	sy
   46904:	4b04      	ldr	r3, [pc, #16]	; (46918 <k_sched_lock+0x24>)
   46906:	689a      	ldr	r2, [r3, #8]
   46908:	7bd3      	ldrb	r3, [r2, #15]
   4690a:	3b01      	subs	r3, #1
   4690c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   4690e:	f381 8811 	msr	BASEPRI, r1
   46912:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   46916:	4770      	bx	lr
   46918:	2001ada0 	.word	0x2001ada0

0004691c <update_cache>:
{
   4691c:	b538      	push	{r3, r4, r5, lr}
   4691e:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   46920:	480c      	ldr	r0, [pc, #48]	; (46954 <update_cache+0x38>)
   46922:	f002 f8bc 	bl	48a9e <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   46926:	4d0c      	ldr	r5, [pc, #48]	; (46958 <update_cache+0x3c>)
   46928:	4604      	mov	r4, r0
   4692a:	b900      	cbnz	r0, 4692e <update_cache+0x12>
   4692c:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   4692e:	68ab      	ldr	r3, [r5, #8]
   46930:	b94a      	cbnz	r2, 46946 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   46932:	7b5a      	ldrb	r2, [r3, #13]
   46934:	06d2      	lsls	r2, r2, #27
   46936:	d106      	bne.n	46946 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   46938:	69a2      	ldr	r2, [r4, #24]
   4693a:	b922      	cbnz	r2, 46946 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   4693c:	89da      	ldrh	r2, [r3, #14]
   4693e:	2a7f      	cmp	r2, #127	; 0x7f
   46940:	d901      	bls.n	46946 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   46942:	61eb      	str	r3, [r5, #28]
}
   46944:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   46946:	429c      	cmp	r4, r3
   46948:	d001      	beq.n	4694e <update_cache+0x32>
			z_reset_time_slice();
   4694a:	f7ff ff87 	bl	4685c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   4694e:	61ec      	str	r4, [r5, #28]
}
   46950:	e7f8      	b.n	46944 <update_cache+0x28>
   46952:	bf00      	nop
   46954:	2001adc0 	.word	0x2001adc0
   46958:	2001ada0 	.word	0x2001ada0

0004695c <move_thread_to_end_of_prio_q>:
{
   4695c:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   4695e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46962:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46964:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46966:	7b43      	ldrb	r3, [r0, #13]
   46968:	da04      	bge.n	46974 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   4696a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   4696e:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   46970:	f002 f849 	bl	48a06 <sys_dlist_remove>
	return list->head == list;
   46974:	4a17      	ldr	r2, [pc, #92]	; (469d4 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46976:	7b4b      	ldrb	r3, [r1, #13]
   46978:	4610      	mov	r0, r2
   4697a:	f063 037f 	orn	r3, r3, #127	; 0x7f
   4697e:	734b      	strb	r3, [r1, #13]
   46980:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46984:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46986:	4283      	cmp	r3, r0
   46988:	bf08      	it	eq
   4698a:	2300      	moveq	r3, #0
   4698c:	2b00      	cmp	r3, #0
   4698e:	bf38      	it	cc
   46990:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46992:	b1cb      	cbz	r3, 469c8 <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   46994:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   46998:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   4699c:	42a6      	cmp	r6, r4
   4699e:	d00f      	beq.n	469c0 <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   469a0:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   469a2:	2c00      	cmp	r4, #0
   469a4:	dd0c      	ble.n	469c0 <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   469a6:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   469a8:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   469ac:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   469ae:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   469b0:	6890      	ldr	r0, [r2, #8]
}
   469b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   469b6:	1a43      	subs	r3, r0, r1
   469b8:	4258      	negs	r0, r3
   469ba:	4158      	adcs	r0, r3
   469bc:	f7ff bfae 	b.w	4691c <update_cache>
	return (node == list->tail) ? NULL : node->next;
   469c0:	42ab      	cmp	r3, r5
   469c2:	d001      	beq.n	469c8 <move_thread_to_end_of_prio_q+0x6c>
   469c4:	681b      	ldr	r3, [r3, #0]
   469c6:	e7e4      	b.n	46992 <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   469c8:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   469cc:	6029      	str	r1, [r5, #0]
	list->tail = node;
   469ce:	6251      	str	r1, [r2, #36]	; 0x24
}
   469d0:	e7ee      	b.n	469b0 <move_thread_to_end_of_prio_q+0x54>
   469d2:	bf00      	nop
   469d4:	2001ada0 	.word	0x2001ada0

000469d8 <z_time_slice>:
{
   469d8:	4601      	mov	r1, r0
   469da:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   469dc:	f04f 0320 	mov.w	r3, #32
   469e0:	f3ef 8411 	mrs	r4, BASEPRI
   469e4:	f383 8812 	msr	BASEPRI_MAX, r3
   469e8:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   469ec:	4b16      	ldr	r3, [pc, #88]	; (46a48 <z_time_slice+0x70>)
   469ee:	4a17      	ldr	r2, [pc, #92]	; (46a4c <z_time_slice+0x74>)
   469f0:	6898      	ldr	r0, [r3, #8]
   469f2:	6815      	ldr	r5, [r2, #0]
   469f4:	42a8      	cmp	r0, r5
   469f6:	461d      	mov	r5, r3
   469f8:	d106      	bne.n	46a08 <z_time_slice+0x30>
			z_reset_time_slice();
   469fa:	f7ff ff2f 	bl	4685c <z_reset_time_slice>
	__asm__ volatile(
   469fe:	f384 8811 	msr	BASEPRI, r4
   46a02:	f3bf 8f6f 	isb	sy
}
   46a06:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   46a08:	2600      	movs	r6, #0
   46a0a:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   46a0c:	4a10      	ldr	r2, [pc, #64]	; (46a50 <z_time_slice+0x78>)
   46a0e:	6812      	ldr	r2, [r2, #0]
   46a10:	b1ba      	cbz	r2, 46a42 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   46a12:	89c2      	ldrh	r2, [r0, #14]
   46a14:	2a7f      	cmp	r2, #127	; 0x7f
   46a16:	d814      	bhi.n	46a42 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   46a18:	7b42      	ldrb	r2, [r0, #13]
   46a1a:	06d2      	lsls	r2, r2, #27
   46a1c:	d111      	bne.n	46a42 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   46a1e:	4a0d      	ldr	r2, [pc, #52]	; (46a54 <z_time_slice+0x7c>)
   46a20:	f990 600e 	ldrsb.w	r6, [r0, #14]
   46a24:	6812      	ldr	r2, [r2, #0]
   46a26:	4296      	cmp	r6, r2
   46a28:	db0b      	blt.n	46a42 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   46a2a:	4a0b      	ldr	r2, [pc, #44]	; (46a58 <z_time_slice+0x80>)
   46a2c:	4290      	cmp	r0, r2
   46a2e:	d008      	beq.n	46a42 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   46a30:	691a      	ldr	r2, [r3, #16]
   46a32:	428a      	cmp	r2, r1
   46a34:	dc02      	bgt.n	46a3c <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   46a36:	f7ff ff91 	bl	4695c <move_thread_to_end_of_prio_q>
   46a3a:	e7de      	b.n	469fa <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   46a3c:	1a52      	subs	r2, r2, r1
   46a3e:	611a      	str	r2, [r3, #16]
   46a40:	e7dd      	b.n	469fe <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   46a42:	2300      	movs	r3, #0
   46a44:	612b      	str	r3, [r5, #16]
   46a46:	e7da      	b.n	469fe <z_time_slice+0x26>
   46a48:	2001ada0 	.word	0x2001ada0
   46a4c:	2001adc8 	.word	0x2001adc8
   46a50:	2001add0 	.word	0x2001add0
   46a54:	2001adcc 	.word	0x2001adcc
   46a58:	2001a780 	.word	0x2001a780

00046a5c <ready_thread>:
{
   46a5c:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   46a5e:	f990 300d 	ldrsb.w	r3, [r0, #13]
   46a62:	7b42      	ldrb	r2, [r0, #13]
   46a64:	2b00      	cmp	r3, #0
   46a66:	db2d      	blt.n	46ac4 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46a68:	06d3      	lsls	r3, r2, #27
   46a6a:	d12b      	bne.n	46ac4 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   46a6c:	6983      	ldr	r3, [r0, #24]
   46a6e:	bb4b      	cbnz	r3, 46ac4 <ready_thread+0x68>
	return list->head == list;
   46a70:	4915      	ldr	r1, [pc, #84]	; (46ac8 <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46a72:	f062 027f 	orn	r2, r2, #127	; 0x7f
   46a76:	7342      	strb	r2, [r0, #13]
   46a78:	460a      	mov	r2, r1
   46a7a:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46a7e:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46a80:	4294      	cmp	r4, r2
   46a82:	bf18      	it	ne
   46a84:	4623      	movne	r3, r4
   46a86:	2b00      	cmp	r3, #0
   46a88:	bf38      	it	cc
   46a8a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46a8c:	b1ab      	cbz	r3, 46aba <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   46a8e:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   46a92:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   46a96:	42a6      	cmp	r6, r4
   46a98:	d00b      	beq.n	46ab2 <ready_thread+0x56>
		return b2 - b1;
   46a9a:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46a9c:	2c00      	cmp	r4, #0
   46a9e:	dd08      	ble.n	46ab2 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   46aa0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46aa2:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   46aa6:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   46aa8:	6058      	str	r0, [r3, #4]
		update_cache(0);
   46aaa:	2000      	movs	r0, #0
}
   46aac:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   46aae:	f7ff bf35 	b.w	4691c <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46ab2:	42ab      	cmp	r3, r5
   46ab4:	d001      	beq.n	46aba <ready_thread+0x5e>
   46ab6:	681b      	ldr	r3, [r3, #0]
   46ab8:	e7e8      	b.n	46a8c <ready_thread+0x30>
	node->prev = tail;
   46aba:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   46abe:	6028      	str	r0, [r5, #0]
	list->tail = node;
   46ac0:	6248      	str	r0, [r1, #36]	; 0x24
}
   46ac2:	e7f2      	b.n	46aaa <ready_thread+0x4e>
}
   46ac4:	bc70      	pop	{r4, r5, r6}
   46ac6:	4770      	bx	lr
   46ac8:	2001ada0 	.word	0x2001ada0

00046acc <z_sched_start>:
{
   46acc:	b510      	push	{r4, lr}
	__asm__ volatile(
   46ace:	f04f 0220 	mov.w	r2, #32
   46ad2:	f3ef 8411 	mrs	r4, BASEPRI
   46ad6:	f382 8812 	msr	BASEPRI_MAX, r2
   46ada:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   46ade:	7b42      	ldrb	r2, [r0, #13]
   46ae0:	0751      	lsls	r1, r2, #29
   46ae2:	d404      	bmi.n	46aee <z_sched_start+0x22>
	__asm__ volatile(
   46ae4:	f384 8811 	msr	BASEPRI, r4
   46ae8:	f3bf 8f6f 	isb	sy
}
   46aec:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   46aee:	f022 0204 	bic.w	r2, r2, #4
   46af2:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   46af4:	f7ff ffb2 	bl	46a5c <ready_thread>
	z_reschedule(&sched_spinlock, key);
   46af8:	4621      	mov	r1, r4
}
   46afa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   46afe:	4801      	ldr	r0, [pc, #4]	; (46b04 <z_sched_start+0x38>)
   46b00:	f7ff bee6 	b.w	468d0 <z_reschedule>
   46b04:	20020b3f 	.word	0x20020b3f

00046b08 <unready_thread>:
{
   46b08:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   46b0a:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46b0e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46b10:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46b12:	7b43      	ldrb	r3, [r0, #13]
   46b14:	da04      	bge.n	46b20 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46b16:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46b1a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46b1c:	f001 ff73 	bl	48a06 <sys_dlist_remove>
	update_cache(thread == _current);
   46b20:	4b04      	ldr	r3, [pc, #16]	; (46b34 <unready_thread+0x2c>)
   46b22:	6898      	ldr	r0, [r3, #8]
   46b24:	1a43      	subs	r3, r0, r1
   46b26:	4258      	negs	r0, r3
   46b28:	4158      	adcs	r0, r3
}
   46b2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   46b2e:	f7ff bef5 	b.w	4691c <update_cache>
   46b32:	bf00      	nop
   46b34:	2001ada0 	.word	0x2001ada0

00046b38 <pend>:
{
   46b38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46b3c:	4606      	mov	r6, r0
   46b3e:	4614      	mov	r4, r2
   46b40:	461d      	mov	r5, r3
	__asm__ volatile(
   46b42:	f04f 0320 	mov.w	r3, #32
   46b46:	f3ef 8711 	mrs	r7, BASEPRI
   46b4a:	f383 8812 	msr	BASEPRI_MAX, r3
   46b4e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   46b52:	f001 ffe0 	bl	48b16 <add_to_waitq_locked>
	__asm__ volatile(
   46b56:	f387 8811 	msr	BASEPRI, r7
   46b5a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46b5e:	1c6b      	adds	r3, r5, #1
   46b60:	bf08      	it	eq
   46b62:	f1b4 3fff 	cmpeq.w	r4, #4294967295	; 0xffffffff
   46b66:	d008      	beq.n	46b7a <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46b68:	4622      	mov	r2, r4
   46b6a:	462b      	mov	r3, r5
   46b6c:	f106 0018 	add.w	r0, r6, #24
   46b70:	4903      	ldr	r1, [pc, #12]	; (46b80 <pend+0x48>)
}
   46b72:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   46b76:	f000 ba23 	b.w	46fc0 <z_add_timeout>
   46b7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46b7e:	bf00      	nop
   46b80:	00048ad3 	.word	0x00048ad3

00046b84 <z_pend_curr>:
{
   46b84:	b510      	push	{r4, lr}
   46b86:	460c      	mov	r4, r1
	pending_current = _current;
   46b88:	4b06      	ldr	r3, [pc, #24]	; (46ba4 <z_pend_curr+0x20>)
{
   46b8a:	4611      	mov	r1, r2
	pending_current = _current;
   46b8c:	6898      	ldr	r0, [r3, #8]
   46b8e:	4b06      	ldr	r3, [pc, #24]	; (46ba8 <z_pend_curr+0x24>)
   46b90:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   46b92:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   46b96:	f7ff ffcf 	bl	46b38 <pend>
   46b9a:	4620      	mov	r0, r4
}
   46b9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   46ba0:	f7fb bb0e 	b.w	421c0 <arch_swap>
   46ba4:	2001ada0 	.word	0x2001ada0
   46ba8:	2001adc8 	.word	0x2001adc8

00046bac <z_set_prio>:
{
   46bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   46bae:	4604      	mov	r4, r0
	__asm__ volatile(
   46bb0:	f04f 0320 	mov.w	r3, #32
   46bb4:	f3ef 8611 	mrs	r6, BASEPRI
   46bb8:	f383 8812 	msr	BASEPRI_MAX, r3
   46bbc:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46bc0:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   46bc2:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46bc4:	06da      	lsls	r2, r3, #27
   46bc6:	d138      	bne.n	46c3a <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   46bc8:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   46bca:	2d00      	cmp	r5, #0
   46bcc:	d135      	bne.n	46c3a <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46bce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46bd2:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46bd4:	f001 ff17 	bl	48a06 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   46bd8:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   46bda:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   46bdc:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46be0:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   46be2:	4817      	ldr	r0, [pc, #92]	; (46c40 <z_set_prio+0x94>)
   46be4:	4603      	mov	r3, r0
   46be6:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46bea:	429f      	cmp	r7, r3
   46bec:	bf18      	it	ne
   46bee:	463d      	movne	r5, r7
   46bf0:	2d00      	cmp	r5, #0
   46bf2:	461a      	mov	r2, r3
   46bf4:	462b      	mov	r3, r5
   46bf6:	bf38      	it	cc
   46bf8:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46bfa:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46bfc:	b1c3      	cbz	r3, 46c30 <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   46bfe:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46c02:	42a9      	cmp	r1, r5
   46c04:	d010      	beq.n	46c28 <z_set_prio+0x7c>
		return b2 - b1;
   46c06:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   46c08:	2d00      	cmp	r5, #0
   46c0a:	dd0d      	ble.n	46c28 <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   46c0c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46c0e:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   46c12:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   46c14:	605c      	str	r4, [r3, #4]
			update_cache(1);
   46c16:	2001      	movs	r0, #1
   46c18:	f7ff fe80 	bl	4691c <update_cache>
   46c1c:	2001      	movs	r0, #1
	__asm__ volatile(
   46c1e:	f386 8811 	msr	BASEPRI, r6
   46c22:	f3bf 8f6f 	isb	sy
}
   46c26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   46c28:	42bb      	cmp	r3, r7
   46c2a:	d001      	beq.n	46c30 <z_set_prio+0x84>
   46c2c:	681b      	ldr	r3, [r3, #0]
   46c2e:	e7e5      	b.n	46bfc <z_set_prio+0x50>
	node->prev = tail;
   46c30:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   46c34:	603c      	str	r4, [r7, #0]
	list->tail = node;
   46c36:	6244      	str	r4, [r0, #36]	; 0x24
}
   46c38:	e7ed      	b.n	46c16 <z_set_prio+0x6a>
			thread->base.prio = prio;
   46c3a:	2000      	movs	r0, #0
   46c3c:	73a1      	strb	r1, [r4, #14]
   46c3e:	e7ee      	b.n	46c1e <z_set_prio+0x72>
   46c40:	2001ada0 	.word	0x2001ada0

00046c44 <z_impl_k_thread_suspend>:
{
   46c44:	b570      	push	{r4, r5, r6, lr}
   46c46:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   46c48:	3018      	adds	r0, #24
   46c4a:	f001 ffce 	bl	48bea <z_abort_timeout>
	__asm__ volatile(
   46c4e:	f04f 0320 	mov.w	r3, #32
   46c52:	f3ef 8611 	mrs	r6, BASEPRI
   46c56:	f383 8812 	msr	BASEPRI_MAX, r3
   46c5a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   46c5e:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46c62:	7b63      	ldrb	r3, [r4, #13]
   46c64:	2a00      	cmp	r2, #0
   46c66:	da05      	bge.n	46c74 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46c68:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   46c6c:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46c6e:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46c70:	f001 fec9 	bl	48a06 <sys_dlist_remove>
		update_cache(thread == _current);
   46c74:	4d0b      	ldr	r5, [pc, #44]	; (46ca4 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   46c76:	7b63      	ldrb	r3, [r4, #13]
   46c78:	68a8      	ldr	r0, [r5, #8]
   46c7a:	f043 0310 	orr.w	r3, r3, #16
   46c7e:	7363      	strb	r3, [r4, #13]
   46c80:	1b03      	subs	r3, r0, r4
   46c82:	4258      	negs	r0, r3
   46c84:	4158      	adcs	r0, r3
   46c86:	f7ff fe49 	bl	4691c <update_cache>
	__asm__ volatile(
   46c8a:	f386 8811 	msr	BASEPRI, r6
   46c8e:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   46c92:	68ab      	ldr	r3, [r5, #8]
   46c94:	42a3      	cmp	r3, r4
   46c96:	d103      	bne.n	46ca0 <z_impl_k_thread_suspend+0x5c>
}
   46c98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   46c9c:	f001 bef5 	b.w	48a8a <z_reschedule_unlocked>
}
   46ca0:	bd70      	pop	{r4, r5, r6, pc}
   46ca2:	bf00      	nop
   46ca4:	2001ada0 	.word	0x2001ada0

00046ca8 <k_sched_unlock>:
{
   46ca8:	b510      	push	{r4, lr}
	__asm__ volatile(
   46caa:	f04f 0320 	mov.w	r3, #32
   46cae:	f3ef 8411 	mrs	r4, BASEPRI
   46cb2:	f383 8812 	msr	BASEPRI_MAX, r3
   46cb6:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   46cba:	4b08      	ldr	r3, [pc, #32]	; (46cdc <k_sched_unlock+0x34>)
		update_cache(0);
   46cbc:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   46cbe:	689a      	ldr	r2, [r3, #8]
   46cc0:	7bd3      	ldrb	r3, [r2, #15]
   46cc2:	3301      	adds	r3, #1
   46cc4:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   46cc6:	f7ff fe29 	bl	4691c <update_cache>
	__asm__ volatile(
   46cca:	f384 8811 	msr	BASEPRI, r4
   46cce:	f3bf 8f6f 	isb	sy
}
   46cd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   46cd6:	f001 bed8 	b.w	48a8a <z_reschedule_unlocked>
   46cda:	bf00      	nop
   46cdc:	2001ada0 	.word	0x2001ada0

00046ce0 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   46ce0:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   46ce2:	4b04      	ldr	r3, [pc, #16]	; (46cf4 <z_sched_init+0x14>)
   46ce4:	4608      	mov	r0, r1
   46ce6:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   46cea:	e9c3 2208 	strd	r2, r2, [r3, #32]
   46cee:	f7ff bdcb 	b.w	46888 <k_sched_time_slice_set>
   46cf2:	bf00      	nop
   46cf4:	2001ada0 	.word	0x2001ada0

00046cf8 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   46cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   46cfa:	f04f 0320 	mov.w	r3, #32
   46cfe:	f3ef 8411 	mrs	r4, BASEPRI
   46d02:	f383 8812 	msr	BASEPRI_MAX, r3
   46d06:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   46d0a:	491b      	ldr	r1, [pc, #108]	; (46d78 <z_impl_k_yield+0x80>)
   46d0c:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46d0e:	7b43      	ldrb	r3, [r0, #13]
   46d10:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46d14:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46d16:	f001 fe76 	bl	48a06 <sys_dlist_remove>
	return list->head == list;
   46d1a:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   46d1c:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   46d1e:	7b53      	ldrb	r3, [r2, #13]
   46d20:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46d24:	7353      	strb	r3, [r2, #13]
   46d26:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46d2a:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46d2c:	4283      	cmp	r3, r0
   46d2e:	bf08      	it	eq
   46d30:	2300      	moveq	r3, #0
   46d32:	2b00      	cmp	r3, #0
   46d34:	bf38      	it	cc
   46d36:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46d38:	b1cb      	cbz	r3, 46d6e <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   46d3a:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   46d3e:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46d42:	42af      	cmp	r7, r5
   46d44:	d00f      	beq.n	46d66 <z_impl_k_yield+0x6e>
		return b2 - b1;
   46d46:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   46d48:	2d00      	cmp	r5, #0
   46d4a:	dd0c      	ble.n	46d66 <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   46d4c:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   46d4e:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   46d52:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   46d54:	605a      	str	r2, [r3, #4]
	update_cache(1);
   46d56:	2001      	movs	r0, #1
   46d58:	f7ff fde0 	bl	4691c <update_cache>
   46d5c:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   46d5e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   46d62:	f7fb ba2d 	b.w	421c0 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   46d66:	42b3      	cmp	r3, r6
   46d68:	d001      	beq.n	46d6e <z_impl_k_yield+0x76>
   46d6a:	681b      	ldr	r3, [r3, #0]
   46d6c:	e7e4      	b.n	46d38 <z_impl_k_yield+0x40>
	node->prev = tail;
   46d6e:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   46d72:	6032      	str	r2, [r6, #0]
	list->tail = node;
   46d74:	624a      	str	r2, [r1, #36]	; 0x24
}
   46d76:	e7ee      	b.n	46d56 <z_impl_k_yield+0x5e>
   46d78:	2001ada0 	.word	0x2001ada0

00046d7c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   46d7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46d80:	4604      	mov	r4, r0
   46d82:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   46d84:	ea54 0105 	orrs.w	r1, r4, r5
   46d88:	d104      	bne.n	46d94 <z_tick_sleep+0x18>
	z_impl_k_yield();
   46d8a:	f7ff ffb5 	bl	46cf8 <z_impl_k_yield>
		k_yield();
		return 0;
   46d8e:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   46d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   46d94:	f06f 0101 	mvn.w	r1, #1
   46d98:	1a0a      	subs	r2, r1, r0
   46d9a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   46d9e:	eb61 0305 	sbc.w	r3, r1, r5
   46da2:	2a01      	cmp	r2, #1
   46da4:	f173 0300 	sbcs.w	r3, r3, #0
   46da8:	da2a      	bge.n	46e00 <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   46daa:	f001 ff5e 	bl	48c6a <sys_clock_tick_get_32>
   46dae:	1906      	adds	r6, r0, r4
   46db0:	f04f 0320 	mov.w	r3, #32
   46db4:	f3ef 8811 	mrs	r8, BASEPRI
   46db8:	f383 8812 	msr	BASEPRI_MAX, r3
   46dbc:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   46dc0:	4f11      	ldr	r7, [pc, #68]	; (46e08 <z_tick_sleep+0x8c>)
   46dc2:	4b12      	ldr	r3, [pc, #72]	; (46e0c <z_tick_sleep+0x90>)
   46dc4:	68b8      	ldr	r0, [r7, #8]
   46dc6:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   46dc8:	f7ff fe9e 	bl	46b08 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   46dcc:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46dce:	4910      	ldr	r1, [pc, #64]	; (46e10 <z_tick_sleep+0x94>)
   46dd0:	4622      	mov	r2, r4
   46dd2:	462b      	mov	r3, r5
   46dd4:	3018      	adds	r0, #24
   46dd6:	f000 f8f3 	bl	46fc0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   46dda:	68ba      	ldr	r2, [r7, #8]
   46ddc:	4640      	mov	r0, r8
   46dde:	7b53      	ldrb	r3, [r2, #13]
   46de0:	f043 0310 	orr.w	r3, r3, #16
   46de4:	7353      	strb	r3, [r2, #13]
   46de6:	f7fb f9eb 	bl	421c0 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   46dea:	f001 ff3e 	bl	48c6a <sys_clock_tick_get_32>
   46dee:	1a30      	subs	r0, r6, r0
   46df0:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   46df4:	2801      	cmp	r0, #1
   46df6:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   46dfa:	bfb8      	it	lt
   46dfc:	2000      	movlt	r0, #0
   46dfe:	e7c7      	b.n	46d90 <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   46e00:	f06f 0601 	mvn.w	r6, #1
   46e04:	1a36      	subs	r6, r6, r0
   46e06:	e7d3      	b.n	46db0 <z_tick_sleep+0x34>
   46e08:	2001ada0 	.word	0x2001ada0
   46e0c:	2001adc8 	.word	0x2001adc8
   46e10:	00048ad3 	.word	0x00048ad3

00046e14 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   46e14:	b508      	push	{r3, lr}
   46e16:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46e18:	3301      	adds	r3, #1
   46e1a:	bf08      	it	eq
   46e1c:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   46e20:	d003      	beq.n	46e2a <z_impl_k_sleep+0x16>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   46e22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ticks = z_tick_sleep(ticks);
   46e26:	f7ff bfa9 	b.w	46d7c <z_tick_sleep>
		k_thread_suspend(_current);
   46e2a:	4b03      	ldr	r3, [pc, #12]	; (46e38 <z_impl_k_sleep+0x24>)
   46e2c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   46e2e:	f7ff ff09 	bl	46c44 <z_impl_k_thread_suspend>
}
   46e32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   46e36:	bd08      	pop	{r3, pc}
   46e38:	2001ada0 	.word	0x2001ada0

00046e3c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   46e3c:	4b01      	ldr	r3, [pc, #4]	; (46e44 <z_impl_z_current_get+0x8>)
   46e3e:	6898      	ldr	r0, [r3, #8]
   46e40:	4770      	bx	lr
   46e42:	bf00      	nop
   46e44:	2001ada0 	.word	0x2001ada0

00046e48 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   46e48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46e4c:	4604      	mov	r4, r0
   46e4e:	f04f 0320 	mov.w	r3, #32
   46e52:	f3ef 8611 	mrs	r6, BASEPRI
   46e56:	f383 8812 	msr	BASEPRI_MAX, r3
   46e5a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   46e5e:	7b43      	ldrb	r3, [r0, #13]
   46e60:	071a      	lsls	r2, r3, #28
   46e62:	d505      	bpl.n	46e70 <z_thread_abort+0x28>
	__asm__ volatile(
   46e64:	f386 8811 	msr	BASEPRI, r6
   46e68:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   46e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46e70:	f023 0220 	bic.w	r2, r3, #32
   46e74:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   46e78:	09d2      	lsrs	r2, r2, #7
   46e7a:	d120      	bne.n	46ebe <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   46e7c:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   46e7e:	68a3      	ldr	r3, [r4, #8]
   46e80:	b113      	cbz	r3, 46e88 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   46e82:	4620      	mov	r0, r4
   46e84:	f001 fdc7 	bl	48a16 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   46e88:	f104 0018 	add.w	r0, r4, #24
   46e8c:	f001 fead 	bl	48bea <z_abort_timeout>
   46e90:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   46e94:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   46e98:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46e9a:	42bd      	cmp	r5, r7
   46e9c:	d000      	beq.n	46ea0 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   46e9e:	b9b5      	cbnz	r5, 46ece <z_thread_abort+0x86>
		update_cache(1);
   46ea0:	2001      	movs	r0, #1
   46ea2:	f7ff fd3b 	bl	4691c <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   46ea6:	4b10      	ldr	r3, [pc, #64]	; (46ee8 <z_thread_abort+0xa0>)
   46ea8:	689b      	ldr	r3, [r3, #8]
   46eaa:	42a3      	cmp	r3, r4
   46eac:	d1da      	bne.n	46e64 <z_thread_abort+0x1c>
   46eae:	f3ef 8305 	mrs	r3, IPSR
   46eb2:	2b00      	cmp	r3, #0
   46eb4:	d1d6      	bne.n	46e64 <z_thread_abort+0x1c>
   46eb6:	4630      	mov	r0, r6
   46eb8:	f7fb f982 	bl	421c0 <arch_swap>
	return ret;
   46ebc:	e7d2      	b.n	46e64 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46ebe:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   46ec2:	f043 0308 	orr.w	r3, r3, #8
   46ec6:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46ec8:	f001 fd9d 	bl	48a06 <sys_dlist_remove>
}
   46ecc:	e7d7      	b.n	46e7e <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   46ece:	4628      	mov	r0, r5
   46ed0:	f001 fda1 	bl	48a16 <unpend_thread_no_timeout>
   46ed4:	f105 0018 	add.w	r0, r5, #24
   46ed8:	f001 fe87 	bl	48bea <z_abort_timeout>
		ready_thread(thread);
   46edc:	4628      	mov	r0, r5
   46ede:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   46ee2:	f7ff fdbb 	bl	46a5c <ready_thread>
   46ee6:	e7d7      	b.n	46e98 <z_thread_abort+0x50>
   46ee8:	2001ada0 	.word	0x2001ada0

00046eec <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   46eec:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   46eee:	4806      	ldr	r0, [pc, #24]	; (46f08 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   46ef0:	4a06      	ldr	r2, [pc, #24]	; (46f0c <z_data_copy+0x20>)
   46ef2:	4907      	ldr	r1, [pc, #28]	; (46f10 <z_data_copy+0x24>)
   46ef4:	1a12      	subs	r2, r2, r0
   46ef6:	f001 f9e8 	bl	482ca <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   46efa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   46efe:	4a05      	ldr	r2, [pc, #20]	; (46f14 <z_data_copy+0x28>)
   46f00:	4905      	ldr	r1, [pc, #20]	; (46f18 <z_data_copy+0x2c>)
   46f02:	4806      	ldr	r0, [pc, #24]	; (46f1c <z_data_copy+0x30>)
   46f04:	f001 b9e1 	b.w	482ca <memcpy>
   46f08:	2001a500 	.word	0x2001a500
   46f0c:	2001a68c 	.word	0x2001a68c
   46f10:	00049b84 	.word	0x00049b84
   46f14:	00000000 	.word	0x00000000
   46f18:	00049b6c 	.word	0x00049b6c
   46f1c:	2001a500 	.word	0x2001a500

00046f20 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   46f20:	4b03      	ldr	r3, [pc, #12]	; (46f30 <elapsed+0x10>)
   46f22:	681b      	ldr	r3, [r3, #0]
   46f24:	b90b      	cbnz	r3, 46f2a <elapsed+0xa>
   46f26:	f7fc bddf 	b.w	43ae8 <sys_clock_elapsed>
}
   46f2a:	2000      	movs	r0, #0
   46f2c:	4770      	bx	lr
   46f2e:	bf00      	nop
   46f30:	2001add4 	.word	0x2001add4

00046f34 <remove_timeout>:
{
   46f34:	b530      	push	{r4, r5, lr}
   46f36:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46f38:	b168      	cbz	r0, 46f56 <remove_timeout+0x22>
   46f3a:	4a0a      	ldr	r2, [pc, #40]	; (46f64 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   46f3c:	6852      	ldr	r2, [r2, #4]
   46f3e:	4290      	cmp	r0, r2
   46f40:	d009      	beq.n	46f56 <remove_timeout+0x22>
	if (next(t) != NULL) {
   46f42:	b143      	cbz	r3, 46f56 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   46f44:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   46f48:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   46f4c:	1912      	adds	r2, r2, r4
   46f4e:	eb45 0101 	adc.w	r1, r5, r1
   46f52:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   46f56:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   46f58:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   46f5a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   46f5c:	2300      	movs	r3, #0
	node->prev = NULL;
   46f5e:	e9c0 3300 	strd	r3, r3, [r0]
}
   46f62:	bd30      	pop	{r4, r5, pc}
   46f64:	2001a5f8 	.word	0x2001a5f8

00046f68 <next_timeout>:

static int32_t next_timeout(void)
{
   46f68:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   46f6a:	4b13      	ldr	r3, [pc, #76]	; (46fb8 <next_timeout+0x50>)
   46f6c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f6e:	429c      	cmp	r4, r3
   46f70:	bf08      	it	eq
   46f72:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   46f74:	f7ff ffd4 	bl	46f20 <elapsed>
   46f78:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   46f7a:	b1bc      	cbz	r4, 46fac <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46f7c:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   46f80:	1b40      	subs	r0, r0, r5
   46f82:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   46f86:	2801      	cmp	r0, #1
   46f88:	f171 0300 	sbcs.w	r3, r1, #0
   46f8c:	db11      	blt.n	46fb2 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   46f8e:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   46f92:	2300      	movs	r3, #0
   46f94:	4282      	cmp	r2, r0
   46f96:	eb73 0401 	sbcs.w	r4, r3, r1
   46f9a:	da00      	bge.n	46f9e <next_timeout+0x36>
   46f9c:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   46f9e:	4b07      	ldr	r3, [pc, #28]	; (46fbc <next_timeout+0x54>)
   46fa0:	691b      	ldr	r3, [r3, #16]
   46fa2:	b113      	cbz	r3, 46faa <next_timeout+0x42>
   46fa4:	4298      	cmp	r0, r3
   46fa6:	bfa8      	it	ge
   46fa8:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   46faa:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   46fac:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   46fb0:	e7f5      	b.n	46f9e <next_timeout+0x36>
   46fb2:	2000      	movs	r0, #0
   46fb4:	e7f3      	b.n	46f9e <next_timeout+0x36>
   46fb6:	bf00      	nop
   46fb8:	2001a5f8 	.word	0x2001a5f8
   46fbc:	2001ada0 	.word	0x2001ada0

00046fc0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46fc0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   46fc4:	bf08      	it	eq
   46fc6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   46fca:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   46fce:	4604      	mov	r4, r0
   46fd0:	4692      	mov	sl, r2
   46fd2:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46fd4:	d073      	beq.n	470be <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   46fd6:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   46fd8:	f04f 0320 	mov.w	r3, #32
   46fdc:	f3ef 8511 	mrs	r5, BASEPRI
   46fe0:	f383 8812 	msr	BASEPRI_MAX, r3
   46fe4:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   46fe8:	f06f 0301 	mvn.w	r3, #1
   46fec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   46ff0:	ebb3 080a 	subs.w	r8, r3, sl
   46ff4:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   46ff8:	f1b8 0f00 	cmp.w	r8, #0
   46ffc:	f179 0100 	sbcs.w	r1, r9, #0
   47000:	db1c      	blt.n	4703c <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   47002:	4830      	ldr	r0, [pc, #192]	; (470c4 <z_add_timeout+0x104>)
   47004:	e9d0 1000 	ldrd	r1, r0, [r0]
   47008:	1a5b      	subs	r3, r3, r1
   4700a:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   4700e:	ebb3 060a 	subs.w	r6, r3, sl
   47012:	eb62 070b 	sbc.w	r7, r2, fp
   47016:	2e01      	cmp	r6, #1
   47018:	f177 0300 	sbcs.w	r3, r7, #0
   4701c:	bfbc      	itt	lt
   4701e:	2601      	movlt	r6, #1
   47020:	2700      	movlt	r7, #0
   47022:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   47026:	4a28      	ldr	r2, [pc, #160]	; (470c8 <z_add_timeout+0x108>)
   47028:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4702c:	4293      	cmp	r3, r2
   4702e:	d11e      	bne.n	4706e <z_add_timeout+0xae>
	node->prev = tail;
   47030:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   47034:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   47038:	6054      	str	r4, [r2, #4]
}
   4703a:	e02d      	b.n	47098 <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   4703c:	f7ff ff70 	bl	46f20 <elapsed>
   47040:	f11a 0301 	adds.w	r3, sl, #1
   47044:	9300      	str	r3, [sp, #0]
   47046:	f14b 0300 	adc.w	r3, fp, #0
   4704a:	9301      	str	r3, [sp, #4]
   4704c:	e9dd 2300 	ldrd	r2, r3, [sp]
   47050:	1812      	adds	r2, r2, r0
   47052:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   47056:	e9c4 2304 	strd	r2, r3, [r4, #16]
   4705a:	e7e4      	b.n	47026 <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   4705c:	ebb6 0008 	subs.w	r0, r6, r8
   47060:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   47064:	4563      	cmp	r3, ip
   47066:	e9c4 0104 	strd	r0, r1, [r4, #16]
   4706a:	d0e1      	beq.n	47030 <z_add_timeout+0x70>
   4706c:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   4706e:	2b00      	cmp	r3, #0
   47070:	d0de      	beq.n	47030 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   47072:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   47076:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   4707a:	4546      	cmp	r6, r8
   4707c:	eb77 0109 	sbcs.w	r1, r7, r9
   47080:	daec      	bge.n	4705c <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   47082:	ebb8 0006 	subs.w	r0, r8, r6
   47086:	eb69 0107 	sbc.w	r1, r9, r7
   4708a:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   4708e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   47090:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   47094:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   47096:	605c      	str	r4, [r3, #4]
	return list->head == list;
   47098:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4709a:	4293      	cmp	r3, r2
   4709c:	d00b      	beq.n	470b6 <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   4709e:	429c      	cmp	r4, r3
   470a0:	d109      	bne.n	470b6 <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   470a2:	f7ff ff61 	bl	46f68 <next_timeout>

			if (next_time == 0 ||
   470a6:	b118      	cbz	r0, 470b0 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   470a8:	4b08      	ldr	r3, [pc, #32]	; (470cc <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   470aa:	691b      	ldr	r3, [r3, #16]
   470ac:	4283      	cmp	r3, r0
   470ae:	d002      	beq.n	470b6 <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   470b0:	2100      	movs	r1, #0
   470b2:	f7fc fce5 	bl	43a80 <sys_clock_set_timeout>
	__asm__ volatile(
   470b6:	f385 8811 	msr	BASEPRI, r5
   470ba:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   470be:	b003      	add	sp, #12
   470c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   470c4:	2001a880 	.word	0x2001a880
   470c8:	2001a5f8 	.word	0x2001a5f8
   470cc:	2001ada0 	.word	0x2001ada0

000470d0 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   470d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   470d4:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   470d6:	f7ff fc7f 	bl	469d8 <z_time_slice>
	__asm__ volatile(
   470da:	f04f 0320 	mov.w	r3, #32
   470de:	f3ef 8411 	mrs	r4, BASEPRI
   470e2:	f383 8812 	msr	BASEPRI_MAX, r3
   470e6:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   470ea:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 4719c <sys_clock_announce+0xcc>
   470ee:	4d2a      	ldr	r5, [pc, #168]	; (47198 <sys_clock_announce+0xc8>)
   470f0:	4651      	mov	r1, sl
	return list->head == list;
   470f2:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 471a0 <sys_clock_announce+0xd0>
   470f6:	602e      	str	r6, [r5, #0]
   470f8:	f8d5 c000 	ldr.w	ip, [r5]
   470fc:	f8db 0000 	ldr.w	r0, [fp]
   47100:	4662      	mov	r2, ip
   47102:	e9da 8900 	ldrd	r8, r9, [sl]
   47106:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47108:	4558      	cmp	r0, fp
   4710a:	e9cd 2300 	strd	r2, r3, [sp]
   4710e:	d00d      	beq.n	4712c <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   47110:	b160      	cbz	r0, 4712c <sys_clock_announce+0x5c>
   47112:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   47116:	45b4      	cmp	ip, r6
   47118:	41bb      	sbcs	r3, r7
   4711a:	da1d      	bge.n	47158 <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   4711c:	9b00      	ldr	r3, [sp, #0]
   4711e:	ebb6 0c03 	subs.w	ip, r6, r3
   47122:	9b01      	ldr	r3, [sp, #4]
   47124:	eb67 0603 	sbc.w	r6, r7, r3
   47128:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   4712c:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   4712e:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   47130:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   47132:	eb13 0208 	adds.w	r2, r3, r8
   47136:	9b01      	ldr	r3, [sp, #4]
   47138:	eb43 0309 	adc.w	r3, r3, r9
   4713c:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   47140:	f7ff ff12 	bl	46f68 <next_timeout>
   47144:	4631      	mov	r1, r6
   47146:	f7fc fc9b 	bl	43a80 <sys_clock_set_timeout>
	__asm__ volatile(
   4714a:	f384 8811 	msr	BASEPRI, r4
   4714e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   47152:	b003      	add	sp, #12
   47154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   47158:	2200      	movs	r2, #0
   4715a:	2300      	movs	r3, #0
		curr_tick += dt;
   4715c:	eb18 0806 	adds.w	r8, r8, r6
   47160:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   47164:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   47168:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   4716c:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   47170:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   47172:	f7ff fedf 	bl	46f34 <remove_timeout>
   47176:	f384 8811 	msr	BASEPRI, r4
   4717a:	f3bf 8f6f 	isb	sy
		t->fn(t);
   4717e:	6883      	ldr	r3, [r0, #8]
   47180:	4798      	blx	r3
	__asm__ volatile(
   47182:	f04f 0320 	mov.w	r3, #32
   47186:	f3ef 8411 	mrs	r4, BASEPRI
   4718a:	f383 8812 	msr	BASEPRI_MAX, r3
   4718e:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   47192:	4902      	ldr	r1, [pc, #8]	; (4719c <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   47194:	e7b0      	b.n	470f8 <sys_clock_announce+0x28>
   47196:	bf00      	nop
   47198:	2001add4 	.word	0x2001add4
   4719c:	2001a880 	.word	0x2001a880
   471a0:	2001a5f8 	.word	0x2001a5f8

000471a4 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   471a4:	b510      	push	{r4, lr}
   471a6:	f04f 0320 	mov.w	r3, #32
   471aa:	f3ef 8411 	mrs	r4, BASEPRI
   471ae:	f383 8812 	msr	BASEPRI_MAX, r3
   471b2:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   471b6:	f7fc fc97 	bl	43ae8 <sys_clock_elapsed>
   471ba:	4b06      	ldr	r3, [pc, #24]	; (471d4 <sys_clock_tick_get+0x30>)
   471bc:	e9d3 2300 	ldrd	r2, r3, [r3]
   471c0:	1812      	adds	r2, r2, r0
   471c2:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   471c6:	f384 8811 	msr	BASEPRI, r4
   471ca:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   471ce:	4610      	mov	r0, r2
   471d0:	4619      	mov	r1, r3
   471d2:	bd10      	pop	{r4, pc}
   471d4:	2001a880 	.word	0x2001a880

000471d8 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   471d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   471da:	4604      	mov	r4, r0
	__asm__ volatile(
   471dc:	f04f 0320 	mov.w	r3, #32
   471e0:	f3ef 8511 	mrs	r5, BASEPRI
   471e4:	f383 8812 	msr	BASEPRI_MAX, r3
   471e8:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   471ec:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   471f0:	1c56      	adds	r6, r2, #1
   471f2:	f143 0700 	adc.w	r7, r3, #0
   471f6:	2f00      	cmp	r7, #0
   471f8:	bf08      	it	eq
   471fa:	2e02      	cmpeq	r6, #2
   471fc:	d302      	bcc.n	47204 <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   471fe:	4917      	ldr	r1, [pc, #92]	; (4725c <z_timer_expiration_handler+0x84>)
   47200:	f7ff fede 	bl	46fc0 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   47204:	6b23      	ldr	r3, [r4, #48]	; 0x30
   47206:	3301      	adds	r3, #1
   47208:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   4720a:	6a23      	ldr	r3, [r4, #32]
   4720c:	b173      	cbz	r3, 4722c <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   4720e:	f385 8811 	msr	BASEPRI, r5
   47212:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   47216:	4620      	mov	r0, r4
   47218:	6a23      	ldr	r3, [r4, #32]
   4721a:	4798      	blx	r3
	__asm__ volatile(
   4721c:	f04f 0320 	mov.w	r3, #32
   47220:	f3ef 8511 	mrs	r5, BASEPRI
   47224:	f383 8812 	msr	BASEPRI_MAX, r3
   47228:	f3bf 8f6f 	isb	sy
	return list->head == list;
   4722c:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47230:	42a6      	cmp	r6, r4
   47232:	d000      	beq.n	47236 <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   47234:	b926      	cbnz	r6, 47240 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   47236:	f385 8811 	msr	BASEPRI, r5
   4723a:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   4723e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   47240:	4630      	mov	r0, r6
   47242:	f001 fbf2 	bl	48a2a <z_unpend_thread_no_timeout>
   47246:	2300      	movs	r3, #0
   47248:	67b3      	str	r3, [r6, #120]	; 0x78
   4724a:	f385 8811 	msr	BASEPRI, r5
   4724e:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   47252:	4630      	mov	r0, r6
}
   47254:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   47258:	f001 bc2b 	b.w	48ab2 <z_ready_thread>
   4725c:	000471d9 	.word	0x000471d9

00047260 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   47260:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   47264:	4619      	mov	r1, r3
   47266:	4606      	mov	r6, r0
   47268:	4610      	mov	r0, r2
   4726a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   4726e:	1c4c      	adds	r4, r1, #1
   47270:	bf08      	it	eq
   47272:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   47276:	4680      	mov	r8, r0
   47278:	4689      	mov	r9, r1
   4727a:	d04c      	beq.n	47316 <z_impl_k_timer_start+0xb6>
   4727c:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   4727e:	1c6b      	adds	r3, r5, #1
   47280:	bf08      	it	eq
   47282:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   47286:	4614      	mov	r4, r2
   47288:	d019      	beq.n	472be <z_impl_k_timer_start+0x5e>
   4728a:	ea54 0305 	orrs.w	r3, r4, r5
   4728e:	d016      	beq.n	472be <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   47290:	f06f 0301 	mvn.w	r3, #1
   47294:	ebb3 0a02 	subs.w	sl, r3, r2
   47298:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4729c:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   472a0:	f1ba 0f00 	cmp.w	sl, #0
   472a4:	f17b 0300 	sbcs.w	r3, fp, #0
   472a8:	da09      	bge.n	472be <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   472aa:	f112 34ff 	adds.w	r4, r2, #4294967295	; 0xffffffff
   472ae:	f145 35ff 	adc.w	r5, r5, #4294967295	; 0xffffffff
   472b2:	2c01      	cmp	r4, #1
   472b4:	f175 0300 	sbcs.w	r3, r5, #0
   472b8:	bfbc      	itt	lt
   472ba:	2401      	movlt	r4, #1
   472bc:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   472be:	f06f 0301 	mvn.w	r3, #1
   472c2:	1a1b      	subs	r3, r3, r0
   472c4:	9300      	str	r3, [sp, #0]
   472c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   472ca:	eb63 0301 	sbc.w	r3, r3, r1
   472ce:	9301      	str	r3, [sp, #4]
   472d0:	e9dd 2300 	ldrd	r2, r3, [sp]
   472d4:	2a00      	cmp	r2, #0
   472d6:	f173 0300 	sbcs.w	r3, r3, #0
   472da:	da0c      	bge.n	472f6 <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   472dc:	f110 38ff 	adds.w	r8, r0, #4294967295	; 0xffffffff
   472e0:	f141 39ff 	adc.w	r9, r1, #4294967295	; 0xffffffff
   472e4:	f1b8 0f00 	cmp.w	r8, #0
   472e8:	f179 0300 	sbcs.w	r3, r9, #0
   472ec:	bfbc      	itt	lt
   472ee:	f04f 0800 	movlt.w	r8, #0
   472f2:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   472f6:	4630      	mov	r0, r6
   472f8:	f001 fc77 	bl	48bea <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   472fc:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   472fe:	4642      	mov	r2, r8
	timer->status = 0U;
   47300:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47302:	4630      	mov	r0, r6
   47304:	464b      	mov	r3, r9
   47306:	4905      	ldr	r1, [pc, #20]	; (4731c <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   47308:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   4730c:	b002      	add	sp, #8
   4730e:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47312:	f7ff be55 	b.w	46fc0 <z_add_timeout>
}
   47316:	b002      	add	sp, #8
   47318:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   4731c:	000471d9 	.word	0x000471d9

00047320 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   47320:	460a      	mov	r2, r1
	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   47322:	4601      	mov	r1, r0
   47324:	4801      	ldr	r0, [pc, #4]	; (4732c <k_aligned_alloc+0xc>)
   47326:	f001 bcfc 	b.w	48d22 <z_heap_aligned_alloc>
   4732a:	bf00      	nop
   4732c:	2001a62c 	.word	0x2001a62c

00047330 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   47330:	4a02      	ldr	r2, [pc, #8]	; (4733c <boot_banner+0xc>)
   47332:	4903      	ldr	r1, [pc, #12]	; (47340 <boot_banner+0x10>)
   47334:	4803      	ldr	r0, [pc, #12]	; (47344 <boot_banner+0x14>)
   47336:	f000 b95e 	b.w	475f6 <printk>
   4733a:	bf00      	nop
   4733c:	00049306 	.word	0x00049306
   47340:	00049b33 	.word	0x00049b33
   47344:	00049b42 	.word	0x00049b42

00047348 <tfm_platform_system_reset>:
#include "tfm_ns_interface.h"
#include "tfm_veneers.h"

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   47348:	2300      	movs	r3, #0
{
   4734a:	b507      	push	{r0, r1, r2, lr}
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   4734c:	461a      	mov	r2, r3
   4734e:	4619      	mov	r1, r3
   47350:	9300      	str	r3, [sp, #0]
   47352:	4803      	ldr	r0, [pc, #12]	; (47360 <tfm_platform_system_reset+0x18>)
   47354:	f7fc fd94 	bl	43e80 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_platform_sp_system_reset_veneer,
                                0,
                                0,
                                0,
                                0);
}
   47358:	b003      	add	sp, #12
   4735a:	f85d fb04 	ldr.w	pc, [sp], #4
   4735e:	bf00      	nop
   47360:	00037e41 	.word	0x00037e41

00047364 <psa_generate_random>:
    return status;
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   47364:	b530      	push	{r4, r5, lr}
   47366:	b093      	sub	sp, #76	; 0x4c
   47368:	4605      	mov	r5, r0
   4736a:	460c      	mov	r4, r1
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   4736c:	2228      	movs	r2, #40	; 0x28
   4736e:	2100      	movs	r1, #0
   47370:	a808      	add	r0, sp, #32
   47372:	f000 ffb5 	bl	482e0 <memset>
   47376:	233f      	movs	r3, #63	; 0x3f
   47378:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_GENERATE_RANDOM_SID,
    };

    psa_invec in_vec[] = {
   4737a:	ab07      	add	r3, sp, #28
   4737c:	9303      	str	r3, [sp, #12]
   4737e:	232c      	movs	r3, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   47380:	9406      	str	r4, [sp, #24]
   47382:	e9cd 3504 	strd	r3, r5, [sp, #16]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   47386:	b144      	cbz	r4, 4739a <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    status = API_DISPATCH(tfm_crypto_generate_random,
   47388:	2201      	movs	r2, #1
   4738a:	4805      	ldr	r0, [pc, #20]	; (473a0 <psa_generate_random+0x3c>)
   4738c:	9200      	str	r2, [sp, #0]
   4738e:	ab05      	add	r3, sp, #20
   47390:	a903      	add	r1, sp, #12
   47392:	f7fc fd75 	bl	43e80 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_RANDOM);

    return status;
}
   47396:	b013      	add	sp, #76	; 0x4c
   47398:	bd30      	pop	{r4, r5, pc}
        return PSA_SUCCESS;
   4739a:	4620      	mov	r0, r4
   4739c:	e7fb      	b.n	47396 <psa_generate_random+0x32>
   4739e:	bf00      	nop
   473a0:	00037c11 	.word	0x00037c11

000473a4 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   473a4:	4770      	bx	lr

000473a6 <ethers_keccak256>:
void ethers_keccak256(const uint8_t *data, uint16_t length, uint8_t *result) {
   473a6:	b570      	push	{r4, r5, r6, lr}
   473a8:	460e      	mov	r6, r1
   473aa:	4605      	mov	r5, r0
   473ac:	4614      	mov	r4, r2
   473ae:	b0e4      	sub	sp, #400	; 0x190
    keccak_init(&context);
   473b0:	4668      	mov	r0, sp
   473b2:	f000 f87d 	bl	474b0 <keccak_init>
    keccak_update(&context, (const unsigned char*)data, (size_t)length);
   473b6:	4632      	mov	r2, r6
   473b8:	4629      	mov	r1, r5
   473ba:	4668      	mov	r0, sp
   473bc:	f000 f87d 	bl	474ba <keccak_update>
    keccak_final(&context, (unsigned char*)result);
   473c0:	4621      	mov	r1, r4
   473c2:	4668      	mov	r0, sp
   473c4:	f000 f8be 	bl	47544 <keccak_final>
    memset((char*)&context, 0, sizeof(SHA3_CTX));
   473c8:	f44f 72c8 	mov.w	r2, #400	; 0x190
   473cc:	2100      	movs	r1, #0
   473ce:	4668      	mov	r0, sp
   473d0:	f000 ff86 	bl	482e0 <memset>
}
   473d4:	b064      	add	sp, #400	; 0x190
   473d6:	bd70      	pop	{r4, r5, r6, pc}

000473d8 <rlp_encode_list>:

// Returns length of output in bytes, or a negative error value
int rlp_encode_list(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, 
                    const RlpElement_t *const *rlpElementsArr, size_t rplElementsLen)
{
   473d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   473dc:	460e      	mov	r6, r1
   473de:	4690      	mov	r8, r2
   473e0:	4699      	mov	r9, r3
  if( rlpEncodedOutput == NULL || rlpElementsArr == NULL || rlpEncodedOutputLen == 0 )
   473e2:	4604      	mov	r4, r0
   473e4:	2800      	cmp	r0, #0
   473e6:	d05d      	beq.n	474a4 <rlp_encode_list+0xcc>
   473e8:	2a00      	cmp	r2, #0
   473ea:	d05b      	beq.n	474a4 <rlp_encode_list+0xcc>
   473ec:	2900      	cmp	r1, #0
   473ee:	d059      	beq.n	474a4 <rlp_encode_list+0xcc>
   473f0:	460a      	mov	r2, r1
    return ERR_RLP_EBADARG;
  
  // loop through all elements and determine if sufficient output space is available
  // and there are no memory overlap violations
  size_t spaceRemaining = rlpEncodedOutputLen;
  for(int i = 0; i < rplElementsLen; i++) {
   473f2:	2300      	movs	r3, #0
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   473f4:	1845      	adds	r5, r0, r1
  for(int i = 0; i < rplElementsLen; i++) {
   473f6:	454b      	cmp	r3, r9
   473f8:	d120      	bne.n	4743c <rlp_encode_list+0x64>
  }
  size_t rlpEncodedLen = 0;
  uint8_t *rlpOut = (uint8_t *) rlpEncodedOutput;
  
  // Encode each element
  for(int i = 0; i < rplElementsLen; i++) {
   473fa:	2700      	movs	r7, #0
  size_t rlpEncodedLen = 0;
   473fc:	463d      	mov	r5, r7
  for(int i = 0; i < rplElementsLen; i++) {
   473fe:	454f      	cmp	r7, r9
   47400:	d135      	bne.n	4746e <rlp_encode_list+0x96>
      return ret;
    rlpEncodedLen += ret;
  }
  // Calculate list header byte size
  uint8_t listHdrByteCnt = 0;
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   47402:	462a      	mov	r2, r5
   47404:	2100      	movs	r1, #0
   47406:	2a00      	cmp	r2, #0
   47408:	b2cb      	uxtb	r3, r1
   4740a:	f101 0101 	add.w	r1, r1, #1
   4740e:	dc39      	bgt.n	47484 <rlp_encode_list+0xac>
    listHdrByteCnt++;
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD)
   47410:	2d37      	cmp	r5, #55	; 0x37
    listHdrByteCnt++; // additional byte for extended length tag
   47412:	bf84      	itt	hi
   47414:	3301      	addhi	r3, #1
   47416:	b2db      	uxtbhi	r3, r3
  // orig
  if((listHdrByteCnt + rlpEncodedLen) > rlpEncodedOutputLen) {
   47418:	1958      	adds	r0, r3, r5
   4741a:	42b0      	cmp	r0, r6
   4741c:	d814      	bhi.n	47448 <rlp_encode_list+0x70>
    // ain't enough room for the header
    return ERR_RLP_ENOMEM;
  }
  // first shift everything down to fit the header
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   4741e:	1822      	adds	r2, r4, r0
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   47420:	425e      	negs	r6, r3
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   47422:	1b11      	subs	r1, r2, r4
   47424:	428b      	cmp	r3, r1
   47426:	dd2f      	ble.n	47488 <rlp_encode_list+0xb0>
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD) {
   47428:	2d37      	cmp	r5, #55	; 0x37
   4742a:	d938      	bls.n	4749e <rlp_encode_list+0xc6>
    // generate the header
    for(int i = 0; i < listHdrByteCnt; i++) {
   4742c:	2200      	movs	r2, #0
   4742e:	1e59      	subs	r1, r3, #1
   47430:	4421      	add	r1, r4
   47432:	4293      	cmp	r3, r2
   47434:	dc2c      	bgt.n	47490 <rlp_encode_list+0xb8>
      rlpOut[(listHdrByteCnt - 1) - i] = // subtract 1 to turn count into index
        (uint8_t) (rlpEncodedLen >> (8 * i));
    }
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_LONG + (listHdrByteCnt - 1));
   47436:	3b0a      	subs	r3, #10
   47438:	7023      	strb	r3, [r4, #0]
   4743a:	e007      	b.n	4744c <rlp_encode_list+0x74>
    if(spaceRemaining < (rlpElementsArr[i]->len + 1)) // extra byte for rlp encoding tag
   4743c:	f858 1023 	ldr.w	r1, [r8, r3, lsl #2]
   47440:	6848      	ldr	r0, [r1, #4]
   47442:	1c47      	adds	r7, r0, #1
   47444:	4297      	cmp	r7, r2
   47446:	d903      	bls.n	47450 <rlp_encode_list+0x78>
      return ERR_RLP_ENOMEM;
   47448:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  else {
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
  }
  rlpEncodedLen += listHdrByteCnt;
  return rlpEncodedLen;
   4744c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   47450:	43c7      	mvns	r7, r0
    if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElementsArr[i]->buff, rlpElementsArr[i]->len)) // No overlapping memory regions
   47452:	6889      	ldr	r1, [r1, #8]
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   47454:	443a      	add	r2, r7
    if( (aAddr == bAddr) ||
   47456:	42a1      	cmp	r1, r4
   47458:	d027      	beq.n	474aa <rlp_encode_list+0xd2>
   4745a:	d901      	bls.n	47460 <rlp_encode_list+0x88>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   4745c:	42a9      	cmp	r1, r5
   4745e:	d924      	bls.n	474aa <rlp_encode_list+0xd2>
   47460:	42a1      	cmp	r1, r4
   47462:	d202      	bcs.n	4746a <rlp_encode_list+0x92>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   47464:	4401      	add	r1, r0
   47466:	428c      	cmp	r4, r1
   47468:	d91f      	bls.n	474aa <rlp_encode_list+0xd2>
  for(int i = 0; i < rplElementsLen; i++) {
   4746a:	3301      	adds	r3, #1
   4746c:	e7c3      	b.n	473f6 <rlp_encode_list+0x1e>
    int ret = rlp_encode_element((rlpOut + rlpEncodedLen), (rlpEncodedOutputLen - rlpEncodedLen), rlpElementsArr[i]);
   4746e:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
   47472:	1b71      	subs	r1, r6, r5
   47474:	1960      	adds	r0, r4, r5
   47476:	f7f9 f861 	bl	4053c <rlp_encode_element>
    if(ret < 0)
   4747a:	2800      	cmp	r0, #0
   4747c:	dbe6      	blt.n	4744c <rlp_encode_list+0x74>
    rlpEncodedLen += ret;
   4747e:	4405      	add	r5, r0
  for(int i = 0; i < rplElementsLen; i++) {
   47480:	3701      	adds	r7, #1
   47482:	e7bc      	b.n	473fe <rlp_encode_list+0x26>
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   47484:	1212      	asrs	r2, r2, #8
   47486:	e7be      	b.n	47406 <rlp_encode_list+0x2e>
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   47488:	5d91      	ldrb	r1, [r2, r6]
   4748a:	f802 1901 	strb.w	r1, [r2], #-1
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   4748e:	e7c8      	b.n	47422 <rlp_encode_list+0x4a>
        (uint8_t) (rlpEncodedLen >> (8 * i));
   47490:	00d6      	lsls	r6, r2, #3
   47492:	fa25 f606 	lsr.w	r6, r5, r6
   47496:	f801 6901 	strb.w	r6, [r1], #-1
    for(int i = 0; i < listHdrByteCnt; i++) {
   4749a:	3201      	adds	r2, #1
   4749c:	e7c9      	b.n	47432 <rlp_encode_list+0x5a>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
   4749e:	3d40      	subs	r5, #64	; 0x40
   474a0:	7025      	strb	r5, [r4, #0]
   474a2:	e7d3      	b.n	4744c <rlp_encode_list+0x74>
    return ERR_RLP_EBADARG;
   474a4:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   474a8:	e7d0      	b.n	4744c <rlp_encode_list+0x74>
      return ERR_RLP_EILLEGALMEM;
   474aa:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   474ae:	e7cd      	b.n	4744c <rlp_encode_list+0x74>

000474b0 <keccak_init>:
    memset(ctx, 0, sizeof(SHA3_CTX));
   474b0:	f44f 72c8 	mov.w	r2, #400	; 0x190
   474b4:	2100      	movs	r1, #0
   474b6:	f000 bf13 	b.w	482e0 <memset>

000474ba <keccak_update>:
 * @param ctx the algorithm context containing current hashing state
 * @param msg message chunk
 * @param size length of the message chunk
 */
void keccak_update(SHA3_CTX *ctx, const unsigned char *msg, uint16_t size)
{
   474ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   474be:	4606      	mov	r6, r0
    uint16_t idx = (uint16_t)ctx->rest;
   474c0:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
{
   474c4:	4614      	mov	r4, r2

    //if (ctx->rest & SHA3_FINALIZED) return; /* too late for additional input */
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   474c6:	1887      	adds	r7, r0, r2
   474c8:	2288      	movs	r2, #136	; 0x88
   474ca:	fbb7 f3f2 	udiv	r3, r7, r2
   474ce:	fb02 7313 	mls	r3, r2, r3, r7
{
   474d2:	460d      	mov	r5, r1
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   474d4:	f8a6 3188 	strh.w	r3, [r6, #392]	; 0x188

    /* fill partial block */
    if (idx) {
   474d8:	b198      	cbz	r0, 47502 <keccak_update+0x48>
        uint16_t left = BLOCK_SIZE - idx;
   474da:	1a17      	subs	r7, r2, r0
   474dc:	b2bf      	uxth	r7, r7
        memcpy((char*)ctx->message + idx, msg, (size < left ? size : left));
   474de:	42bc      	cmp	r4, r7
   474e0:	f106 08c8 	add.w	r8, r6, #200	; 0xc8
   474e4:	4622      	mov	r2, r4
   474e6:	4440      	add	r0, r8
   474e8:	bf28      	it	cs
   474ea:	463a      	movcs	r2, r7
   474ec:	f000 feed 	bl	482ca <memcpy>
        if (size < left) return;
   474f0:	42bc      	cmp	r4, r7
   474f2:	d325      	bcc.n	47540 <keccak_update+0x86>

        /* process partial block */
        sha3_process_block(ctx->hash, ctx->message);
   474f4:	4641      	mov	r1, r8
   474f6:	4630      	mov	r0, r6
   474f8:	f7f9 f89e 	bl	40638 <sha3_process_block>
        msg  += left;
        size -= left;
   474fc:	1be4      	subs	r4, r4, r7
        msg  += left;
   474fe:	443d      	add	r5, r7
        size -= left;
   47500:	b2a4      	uxth	r4, r4
        uint64_t* aligned_message_block;
        if (IS_ALIGNED_64(msg)) {
            // the most common case is processing of an already aligned message without copying it
            aligned_message_block = (uint64_t*)(void*)msg;
        } else {
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47502:	f106 07c8 	add.w	r7, r6, #200	; 0xc8
    while (size >= BLOCK_SIZE) {
   47506:	2c87      	cmp	r4, #135	; 0x87
   47508:	d808      	bhi.n	4751c <keccak_update+0x62>
        sha3_process_block(ctx->hash, aligned_message_block);
        msg  += BLOCK_SIZE;
        size -= BLOCK_SIZE;
    }

    if (size) {
   4750a:	b1cc      	cbz	r4, 47540 <keccak_update+0x86>
        memcpy(ctx->message, msg, size); /* save leftovers */
   4750c:	4622      	mov	r2, r4
   4750e:	4629      	mov	r1, r5
   47510:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
    }
}
   47514:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        memcpy(ctx->message, msg, size); /* save leftovers */
   47518:	f000 bed7 	b.w	482ca <memcpy>
        if (IS_ALIGNED_64(msg)) {
   4751c:	076b      	lsls	r3, r5, #29
   4751e:	d00d      	beq.n	4753c <keccak_update+0x82>
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47520:	2288      	movs	r2, #136	; 0x88
   47522:	4629      	mov	r1, r5
   47524:	4638      	mov	r0, r7
   47526:	46b8      	mov	r8, r7
   47528:	f000 fecf 	bl	482ca <memcpy>
        sha3_process_block(ctx->hash, aligned_message_block);
   4752c:	4641      	mov	r1, r8
   4752e:	4630      	mov	r0, r6
   47530:	3c88      	subs	r4, #136	; 0x88
   47532:	f7f9 f881 	bl	40638 <sha3_process_block>
        msg  += BLOCK_SIZE;
   47536:	3588      	adds	r5, #136	; 0x88
        size -= BLOCK_SIZE;
   47538:	b2a4      	uxth	r4, r4
   4753a:	e7e4      	b.n	47506 <keccak_update+0x4c>
   4753c:	46a8      	mov	r8, r5
   4753e:	e7f5      	b.n	4752c <keccak_update+0x72>
}
   47540:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047544 <keccak_final>:
*
* @param ctx the algorithm context containing current hashing state
* @param result calculated hash in binary form
*/
void keccak_final(SHA3_CTX *ctx, unsigned char* result)
{
   47544:	b570      	push	{r4, r5, r6, lr}
   47546:	4604      	mov	r4, r0
   47548:	460d      	mov	r5, r1
    uint16_t digest_length = 100 - BLOCK_SIZE / 2;

//    if (!(ctx->rest & SHA3_FINALIZED)) {
        /* clear the rest of the data queue */
        memset((char*)ctx->message + ctx->rest, 0, BLOCK_SIZE - ctx->rest);
   4754a:	f100 06c8 	add.w	r6, r0, #200	; 0xc8
   4754e:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
   47552:	2100      	movs	r1, #0
   47554:	f1c0 0288 	rsb	r2, r0, #136	; 0x88
   47558:	4430      	add	r0, r6
   4755a:	f000 fec1 	bl	482e0 <memset>
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   4755e:	f8b4 2188 	ldrh.w	r2, [r4, #392]	; 0x188
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;

        /* process final block */
        sha3_process_block(ctx->hash, ctx->message);
   47562:	4631      	mov	r1, r6
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   47564:	5cb3      	ldrb	r3, [r6, r2]
        sha3_process_block(ctx->hash, ctx->message);
   47566:	4620      	mov	r0, r4
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   47568:	f043 0301 	orr.w	r3, r3, #1
   4756c:	54b3      	strb	r3, [r6, r2]
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;
   4756e:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
   47572:	f063 037f 	orn	r3, r3, #127	; 0x7f
   47576:	f884 314f 	strb.w	r3, [r4, #335]	; 0x14f
        sha3_process_block(ctx->hash, ctx->message);
   4757a:	f7f9 f85d 	bl	40638 <sha3_process_block>
//        ctx->rest = SHA3_FINALIZED; /* mark context as finalized */
//    }

    if (result) {
   4757e:	b135      	cbz	r5, 4758e <keccak_final+0x4a>
         me64_to_le_str(result, ctx->hash, digest_length);
   47580:	4621      	mov	r1, r4
   47582:	4628      	mov	r0, r5
    }
}
   47584:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
         me64_to_le_str(result, ctx->hash, digest_length);
   47588:	2220      	movs	r2, #32
   4758a:	f000 be9e 	b.w	482ca <memcpy>
}
   4758e:	bd70      	pop	{r4, r5, r6, pc}

00047590 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   47590:	4603      	mov	r3, r0
   47592:	b158      	cbz	r0, 475ac <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   47594:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   47596:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   4759a:	2a01      	cmp	r2, #1
   4759c:	d003      	beq.n	475a6 <sys_notify_validate+0x16>
   4759e:	2a03      	cmp	r2, #3
   475a0:	d104      	bne.n	475ac <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   475a2:	6802      	ldr	r2, [r0, #0]
   475a4:	b112      	cbz	r2, 475ac <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   475a6:	2000      	movs	r0, #0
   475a8:	6098      	str	r0, [r3, #8]
   475aa:	4770      	bx	lr
		return -EINVAL;
   475ac:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   475b0:	4770      	bx	lr

000475b2 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   475b2:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   475b4:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   475b6:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   475ba:	2a03      	cmp	r2, #3
   475bc:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   475c0:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   475c2:	bf14      	ite	ne
   475c4:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   475c6:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   475c8:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   475ca:	4770      	bx	lr

000475cc <arch_printk_char_out>:
}
   475cc:	2000      	movs	r0, #0
   475ce:	4770      	bx	lr

000475d0 <str_out>:
{
   475d0:	b530      	push	{r4, r5, lr}
   475d2:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   475d4:	680c      	ldr	r4, [r1, #0]
   475d6:	1c55      	adds	r5, r2, #1
   475d8:	b114      	cbz	r4, 475e0 <str_out+0x10>
   475da:	684b      	ldr	r3, [r1, #4]
   475dc:	4293      	cmp	r3, r2
   475de:	dc01      	bgt.n	475e4 <str_out+0x14>
		ctx->count++;
   475e0:	608d      	str	r5, [r1, #8]
}
   475e2:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   475e4:	3b01      	subs	r3, #1
   475e6:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   475e8:	bf08      	it	eq
   475ea:	2200      	moveq	r2, #0
   475ec:	608d      	str	r5, [r1, #8]
   475ee:	bf0c      	ite	eq
   475f0:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   475f2:	54a0      	strbne	r0, [r4, r2]
   475f4:	e7f5      	b.n	475e2 <str_out+0x12>

000475f6 <printk>:
{
   475f6:	b40f      	push	{r0, r1, r2, r3}
   475f8:	b507      	push	{r0, r1, r2, lr}
   475fa:	a904      	add	r1, sp, #16
   475fc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   47600:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   47602:	f7f9 f963 	bl	408cc <vprintk>
}
   47606:	b003      	add	sp, #12
   47608:	f85d eb04 	ldr.w	lr, [sp], #4
   4760c:	b004      	add	sp, #16
   4760e:	4770      	bx	lr

00047610 <snprintk>:
{
   47610:	b40c      	push	{r2, r3}
   47612:	b507      	push	{r0, r1, r2, lr}
   47614:	ab04      	add	r3, sp, #16
   47616:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   4761a:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   4761c:	f7f9 f964 	bl	408e8 <vsnprintk>
}
   47620:	b003      	add	sp, #12
   47622:	f85d eb04 	ldr.w	lr, [sp], #4
   47626:	b002      	add	sp, #8
   47628:	4770      	bx	lr

0004762a <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   4762a:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   4762c:	f013 0307 	ands.w	r3, r3, #7
   47630:	d105      	bne.n	4763e <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   47632:	6803      	ldr	r3, [r0, #0]
   47634:	2b00      	cmp	r3, #0
		evt = EVT_START;
   47636:	bf0c      	ite	eq
   47638:	2000      	moveq	r0, #0
   4763a:	2003      	movne	r0, #3
   4763c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   4763e:	2b02      	cmp	r3, #2
   47640:	d105      	bne.n	4764e <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   47642:	8b43      	ldrh	r3, [r0, #26]
   47644:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   47646:	bf14      	ite	ne
   47648:	2000      	movne	r0, #0
   4764a:	2004      	moveq	r0, #4
   4764c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   4764e:	2b01      	cmp	r3, #1
   47650:	d105      	bne.n	4765e <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   47652:	6803      	ldr	r3, [r0, #0]
   47654:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   47656:	bf0c      	ite	eq
   47658:	2000      	moveq	r0, #0
   4765a:	2005      	movne	r0, #5
   4765c:	4770      	bx	lr
	int evt = EVT_NOP;
   4765e:	2000      	movs	r0, #0
}
   47660:	4770      	bx	lr

00047662 <notify_one>:
{
   47662:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47666:	460d      	mov	r5, r1
   47668:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   4766a:	4619      	mov	r1, r3
   4766c:	1d28      	adds	r0, r5, #4
{
   4766e:	4690      	mov	r8, r2
   47670:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47672:	f7ff ff9e 	bl	475b2 <sys_notify_finalize>
	if (cb) {
   47676:	4604      	mov	r4, r0
   47678:	b138      	cbz	r0, 4768a <notify_one+0x28>
		cb(mgr, cli, state, res);
   4767a:	4633      	mov	r3, r6
   4767c:	4642      	mov	r2, r8
   4767e:	4629      	mov	r1, r5
   47680:	4638      	mov	r0, r7
   47682:	46a4      	mov	ip, r4
}
   47684:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   47688:	4760      	bx	ip
}
   4768a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004768e <transition_complete>:
{
   4768e:	b410      	push	{r4}
	__asm__ volatile(
   47690:	f04f 0420 	mov.w	r4, #32
   47694:	f3ef 8211 	mrs	r2, BASEPRI
   47698:	f384 8812 	msr	BASEPRI_MAX, r4
   4769c:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   476a0:	6141      	str	r1, [r0, #20]
}
   476a2:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   476a4:	2101      	movs	r1, #1
   476a6:	f7f9 b933 	b.w	40910 <process_event>

000476aa <validate_args>:
{
   476aa:	b510      	push	{r4, lr}
   476ac:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   476ae:	b140      	cbz	r0, 476c2 <validate_args+0x18>
   476b0:	b139      	cbz	r1, 476c2 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   476b2:	1d08      	adds	r0, r1, #4
   476b4:	f7ff ff6c 	bl	47590 <sys_notify_validate>
	if ((rv == 0)
   476b8:	b928      	cbnz	r0, 476c6 <validate_args+0x1c>
	    && ((cli->notify.flags
   476ba:	68a3      	ldr	r3, [r4, #8]
   476bc:	f033 0303 	bics.w	r3, r3, #3
   476c0:	d001      	beq.n	476c6 <validate_args+0x1c>
		rv = -EINVAL;
   476c2:	f06f 0015 	mvn.w	r0, #21
}
   476c6:	bd10      	pop	{r4, pc}

000476c8 <onoff_manager_init>:
{
   476c8:	b538      	push	{r3, r4, r5, lr}
   476ca:	460c      	mov	r4, r1
	if ((mgr == NULL)
   476cc:	4605      	mov	r5, r0
   476ce:	b158      	cbz	r0, 476e8 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   476d0:	b151      	cbz	r1, 476e8 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   476d2:	680b      	ldr	r3, [r1, #0]
   476d4:	b143      	cbz	r3, 476e8 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   476d6:	684b      	ldr	r3, [r1, #4]
   476d8:	b133      	cbz	r3, 476e8 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   476da:	221c      	movs	r2, #28
   476dc:	2100      	movs	r1, #0
   476de:	f000 fdff 	bl	482e0 <memset>
	return 0;
   476e2:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   476e4:	612c      	str	r4, [r5, #16]
}
   476e6:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   476e8:	f06f 0015 	mvn.w	r0, #21
   476ec:	e7fb      	b.n	476e6 <onoff_manager_init+0x1e>

000476ee <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   476ee:	b570      	push	{r4, r5, r6, lr}
   476f0:	4604      	mov	r4, r0
   476f2:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   476f4:	f7ff ffd9 	bl	476aa <validate_args>

	if (rv < 0) {
   476f8:	1e05      	subs	r5, r0, #0
   476fa:	db31      	blt.n	47760 <onoff_request+0x72>
   476fc:	f04f 0320 	mov.w	r3, #32
   47700:	f3ef 8111 	mrs	r1, BASEPRI
   47704:	f383 8812 	msr	BASEPRI_MAX, r3
   47708:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   4770c:	f64f 75ff 	movw	r5, #65535	; 0xffff
   47710:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47712:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   47714:	42ab      	cmp	r3, r5
   47716:	f000 0207 	and.w	r2, r0, #7
   4771a:	d02e      	beq.n	4777a <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   4771c:	2a02      	cmp	r2, #2
   4771e:	d10e      	bne.n	4773e <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   47720:	3301      	adds	r3, #1
   47722:	8363      	strh	r3, [r4, #26]
	rv = state;
   47724:	4615      	mov	r5, r2
		notify = true;
   47726:	2301      	movs	r3, #1
	__asm__ volatile(
   47728:	f381 8811 	msr	BASEPRI, r1
   4772c:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   47730:	b1b3      	cbz	r3, 47760 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   47732:	2300      	movs	r3, #0
   47734:	4631      	mov	r1, r6
   47736:	4620      	mov	r0, r4
   47738:	f7ff ff93 	bl	47662 <notify_one>
   4773c:	e010      	b.n	47760 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   4773e:	0783      	lsls	r3, r0, #30
   47740:	d001      	beq.n	47746 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   47742:	2a06      	cmp	r2, #6
   47744:	d10e      	bne.n	47764 <onoff_request+0x76>
	parent->next = child;
   47746:	2300      	movs	r3, #0
   47748:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   4774a:	6863      	ldr	r3, [r4, #4]
   4774c:	b993      	cbnz	r3, 47774 <onoff_request+0x86>
	list->head = node;
   4774e:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   47752:	4615      	mov	r5, r2
   47754:	b962      	cbnz	r2, 47770 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   47756:	460a      	mov	r2, r1
   47758:	4620      	mov	r0, r4
   4775a:	2102      	movs	r1, #2
   4775c:	f7f9 f8d8 	bl	40910 <process_event>
		}
	}

	return rv;
}
   47760:	4628      	mov	r0, r5
   47762:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   47764:	2a05      	cmp	r2, #5
   47766:	bf0c      	ite	eq
   47768:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   4776c:	f06f 0504 	mvnne.w	r5, #4
   47770:	2300      	movs	r3, #0
   47772:	e7d9      	b.n	47728 <onoff_request+0x3a>
	parent->next = child;
   47774:	601e      	str	r6, [r3, #0]
	list->tail = node;
   47776:	6066      	str	r6, [r4, #4]
}
   47778:	e7eb      	b.n	47752 <onoff_request+0x64>
		rv = -EAGAIN;
   4777a:	f06f 050a 	mvn.w	r5, #10
   4777e:	e7f7      	b.n	47770 <onoff_request+0x82>

00047780 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   47780:	4604      	mov	r4, r0
   47782:	b508      	push	{r3, lr}
   47784:	4608      	mov	r0, r1
   47786:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   47788:	461a      	mov	r2, r3
   4778a:	47a0      	blx	r4
	return z_impl_z_current_get();
   4778c:	f7ff fb56 	bl	46e3c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   47790:	f7fb f888 	bl	428a4 <z_impl_k_thread_abort>

00047794 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   47794:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   47798:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   4779a:	0840      	lsrs	r0, r0, #1
   4779c:	4770      	bx	lr

0004779e <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   4779e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   477a0:	4603      	mov	r3, r0
   477a2:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   477a4:	f7ff fff6 	bl	47794 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   477a8:	fab0 f080 	clz	r0, r0
   477ac:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   477b0:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   477b4:	f8dc 6010 	ldr.w	r6, [ip, #16]
   477b8:	00ca      	lsls	r2, r1, #3
   477ba:	1d17      	adds	r7, r2, #4
   477bc:	b28d      	uxth	r5, r1
   477be:	3206      	adds	r2, #6
   477c0:	b956      	cbnz	r6, 477d8 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   477c2:	2101      	movs	r1, #1
   477c4:	fa01 f000 	lsl.w	r0, r1, r0
   477c8:	68d9      	ldr	r1, [r3, #12]
   477ca:	4301      	orrs	r1, r0
   477cc:	60d9      	str	r1, [r3, #12]
		b->next = c;
   477ce:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   477d2:	53dd      	strh	r5, [r3, r7]
   477d4:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   477d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   477d8:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   477da:	3104      	adds	r1, #4
   477dc:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   477de:	53d8      	strh	r0, [r3, r7]
   477e0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   477e4:	529e      	strh	r6, [r3, r2]
   477e6:	80c5      	strh	r5, [r0, #6]
   477e8:	525d      	strh	r5, [r3, r1]
   477ea:	e7f4      	b.n	477d6 <free_list_add+0x38>

000477ec <free_list_remove_bidx>:
{
   477ec:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   477ee:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   477f2:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   477f4:	4299      	cmp	r1, r3
   477f6:	f102 0104 	add.w	r1, r2, #4
   477fa:	d10a      	bne.n	47812 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   477fc:	2301      	movs	r3, #1
   477fe:	fa03 f202 	lsl.w	r2, r3, r2
   47802:	68c3      	ldr	r3, [r0, #12]
   47804:	ea23 0302 	bic.w	r3, r3, r2
   47808:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   4780a:	2300      	movs	r3, #0
   4780c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   47810:	bd10      	pop	{r4, pc}
   47812:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   47814:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   47818:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   4781c:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   47820:	80cb      	strh	r3, [r1, #6]
   47822:	8082      	strh	r2, [r0, #4]
}
   47824:	e7f4      	b.n	47810 <free_list_remove_bidx+0x24>

00047826 <free_list_remove>:
{
   47826:	b510      	push	{r4, lr}
   47828:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   4782a:	f7ff ffb3 	bl	47794 <chunk_size>
}
   4782e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   47832:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   47836:	4618      	mov	r0, r3
   47838:	f1c2 021f 	rsb	r2, r2, #31
   4783c:	f7ff bfd6 	b.w	477ec <free_list_remove_bidx>

00047840 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   47840:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47844:	fab1 f581 	clz	r5, r1
   47848:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   4784c:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   47850:	693a      	ldr	r2, [r7, #16]
{
   47852:	4603      	mov	r3, r0
   47854:	460e      	mov	r6, r1
	if (b->next) {
   47856:	b1ca      	cbz	r2, 4788c <alloc_chunk+0x4c>
   47858:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   4785c:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   4785e:	4618      	mov	r0, r3
   47860:	4621      	mov	r1, r4
   47862:	f7ff ff97 	bl	47794 <chunk_size>
   47866:	42b0      	cmp	r0, r6
   47868:	d307      	bcc.n	4787a <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   4786a:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   4786c:	4621      	mov	r1, r4
   4786e:	4618      	mov	r0, r3
   47870:	f7ff ffbc 	bl	477ec <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   47874:	4620      	mov	r0, r4
   47876:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   4787a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   4787e:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   47880:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   47884:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   47886:	d001      	beq.n	4788c <alloc_chunk+0x4c>
   47888:	428a      	cmp	r2, r1
   4788a:	d1e7      	bne.n	4785c <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   4788c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   47890:	68d9      	ldr	r1, [r3, #12]
   47892:	f1c5 0520 	rsb	r5, r5, #32
   47896:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   47898:	400c      	ands	r4, r1
   4789a:	d0eb      	beq.n	47874 <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   4789c:	fa94 f2a4 	rbit	r2, r4
   478a0:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   478a4:	1d11      	adds	r1, r2, #4
   478a6:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   478aa:	e7df      	b.n	4786c <alloc_chunk+0x2c>

000478ac <merge_chunks>:
{
   478ac:	b538      	push	{r3, r4, r5, lr}
   478ae:	4603      	mov	r3, r0
   478b0:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   478b2:	f7ff ff6f 	bl	47794 <chunk_size>
   478b6:	4611      	mov	r1, r2
   478b8:	4604      	mov	r4, r0
   478ba:	4618      	mov	r0, r3
   478bc:	f7ff ff6a 	bl	47794 <chunk_size>
   478c0:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   478c2:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   478c6:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   478c8:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   478ca:	4618      	mov	r0, r3
   478cc:	4611      	mov	r1, r2
   478ce:	f7ff ff61 	bl	47794 <chunk_size>
	void *cmem = &buf[c];
   478d2:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   478d4:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   478d8:	bd38      	pop	{r3, r4, r5, pc}

000478da <split_chunks>:
{
   478da:	b538      	push	{r3, r4, r5, lr}
   478dc:	4603      	mov	r3, r0
   478de:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   478e0:	f7ff ff58 	bl	47794 <chunk_size>
	chunksz_t lsz = rc - lc;
   478e4:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   478e6:	1aa5      	subs	r5, r4, r2
   478e8:	4405      	add	r5, r0
   478ea:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   478ee:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   478f0:	8060      	strh	r0, [r4, #2]
   478f2:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   478f6:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   478f8:	8044      	strh	r4, [r0, #2]
   478fa:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   478fe:	4618      	mov	r0, r3
   47900:	4611      	mov	r1, r2
   47902:	f7ff ff47 	bl	47794 <chunk_size>
	void *cmem = &buf[c];
   47906:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   47908:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   4790c:	bd38      	pop	{r3, r4, r5, pc}

0004790e <free_chunk>:
{
   4790e:	b538      	push	{r3, r4, r5, lr}
   47910:	4605      	mov	r5, r0
   47912:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   47914:	f7ff ff3e 	bl	47794 <chunk_size>
   47918:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   4791a:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   4791e:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   47920:	07da      	lsls	r2, r3, #31
   47922:	d40a      	bmi.n	4793a <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   47924:	4628      	mov	r0, r5
   47926:	f7ff ff7e 	bl	47826 <free_list_remove>
	return c + chunk_size(h, c);
   4792a:	4621      	mov	r1, r4
   4792c:	4628      	mov	r0, r5
   4792e:	f7ff ff31 	bl	47794 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   47932:	1822      	adds	r2, r4, r0
   47934:	4628      	mov	r0, r5
   47936:	f7ff ffb9 	bl	478ac <merge_chunks>
		return ((uint16_t *)cmem)[f];
   4793a:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   4793e:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   47940:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   47944:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   47946:	07db      	lsls	r3, r3, #31
   47948:	d40c      	bmi.n	47964 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   4794a:	4628      	mov	r0, r5
   4794c:	f7ff ff6b 	bl	47826 <free_list_remove>
		return ((uint16_t *)cmem)[f];
   47950:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   47954:	4622      	mov	r2, r4
   47956:	1a61      	subs	r1, r4, r1
   47958:	4628      	mov	r0, r5
   4795a:	f7ff ffa7 	bl	478ac <merge_chunks>
   4795e:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47962:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   47964:	4621      	mov	r1, r4
   47966:	4628      	mov	r0, r5
}
   47968:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   4796c:	f7ff bf17 	b.w	4779e <free_list_add>

00047970 <sys_heap_free>:
	if (mem == NULL) {
   47970:	b161      	cbz	r1, 4798c <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   47972:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47974:	3904      	subs	r1, #4
   47976:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   47978:	f021 0307 	bic.w	r3, r1, #7
   4797c:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   4797e:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   47980:	08c9      	lsrs	r1, r1, #3
   47982:	f022 0201 	bic.w	r2, r2, #1
   47986:	805a      	strh	r2, [r3, #2]
   47988:	f7ff bfc1 	b.w	4790e <free_chunk>
}
   4798c:	4770      	bx	lr

0004798e <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   4798e:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   47990:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   47992:	b909      	cbnz	r1, 47998 <sys_heap_alloc+0xa>
		return NULL;
   47994:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   47996:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   47998:	68ab      	ldr	r3, [r5, #8]
   4799a:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   4799e:	d9f9      	bls.n	47994 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   479a0:	310b      	adds	r1, #11
   479a2:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   479a4:	4621      	mov	r1, r4
   479a6:	4628      	mov	r0, r5
   479a8:	f7ff ff4a 	bl	47840 <alloc_chunk>
	if (c == 0U) {
   479ac:	4606      	mov	r6, r0
   479ae:	2800      	cmp	r0, #0
   479b0:	d0f0      	beq.n	47994 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   479b2:	4601      	mov	r1, r0
   479b4:	4628      	mov	r0, r5
   479b6:	f7ff feed 	bl	47794 <chunk_size>
   479ba:	42a0      	cmp	r0, r4
   479bc:	d908      	bls.n	479d0 <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   479be:	4434      	add	r4, r6
   479c0:	4628      	mov	r0, r5
   479c2:	4622      	mov	r2, r4
   479c4:	f7ff ff89 	bl	478da <split_chunks>
		free_list_add(h, c + chunk_sz);
   479c8:	4621      	mov	r1, r4
   479ca:	4628      	mov	r0, r5
   479cc:	f7ff fee7 	bl	4779e <free_list_add>
	void *cmem = &buf[c];
   479d0:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   479d4:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   479d6:	8853      	ldrh	r3, [r2, #2]
   479d8:	3004      	adds	r0, #4
   479da:	f043 0301 	orr.w	r3, r3, #1
   479de:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   479e0:	e7d9      	b.n	47996 <sys_heap_alloc+0x8>

000479e2 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   479e2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   479e6:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   479e8:	424a      	negs	r2, r1
   479ea:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   479ee:	ea31 0202 	bics.w	r2, r1, r2
{
   479f2:	4603      	mov	r3, r0
	if (align != rew) {
   479f4:	d00a      	beq.n	47a0c <sys_heap_aligned_alloc+0x2a>
		return false;
   479f6:	2f04      	cmp	r7, #4
   479f8:	463a      	mov	r2, r7
   479fa:	bf28      	it	cs
   479fc:	2204      	movcs	r2, #4
   479fe:	46b9      	mov	r9, r7
		align -= rew;
   47a00:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   47a02:	b974      	cbnz	r4, 47a22 <sys_heap_aligned_alloc+0x40>
		return NULL;
   47a04:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   47a06:	4628      	mov	r0, r5
   47a08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   47a0c:	2904      	cmp	r1, #4
   47a0e:	d804      	bhi.n	47a1a <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   47a10:	4621      	mov	r1, r4
}
   47a12:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   47a16:	f7ff bfba 	b.w	4798e <sys_heap_alloc>
		rew = 0;
   47a1a:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   47a1e:	2204      	movs	r2, #4
   47a20:	e7ef      	b.n	47a02 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   47a22:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   47a24:	68b3      	ldr	r3, [r6, #8]
   47a26:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   47a2a:	d9eb      	bls.n	47a04 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47a2c:	f104 010b 	add.w	r1, r4, #11
   47a30:	4439      	add	r1, r7
   47a32:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   47a34:	4630      	mov	r0, r6
   47a36:	08c9      	lsrs	r1, r1, #3
   47a38:	f7ff ff02 	bl	47840 <alloc_chunk>
	if (c0 == 0) {
   47a3c:	4680      	mov	r8, r0
   47a3e:	2800      	cmp	r0, #0
   47a40:	d0e0      	beq.n	47a04 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   47a42:	f109 0504 	add.w	r5, r9, #4
   47a46:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   47a4a:	1e7b      	subs	r3, r7, #1
   47a4c:	4435      	add	r5, r6
   47a4e:	441d      	add	r5, r3
   47a50:	427f      	negs	r7, r7
   47a52:	403d      	ands	r5, r7
   47a54:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47a58:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47a5a:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47a5c:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47a5e:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47a60:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   47a64:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   47a66:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47a6a:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   47a6e:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   47a72:	d208      	bcs.n	47a86 <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   47a74:	4601      	mov	r1, r0
   47a76:	463a      	mov	r2, r7
   47a78:	4630      	mov	r0, r6
   47a7a:	f7ff ff2e 	bl	478da <split_chunks>
		free_list_add(h, c0);
   47a7e:	4641      	mov	r1, r8
   47a80:	4630      	mov	r0, r6
   47a82:	f7ff fe8c 	bl	4779e <free_list_add>
	return c + chunk_size(h, c);
   47a86:	4639      	mov	r1, r7
   47a88:	4630      	mov	r0, r6
   47a8a:	f7ff fe83 	bl	47794 <chunk_size>
   47a8e:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   47a90:	4284      	cmp	r4, r0
   47a92:	d207      	bcs.n	47aa4 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   47a94:	4630      	mov	r0, r6
   47a96:	4622      	mov	r2, r4
   47a98:	f7ff ff1f 	bl	478da <split_chunks>
		free_list_add(h, c_end);
   47a9c:	4621      	mov	r1, r4
   47a9e:	4630      	mov	r0, r6
   47aa0:	f7ff fe7d 	bl	4779e <free_list_add>
	void *cmem = &buf[c];
   47aa4:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47aa8:	8873      	ldrh	r3, [r6, #2]
   47aaa:	f043 0301 	orr.w	r3, r3, #1
   47aae:	8073      	strh	r3, [r6, #2]
   47ab0:	e7a9      	b.n	47a06 <sys_heap_aligned_alloc+0x24>

00047ab2 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   47ab2:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   47ab4:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47ab6:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   47ab8:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   47abc:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   47ac0:	1ad2      	subs	r2, r2, r3
{
   47ac2:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   47ac4:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   47ac6:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   47ac8:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   47acc:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   47ace:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   47ad2:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47ad4:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   47ad6:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   47ad8:	60dd      	str	r5, [r3, #12]
   47ada:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   47adc:	f103 0610 	add.w	r6, r3, #16
   47ae0:	4418      	add	r0, r3
   47ae2:	4286      	cmp	r6, r0
   47ae4:	d118      	bne.n	47b18 <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47ae6:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47ae8:	f040 0001 	orr.w	r0, r0, #1
   47aec:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   47aee:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47af0:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   47af2:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   47af6:	801d      	strh	r5, [r3, #0]
   47af8:	8077      	strh	r7, [r6, #2]
   47afa:	189e      	adds	r6, r3, r2
   47afc:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   47b00:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   47b04:	8075      	strh	r5, [r6, #2]
   47b06:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47b08:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   47b0a:	4618      	mov	r0, r3
   47b0c:	f042 0201 	orr.w	r2, r2, #1
   47b10:	8062      	strh	r2, [r4, #2]
}
   47b12:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   47b14:	f7ff be43 	b.w	4779e <free_list_add>
		h->buckets[i].next = 0;
   47b18:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   47b1c:	e7e1      	b.n	47ae2 <sys_heap_init+0x30>

00047b1e <encode_uint>:
{
   47b1e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   47b22:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   47b24:	78d3      	ldrb	r3, [r2, #3]
{
   47b26:	4614      	mov	r4, r2
	switch (specifier) {
   47b28:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   47b2a:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   47b2e:	4606      	mov	r6, r0
   47b30:	460f      	mov	r7, r1
   47b32:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   47b34:	d02d      	beq.n	47b92 <encode_uint+0x74>
   47b36:	d828      	bhi.n	47b8a <encode_uint+0x6c>
		return 16;
   47b38:	2b58      	cmp	r3, #88	; 0x58
   47b3a:	bf14      	ite	ne
   47b3c:	250a      	movne	r5, #10
   47b3e:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   47b40:	46aa      	mov	sl, r5
   47b42:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   47b46:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   47b4a:	4652      	mov	r2, sl
   47b4c:	465b      	mov	r3, fp
   47b4e:	4630      	mov	r0, r6
   47b50:	4639      	mov	r1, r7
   47b52:	f7f8 faf7 	bl	40144 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47b56:	2a09      	cmp	r2, #9
   47b58:	b2d3      	uxtb	r3, r2
   47b5a:	d81f      	bhi.n	47b9c <encode_uint+0x7e>
   47b5c:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   47b5e:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47b60:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   47b62:	bf08      	it	eq
   47b64:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47b66:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   47b6a:	d301      	bcc.n	47b70 <encode_uint+0x52>
   47b6c:	45c8      	cmp	r8, r9
   47b6e:	d812      	bhi.n	47b96 <encode_uint+0x78>
	if (conv->flag_hash) {
   47b70:	7823      	ldrb	r3, [r4, #0]
   47b72:	069b      	lsls	r3, r3, #26
   47b74:	d505      	bpl.n	47b82 <encode_uint+0x64>
		if (radix == 8) {
   47b76:	2d08      	cmp	r5, #8
   47b78:	d116      	bne.n	47ba8 <encode_uint+0x8a>
			conv->altform_0 = true;
   47b7a:	78a3      	ldrb	r3, [r4, #2]
   47b7c:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   47b80:	70a3      	strb	r3, [r4, #2]
}
   47b82:	4640      	mov	r0, r8
   47b84:	b003      	add	sp, #12
   47b86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   47b8a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   47b8e:	2b70      	cmp	r3, #112	; 0x70
   47b90:	e7d3      	b.n	47b3a <encode_uint+0x1c>
	switch (specifier) {
   47b92:	2508      	movs	r5, #8
   47b94:	e7d4      	b.n	47b40 <encode_uint+0x22>
		value /= radix;
   47b96:	4606      	mov	r6, r0
   47b98:	460f      	mov	r7, r1
   47b9a:	e7d6      	b.n	47b4a <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   47b9c:	9a01      	ldr	r2, [sp, #4]
   47b9e:	2a19      	cmp	r2, #25
   47ba0:	bf94      	ite	ls
   47ba2:	3337      	addls	r3, #55	; 0x37
   47ba4:	3357      	addhi	r3, #87	; 0x57
   47ba6:	e7da      	b.n	47b5e <encode_uint+0x40>
		} else if (radix == 16) {
   47ba8:	2d10      	cmp	r5, #16
   47baa:	d1ea      	bne.n	47b82 <encode_uint+0x64>
			conv->altform_0c = true;
   47bac:	78a3      	ldrb	r3, [r4, #2]
   47bae:	f043 0310 	orr.w	r3, r3, #16
   47bb2:	e7e5      	b.n	47b80 <encode_uint+0x62>

00047bb4 <outs>:
{
   47bb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47bb8:	4607      	mov	r7, r0
   47bba:	4688      	mov	r8, r1
   47bbc:	4615      	mov	r5, r2
   47bbe:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   47bc0:	4614      	mov	r4, r2
   47bc2:	42b4      	cmp	r4, r6
   47bc4:	eba4 0005 	sub.w	r0, r4, r5
   47bc8:	d302      	bcc.n	47bd0 <outs+0x1c>
   47bca:	b93e      	cbnz	r6, 47bdc <outs+0x28>
   47bcc:	7823      	ldrb	r3, [r4, #0]
   47bce:	b12b      	cbz	r3, 47bdc <outs+0x28>
		int rc = out((int)*sp++, ctx);
   47bd0:	4641      	mov	r1, r8
   47bd2:	f814 0b01 	ldrb.w	r0, [r4], #1
   47bd6:	47b8      	blx	r7
		if (rc < 0) {
   47bd8:	2800      	cmp	r0, #0
   47bda:	daf2      	bge.n	47bc2 <outs+0xe>
}
   47bdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047be0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   47be0:	4770      	bx	lr

00047be2 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   47be2:	b084      	sub	sp, #16
   47be4:	ab04      	add	r3, sp, #16
   47be6:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   47bea:	f89d 3004 	ldrb.w	r3, [sp, #4]
   47bee:	2b06      	cmp	r3, #6
   47bf0:	d108      	bne.n	47c04 <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   47bf2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   47bf6:	2201      	movs	r2, #1
   47bf8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   47bfc:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   47c00:	bf20      	wfe
    while (true)
   47c02:	e7fd      	b.n	47c00 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   47c04:	b004      	add	sp, #16
   47c06:	4770      	bx	lr

00047c08 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   47c08:	b084      	sub	sp, #16
   47c0a:	ab04      	add	r3, sp, #16
   47c0c:	e903 0007 	stmdb	r3, {r0, r1, r2}
   47c10:	2300      	movs	r3, #0
   47c12:	f383 8811 	msr	BASEPRI, r3
   47c16:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   47c1a:	b004      	add	sp, #16
   47c1c:	4770      	bx	lr

00047c1e <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   47c1e:	2300      	movs	r3, #0
	list->head = NULL;
   47c20:	e9c0 3300 	strd	r3, r3, [r0]
}
   47c24:	4770      	bx	lr

00047c26 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   47c26:	6803      	ldr	r3, [r0, #0]
   47c28:	b923      	cbnz	r3, 47c34 <log_list_add_tail+0xe>
		list->head = msg;
   47c2a:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   47c2c:	2300      	movs	r3, #0
	list->tail = msg;
   47c2e:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   47c30:	600b      	str	r3, [r1, #0]
}
   47c32:	4770      	bx	lr
		list->tail->next = msg;
   47c34:	6843      	ldr	r3, [r0, #4]
   47c36:	6019      	str	r1, [r3, #0]
   47c38:	e7f8      	b.n	47c2c <log_list_add_tail+0x6>

00047c3a <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   47c3a:	6800      	ldr	r0, [r0, #0]
   47c3c:	4770      	bx	lr

00047c3e <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   47c3e:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   47c40:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   47c42:	b108      	cbz	r0, 47c48 <log_list_head_get+0xa>
		list->head = list->head->next;
   47c44:	6802      	ldr	r2, [r0, #0]
   47c46:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   47c48:	4770      	bx	lr

00047c4a <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   47c4a:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   47c4c:	f7f9 fde0 	bl	41810 <log_msg_chunk_alloc>

	if (msg != NULL) {
   47c50:	b118      	cbz	r0, 47c5a <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   47c52:	2301      	movs	r3, #1
   47c54:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   47c56:	2300      	movs	r3, #0
   47c58:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
   47c5a:	bd08      	pop	{r3, pc}

00047c5c <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   47c5c:	f000 bcb8 	b.w	485d0 <sys_clock_cycle_get_32>

00047c60 <dummy_timestamp>:
   47c60:	2000      	movs	r0, #0
   47c62:	4770      	bx	lr

00047c64 <z_log_get_s_mask>:
{
   47c64:	b5f0      	push	{r4, r5, r6, r7, lr}
   47c66:	4605      	mov	r5, r0
	uint32_t mask = 0U;
   47c68:	2000      	movs	r0, #0
				mask |= BIT(arg);
   47c6a:	2701      	movs	r7, #1
	uint32_t arg = 0U;
   47c6c:	4603      	mov	r3, r0
	bool arm = false;
   47c6e:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
   47c70:	f815 4b01 	ldrb.w	r4, [r5], #1
   47c74:	b10c      	cbz	r4, 47c7a <z_log_get_s_mask+0x16>
   47c76:	428b      	cmp	r3, r1
   47c78:	d300      	bcc.n	47c7c <z_log_get_s_mask+0x18>
}
   47c7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   47c7c:	2c25      	cmp	r4, #37	; 0x25
   47c7e:	d102      	bne.n	47c86 <z_log_get_s_mask+0x22>
			arm = !arm;
   47c80:	f082 0201 	eor.w	r2, r2, #1
   47c84:	e7f4      	b.n	47c70 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   47c86:	2a00      	cmp	r2, #0
   47c88:	d0f2      	beq.n	47c70 <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   47c8a:	f044 0620 	orr.w	r6, r4, #32
   47c8e:	3e61      	subs	r6, #97	; 0x61
   47c90:	2e19      	cmp	r6, #25
   47c92:	d8ed      	bhi.n	47c70 <z_log_get_s_mask+0xc>
			if (curr == 's') {
   47c94:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   47c96:	bf04      	itt	eq
   47c98:	fa07 f203 	lsleq.w	r2, r7, r3
   47c9c:	4310      	orreq	r0, r2
			arg++;
   47c9e:	3301      	adds	r3, #1
			arm = false;
   47ca0:	2200      	movs	r2, #0
   47ca2:	e7e5      	b.n	47c70 <z_log_get_s_mask+0xc>

00047ca4 <log_0>:
{
   47ca4:	b538      	push	{r3, r4, r5, lr}
   47ca6:	4605      	mov	r5, r0
   47ca8:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   47caa:	f7ff ffce 	bl	47c4a <z_log_msg_std_alloc>

	if (msg != NULL) {
   47cae:	b128      	cbz	r0, 47cbc <log_0+0x18>
		msg_finalize(msg, src_level);
   47cb0:	4621      	mov	r1, r4
		msg->str = str;
   47cb2:	6105      	str	r5, [r0, #16]
}
   47cb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   47cb8:	f7f9 bcb0 	b.w	4161c <msg_finalize>
}
   47cbc:	bd38      	pop	{r3, r4, r5, pc}

00047cbe <log_1>:
{
   47cbe:	b570      	push	{r4, r5, r6, lr}
   47cc0:	4606      	mov	r6, r0
   47cc2:	460d      	mov	r5, r1
   47cc4:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47cc6:	f7ff ffc0 	bl	47c4a <z_log_msg_std_alloc>

	if (msg != NULL) {
   47cca:	b158      	cbz	r0, 47ce4 <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   47ccc:	2101      	movs	r1, #1
   47cce:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   47cd0:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   47cd2:	f361 1207 	bfi	r2, r1, #4, #4
   47cd6:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
   47cd8:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
   47cda:	6145      	str	r5, [r0, #20]
}
   47cdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   47ce0:	f7f9 bc9c 	b.w	4161c <msg_finalize>
}
   47ce4:	bd70      	pop	{r4, r5, r6, pc}

00047ce6 <log_2>:
{
   47ce6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47cea:	4680      	mov	r8, r0
   47cec:	460f      	mov	r7, r1
   47cee:	4616      	mov	r6, r2
   47cf0:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47cf2:	f7ff ffaa 	bl	47c4a <z_log_msg_std_alloc>

	if (msg != NULL) {
   47cf6:	b168      	cbz	r0, 47d14 <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   47cf8:	2202      	movs	r2, #2
   47cfa:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47cfc:	4629      	mov	r1, r5
   47cfe:	f362 1307 	bfi	r3, r2, #4, #4
   47d02:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47d04:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47d08:	f8c0 8010 	str.w	r8, [r0, #16]
}
   47d0c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   47d10:	f7f9 bc84 	b.w	4161c <msg_finalize>
}
   47d14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047d18 <log_3>:
{
   47d18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47d1c:	4680      	mov	r8, r0
   47d1e:	460f      	mov	r7, r1
   47d20:	4616      	mov	r6, r2
   47d22:	461d      	mov	r5, r3
   47d24:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   47d28:	f7ff ff8f 	bl	47c4a <z_log_msg_std_alloc>

	if (msg != NULL) {
   47d2c:	b170      	cbz	r0, 47d4c <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   47d2e:	2203      	movs	r2, #3
   47d30:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   47d32:	4649      	mov	r1, r9
   47d34:	f362 1307 	bfi	r3, r2, #4, #4
   47d38:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   47d3a:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   47d3e:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
   47d42:	61c5      	str	r5, [r0, #28]
}
   47d44:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   47d48:	f7f9 bc68 	b.w	4161c <msg_finalize>
}
   47d4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00047d50 <z_log_get_tag>:
}
   47d50:	2000      	movs	r0, #0
   47d52:	4770      	bx	lr

00047d54 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   47d54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47d58:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47d5a:	8903      	ldrh	r3, [r0, #8]
{
   47d5c:	460e      	mov	r6, r1
   47d5e:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
   47d60:	f3c3 028d 	ubfx	r2, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   47d64:	42a2      	cmp	r2, r4
{
   47d66:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
   47d6a:	d803      	bhi.n	47d74 <log_msg_hexdump_data_op+0x20>
		*length = 0;
   47d6c:	2300      	movs	r3, #0
   47d6e:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   47d70:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   47d74:	680b      	ldr	r3, [r1, #0]
   47d76:	4423      	add	r3, r4
   47d78:	4293      	cmp	r3, r2
		*length = available_len - offset;
   47d7a:	bf84      	itt	hi
   47d7c:	1b13      	subhi	r3, r2, r4
   47d7e:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47d80:	2a0c      	cmp	r2, #12
	req_len = *length;
   47d82:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   47d86:	d92a      	bls.n	47dde <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   47d88:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   47d8a:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   47d8e:	d82d      	bhi.n	47dec <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   47d90:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
   47d92:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47d94:	454a      	cmp	r2, r9
   47d96:	bf28      	it	cs
   47d98:	464a      	movcs	r2, r9
   47d9a:	4420      	add	r0, r4
   47d9c:	4615      	mov	r5, r2
		if (put_op) {
   47d9e:	b317      	cbz	r7, 47de6 <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
   47da0:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   47da2:	f000 fa92 	bl	482ca <memcpy>
		req_len -= cpy_len;
   47da6:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47daa:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
   47dac:	f1b9 0f00 	cmp.w	r9, #0
   47db0:	d0de      	beq.n	47d70 <log_msg_hexdump_data_op+0x1c>
   47db2:	f1b8 0f00 	cmp.w	r8, #0
   47db6:	d0db      	beq.n	47d70 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   47db8:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   47dbc:	454d      	cmp	r5, r9
   47dbe:	bf28      	it	cs
   47dc0:	464d      	movcs	r5, r9
		if (put_op) {
   47dc2:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
   47dc4:	462a      	mov	r2, r5
   47dc6:	4440      	add	r0, r8
		if (put_op) {
   47dc8:	b1bf      	cbz	r7, 47dfa <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
   47dca:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   47dcc:	f000 fa7d 	bl	482ca <memcpy>
		offset = 0;
   47dd0:	2400      	movs	r4, #0
		cont = cont->next;
   47dd2:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
   47dd6:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   47dda:	442e      	add	r6, r5
   47ddc:	e7e6      	b.n	47dac <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
   47dde:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
   47de2:	3014      	adds	r0, #20
	if (offset < chunk_len) {
   47de4:	e7d6      	b.n	47d94 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   47de6:	4601      	mov	r1, r0
   47de8:	4630      	mov	r0, r6
   47dea:	e7da      	b.n	47da2 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   47dec:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   47dee:	2c1b      	cmp	r4, #27
   47df0:	d9dc      	bls.n	47dac <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   47df2:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   47df6:	3c1c      	subs	r4, #28
   47df8:	e7f9      	b.n	47dee <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
   47dfa:	4601      	mov	r1, r0
   47dfc:	4630      	mov	r0, r6
   47dfe:	e7e5      	b.n	47dcc <log_msg_hexdump_data_op+0x78>

00047e00 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   47e00:	3004      	adds	r0, #4
   47e02:	e8d0 3fef 	ldaex	r3, [r0]
   47e06:	3301      	adds	r3, #1
   47e08:	e8c0 3fe2 	stlex	r2, r3, [r0]
   47e0c:	2a00      	cmp	r2, #0
   47e0e:	d1f8      	bne.n	47e02 <log_msg_get+0x2>
}
   47e10:	4770      	bx	lr

00047e12 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   47e12:	7a40      	ldrb	r0, [r0, #9]
}
   47e14:	0900      	lsrs	r0, r0, #4
   47e16:	4770      	bx	lr

00047e18 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   47e18:	7a43      	ldrb	r3, [r0, #9]
   47e1a:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   47e1e:	ea4f 1213 	mov.w	r2, r3, lsr #4
   47e22:	d216      	bcs.n	47e52 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   47e24:	2a03      	cmp	r2, #3
   47e26:	d803      	bhi.n	47e30 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   47e28:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47e2c:	6948      	ldr	r0, [r1, #20]
   47e2e:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   47e30:	2901      	cmp	r1, #1
   47e32:	d803      	bhi.n	47e3c <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   47e34:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   47e38:	6988      	ldr	r0, [r1, #24]
   47e3a:	4770      	bx	lr
	cont = msg->payload.ext.next;
   47e3c:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   47e3e:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   47e40:	2906      	cmp	r1, #6
   47e42:	d803      	bhi.n	47e4c <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   47e44:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   47e48:	6848      	ldr	r0, [r1, #4]
   47e4a:	4770      	bx	lr
		cont = cont->next;
   47e4c:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   47e4e:	3907      	subs	r1, #7
		cont = cont->next;
   47e50:	e7f6      	b.n	47e40 <log_msg_arg_get+0x28>
		return 0;
   47e52:	2000      	movs	r0, #0
}
   47e54:	4770      	bx	lr

00047e56 <log_msg_put>:
{
   47e56:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   47e58:	1d02      	adds	r2, r0, #4
   47e5a:	e8d2 1fef 	ldaex	r1, [r2]
   47e5e:	3901      	subs	r1, #1
   47e60:	e8c2 1fec 	stlex	ip, r1, [r2]
   47e64:	f1bc 0f00 	cmp.w	ip, #0
   47e68:	d1f7      	bne.n	47e5a <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
   47e6a:	685b      	ldr	r3, [r3, #4]
   47e6c:	b90b      	cbnz	r3, 47e72 <log_msg_put+0x1c>
		msg_free(msg);
   47e6e:	f7f9 bce3 	b.w	41838 <msg_free>
}
   47e72:	4770      	bx	lr

00047e74 <log_msg_str_get>:
}
   47e74:	6900      	ldr	r0, [r0, #16]
   47e76:	4770      	bx	lr

00047e78 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   47e78:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   47e7a:	2400      	movs	r4, #0
   47e7c:	9400      	str	r4, [sp, #0]
   47e7e:	f7ff ff69 	bl	47d54 <log_msg_hexdump_data_op>
}
   47e82:	b002      	add	sp, #8
   47e84:	bd10      	pop	{r4, pc}

00047e86 <buffer_write>:
{
   47e86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47e88:	4606      	mov	r6, r0
   47e8a:	460d      	mov	r5, r1
   47e8c:	4614      	mov	r4, r2
   47e8e:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   47e90:	4621      	mov	r1, r4
   47e92:	4628      	mov	r0, r5
   47e94:	463a      	mov	r2, r7
   47e96:	47b0      	blx	r6
	} while (len != 0);
   47e98:	1a24      	subs	r4, r4, r0
		buf += processed;
   47e9a:	4405      	add	r5, r0
	} while (len != 0);
   47e9c:	d1f8      	bne.n	47e90 <buffer_write+0xa>
}
   47e9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00047ea0 <std_print>:
{
   47ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   47ea4:	b08e      	sub	sp, #56	; 0x38
   47ea6:	af0e      	add	r7, sp, #56	; 0x38
   47ea8:	4680      	mov	r8, r0
   47eaa:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   47eac:	f7ff ffe2 	bl	47e74 <log_msg_str_get>
   47eb0:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
   47eb2:	4640      	mov	r0, r8
   47eb4:	f7ff ffad 	bl	47e12 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
   47eb8:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
   47ebc:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
   47ebe:	0083      	lsls	r3, r0, #2
   47ec0:	3307      	adds	r3, #7
   47ec2:	f023 0307 	bic.w	r3, r3, #7
   47ec6:	ebad 0d03 	sub.w	sp, sp, r3
   47eca:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   47ecc:	45d1      	cmp	r9, sl
   47ece:	d116      	bne.n	47efe <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   47ed0:	4640      	mov	r0, r8
   47ed2:	f7ff ff9e 	bl	47e12 <log_msg_nargs_get>
   47ed6:	280f      	cmp	r0, #15
   47ed8:	d81e      	bhi.n	47f18 <std_print+0x78>
   47eda:	e8df f010 	tbh	[pc, r0, lsl #1]
   47ede:	0019      	.short	0x0019
   47ee0:	00260020 	.word	0x00260020
   47ee4:	0036002d 	.word	0x0036002d
   47ee8:	004e0041 	.word	0x004e0041
   47eec:	006e005d 	.word	0x006e005d
   47ef0:	00960081 	.word	0x00960081
   47ef4:	00c600ad 	.word	0x00c600ad
   47ef8:	00fe00e1 	.word	0x00fe00e1
   47efc:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   47efe:	4649      	mov	r1, r9
   47f00:	4640      	mov	r0, r8
   47f02:	f7ff ff89 	bl	47e18 <log_msg_arg_get>
   47f06:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   47f0a:	f109 0901 	add.w	r9, r9, #1
   47f0e:	e7dd      	b.n	47ecc <std_print+0x2c>
		print_formatted(output, str);
   47f10:	4631      	mov	r1, r6
   47f12:	4628      	mov	r0, r5
   47f14:	f7f9 fcce 	bl	418b4 <print_formatted>
}
   47f18:	46bd      	mov	sp, r7
   47f1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
   47f1e:	4631      	mov	r1, r6
   47f20:	4628      	mov	r0, r5
   47f22:	6822      	ldr	r2, [r4, #0]
   47f24:	f7f9 fcc6 	bl	418b4 <print_formatted>
		break;
   47f28:	e7f6      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
   47f2a:	4631      	mov	r1, r6
   47f2c:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f30:	4628      	mov	r0, r5
   47f32:	f7f9 fcbf 	bl	418b4 <print_formatted>
		break;
   47f36:	e7ef      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
   47f38:	68a3      	ldr	r3, [r4, #8]
   47f3a:	4631      	mov	r1, r6
   47f3c:	9300      	str	r3, [sp, #0]
   47f3e:	4628      	mov	r0, r5
   47f40:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f44:	f7f9 fcb6 	bl	418b4 <print_formatted>
		break;
   47f48:	e7e6      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f4a:	68e3      	ldr	r3, [r4, #12]
   47f4c:	4631      	mov	r1, r6
   47f4e:	9301      	str	r3, [sp, #4]
   47f50:	68a3      	ldr	r3, [r4, #8]
   47f52:	4628      	mov	r0, r5
   47f54:	9300      	str	r3, [sp, #0]
   47f56:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f5a:	f7f9 fcab 	bl	418b4 <print_formatted>
		break;
   47f5e:	e7db      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f60:	6923      	ldr	r3, [r4, #16]
   47f62:	4631      	mov	r1, r6
   47f64:	9302      	str	r3, [sp, #8]
   47f66:	68e3      	ldr	r3, [r4, #12]
   47f68:	4628      	mov	r0, r5
   47f6a:	9301      	str	r3, [sp, #4]
   47f6c:	68a3      	ldr	r3, [r4, #8]
   47f6e:	9300      	str	r3, [sp, #0]
   47f70:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f74:	f7f9 fc9e 	bl	418b4 <print_formatted>
		break;
   47f78:	e7ce      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f7a:	6963      	ldr	r3, [r4, #20]
   47f7c:	4631      	mov	r1, r6
   47f7e:	9303      	str	r3, [sp, #12]
   47f80:	6923      	ldr	r3, [r4, #16]
   47f82:	4628      	mov	r0, r5
   47f84:	9302      	str	r3, [sp, #8]
   47f86:	68e3      	ldr	r3, [r4, #12]
   47f88:	9301      	str	r3, [sp, #4]
   47f8a:	68a3      	ldr	r3, [r4, #8]
   47f8c:	9300      	str	r3, [sp, #0]
   47f8e:	e9d4 2300 	ldrd	r2, r3, [r4]
   47f92:	f7f9 fc8f 	bl	418b4 <print_formatted>
		break;
   47f96:	e7bf      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47f98:	69a3      	ldr	r3, [r4, #24]
   47f9a:	4631      	mov	r1, r6
   47f9c:	9304      	str	r3, [sp, #16]
   47f9e:	6963      	ldr	r3, [r4, #20]
   47fa0:	4628      	mov	r0, r5
   47fa2:	9303      	str	r3, [sp, #12]
   47fa4:	6923      	ldr	r3, [r4, #16]
   47fa6:	9302      	str	r3, [sp, #8]
   47fa8:	68e3      	ldr	r3, [r4, #12]
   47faa:	9301      	str	r3, [sp, #4]
   47fac:	68a3      	ldr	r3, [r4, #8]
   47fae:	9300      	str	r3, [sp, #0]
   47fb0:	e9d4 2300 	ldrd	r2, r3, [r4]
   47fb4:	f7f9 fc7e 	bl	418b4 <print_formatted>
		break;
   47fb8:	e7ae      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47fba:	69e3      	ldr	r3, [r4, #28]
   47fbc:	4631      	mov	r1, r6
   47fbe:	9305      	str	r3, [sp, #20]
   47fc0:	69a3      	ldr	r3, [r4, #24]
   47fc2:	4628      	mov	r0, r5
   47fc4:	9304      	str	r3, [sp, #16]
   47fc6:	6963      	ldr	r3, [r4, #20]
   47fc8:	9303      	str	r3, [sp, #12]
   47fca:	6923      	ldr	r3, [r4, #16]
   47fcc:	9302      	str	r3, [sp, #8]
   47fce:	68e3      	ldr	r3, [r4, #12]
   47fd0:	9301      	str	r3, [sp, #4]
   47fd2:	68a3      	ldr	r3, [r4, #8]
   47fd4:	9300      	str	r3, [sp, #0]
   47fd6:	e9d4 2300 	ldrd	r2, r3, [r4]
   47fda:	f7f9 fc6b 	bl	418b4 <print_formatted>
		break;
   47fde:	e79b      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   47fe0:	6a23      	ldr	r3, [r4, #32]
   47fe2:	4631      	mov	r1, r6
   47fe4:	9306      	str	r3, [sp, #24]
   47fe6:	69e3      	ldr	r3, [r4, #28]
   47fe8:	4628      	mov	r0, r5
   47fea:	9305      	str	r3, [sp, #20]
   47fec:	69a3      	ldr	r3, [r4, #24]
   47fee:	9304      	str	r3, [sp, #16]
   47ff0:	6963      	ldr	r3, [r4, #20]
   47ff2:	9303      	str	r3, [sp, #12]
   47ff4:	6923      	ldr	r3, [r4, #16]
   47ff6:	9302      	str	r3, [sp, #8]
   47ff8:	68e3      	ldr	r3, [r4, #12]
   47ffa:	9301      	str	r3, [sp, #4]
   47ffc:	68a3      	ldr	r3, [r4, #8]
   47ffe:	9300      	str	r3, [sp, #0]
   48000:	e9d4 2300 	ldrd	r2, r3, [r4]
   48004:	f7f9 fc56 	bl	418b4 <print_formatted>
		break;
   48008:	e786      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   4800a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4800c:	4631      	mov	r1, r6
   4800e:	9307      	str	r3, [sp, #28]
   48010:	6a23      	ldr	r3, [r4, #32]
   48012:	4628      	mov	r0, r5
   48014:	9306      	str	r3, [sp, #24]
   48016:	69e3      	ldr	r3, [r4, #28]
   48018:	9305      	str	r3, [sp, #20]
   4801a:	69a3      	ldr	r3, [r4, #24]
   4801c:	9304      	str	r3, [sp, #16]
   4801e:	6963      	ldr	r3, [r4, #20]
   48020:	9303      	str	r3, [sp, #12]
   48022:	6923      	ldr	r3, [r4, #16]
   48024:	9302      	str	r3, [sp, #8]
   48026:	68e3      	ldr	r3, [r4, #12]
   48028:	9301      	str	r3, [sp, #4]
   4802a:	68a3      	ldr	r3, [r4, #8]
   4802c:	9300      	str	r3, [sp, #0]
   4802e:	e9d4 2300 	ldrd	r2, r3, [r4]
   48032:	f7f9 fc3f 	bl	418b4 <print_formatted>
		break;
   48036:	e76f      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48038:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   4803a:	4631      	mov	r1, r6
   4803c:	9308      	str	r3, [sp, #32]
   4803e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48040:	4628      	mov	r0, r5
   48042:	9307      	str	r3, [sp, #28]
   48044:	6a23      	ldr	r3, [r4, #32]
   48046:	9306      	str	r3, [sp, #24]
   48048:	69e3      	ldr	r3, [r4, #28]
   4804a:	9305      	str	r3, [sp, #20]
   4804c:	69a3      	ldr	r3, [r4, #24]
   4804e:	9304      	str	r3, [sp, #16]
   48050:	6963      	ldr	r3, [r4, #20]
   48052:	9303      	str	r3, [sp, #12]
   48054:	6923      	ldr	r3, [r4, #16]
   48056:	9302      	str	r3, [sp, #8]
   48058:	68e3      	ldr	r3, [r4, #12]
   4805a:	9301      	str	r3, [sp, #4]
   4805c:	68a3      	ldr	r3, [r4, #8]
   4805e:	9300      	str	r3, [sp, #0]
   48060:	e9d4 2300 	ldrd	r2, r3, [r4]
   48064:	f7f9 fc26 	bl	418b4 <print_formatted>
		break;
   48068:	e756      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   4806a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   4806c:	4631      	mov	r1, r6
   4806e:	9309      	str	r3, [sp, #36]	; 0x24
   48070:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   48072:	4628      	mov	r0, r5
   48074:	9308      	str	r3, [sp, #32]
   48076:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48078:	9307      	str	r3, [sp, #28]
   4807a:	6a23      	ldr	r3, [r4, #32]
   4807c:	9306      	str	r3, [sp, #24]
   4807e:	69e3      	ldr	r3, [r4, #28]
   48080:	9305      	str	r3, [sp, #20]
   48082:	69a3      	ldr	r3, [r4, #24]
   48084:	9304      	str	r3, [sp, #16]
   48086:	6963      	ldr	r3, [r4, #20]
   48088:	9303      	str	r3, [sp, #12]
   4808a:	6923      	ldr	r3, [r4, #16]
   4808c:	9302      	str	r3, [sp, #8]
   4808e:	68e3      	ldr	r3, [r4, #12]
   48090:	9301      	str	r3, [sp, #4]
   48092:	68a3      	ldr	r3, [r4, #8]
   48094:	9300      	str	r3, [sp, #0]
   48096:	e9d4 2300 	ldrd	r2, r3, [r4]
   4809a:	f7f9 fc0b 	bl	418b4 <print_formatted>
		break;
   4809e:	e73b      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   480a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   480a2:	4631      	mov	r1, r6
   480a4:	930a      	str	r3, [sp, #40]	; 0x28
   480a6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   480a8:	4628      	mov	r0, r5
   480aa:	9309      	str	r3, [sp, #36]	; 0x24
   480ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   480ae:	9308      	str	r3, [sp, #32]
   480b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   480b2:	9307      	str	r3, [sp, #28]
   480b4:	6a23      	ldr	r3, [r4, #32]
   480b6:	9306      	str	r3, [sp, #24]
   480b8:	69e3      	ldr	r3, [r4, #28]
   480ba:	9305      	str	r3, [sp, #20]
   480bc:	69a3      	ldr	r3, [r4, #24]
   480be:	9304      	str	r3, [sp, #16]
   480c0:	6963      	ldr	r3, [r4, #20]
   480c2:	9303      	str	r3, [sp, #12]
   480c4:	6923      	ldr	r3, [r4, #16]
   480c6:	9302      	str	r3, [sp, #8]
   480c8:	68e3      	ldr	r3, [r4, #12]
   480ca:	9301      	str	r3, [sp, #4]
   480cc:	68a3      	ldr	r3, [r4, #8]
   480ce:	9300      	str	r3, [sp, #0]
   480d0:	e9d4 2300 	ldrd	r2, r3, [r4]
   480d4:	f7f9 fbee 	bl	418b4 <print_formatted>
		break;
   480d8:	e71e      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   480da:	6b63      	ldr	r3, [r4, #52]	; 0x34
   480dc:	4631      	mov	r1, r6
   480de:	930b      	str	r3, [sp, #44]	; 0x2c
   480e0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   480e2:	4628      	mov	r0, r5
   480e4:	930a      	str	r3, [sp, #40]	; 0x28
   480e6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   480e8:	9309      	str	r3, [sp, #36]	; 0x24
   480ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   480ec:	9308      	str	r3, [sp, #32]
   480ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
   480f0:	9307      	str	r3, [sp, #28]
   480f2:	6a23      	ldr	r3, [r4, #32]
   480f4:	9306      	str	r3, [sp, #24]
   480f6:	69e3      	ldr	r3, [r4, #28]
   480f8:	9305      	str	r3, [sp, #20]
   480fa:	69a3      	ldr	r3, [r4, #24]
   480fc:	9304      	str	r3, [sp, #16]
   480fe:	6963      	ldr	r3, [r4, #20]
   48100:	9303      	str	r3, [sp, #12]
   48102:	6923      	ldr	r3, [r4, #16]
   48104:	9302      	str	r3, [sp, #8]
   48106:	68e3      	ldr	r3, [r4, #12]
   48108:	9301      	str	r3, [sp, #4]
   4810a:	68a3      	ldr	r3, [r4, #8]
   4810c:	9300      	str	r3, [sp, #0]
   4810e:	e9d4 2300 	ldrd	r2, r3, [r4]
   48112:	f7f9 fbcf 	bl	418b4 <print_formatted>
		break;
   48116:	e6ff      	b.n	47f18 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48118:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   4811a:	4631      	mov	r1, r6
   4811c:	930c      	str	r3, [sp, #48]	; 0x30
   4811e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   48120:	4628      	mov	r0, r5
   48122:	930b      	str	r3, [sp, #44]	; 0x2c
   48124:	6b23      	ldr	r3, [r4, #48]	; 0x30
   48126:	930a      	str	r3, [sp, #40]	; 0x28
   48128:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   4812a:	9309      	str	r3, [sp, #36]	; 0x24
   4812c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   4812e:	9308      	str	r3, [sp, #32]
   48130:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48132:	9307      	str	r3, [sp, #28]
   48134:	6a23      	ldr	r3, [r4, #32]
   48136:	9306      	str	r3, [sp, #24]
   48138:	69e3      	ldr	r3, [r4, #28]
   4813a:	9305      	str	r3, [sp, #20]
   4813c:	69a3      	ldr	r3, [r4, #24]
   4813e:	9304      	str	r3, [sp, #16]
   48140:	6963      	ldr	r3, [r4, #20]
   48142:	9303      	str	r3, [sp, #12]
   48144:	6923      	ldr	r3, [r4, #16]
   48146:	9302      	str	r3, [sp, #8]
   48148:	68e3      	ldr	r3, [r4, #12]
   4814a:	9301      	str	r3, [sp, #4]
   4814c:	68a3      	ldr	r3, [r4, #8]
   4814e:	9300      	str	r3, [sp, #0]
   48150:	e9d4 2300 	ldrd	r2, r3, [r4]
   48154:	f7f9 fbae 	bl	418b4 <print_formatted>
}
   48158:	e6de      	b.n	47f18 <std_print+0x78>

0004815a <log_output_flush>:
		     output->control_block->offset,
   4815a:	6842      	ldr	r2, [r0, #4]
{
   4815c:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
   4815e:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   48162:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   48164:	6881      	ldr	r1, [r0, #8]
   48166:	6800      	ldr	r0, [r0, #0]
   48168:	f7ff fe8d 	bl	47e86 <buffer_write>
	output->control_block->offset = 0;
   4816c:	2200      	movs	r2, #0
   4816e:	6863      	ldr	r3, [r4, #4]
   48170:	601a      	str	r2, [r3, #0]
}
   48172:	bd10      	pop	{r4, pc}

00048174 <out_func>:
{
   48174:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   48176:	684b      	ldr	r3, [r1, #4]
{
   48178:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
   4817a:	681a      	ldr	r2, [r3, #0]
   4817c:	68cb      	ldr	r3, [r1, #12]
{
   4817e:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   48180:	429a      	cmp	r2, r3
   48182:	d102      	bne.n	4818a <out_func+0x16>
		log_output_flush(out_ctx);
   48184:	4608      	mov	r0, r1
   48186:	f7ff ffe8 	bl	4815a <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   4818a:	6863      	ldr	r3, [r4, #4]
   4818c:	e8d3 2fef 	ldaex	r2, [r3]
   48190:	1c51      	adds	r1, r2, #1
   48192:	e8c3 1fe0 	stlex	r0, r1, [r3]
   48196:	2800      	cmp	r0, #0
   48198:	d1f8      	bne.n	4818c <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
   4819a:	68a3      	ldr	r3, [r4, #8]
}
   4819c:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
   4819e:	549d      	strb	r5, [r3, r2]
}
   481a0:	bd38      	pop	{r3, r4, r5, pc}

000481a2 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   481a2:	2200      	movs	r2, #0
   481a4:	e9c0 2200 	strd	r2, r2, [r0]
   481a8:	6082      	str	r2, [r0, #8]
}
   481aa:	4770      	bx	lr

000481ac <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   481ac:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   481ae:	6800      	ldr	r0, [r0, #0]
   481b0:	f7f9 bf6c 	b.w	4208c <z_arm_fatal_error>

000481b4 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   481b4:	2100      	movs	r1, #0
   481b6:	2001      	movs	r0, #1
   481b8:	f7f9 bf68 	b.w	4208c <z_arm_fatal_error>

000481bc <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   481bc:	b508      	push	{r3, lr}
	handler();
   481be:	f7f9 ffdf 	bl	42180 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   481c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   481c6:	f7fa b8a7 	b.w	42318 <z_arm_exc_exit>

000481ca <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   481ca:	6e43      	ldr	r3, [r0, #100]	; 0x64
   481cc:	f383 880b 	msr	PSPLIM, r3
}
   481d0:	4770      	bx	lr

000481d2 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   481d2:	4770      	bx	lr

000481d4 <z_arm_restore_fp_context>:
   481d4:	4770      	bx	lr

000481d6 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   481d6:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   481da:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   481de:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   481e0:	bf08      	it	eq
   481e2:	f06f 0015 	mvneq.w	r0, #21
   481e6:	4770      	bx	lr

000481e8 <mpu_configure_region>:
{
   481e8:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   481ea:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   481ec:	680c      	ldr	r4, [r1, #0]
{
   481ee:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   481f0:	890a      	ldrh	r2, [r1, #8]
   481f2:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   481f4:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   481f6:	3b01      	subs	r3, #1
   481f8:	f024 041f 	bic.w	r4, r4, #31
   481fc:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   481fe:	f002 021f 	and.w	r2, r2, #31
   48202:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48206:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   4820a:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
   4820c:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48210:	9303      	str	r3, [sp, #12]
   48212:	f7fa fb8d 	bl	42930 <region_allocate_and_init>
}
   48216:	b005      	add	sp, #20
   48218:	bd30      	pop	{r4, r5, pc}

0004821a <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
   4821a:	4770      	bx	lr

0004821c <calloc>:

#endif /* CONFIG_MINIMAL_LIBC_MALLOC */

#ifdef CONFIG_MINIMAL_LIBC_CALLOC
void *calloc(size_t nmemb, size_t size)
{
   4821c:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   4821e:	fba0 4501 	umull	r4, r5, r0, r1
   48222:	b935      	cbnz	r5, 48232 <calloc+0x16>
	if (size_mul_overflow(nmemb, size, &size)) {
		errno = ENOMEM;
		return NULL;
	}

	ret = malloc(size);
   48224:	4620      	mov	r0, r4
   48226:	f7fa fcef 	bl	42c08 <malloc>

	if (ret != NULL) {
   4822a:	4606      	mov	r6, r0
   4822c:	b938      	cbnz	r0, 4823e <calloc+0x22>
		(void)memset(ret, 0, size);
	}

	return ret;
}
   4822e:	4630      	mov	r0, r6
   48230:	bd70      	pop	{r4, r5, r6, pc}
   48232:	f7fd ffbd 	bl	461b0 <z_impl_z_errno>
		errno = ENOMEM;
   48236:	230c      	movs	r3, #12
		return NULL;
   48238:	2600      	movs	r6, #0
		errno = ENOMEM;
   4823a:	6003      	str	r3, [r0, #0]
		return NULL;
   4823c:	e7f7      	b.n	4822e <calloc+0x12>
		(void)memset(ret, 0, size);
   4823e:	4622      	mov	r2, r4
   48240:	4629      	mov	r1, r5
   48242:	f000 f84d 	bl	482e0 <memset>
   48246:	e7f2      	b.n	4822e <calloc+0x12>

00048248 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   48248:	4603      	mov	r3, r0
   4824a:	3901      	subs	r1, #1
   4824c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   48250:	b90a      	cbnz	r2, 48256 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   48252:	701a      	strb	r2, [r3, #0]

	return dest;
}
   48254:	4770      	bx	lr
		*d = *s;
   48256:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   4825a:	e7f7      	b.n	4824c <strcpy+0x4>

0004825c <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
   4825c:	b570      	push	{r4, r5, r6, lr}
   4825e:	4605      	mov	r5, r0
   48260:	3901      	subs	r1, #1
   48262:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   48264:	b142      	cbz	r2, 48278 <strncpy+0x1c>
   48266:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   4826a:	1e56      	subs	r6, r2, #1
   4826c:	b92b      	cbnz	r3, 4827a <strncpy+0x1e>
   4826e:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   48270:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   48274:	42a2      	cmp	r2, r4
   48276:	d1fb      	bne.n	48270 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   48278:	bd70      	pop	{r4, r5, r6, pc}
		n--;
   4827a:	4632      	mov	r2, r6
		*d = *s;
   4827c:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   48280:	e7ef      	b.n	48262 <strncpy+0x6>

00048282 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   48282:	4603      	mov	r3, r0
	size_t n = 0;
   48284:	2000      	movs	r0, #0

	while (*s != '\0') {
   48286:	5c1a      	ldrb	r2, [r3, r0]
   48288:	b902      	cbnz	r2, 4828c <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   4828a:	4770      	bx	lr
		n++;
   4828c:	3001      	adds	r0, #1
   4828e:	e7fa      	b.n	48286 <strlen+0x4>

00048290 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   48290:	4603      	mov	r3, r0
	size_t n = 0;
   48292:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   48294:	5c1a      	ldrb	r2, [r3, r0]
   48296:	b10a      	cbz	r2, 4829c <strnlen+0xc>
   48298:	4288      	cmp	r0, r1
   4829a:	d100      	bne.n	4829e <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   4829c:	4770      	bx	lr
		n++;
   4829e:	3001      	adds	r0, #1
   482a0:	e7f8      	b.n	48294 <strnlen+0x4>

000482a2 <strncat>:
	return dest;
}

char *strncat(char *ZRESTRICT dest, const char *ZRESTRICT src,
	      size_t n)
{
   482a2:	b538      	push	{r3, r4, r5, lr}
   482a4:	4605      	mov	r5, r0
   482a6:	4614      	mov	r4, r2
	char *orig_dest = dest;
	size_t len = strlen(dest);
   482a8:	f7ff ffeb 	bl	48282 <strlen>

	dest += len;
   482ac:	182b      	adds	r3, r5, r0
	while ((n-- > 0) && (*src != '\0')) {
   482ae:	3901      	subs	r1, #1
   482b0:	441c      	add	r4, r3
   482b2:	42a3      	cmp	r3, r4
   482b4:	d002      	beq.n	482bc <strncat+0x1a>
   482b6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   482ba:	b91a      	cbnz	r2, 482c4 <strncat+0x22>
		*dest++ = *src++;
	}
	*dest = '\0';
   482bc:	2200      	movs	r2, #0
   482be:	701a      	strb	r2, [r3, #0]

	return orig_dest;
}
   482c0:	4628      	mov	r0, r5
   482c2:	bd38      	pop	{r3, r4, r5, pc}
		*dest++ = *src++;
   482c4:	f803 2b01 	strb.w	r2, [r3], #1
   482c8:	e7f3      	b.n	482b2 <strncat+0x10>

000482ca <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   482ca:	b510      	push	{r4, lr}
   482cc:	1e43      	subs	r3, r0, #1
   482ce:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   482d0:	4291      	cmp	r1, r2
   482d2:	d100      	bne.n	482d6 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   482d4:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   482d6:	f811 4b01 	ldrb.w	r4, [r1], #1
   482da:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   482de:	e7f7      	b.n	482d0 <memcpy+0x6>

000482e0 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   482e0:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   482e2:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   482e4:	4402      	add	r2, r0
   482e6:	4293      	cmp	r3, r2
   482e8:	d100      	bne.n	482ec <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   482ea:	4770      	bx	lr
		*(d_byte++) = c_byte;
   482ec:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   482f0:	e7f9      	b.n	482e6 <memset+0x6>

000482f2 <_stdout_hook_default>:
}
   482f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   482f6:	4770      	bx	lr

000482f8 <fputc>:
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
   482f8:	f7fa bcac 	b.w	42c54 <z_impl_zephyr_fputc>

000482fc <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   482fc:	684b      	ldr	r3, [r1, #4]
   482fe:	2b01      	cmp	r3, #1
   48300:	dd07      	ble.n	48312 <sprintf_out+0x16>
		*(p->ptr) = c;
   48302:	680b      	ldr	r3, [r1, #0]
   48304:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   48306:	680b      	ldr	r3, [r1, #0]
   48308:	3301      	adds	r3, #1
   4830a:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   4830c:	684b      	ldr	r3, [r1, #4]
   4830e:	3b01      	subs	r3, #1
   48310:	604b      	str	r3, [r1, #4]
}
   48312:	2000      	movs	r0, #0
   48314:	4770      	bx	lr

00048316 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   48316:	b2cb      	uxtb	r3, r1
   48318:	210c      	movs	r1, #12
   4831a:	6902      	ldr	r2, [r0, #16]
   4831c:	fb03 2101 	mla	r1, r3, r1, r2
   48320:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   48322:	f000 0007 	and.w	r0, r0, #7
   48326:	4770      	bx	lr

00048328 <set_off_state>:
	__asm__ volatile(
   48328:	f04f 0320 	mov.w	r3, #32
   4832c:	f3ef 8211 	mrs	r2, BASEPRI
   48330:	f383 8812 	msr	BASEPRI_MAX, r3
   48334:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   48338:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   4833a:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   4833e:	d001      	beq.n	48344 <set_off_state+0x1c>
   48340:	428b      	cmp	r3, r1
   48342:	d107      	bne.n	48354 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   48344:	2301      	movs	r3, #1
   48346:	6003      	str	r3, [r0, #0]
	int err = 0;
   48348:	2000      	movs	r0, #0
	__asm__ volatile(
   4834a:	f382 8811 	msr	BASEPRI, r2
   4834e:	f3bf 8f6f 	isb	sy
}
   48352:	4770      	bx	lr
		err = -EPERM;
   48354:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   48358:	e7f7      	b.n	4834a <set_off_state+0x22>

0004835a <set_starting_state>:
{
   4835a:	b510      	push	{r4, lr}
	__asm__ volatile(
   4835c:	f04f 0320 	mov.w	r3, #32
   48360:	f3ef 8211 	mrs	r2, BASEPRI
   48364:	f383 8812 	msr	BASEPRI_MAX, r3
   48368:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   4836c:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   4836e:	f003 0407 	and.w	r4, r3, #7
   48372:	2c01      	cmp	r4, #1
   48374:	d106      	bne.n	48384 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   48376:	6001      	str	r1, [r0, #0]
	int err = 0;
   48378:	2000      	movs	r0, #0
	__asm__ volatile(
   4837a:	f382 8811 	msr	BASEPRI, r2
   4837e:	f3bf 8f6f 	isb	sy
}
   48382:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   48384:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   48388:	428b      	cmp	r3, r1
		err = -EALREADY;
   4838a:	bf14      	ite	ne
   4838c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   48390:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   48394:	e7f1      	b.n	4837a <set_starting_state+0x20>

00048396 <set_on_state>:
	__asm__ volatile(
   48396:	f04f 0320 	mov.w	r3, #32
   4839a:	f3ef 8211 	mrs	r2, BASEPRI
   4839e:	f383 8812 	msr	BASEPRI_MAX, r3
   483a2:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   483a6:	6803      	ldr	r3, [r0, #0]
   483a8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   483ac:	f043 0302 	orr.w	r3, r3, #2
   483b0:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   483b2:	f382 8811 	msr	BASEPRI, r2
   483b6:	f3bf 8f6f 	isb	sy
}
   483ba:	4770      	bx	lr

000483bc <onoff_started_callback>:
{
   483bc:	b410      	push	{r4}
	notify(mgr, 0);
   483be:	241c      	movs	r4, #28
	return &data->mgr[type];
   483c0:	6900      	ldr	r0, [r0, #16]
   483c2:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   483c4:	fb03 0004 	mla	r0, r3, r4, r0
   483c8:	2100      	movs	r1, #0
}
   483ca:	bc10      	pop	{r4}
	notify(mgr, 0);
   483cc:	4710      	bx	r2

000483ce <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   483ce:	2000      	movs	r0, #0
   483d0:	f7fb bdd0 	b.w	43f74 <nrfx_clock_start>

000483d4 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   483d4:	2000      	movs	r0, #0
   483d6:	f7fb bdff 	b.w	43fd8 <nrfx_clock_stop>

000483da <blocking_start_callback>:
{
   483da:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   483dc:	f7fe b9f4 	b.w	467c8 <z_impl_k_sem_give>

000483e0 <api_stop>:
{
   483e0:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   483e2:	240c      	movs	r4, #12
   483e4:	b2c9      	uxtb	r1, r1
   483e6:	434c      	muls	r4, r1
{
   483e8:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   483ea:	6900      	ldr	r0, [r0, #16]
   483ec:	f104 0340 	add.w	r3, r4, #64	; 0x40
   483f0:	2180      	movs	r1, #128	; 0x80
   483f2:	4418      	add	r0, r3
   483f4:	f7ff ff98 	bl	48328 <set_off_state>
	if (err < 0) {
   483f8:	2800      	cmp	r0, #0
   483fa:	db04      	blt.n	48406 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   483fc:	6869      	ldr	r1, [r5, #4]
   483fe:	440c      	add	r4, r1
   48400:	6863      	ldr	r3, [r4, #4]
   48402:	4798      	blx	r3
	return 0;
   48404:	2000      	movs	r0, #0
}
   48406:	bd38      	pop	{r3, r4, r5, pc}

00048408 <api_start>:
{
   48408:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   4840c:	240c      	movs	r4, #12
   4840e:	b2c9      	uxtb	r1, r1
   48410:	434c      	muls	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   48412:	6905      	ldr	r5, [r0, #16]
{
   48414:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   48416:	f104 0040 	add.w	r0, r4, #64	; 0x40
   4841a:	2180      	movs	r1, #128	; 0x80
   4841c:	4428      	add	r0, r5
{
   4841e:	4690      	mov	r8, r2
   48420:	461f      	mov	r7, r3
	err = set_starting_state(&subdata->flags, ctx);
   48422:	f7ff ff9a 	bl	4835a <set_starting_state>
	if (err < 0) {
   48426:	2800      	cmp	r0, #0
   48428:	db06      	blt.n	48438 <api_start+0x30>
	subdata->cb = cb;
   4842a:	4425      	add	r5, r4
	subdata->user_data = user_data;
   4842c:	e9c5 870e 	strd	r8, r7, [r5, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   48430:	6873      	ldr	r3, [r6, #4]
   48432:	591b      	ldr	r3, [r3, r4]
   48434:	4798      	blx	r3
	return 0;
   48436:	2000      	movs	r0, #0
}
   48438:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0004843c <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4843c:	6843      	ldr	r3, [r0, #4]
}
   4843e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48440:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   48442:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   48444:	600b      	str	r3, [r1, #0]
}
   48446:	4770      	bx	lr

00048448 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48448:	6843      	ldr	r3, [r0, #4]
   4844a:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   4844c:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   4844e:	4042      	eors	r2, r0
   48450:	400a      	ands	r2, r1
   48452:	4042      	eors	r2, r0
    p_reg->OUT = value;
   48454:	605a      	str	r2, [r3, #4]
}
   48456:	2000      	movs	r0, #0
   48458:	4770      	bx	lr

0004845a <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4845a:	6843      	ldr	r3, [r0, #4]
}
   4845c:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4845e:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   48460:	6099      	str	r1, [r3, #8]
}
   48462:	4770      	bx	lr

00048464 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48464:	6843      	ldr	r3, [r0, #4]
}
   48466:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48468:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   4846a:	60d9      	str	r1, [r3, #12]
}
   4846c:	4770      	bx	lr

0004846e <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   4846e:	6843      	ldr	r3, [r0, #4]
}
   48470:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48472:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   48474:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   48476:	404b      	eors	r3, r1
    p_reg->OUT = value;
   48478:	6053      	str	r3, [r2, #4]
}
   4847a:	4770      	bx	lr

0004847c <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   4847c:	6903      	ldr	r3, [r0, #16]
{
   4847e:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   48480:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   48482:	b158      	cbz	r0, 4849c <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48484:	2400      	movs	r4, #0
   48486:	4281      	cmp	r1, r0
   48488:	d113      	bne.n	484b2 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   4848a:	6808      	ldr	r0, [r1, #0]
   4848c:	b95c      	cbnz	r4, 484a6 <gpio_nrfx_manage_callback+0x2a>
   4848e:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   48490:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   48492:	42a1      	cmp	r1, r4
   48494:	d100      	bne.n	48498 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   48496:	6098      	str	r0, [r3, #8]
	parent->next = child;
   48498:	2000      	movs	r0, #0
   4849a:	6008      	str	r0, [r1, #0]
	if (set) {
   4849c:	b972      	cbnz	r2, 484bc <gpio_nrfx_manage_callback+0x40>
	return 0;
   4849e:	2000      	movs	r0, #0
}
   484a0:	bd30      	pop	{r4, r5, pc}
   484a2:	4628      	mov	r0, r5
   484a4:	e7ef      	b.n	48486 <gpio_nrfx_manage_callback+0xa>
   484a6:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   484a8:	6898      	ldr	r0, [r3, #8]
   484aa:	4281      	cmp	r1, r0
	list->tail = node;
   484ac:	bf08      	it	eq
   484ae:	609c      	streq	r4, [r3, #8]
}
   484b0:	e7f2      	b.n	48498 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   484b2:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   484b4:	4604      	mov	r4, r0
   484b6:	2d00      	cmp	r5, #0
   484b8:	d1f3      	bne.n	484a2 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   484ba:	b13a      	cbz	r2, 484cc <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   484bc:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   484be:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   484c0:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   484c2:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   484c4:	2800      	cmp	r0, #0
   484c6:	d1ea      	bne.n	4849e <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   484c8:	6099      	str	r1, [r3, #8]
}
   484ca:	e7e9      	b.n	484a0 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   484cc:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   484d0:	e7e6      	b.n	484a0 <gpio_nrfx_manage_callback+0x24>

000484d2 <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   484d2:	6843      	ldr	r3, [r0, #4]
   484d4:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   484d6:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   484da:	05d1      	lsls	r1, r2, #23
   484dc:	d518      	bpl.n	48510 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   484de:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   484e2:	b1aa      	cbz	r2, 48510 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   484e4:	f04f 0120 	mov.w	r1, #32
   484e8:	f3ef 8211 	mrs	r2, BASEPRI
   484ec:	f381 8812 	msr	BASEPRI_MAX, r1
   484f0:	f3bf 8f6f 	isb	sy
   484f4:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   484f8:	b131      	cbz	r1, 48508 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   484fa:	2100      	movs	r1, #0
   484fc:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   48500:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48504:	2101      	movs	r1, #1
   48506:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   48508:	f382 8811 	msr	BASEPRI, r2
   4850c:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   48510:	6842      	ldr	r2, [r0, #4]
   48512:	6852      	ldr	r2, [r2, #4]
   48514:	06d2      	lsls	r2, r2, #27
   48516:	d515      	bpl.n	48544 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   48518:	f04f 0120 	mov.w	r1, #32
   4851c:	f3ef 8211 	mrs	r2, BASEPRI
   48520:	f381 8812 	msr	BASEPRI_MAX, r1
   48524:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48528:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   4852c:	b111      	cbz	r1, 48534 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   4852e:	2100      	movs	r1, #0
   48530:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   48534:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   48538:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   4853c:	f382 8811 	msr	BASEPRI, r2
   48540:	f3bf 8f6f 	isb	sy
}
   48544:	4770      	bx	lr

00048546 <uarte_nrfx_config_get>:
{
   48546:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   48548:	6902      	ldr	r2, [r0, #16]
   4854a:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   4854e:	e883 0003 	stmia.w	r3, {r0, r1}
}
   48552:	2000      	movs	r0, #0
   48554:	4770      	bx	lr

00048556 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   48556:	6843      	ldr	r3, [r0, #4]
   48558:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   4855a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   4855e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   48562:	4770      	bx	lr

00048564 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   48564:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   48566:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48568:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   4856c:	b940      	cbnz	r0, 48580 <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   4856e:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   48570:	0792      	lsls	r2, r2, #30
   48572:	d406      	bmi.n	48582 <is_tx_ready+0x1e>
   48574:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   48578:	3800      	subs	r0, #0
   4857a:	bf18      	it	ne
   4857c:	2001      	movne	r0, #1
   4857e:	4770      	bx	lr
   48580:	2001      	movs	r0, #1
}
   48582:	4770      	bx	lr

00048584 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   48584:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   48586:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   48588:	681b      	ldr	r3, [r3, #0]
   4858a:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   4858e:	b148      	cbz	r0, 485a4 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48590:	2000      	movs	r0, #0
	*c = data->rx_data;
   48592:	7c52      	ldrb	r2, [r2, #17]
   48594:	700a      	strb	r2, [r1, #0]
   48596:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   4859a:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4859e:	2201      	movs	r2, #1
   485a0:	601a      	str	r2, [r3, #0]
	return 0;
   485a2:	4770      	bx	lr
		return -1;
   485a4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   485a8:	4770      	bx	lr

000485aa <entropy_cc3xx_rng_get_entropy>:

static int entropy_cc3xx_rng_get_entropy(
	const struct device *dev,
	uint8_t *buffer,
	uint16_t length)
{
   485aa:	4608      	mov	r0, r1
   485ac:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buffer != NULL);


#if defined(CONFIG_BUILD_WITH_TFM)

	res = psa_generate_random(buffer, length);
   485ae:	4611      	mov	r1, r2
   485b0:	f7fe fed8 	bl	47364 <psa_generate_random>
	if (res != PSA_SUCCESS) {
   485b4:	2800      	cmp	r0, #0
		offset += chunk_size;
	}
#endif

	return res;
}
   485b6:	bf18      	it	ne
   485b8:	f06f 0015 	mvnne.w	r0, #21
   485bc:	bd08      	pop	{r3, pc}

000485be <entropy_cc3xx_rng_init>:

static int entropy_cc3xx_rng_init(const struct device *dev)
{
   485be:	b508      	push	{r3, lr}
	(void)dev;

	#if defined(CONFIG_BUILD_WITH_TFM)
		int ret = -1;

		ret = psa_crypto_init();
   485c0:	f000 fbc6 	bl	48d50 <psa_crypto_init>
		if (ret != PSA_SUCCESS) {
   485c4:	2800      	cmp	r0, #0
			return -EINVAL;
		}
	#endif

	return 0;
}
   485c6:	bf18      	it	ne
   485c8:	f06f 0015 	mvnne.w	r0, #21
   485cc:	bd08      	pop	{r3, pc}

000485ce <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   485ce:	4770      	bx	lr

000485d0 <sys_clock_cycle_get_32>:
{
   485d0:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   485d2:	f7fb f8dd 	bl	43790 <z_nrf_rtc_timer_read>
}
   485d6:	bd08      	pop	{r3, pc}

000485d8 <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   485d8:	f000 bb4d 	b.w	48c76 <z_impl_k_busy_wait>

000485dc <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   485dc:	f000 b9ee 	b.w	489bc <k_is_in_isr>

000485e0 <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   485e0:	f7fe b8f2 	b.w	467c8 <z_impl_k_sem_give>

000485e4 <nrf_modem_os_sem_take>:
{
   485e4:	b508      	push	{r3, lr}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   485e6:	1c4b      	adds	r3, r1, #1
   485e8:	bf13      	iteet	ne
   485ea:	ea21 72e1 	bicne.w	r2, r1, r1, asr #31
   485ee:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   485f2:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   485f6:	17d3      	asrne	r3, r2, #31
	return z_impl_k_sem_take(sem, timeout);
   485f8:	f7fe f906 	bl	46808 <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   485fc:	f110 0f0b 	cmn.w	r0, #11
}
   48600:	bf0c      	ite	eq
   48602:	2074      	moveq	r0, #116	; 0x74
   48604:	2000      	movne	r0, #0
   48606:	bd08      	pop	{r3, pc}

00048608 <read_task_create>:
{
   48608:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   4860a:	201c      	movs	r0, #28
   4860c:	2200      	movs	r2, #0
   4860e:	2106      	movs	r1, #6
   48610:	f7f9 fd92 	bl	42138 <z_arm_irq_priority_set>
}
   48614:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   48618:	201c      	movs	r0, #28
   4861a:	f7f9 bd6f 	b.w	420fc <arch_irq_enable>

0004861e <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   4861e:	2000      	movs	r0, #0
   48620:	4770      	bx	lr

00048622 <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   48622:	2000      	movs	r0, #0
   48624:	4770      	bx	lr

00048626 <sys_arch_reboot>:
#if defined(CONFIG_TFM_PARTITION_PLATFORM)
void sys_arch_reboot(int type)
{
	ARG_UNUSED(type);

	(void)tfm_platform_system_reset();
   48626:	f7fe be8f 	b.w	47348 <tfm_platform_system_reset>

0004862a <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   4862a:	4700      	bx	r0

0004862c <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   4862c:	f000 bb23 	b.w	48c76 <z_impl_k_busy_wait>

00048630 <nrfx_clock_enable>:
{
   48630:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   48632:	2005      	movs	r0, #5
   48634:	f7f9 fd72 	bl	4211c <arch_irq_is_enabled>
   48638:	b920      	cbnz	r0, 48644 <nrfx_clock_enable+0x14>
}
   4863a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   4863e:	2005      	movs	r0, #5
   48640:	f7f9 bd5c 	b.w	420fc <arch_irq_enable>
   48644:	bd08      	pop	{r3, pc}

00048646 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   48646:	f7fc b8f9 	b.w	4483c <_DoInit>

0004864a <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   4864a:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   4864c:	f7ff fffb 	bl	48646 <SEGGER_RTT_Init>

	return 0;
}
   48650:	2000      	movs	r0, #0
   48652:	bd08      	pop	{r3, pc}

00048654 <rpc_handle_ctrl_message>:
   48654:	2902      	cmp	r1, #2
   48656:	b510      	push	{r4, lr}
   48658:	4604      	mov	r4, r0
   4865a:	d005      	beq.n	48668 <rpc_handle_ctrl_message+0x14>
   4865c:	2904      	cmp	r1, #4
   4865e:	d001      	beq.n	48664 <rpc_handle_ctrl_message+0x10>
   48660:	2901      	cmp	r1, #1
   48662:	d107      	bne.n	48674 <rpc_handle_ctrl_message+0x20>
   48664:	2000      	movs	r0, #0
   48666:	bd10      	pop	{r4, pc}
   48668:	6880      	ldr	r0, [r0, #8]
   4866a:	2800      	cmp	r0, #0
   4866c:	d0fa      	beq.n	48664 <rpc_handle_ctrl_message+0x10>
   4866e:	f000 f831 	bl	486d4 <rpc_transport_local_data_free>
   48672:	e7f7      	b.n	48664 <rpc_handle_ctrl_message+0x10>
   48674:	6880      	ldr	r0, [r0, #8]
   48676:	b108      	cbz	r0, 4867c <rpc_handle_ctrl_message+0x28>
   48678:	f000 f82c 	bl	486d4 <rpc_transport_local_data_free>
   4867c:	4620      	mov	r0, r4
   4867e:	f000 f825 	bl	486cc <rpc_transport_msg_free>
   48682:	e7ef      	b.n	48664 <rpc_handle_ctrl_message+0x10>

00048684 <rpc_message_send>:
   48684:	6843      	ldr	r3, [r0, #4]
   48686:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   4868a:	f043 0302 	orr.w	r3, r3, #2
   4868e:	6043      	str	r3, [r0, #4]
   48690:	f000 b824 	b.w	486dc <rpc_transport_data_msg_send>

00048694 <rpc_message_alloc>:
   48694:	b570      	push	{r4, r5, r6, lr}
   48696:	4606      	mov	r6, r0
   48698:	b130      	cbz	r0, 486a8 <rpc_message_alloc+0x14>
   4869a:	f000 f819 	bl	486d0 <rpc_transport_data_alloc>
   4869e:	4605      	mov	r5, r0
   486a0:	b918      	cbnz	r0, 486aa <rpc_message_alloc+0x16>
   486a2:	2400      	movs	r4, #0
   486a4:	4620      	mov	r0, r4
   486a6:	bd70      	pop	{r4, r5, r6, pc}
   486a8:	4605      	mov	r5, r0
   486aa:	f000 f80d 	bl	486c8 <rpc_transport_data_msg_alloc>
   486ae:	4604      	mov	r4, r0
   486b0:	b110      	cbz	r0, 486b8 <rpc_message_alloc+0x24>
   486b2:	60c6      	str	r6, [r0, #12]
   486b4:	6085      	str	r5, [r0, #8]
   486b6:	e7f5      	b.n	486a4 <rpc_message_alloc+0x10>
   486b8:	2d00      	cmp	r5, #0
   486ba:	d0f2      	beq.n	486a2 <rpc_message_alloc+0xe>
   486bc:	4628      	mov	r0, r5
   486be:	f000 f809 	bl	486d4 <rpc_transport_local_data_free>
   486c2:	e7ef      	b.n	486a4 <rpc_message_alloc+0x10>

000486c4 <rpc_message_data_free>:
   486c4:	f000 b808 	b.w	486d8 <rpc_transport_peer_data_free>

000486c8 <rpc_transport_data_msg_alloc>:
   486c8:	f7fc bba0 	b.w	44e0c <rpc_transport_ipc_data_msg_alloc>

000486cc <rpc_transport_msg_free>:
   486cc:	f7fc bbea 	b.w	44ea4 <rpc_transport_ipc_msg_free>

000486d0 <rpc_transport_data_alloc>:
   486d0:	f7fc bbce 	b.w	44e70 <rpc_transport_ipc_data_alloc>

000486d4 <rpc_transport_local_data_free>:
   486d4:	f000 b804 	b.w	486e0 <rpc_transport_ipc_local_data_free>

000486d8 <rpc_transport_peer_data_free>:
   486d8:	f000 b809 	b.w	486ee <rpc_transport_ipc_peer_data_free>

000486dc <rpc_transport_data_msg_send>:
   486dc:	f7fc bb5a 	b.w	44d94 <rpc_transport_ipc_data_msg_send>

000486e0 <rpc_transport_ipc_local_data_free>:
   486e0:	b508      	push	{r3, lr}
   486e2:	f7fb fb85 	bl	43df0 <nrf_modem_os_shm_tx_free>
   486e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   486ea:	f7fb bb4b 	b.w	43d84 <nrf_modem_os_application_irq_set>

000486ee <rpc_transport_ipc_peer_data_free>:
   486ee:	b510      	push	{r4, lr}
   486f0:	4604      	mov	r4, r0
   486f2:	f7fc fb9d 	bl	44e30 <rpc_transport_ipc_ctrl_msg_alloc>
   486f6:	2101      	movs	r1, #1
   486f8:	2200      	movs	r2, #0
   486fa:	7001      	strb	r1, [r0, #0]
   486fc:	2102      	movs	r1, #2
   486fe:	6084      	str	r4, [r0, #8]
   48700:	7042      	strb	r2, [r0, #1]
   48702:	7081      	strb	r1, [r0, #2]
   48704:	70c2      	strb	r2, [r0, #3]
   48706:	f7fc fb63 	bl	44dd0 <rpc_transport_ipc_ctrl_msg_send>
   4870a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   4870e:	f7fb bb39 	b.w	43d84 <nrf_modem_os_application_irq_set>

00048712 <rpc_client_request_alloc>:
   48712:	b508      	push	{r3, lr}
   48714:	f7ff ffbe 	bl	48694 <rpc_message_alloc>
   48718:	b100      	cbz	r0, 4871c <rpc_client_request_alloc+0xa>
   4871a:	3008      	adds	r0, #8
   4871c:	bd08      	pop	{r3, pc}

0004871e <rpc_client_request_send>:
   4871e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   48722:	4610      	mov	r0, r2
   48724:	f840 1d08 	str.w	r1, [r0, #-8]!
   48728:	f7ff bfac 	b.w	48684 <rpc_message_send>

0004872c <rpc_client_data_free>:
   4872c:	f7ff bfca 	b.w	486c4 <rpc_message_data_free>

00048730 <ip_interface_request_create>:
   48730:	b570      	push	{r4, r5, r6, lr}
   48732:	4606      	mov	r6, r0
   48734:	4618      	mov	r0, r3
   48736:	460d      	mov	r5, r1
   48738:	4614      	mov	r4, r2
   4873a:	f7ff ffea 	bl	48712 <rpc_client_request_alloc>
   4873e:	b148      	cbz	r0, 48754 <ip_interface_request_create+0x24>
   48740:	2300      	movs	r3, #0
   48742:	2208      	movs	r2, #8
   48744:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   48748:	60c4      	str	r4, [r0, #12]
   4874a:	6105      	str	r5, [r0, #16]
   4874c:	7202      	strb	r2, [r0, #8]
   4874e:	7243      	strb	r3, [r0, #9]
   48750:	7283      	strb	r3, [r0, #10]
   48752:	72c3      	strb	r3, [r0, #11]
   48754:	bd70      	pop	{r4, r5, r6, pc}

00048756 <ip_interface_wait>:
   48756:	b538      	push	{r3, r4, r5, lr}
   48758:	4605      	mov	r5, r0
   4875a:	f7fc fd29 	bl	451b0 <interface_socket_wait>
   4875e:	4604      	mov	r4, r0
   48760:	b938      	cbnz	r0, 48772 <ip_interface_wait+0x1c>
   48762:	4628      	mov	r0, r5
   48764:	f7fc fd9e 	bl	452a4 <interface_socket_from_handle_get>
   48768:	b118      	cbz	r0, 48772 <ip_interface_wait+0x1c>
   4876a:	6844      	ldr	r4, [r0, #4]
   4876c:	b10c      	cbz	r4, 48772 <ip_interface_wait+0x1c>
   4876e:	2300      	movs	r3, #0
   48770:	6043      	str	r3, [r0, #4]
   48772:	4620      	mov	r0, r4
   48774:	bd38      	pop	{r3, r4, r5, pc}

00048776 <secure_client_socket>:
   48776:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4877a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4877c:	9301      	str	r3, [sp, #4]
   4877e:	680b      	ldr	r3, [r1, #0]
   48780:	4606      	mov	r6, r0
   48782:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   48786:	600b      	str	r3, [r1, #0]
   48788:	680b      	ldr	r3, [r1, #0]
   4878a:	460c      	mov	r4, r1
   4878c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   48790:	600b      	str	r3, [r1, #0]
   48792:	680f      	ldr	r7, [r1, #0]
   48794:	463a      	mov	r2, r7
   48796:	f7fd f851 	bl	4583c <secure_socket_attach_initiate>
   4879a:	4605      	mov	r5, r0
   4879c:	b950      	cbnz	r0, 487b4 <secure_client_socket+0x3e>
   4879e:	220c      	movs	r2, #12
   487a0:	4630      	mov	r0, r6
   487a2:	4611      	mov	r1, r2
   487a4:	ab01      	add	r3, sp, #4
   487a6:	f7ff ffd6 	bl	48756 <ip_interface_wait>
   487aa:	4605      	mov	r5, r0
   487ac:	b128      	cbz	r0, 487ba <secure_client_socket+0x44>
   487ae:	2877      	cmp	r0, #119	; 0x77
   487b0:	d000      	beq.n	487b4 <secure_client_socket+0x3e>
   487b2:	6027      	str	r7, [r4, #0]
   487b4:	4628      	mov	r0, r5
   487b6:	b003      	add	sp, #12
   487b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   487ba:	4630      	mov	r0, r6
   487bc:	f7fd f82c 	bl	45818 <hostname_free>
   487c0:	6823      	ldr	r3, [r4, #0]
   487c2:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   487c6:	6023      	str	r3, [r4, #0]
   487c8:	6823      	ldr	r3, [r4, #0]
   487ca:	0c1b      	lsrs	r3, r3, #16
   487cc:	041b      	lsls	r3, r3, #16
   487ce:	f043 030c 	orr.w	r3, r3, #12
   487d2:	6023      	str	r3, [r4, #0]
   487d4:	6823      	ldr	r3, [r4, #0]
   487d6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   487da:	6023      	str	r3, [r4, #0]
   487dc:	6823      	ldr	r3, [r4, #0]
   487de:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   487e2:	6023      	str	r3, [r4, #0]
   487e4:	e7e6      	b.n	487b4 <secure_client_socket+0x3e>

000487e6 <nrf_modem_recoverable_error_handler>:
   487e6:	4770      	bx	lr

000487e8 <nrf_modem_platform_error_handler>:
   487e8:	b508      	push	{r3, lr}
   487ea:	f7ff fffc 	bl	487e6 <nrf_modem_recoverable_error_handler>
   487ee:	bd08      	pop	{r3, pc}

000487f0 <rpc_transport_ipc_fault_handler>:
   487f0:	f7ff bffa 	b.w	487e8 <nrf_modem_platform_error_handler>

000487f4 <nrf_modem_platform_init>:
   487f4:	b513      	push	{r0, r1, r4, lr}
   487f6:	4604      	mov	r4, r0
   487f8:	f7fb fb00 	bl	43dfc <nrf_modem_os_init>
   487fc:	6a23      	ldr	r3, [r4, #32]
   487fe:	4668      	mov	r0, sp
   48800:	9400      	str	r4, [sp, #0]
   48802:	f88d 3004 	strb.w	r3, [sp, #4]
   48806:	f7fc fb73 	bl	44ef0 <rpc_transport_ipc_init>
   4880a:	4604      	mov	r4, r0
   4880c:	b948      	cbnz	r0, 48822 <nrf_modem_platform_init+0x2e>
   4880e:	f7fc fcc3 	bl	45198 <interface_init>
   48812:	f7fd f907 	bl	45a24 <nrf_modem_at_init>
   48816:	4604      	mov	r4, r0
   48818:	b918      	cbnz	r0, 48822 <nrf_modem_platform_init+0x2e>
   4881a:	f7fc fd7b 	bl	45314 <ip_interface_init>
   4881e:	f7fd f85f 	bl	458e0 <tls_interface_init>
   48822:	4620      	mov	r0, r4
   48824:	b002      	add	sp, #8
   48826:	bd10      	pop	{r4, pc}

00048828 <mbedtls_heap_init>:
{
	mbedtls_memory_buffer_alloc_free();
}

static int mbedtls_heap_init(const struct device *dev)
{
   48828:	b508      	push	{r3, lr}
	ARG_UNUSED(dev);

	_heap_init();
   4882a:	f7fd fb23 	bl	45e74 <_heap_init>

	return 0;
}
   4882e:	2000      	movs	r0, #0
   48830:	bd08      	pop	{r3, pc}

00048832 <z_device_state_init>:
}
   48832:	4770      	bx	lr

00048834 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   48834:	b138      	cbz	r0, 48846 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   48836:	68c3      	ldr	r3, [r0, #12]
   48838:	8818      	ldrh	r0, [r3, #0]
   4883a:	f3c0 0008 	ubfx	r0, r0, #0, #9
   4883e:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   48842:	4258      	negs	r0, r3
   48844:	4158      	adcs	r0, r3
}
   48846:	4770      	bx	lr

00048848 <k_heap_init>:
{
   48848:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   4884a:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   4884e:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   48852:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   48854:	f7ff b92d 	b.w	47ab2 <sys_heap_init>

00048858 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   48858:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4885c:	b087      	sub	sp, #28
   4885e:	4604      	mov	r4, r0
   48860:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48862:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   48866:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48868:	f000 fa09 	bl	48c7e <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   4886c:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48870:	4605      	mov	r5, r0
   48872:	4688      	mov	r8, r1
	__asm__ volatile(
   48874:	f04f 0320 	mov.w	r3, #32
   48878:	f3ef 8b11 	mrs	fp, BASEPRI
   4887c:	f383 8812 	msr	BASEPRI_MAX, r3
   48880:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   48884:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   48888:	463a      	mov	r2, r7
   4888a:	4631      	mov	r1, r6
   4888c:	4620      	mov	r0, r4
   4888e:	f7ff f8a8 	bl	479e2 <sys_heap_aligned_alloc>
   48892:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   48894:	f7fe fc86 	bl	471a4 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   48898:	9b05      	ldr	r3, [sp, #20]
   4889a:	b13b      	cbz	r3, 488ac <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   4889c:	f38b 8811 	msr	BASEPRI, fp
   488a0:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   488a4:	4618      	mov	r0, r3
   488a6:	b007      	add	sp, #28
   488a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   488ac:	1a2a      	subs	r2, r5, r0
   488ae:	9202      	str	r2, [sp, #8]
   488b0:	eb68 0201 	sbc.w	r2, r8, r1
   488b4:	9203      	str	r2, [sp, #12]
   488b6:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   488ba:	2901      	cmp	r1, #1
   488bc:	f172 0200 	sbcs.w	r2, r2, #0
   488c0:	dbec      	blt.n	4889c <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   488c2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   488c6:	4659      	mov	r1, fp
   488c8:	e9cd 2300 	strd	r2, r3, [sp]
   488cc:	4648      	mov	r0, r9
   488ce:	4652      	mov	r2, sl
   488d0:	f7fe f958 	bl	46b84 <z_pend_curr>
	__asm__ volatile(
   488d4:	f04f 0320 	mov.w	r3, #32
   488d8:	f3ef 8b11 	mrs	fp, BASEPRI
   488dc:	f383 8812 	msr	BASEPRI_MAX, r3
   488e0:	f3bf 8f6f 	isb	sy
   488e4:	e7d0      	b.n	48888 <k_heap_aligned_alloc+0x30>

000488e6 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   488e6:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   488e8:	e9cd 2300 	strd	r2, r3, [sp]
   488ec:	460a      	mov	r2, r1
   488ee:	2104      	movs	r1, #4
   488f0:	f7ff ffb2 	bl	48858 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   488f4:	b003      	add	sp, #12
   488f6:	f85d fb04 	ldr.w	pc, [sp], #4

000488fa <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   488fa:	b538      	push	{r3, r4, r5, lr}
   488fc:	4604      	mov	r4, r0
   488fe:	f04f 0320 	mov.w	r3, #32
   48902:	f3ef 8511 	mrs	r5, BASEPRI
   48906:	f383 8812 	msr	BASEPRI_MAX, r3
   4890a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   4890e:	f7ff f82f 	bl	47970 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   48912:	f104 000c 	add.w	r0, r4, #12
   48916:	f000 f958 	bl	48bca <z_unpend_all>
   4891a:	b130      	cbz	r0, 4892a <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   4891c:	4629      	mov	r1, r5
   4891e:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   48922:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   48926:	f7fd bfd3 	b.w	468d0 <z_reschedule>
	__asm__ volatile(
   4892a:	f385 8811 	msr	BASEPRI, r5
   4892e:	f3bf 8f6f 	isb	sy
}
   48932:	bd38      	pop	{r3, r4, r5, pc}

00048934 <k_mem_slab_init>:
{
   48934:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   48936:	2400      	movs	r4, #0
   48938:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   4893a:	ea41 0402 	orr.w	r4, r1, r2
   4893e:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   48942:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   48946:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   48948:	d10c      	bne.n	48964 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   4894a:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   4894c:	42a3      	cmp	r3, r4
   4894e:	d103      	bne.n	48958 <k_mem_slab_init+0x24>
   48950:	e9c0 0000 	strd	r0, r0, [r0]
}
   48954:	2000      	movs	r0, #0
}
   48956:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   48958:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   4895a:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   4895c:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   4895e:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   48960:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   48962:	e7f3      	b.n	4894c <k_mem_slab_init+0x18>
		return -EINVAL;
   48964:	f06f 0015 	mvn.w	r0, #21
	return rc;
   48968:	e7f5      	b.n	48956 <k_mem_slab_init+0x22>

0004896a <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   4896a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4896c:	4604      	mov	r4, r0
   4896e:	460d      	mov	r5, r1
	__asm__ volatile(
   48970:	f04f 0320 	mov.w	r3, #32
   48974:	f3ef 8611 	mrs	r6, BASEPRI
   48978:	f383 8812 	msr	BASEPRI_MAX, r3
   4897c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   48980:	6947      	ldr	r7, [r0, #20]
   48982:	b977      	cbnz	r7, 489a2 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   48984:	f000 f909 	bl	48b9a <z_unpend_first_thread>

		if (pending_thread != NULL) {
   48988:	b158      	cbz	r0, 489a2 <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   4898a:	682a      	ldr	r2, [r5, #0]
   4898c:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   4898e:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   48990:	f000 f88f 	bl	48ab2 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   48994:	4631      	mov	r1, r6
   48996:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   4899a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   4899e:	f7fd bf97 	b.w	468d0 <z_reschedule>
	**(char ***) mem = slab->free_list;
   489a2:	682b      	ldr	r3, [r5, #0]
   489a4:	6962      	ldr	r2, [r4, #20]
   489a6:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   489a8:	682b      	ldr	r3, [r5, #0]
   489aa:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   489ac:	69a3      	ldr	r3, [r4, #24]
   489ae:	3b01      	subs	r3, #1
   489b0:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   489b2:	f386 8811 	msr	BASEPRI, r6
   489b6:	f3bf 8f6f 	isb	sy
}
   489ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000489bc <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   489bc:	f3ef 8005 	mrs	r0, IPSR
}
   489c0:	3800      	subs	r0, #0
   489c2:	bf18      	it	ne
   489c4:	2001      	movne	r0, #1
   489c6:	4770      	bx	lr

000489c8 <z_impl_k_thread_name_set>:
}
   489c8:	f06f 0057 	mvn.w	r0, #87	; 0x57
   489cc:	4770      	bx	lr

000489ce <k_thread_name_get>:
}
   489ce:	2000      	movs	r0, #0
   489d0:	4770      	bx	lr

000489d2 <z_pm_save_idle_exit>:
{
   489d2:	b508      	push	{r3, lr}
	pm_system_resume();
   489d4:	f7f9 fa7c 	bl	41ed0 <pm_system_resume>
}
   489d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   489dc:	f7ff bdf7 	b.w	485ce <sys_clock_idle_exit>

000489e0 <z_impl_k_mutex_init>:
{
   489e0:	4603      	mov	r3, r0
	mutex->owner = NULL;
   489e2:	2000      	movs	r0, #0
   489e4:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   489e8:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   489ec:	4770      	bx	lr

000489ee <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   489ee:	b13a      	cbz	r2, 48a00 <z_impl_k_sem_init+0x12>
   489f0:	428a      	cmp	r2, r1
   489f2:	d305      	bcc.n	48a00 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   489f4:	e9c0 1202 	strd	r1, r2, [r0, #8]
   489f8:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   489fc:	2000      	movs	r0, #0
   489fe:	4770      	bx	lr
		return -EINVAL;
   48a00:	f06f 0015 	mvn.w	r0, #21
}
   48a04:	4770      	bx	lr

00048a06 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   48a06:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   48a0a:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   48a0c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   48a0e:	2300      	movs	r3, #0
	node->prev = NULL;
   48a10:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   48a14:	4770      	bx	lr

00048a16 <unpend_thread_no_timeout>:
{
   48a16:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   48a18:	f7ff fff5 	bl	48a06 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   48a1c:	7b43      	ldrb	r3, [r0, #13]
   48a1e:	f023 0302 	bic.w	r3, r3, #2
   48a22:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   48a24:	2300      	movs	r3, #0
   48a26:	6083      	str	r3, [r0, #8]
}
   48a28:	bd08      	pop	{r3, pc}

00048a2a <z_unpend_thread_no_timeout>:
{
   48a2a:	b508      	push	{r3, lr}
	__asm__ volatile(
   48a2c:	f04f 0320 	mov.w	r3, #32
   48a30:	f3ef 8111 	mrs	r1, BASEPRI
   48a34:	f383 8812 	msr	BASEPRI_MAX, r3
   48a38:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   48a3c:	f7ff ffeb 	bl	48a16 <unpend_thread_no_timeout>
	__asm__ volatile(
   48a40:	f381 8811 	msr	BASEPRI, r1
   48a44:	f3bf 8f6f 	isb	sy
}
   48a48:	bd08      	pop	{r3, pc}

00048a4a <z_unpend_thread>:
{
   48a4a:	b510      	push	{r4, lr}
	__asm__ volatile(
   48a4c:	f04f 0320 	mov.w	r3, #32
   48a50:	f3ef 8411 	mrs	r4, BASEPRI
   48a54:	f383 8812 	msr	BASEPRI_MAX, r3
   48a58:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   48a5c:	f7ff ffdb 	bl	48a16 <unpend_thread_no_timeout>
	__asm__ volatile(
   48a60:	f384 8811 	msr	BASEPRI, r4
   48a64:	f3bf 8f6f 	isb	sy
}
   48a68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   48a6c:	3018      	adds	r0, #24
   48a6e:	f000 b8bc 	b.w	48bea <z_abort_timeout>

00048a72 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   48a72:	4603      	mov	r3, r0
   48a74:	b920      	cbnz	r0, 48a80 <z_reschedule_irqlock+0xe>
   48a76:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   48a7a:	b90a      	cbnz	r2, 48a80 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   48a7c:	f7f9 bba0 	b.w	421c0 <arch_swap>
   48a80:	f383 8811 	msr	BASEPRI, r3
   48a84:	f3bf 8f6f 	isb	sy
}
   48a88:	4770      	bx	lr

00048a8a <z_reschedule_unlocked>:
	__asm__ volatile(
   48a8a:	f04f 0320 	mov.w	r3, #32
   48a8e:	f3ef 8011 	mrs	r0, BASEPRI
   48a92:	f383 8812 	msr	BASEPRI_MAX, r3
   48a96:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   48a9a:	f7ff bfea 	b.w	48a72 <z_reschedule_irqlock>

00048a9e <z_priq_dumb_best>:
{
   48a9e:	4603      	mov	r3, r0
	return list->head == list;
   48aa0:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48aa2:	4283      	cmp	r3, r0
   48aa4:	d003      	beq.n	48aae <z_priq_dumb_best+0x10>
	if (n != NULL) {
   48aa6:	2800      	cmp	r0, #0
   48aa8:	bf38      	it	cc
   48aaa:	2000      	movcc	r0, #0
   48aac:	4770      	bx	lr
	struct k_thread *thread = NULL;
   48aae:	2000      	movs	r0, #0
}
   48ab0:	4770      	bx	lr

00048ab2 <z_ready_thread>:
{
   48ab2:	b510      	push	{r4, lr}
   48ab4:	f04f 0320 	mov.w	r3, #32
   48ab8:	f3ef 8411 	mrs	r4, BASEPRI
   48abc:	f383 8812 	msr	BASEPRI_MAX, r3
   48ac0:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   48ac4:	f7fd ffca 	bl	46a5c <ready_thread>
	__asm__ volatile(
   48ac8:	f384 8811 	msr	BASEPRI, r4
   48acc:	f3bf 8f6f 	isb	sy
}
   48ad0:	bd10      	pop	{r4, pc}

00048ad2 <z_thread_timeout>:
{
   48ad2:	4601      	mov	r1, r0
   48ad4:	b510      	push	{r4, lr}
	__asm__ volatile(
   48ad6:	f04f 0320 	mov.w	r3, #32
   48ada:	f3ef 8411 	mrs	r4, BASEPRI
   48ade:	f383 8812 	msr	BASEPRI_MAX, r3
   48ae2:	f3bf 8f6f 	isb	sy
		if (!killed) {
   48ae6:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   48aea:	f013 0f28 	tst.w	r3, #40	; 0x28
   48aee:	d10d      	bne.n	48b0c <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   48af0:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   48af4:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   48af6:	b10b      	cbz	r3, 48afc <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   48af8:	f7ff ff8d 	bl	48a16 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   48afc:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   48b00:	f023 0314 	bic.w	r3, r3, #20
   48b04:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   48b08:	f7fd ffa8 	bl	46a5c <ready_thread>
	__asm__ volatile(
   48b0c:	f384 8811 	msr	BASEPRI, r4
   48b10:	f3bf 8f6f 	isb	sy
}
   48b14:	bd10      	pop	{r4, pc}

00048b16 <add_to_waitq_locked>:
{
   48b16:	b538      	push	{r3, r4, r5, lr}
   48b18:	4604      	mov	r4, r0
   48b1a:	460d      	mov	r5, r1
	unready_thread(thread);
   48b1c:	f7fd fff4 	bl	46b08 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   48b20:	7b63      	ldrb	r3, [r4, #13]
   48b22:	f043 0302 	orr.w	r3, r3, #2
   48b26:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   48b28:	b1b5      	cbz	r5, 48b58 <add_to_waitq_locked+0x42>
	return list->head == list;
   48b2a:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   48b2c:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48b2e:	429d      	cmp	r5, r3
   48b30:	bf08      	it	eq
   48b32:	2300      	moveq	r3, #0
   48b34:	2b00      	cmp	r3, #0
   48b36:	bf38      	it	cc
   48b38:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   48b3a:	b19b      	cbz	r3, 48b64 <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   48b3c:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   48b40:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   48b44:	4291      	cmp	r1, r2
   48b46:	d008      	beq.n	48b5a <add_to_waitq_locked+0x44>
		return b2 - b1;
   48b48:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   48b4a:	2a00      	cmp	r2, #0
   48b4c:	dd05      	ble.n	48b5a <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   48b4e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   48b50:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   48b54:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   48b56:	605c      	str	r4, [r3, #4]
}
   48b58:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   48b5a:	686a      	ldr	r2, [r5, #4]
   48b5c:	4293      	cmp	r3, r2
   48b5e:	d001      	beq.n	48b64 <add_to_waitq_locked+0x4e>
   48b60:	681b      	ldr	r3, [r3, #0]
   48b62:	e7ea      	b.n	48b3a <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   48b64:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   48b66:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   48b6a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   48b6c:	606c      	str	r4, [r5, #4]
   48b6e:	e7f3      	b.n	48b58 <add_to_waitq_locked+0x42>

00048b70 <z_unpend1_no_timeout>:
{
   48b70:	b510      	push	{r4, lr}
	__asm__ volatile(
   48b72:	f04f 0320 	mov.w	r3, #32
   48b76:	f3ef 8411 	mrs	r4, BASEPRI
   48b7a:	f383 8812 	msr	BASEPRI_MAX, r3
   48b7e:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48b82:	f7ff ff8c 	bl	48a9e <z_priq_dumb_best>
		if (thread != NULL) {
   48b86:	4601      	mov	r1, r0
   48b88:	b108      	cbz	r0, 48b8e <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   48b8a:	f7ff ff44 	bl	48a16 <unpend_thread_no_timeout>
	__asm__ volatile(
   48b8e:	f384 8811 	msr	BASEPRI, r4
   48b92:	f3bf 8f6f 	isb	sy
}
   48b96:	4608      	mov	r0, r1
   48b98:	bd10      	pop	{r4, pc}

00048b9a <z_unpend_first_thread>:
{
   48b9a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   48b9c:	f04f 0320 	mov.w	r3, #32
   48ba0:	f3ef 8511 	mrs	r5, BASEPRI
   48ba4:	f383 8812 	msr	BASEPRI_MAX, r3
   48ba8:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   48bac:	f7ff ff77 	bl	48a9e <z_priq_dumb_best>
		if (thread != NULL) {
   48bb0:	4604      	mov	r4, r0
   48bb2:	b120      	cbz	r0, 48bbe <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   48bb4:	f7ff ff2f 	bl	48a16 <unpend_thread_no_timeout>
   48bb8:	3018      	adds	r0, #24
   48bba:	f000 f816 	bl	48bea <z_abort_timeout>
	__asm__ volatile(
   48bbe:	f385 8811 	msr	BASEPRI, r5
   48bc2:	f3bf 8f6f 	isb	sy
}
   48bc6:	4620      	mov	r0, r4
   48bc8:	bd38      	pop	{r3, r4, r5, pc}

00048bca <z_unpend_all>:
{
   48bca:	b538      	push	{r3, r4, r5, lr}
   48bcc:	4605      	mov	r5, r0
	int need_sched = 0;
   48bce:	2000      	movs	r0, #0
	return list->head == list;
   48bd0:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   48bd2:	42a5      	cmp	r5, r4
   48bd4:	d000      	beq.n	48bd8 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   48bd6:	b904      	cbnz	r4, 48bda <z_unpend_all+0x10>
}
   48bd8:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   48bda:	4620      	mov	r0, r4
   48bdc:	f7ff ff35 	bl	48a4a <z_unpend_thread>
		z_ready_thread(thread);
   48be0:	4620      	mov	r0, r4
   48be2:	f7ff ff66 	bl	48ab2 <z_ready_thread>
		need_sched = 1;
   48be6:	2001      	movs	r0, #1
   48be8:	e7f2      	b.n	48bd0 <z_unpend_all+0x6>

00048bea <z_abort_timeout>:
{
   48bea:	b510      	push	{r4, lr}
	__asm__ volatile(
   48bec:	f04f 0220 	mov.w	r2, #32
   48bf0:	f3ef 8411 	mrs	r4, BASEPRI
   48bf4:	f382 8812 	msr	BASEPRI_MAX, r2
   48bf8:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   48bfc:	6803      	ldr	r3, [r0, #0]
   48bfe:	b13b      	cbz	r3, 48c10 <z_abort_timeout+0x26>
			remove_timeout(to);
   48c00:	f7fe f998 	bl	46f34 <remove_timeout>
			ret = 0;
   48c04:	2000      	movs	r0, #0
	__asm__ volatile(
   48c06:	f384 8811 	msr	BASEPRI, r4
   48c0a:	f3bf 8f6f 	isb	sy
}
   48c0e:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   48c10:	f06f 0015 	mvn.w	r0, #21
   48c14:	e7f7      	b.n	48c06 <z_abort_timeout+0x1c>

00048c16 <z_get_next_timeout_expiry>:
{
   48c16:	b510      	push	{r4, lr}
	__asm__ volatile(
   48c18:	f04f 0320 	mov.w	r3, #32
   48c1c:	f3ef 8411 	mrs	r4, BASEPRI
   48c20:	f383 8812 	msr	BASEPRI_MAX, r3
   48c24:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   48c28:	f7fe f99e 	bl	46f68 <next_timeout>
	__asm__ volatile(
   48c2c:	f384 8811 	msr	BASEPRI, r4
   48c30:	f3bf 8f6f 	isb	sy
}
   48c34:	bd10      	pop	{r4, pc}

00048c36 <z_set_timeout_expiry>:
{
   48c36:	b570      	push	{r4, r5, r6, lr}
   48c38:	4604      	mov	r4, r0
   48c3a:	460d      	mov	r5, r1
	__asm__ volatile(
   48c3c:	f04f 0320 	mov.w	r3, #32
   48c40:	f3ef 8611 	mrs	r6, BASEPRI
   48c44:	f383 8812 	msr	BASEPRI_MAX, r3
   48c48:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   48c4c:	f7fe f98c 	bl	46f68 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   48c50:	2801      	cmp	r0, #1
   48c52:	dd05      	ble.n	48c60 <z_set_timeout_expiry+0x2a>
   48c54:	42a0      	cmp	r0, r4
   48c56:	db03      	blt.n	48c60 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   48c58:	4629      	mov	r1, r5
   48c5a:	4620      	mov	r0, r4
   48c5c:	f7fa ff10 	bl	43a80 <sys_clock_set_timeout>
	__asm__ volatile(
   48c60:	f386 8811 	msr	BASEPRI, r6
   48c64:	f3bf 8f6f 	isb	sy
}
   48c68:	bd70      	pop	{r4, r5, r6, pc}

00048c6a <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   48c6a:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   48c6c:	f7fe fa9a 	bl	471a4 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   48c70:	bd08      	pop	{r3, pc}

00048c72 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   48c72:	f7fe ba97 	b.w	471a4 <sys_clock_tick_get>

00048c76 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   48c76:	b108      	cbz	r0, 48c7c <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   48c78:	f7f8 bb04 	b.w	41284 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   48c7c:	4770      	bx	lr

00048c7e <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   48c7e:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48c80:	1c4b      	adds	r3, r1, #1
   48c82:	bf08      	it	eq
   48c84:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   48c88:	4604      	mov	r4, r0
   48c8a:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   48c8c:	d013      	beq.n	48cb6 <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   48c8e:	ea54 0105 	orrs.w	r1, r4, r5
   48c92:	d103      	bne.n	48c9c <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   48c94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   48c98:	f7fe ba84 	b.w	471a4 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   48c9c:	f06f 0101 	mvn.w	r1, #1
   48ca0:	1a0a      	subs	r2, r1, r0
   48ca2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   48ca6:	eb61 0305 	sbc.w	r3, r1, r5
   48caa:	2a00      	cmp	r2, #0
   48cac:	f173 0100 	sbcs.w	r1, r3, #0
   48cb0:	db02      	blt.n	48cb8 <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   48cb2:	4610      	mov	r0, r2
   48cb4:	4619      	mov	r1, r3
}
   48cb6:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   48cb8:	f7fe fa74 	bl	471a4 <sys_clock_tick_get>
   48cbc:	2c01      	cmp	r4, #1
   48cbe:	f175 0300 	sbcs.w	r3, r5, #0
   48cc2:	bfbc      	itt	lt
   48cc4:	2401      	movlt	r4, #1
   48cc6:	2500      	movlt	r5, #0
   48cc8:	1820      	adds	r0, r4, r0
   48cca:	eb45 0101 	adc.w	r1, r5, r1
   48cce:	e7f2      	b.n	48cb6 <sys_clock_timeout_end_calc+0x38>

00048cd0 <k_timer_init>:
	timer->status = 0U;
   48cd0:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   48cd2:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
   48cd6:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   48cda:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   48cde:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   48ce2:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   48ce4:	6343      	str	r3, [r0, #52]	; 0x34
}
   48ce6:	4770      	bx	lr

00048ce8 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   48ce8:	b510      	push	{r4, lr}
   48cea:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   48cec:	f7ff ff7d 	bl	48bea <z_abort_timeout>

	if (inactive) {
   48cf0:	b9b0      	cbnz	r0, 48d20 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   48cf2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48cf4:	b10b      	cbz	r3, 48cfa <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   48cf6:	4620      	mov	r0, r4
   48cf8:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   48cfa:	f104 0018 	add.w	r0, r4, #24
   48cfe:	f7ff ff37 	bl	48b70 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   48d02:	b168      	cbz	r0, 48d20 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   48d04:	f7ff fed5 	bl	48ab2 <z_ready_thread>
	__asm__ volatile(
   48d08:	f04f 0320 	mov.w	r3, #32
   48d0c:	f3ef 8011 	mrs	r0, BASEPRI
   48d10:	f383 8812 	msr	BASEPRI_MAX, r3
   48d14:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   48d18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   48d1c:	f7ff bea9 	b.w	48a72 <z_reschedule_irqlock>
   48d20:	bd10      	pop	{r4, pc}

00048d22 <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
   48d22:	2304      	movs	r3, #4
   48d24:	18d2      	adds	r2, r2, r3
{
   48d26:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   48d28:	4604      	mov	r4, r0
   48d2a:	d207      	bcs.n	48d3c <z_heap_aligned_alloc+0x1a>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   48d2c:	2600      	movs	r6, #0
   48d2e:	2700      	movs	r7, #0
   48d30:	4319      	orrs	r1, r3
   48d32:	e9cd 6700 	strd	r6, r7, [sp]
   48d36:	f7ff fd8f 	bl	48858 <k_heap_aligned_alloc>
	if (mem == NULL) {
   48d3a:	b910      	cbnz	r0, 48d42 <z_heap_aligned_alloc+0x20>
		return NULL;
   48d3c:	2000      	movs	r0, #0
}
   48d3e:	b002      	add	sp, #8
   48d40:	bdd0      	pop	{r4, r6, r7, pc}
	*heap_ref = heap;
   48d42:	f840 4b04 	str.w	r4, [r0], #4
	return mem;
   48d46:	e7fa      	b.n	48d3e <z_heap_aligned_alloc+0x1c>

00048d48 <k_malloc>:

	return ret;
}

void *k_malloc(size_t size)
{
   48d48:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_malloc, _SYSTEM_HEAP);

	void *ret = k_aligned_alloc(sizeof(void *), size);
   48d4a:	2004      	movs	r0, #4
   48d4c:	f7fe bae8 	b.w	47320 <k_aligned_alloc>

00048d50 <psa_crypto_init>:
}
   48d50:	2000      	movs	r0, #0
   48d52:	4770      	bx	lr

00048d54 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   48d54:	f7fb b8b8 	b.w	43ec8 <SystemInit>
