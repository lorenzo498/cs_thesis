
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00040000 <_vector_start>:
   40000:	20023330 	.word	0x20023330
   40004:	00042b3d 	.word	0x00042b3d
   40008:	00048819 	.word	0x00048819
   4000c:	00042b11 	.word	0x00042b11
   40010:	00042b11 	.word	0x00042b11
   40014:	00042b11 	.word	0x00042b11
   40018:	00042b11 	.word	0x00042b11
   4001c:	00042b11 	.word	0x00042b11
	...
   4002c:	000425b9 	.word	0x000425b9
   40030:	00042b11 	.word	0x00042b11
   40034:	00000000 	.word	0x00000000
   40038:	00042559 	.word	0x00042559
   4003c:	00042b11 	.word	0x00042b11

00040040 <_irq_vector_table>:
   40040:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40050:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40060:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40070:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40080:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40090:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   400a0:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   400b0:	00043f29 0004263d 0004263d 0004263d     )?..=&..=&..=&..
   400c0:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   400d0:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   400e0:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   400f0:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40100:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40110:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40120:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40130:	0004263d 0004263d 0004263d 0004263d     =&..=&..=&..=&..
   40140:	0004263d                                =&..

Disassembly of section text:

00040144 <__aeabi_uldivmod>:
   40144:	b953      	cbnz	r3, 4015c <__aeabi_uldivmod+0x18>
   40146:	b94a      	cbnz	r2, 4015c <__aeabi_uldivmod+0x18>
   40148:	2900      	cmp	r1, #0
   4014a:	bf08      	it	eq
   4014c:	2800      	cmpeq	r0, #0
   4014e:	bf1c      	itt	ne
   40150:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   40154:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   40158:	f000 b970 	b.w	4043c <__aeabi_idiv0>
   4015c:	f1ad 0c08 	sub.w	ip, sp, #8
   40160:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   40164:	f000 f806 	bl	40174 <__udivmoddi4>
   40168:	f8dd e004 	ldr.w	lr, [sp, #4]
   4016c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   40170:	b004      	add	sp, #16
   40172:	4770      	bx	lr

00040174 <__udivmoddi4>:
   40174:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   40178:	9e08      	ldr	r6, [sp, #32]
   4017a:	460d      	mov	r5, r1
   4017c:	4604      	mov	r4, r0
   4017e:	468a      	mov	sl, r1
   40180:	2b00      	cmp	r3, #0
   40182:	d17f      	bne.n	40284 <__udivmoddi4+0x110>
   40184:	428a      	cmp	r2, r1
   40186:	4617      	mov	r7, r2
   40188:	d941      	bls.n	4020e <__udivmoddi4+0x9a>
   4018a:	fab2 f282 	clz	r2, r2
   4018e:	b14a      	cbz	r2, 401a4 <__udivmoddi4+0x30>
   40190:	f1c2 0120 	rsb	r1, r2, #32
   40194:	fa05 f302 	lsl.w	r3, r5, r2
   40198:	4097      	lsls	r7, r2
   4019a:	4094      	lsls	r4, r2
   4019c:	fa20 f101 	lsr.w	r1, r0, r1
   401a0:	ea41 0a03 	orr.w	sl, r1, r3
   401a4:	ea4f 4817 	mov.w	r8, r7, lsr #16
   401a8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   401ac:	fa1f f987 	uxth.w	r9, r7
   401b0:	fbba fef8 	udiv	lr, sl, r8
   401b4:	fb08 a31e 	mls	r3, r8, lr, sl
   401b8:	fb0e f109 	mul.w	r1, lr, r9
   401bc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   401c0:	4299      	cmp	r1, r3
   401c2:	d906      	bls.n	401d2 <__udivmoddi4+0x5e>
   401c4:	18fb      	adds	r3, r7, r3
   401c6:	d202      	bcs.n	401ce <__udivmoddi4+0x5a>
   401c8:	4299      	cmp	r1, r3
   401ca:	f200 8124 	bhi.w	40416 <__udivmoddi4+0x2a2>
   401ce:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
   401d2:	1a59      	subs	r1, r3, r1
   401d4:	b2a3      	uxth	r3, r4
   401d6:	fbb1 f0f8 	udiv	r0, r1, r8
   401da:	fb08 1110 	mls	r1, r8, r0, r1
   401de:	fb00 f909 	mul.w	r9, r0, r9
   401e2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   401e6:	45a1      	cmp	r9, r4
   401e8:	d905      	bls.n	401f6 <__udivmoddi4+0x82>
   401ea:	193c      	adds	r4, r7, r4
   401ec:	d202      	bcs.n	401f4 <__udivmoddi4+0x80>
   401ee:	45a1      	cmp	r9, r4
   401f0:	f200 810e 	bhi.w	40410 <__udivmoddi4+0x29c>
   401f4:	3801      	subs	r0, #1
   401f6:	eba4 0409 	sub.w	r4, r4, r9
   401fa:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   401fe:	2100      	movs	r1, #0
   40200:	b11e      	cbz	r6, 4020a <__udivmoddi4+0x96>
   40202:	40d4      	lsrs	r4, r2
   40204:	2300      	movs	r3, #0
   40206:	e9c6 4300 	strd	r4, r3, [r6]
   4020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4020e:	b902      	cbnz	r2, 40212 <__udivmoddi4+0x9e>
   40210:	deff      	udf	#255	; 0xff
   40212:	fab2 f282 	clz	r2, r2
   40216:	2a00      	cmp	r2, #0
   40218:	d14f      	bne.n	402ba <__udivmoddi4+0x146>
   4021a:	1bcb      	subs	r3, r1, r7
   4021c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   40220:	fa1f f887 	uxth.w	r8, r7
   40224:	2101      	movs	r1, #1
   40226:	0c25      	lsrs	r5, r4, #16
   40228:	fbb3 fcfe 	udiv	ip, r3, lr
   4022c:	fb0e 301c 	mls	r0, lr, ip, r3
   40230:	462b      	mov	r3, r5
   40232:	fb08 f90c 	mul.w	r9, r8, ip
   40236:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   4023a:	45a9      	cmp	r9, r5
   4023c:	d90a      	bls.n	40254 <__udivmoddi4+0xe0>
   4023e:	197d      	adds	r5, r7, r5
   40240:	bf2c      	ite	cs
   40242:	2301      	movcs	r3, #1
   40244:	2300      	movcc	r3, #0
   40246:	45a9      	cmp	r9, r5
   40248:	d902      	bls.n	40250 <__udivmoddi4+0xdc>
   4024a:	2b00      	cmp	r3, #0
   4024c:	f000 80d9 	beq.w	40402 <__udivmoddi4+0x28e>
   40250:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   40254:	eba5 0509 	sub.w	r5, r5, r9
   40258:	b2a3      	uxth	r3, r4
   4025a:	fbb5 f0fe 	udiv	r0, r5, lr
   4025e:	fb0e 5510 	mls	r5, lr, r0, r5
   40262:	fb08 f800 	mul.w	r8, r8, r0
   40266:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   4026a:	45a0      	cmp	r8, r4
   4026c:	d905      	bls.n	4027a <__udivmoddi4+0x106>
   4026e:	193c      	adds	r4, r7, r4
   40270:	d202      	bcs.n	40278 <__udivmoddi4+0x104>
   40272:	45a0      	cmp	r8, r4
   40274:	f200 80c9 	bhi.w	4040a <__udivmoddi4+0x296>
   40278:	3801      	subs	r0, #1
   4027a:	eba4 0408 	sub.w	r4, r4, r8
   4027e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   40282:	e7bd      	b.n	40200 <__udivmoddi4+0x8c>
   40284:	428b      	cmp	r3, r1
   40286:	d908      	bls.n	4029a <__udivmoddi4+0x126>
   40288:	2e00      	cmp	r6, #0
   4028a:	f000 80b1 	beq.w	403f0 <__udivmoddi4+0x27c>
   4028e:	2100      	movs	r1, #0
   40290:	e9c6 0500 	strd	r0, r5, [r6]
   40294:	4608      	mov	r0, r1
   40296:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   4029a:	fab3 f183 	clz	r1, r3
   4029e:	2900      	cmp	r1, #0
   402a0:	d146      	bne.n	40330 <__udivmoddi4+0x1bc>
   402a2:	42ab      	cmp	r3, r5
   402a4:	f0c0 80a7 	bcc.w	403f6 <__udivmoddi4+0x282>
   402a8:	4282      	cmp	r2, r0
   402aa:	f240 80a4 	bls.w	403f6 <__udivmoddi4+0x282>
   402ae:	4608      	mov	r0, r1
   402b0:	2e00      	cmp	r6, #0
   402b2:	d0aa      	beq.n	4020a <__udivmoddi4+0x96>
   402b4:	e9c6 4a00 	strd	r4, sl, [r6]
   402b8:	e7a7      	b.n	4020a <__udivmoddi4+0x96>
   402ba:	f1c2 0020 	rsb	r0, r2, #32
   402be:	4097      	lsls	r7, r2
   402c0:	fa01 f302 	lsl.w	r3, r1, r2
   402c4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   402c8:	40c1      	lsrs	r1, r0
   402ca:	fa24 f500 	lsr.w	r5, r4, r0
   402ce:	fa1f f887 	uxth.w	r8, r7
   402d2:	4094      	lsls	r4, r2
   402d4:	431d      	orrs	r5, r3
   402d6:	fbb1 f0fe 	udiv	r0, r1, lr
   402da:	0c2b      	lsrs	r3, r5, #16
   402dc:	fb0e 1110 	mls	r1, lr, r0, r1
   402e0:	fb00 fc08 	mul.w	ip, r0, r8
   402e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   402e8:	459c      	cmp	ip, r3
   402ea:	d909      	bls.n	40300 <__udivmoddi4+0x18c>
   402ec:	18fb      	adds	r3, r7, r3
   402ee:	bf2c      	ite	cs
   402f0:	2101      	movcs	r1, #1
   402f2:	2100      	movcc	r1, #0
   402f4:	459c      	cmp	ip, r3
   402f6:	d902      	bls.n	402fe <__udivmoddi4+0x18a>
   402f8:	2900      	cmp	r1, #0
   402fa:	f000 8095 	beq.w	40428 <__udivmoddi4+0x2b4>
   402fe:	3801      	subs	r0, #1
   40300:	eba3 030c 	sub.w	r3, r3, ip
   40304:	b2ad      	uxth	r5, r5
   40306:	fbb3 f1fe 	udiv	r1, r3, lr
   4030a:	fb0e 3311 	mls	r3, lr, r1, r3
   4030e:	fb01 fc08 	mul.w	ip, r1, r8
   40312:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   40316:	45ac      	cmp	ip, r5
   40318:	d905      	bls.n	40326 <__udivmoddi4+0x1b2>
   4031a:	197d      	adds	r5, r7, r5
   4031c:	d202      	bcs.n	40324 <__udivmoddi4+0x1b0>
   4031e:	45ac      	cmp	ip, r5
   40320:	f200 8089 	bhi.w	40436 <__udivmoddi4+0x2c2>
   40324:	3901      	subs	r1, #1
   40326:	eba5 030c 	sub.w	r3, r5, ip
   4032a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   4032e:	e77a      	b.n	40226 <__udivmoddi4+0xb2>
   40330:	f1c1 0420 	rsb	r4, r1, #32
   40334:	408b      	lsls	r3, r1
   40336:	fa02 f701 	lsl.w	r7, r2, r1
   4033a:	fa05 fc01 	lsl.w	ip, r5, r1
   4033e:	40e2      	lsrs	r2, r4
   40340:	fa20 f804 	lsr.w	r8, r0, r4
   40344:	40e5      	lsrs	r5, r4
   40346:	fa00 fe01 	lsl.w	lr, r0, r1
   4034a:	4313      	orrs	r3, r2
   4034c:	ea48 020c 	orr.w	r2, r8, ip
   40350:	ea4f 4813 	mov.w	r8, r3, lsr #16
   40354:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   40358:	fa1f f983 	uxth.w	r9, r3
   4035c:	fbb5 faf8 	udiv	sl, r5, r8
   40360:	fb08 551a 	mls	r5, r8, sl, r5
   40364:	fb0a f009 	mul.w	r0, sl, r9
   40368:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   4036c:	4560      	cmp	r0, ip
   4036e:	d90a      	bls.n	40386 <__udivmoddi4+0x212>
   40370:	eb13 0c0c 	adds.w	ip, r3, ip
   40374:	bf2c      	ite	cs
   40376:	2501      	movcs	r5, #1
   40378:	2500      	movcc	r5, #0
   4037a:	4560      	cmp	r0, ip
   4037c:	d901      	bls.n	40382 <__udivmoddi4+0x20e>
   4037e:	2d00      	cmp	r5, #0
   40380:	d055      	beq.n	4042e <__udivmoddi4+0x2ba>
   40382:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   40386:	ebac 0c00 	sub.w	ip, ip, r0
   4038a:	b292      	uxth	r2, r2
   4038c:	fbbc f0f8 	udiv	r0, ip, r8
   40390:	fb08 cc10 	mls	ip, r8, r0, ip
   40394:	fb00 f909 	mul.w	r9, r0, r9
   40398:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   4039c:	45e1      	cmp	r9, ip
   4039e:	d905      	bls.n	403ac <__udivmoddi4+0x238>
   403a0:	eb13 0c0c 	adds.w	ip, r3, ip
   403a4:	d201      	bcs.n	403aa <__udivmoddi4+0x236>
   403a6:	45e1      	cmp	r9, ip
   403a8:	d83b      	bhi.n	40422 <__udivmoddi4+0x2ae>
   403aa:	3801      	subs	r0, #1
   403ac:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   403b0:	ebac 0c09 	sub.w	ip, ip, r9
   403b4:	fba0 8907 	umull	r8, r9, r0, r7
   403b8:	45cc      	cmp	ip, r9
   403ba:	4645      	mov	r5, r8
   403bc:	464a      	mov	r2, r9
   403be:	d302      	bcc.n	403c6 <__udivmoddi4+0x252>
   403c0:	d106      	bne.n	403d0 <__udivmoddi4+0x25c>
   403c2:	45c6      	cmp	lr, r8
   403c4:	d204      	bcs.n	403d0 <__udivmoddi4+0x25c>
   403c6:	3801      	subs	r0, #1
   403c8:	ebb8 0507 	subs.w	r5, r8, r7
   403cc:	eb69 0203 	sbc.w	r2, r9, r3
   403d0:	b32e      	cbz	r6, 4041e <__udivmoddi4+0x2aa>
   403d2:	ebbe 0305 	subs.w	r3, lr, r5
   403d6:	eb6c 0c02 	sbc.w	ip, ip, r2
   403da:	fa23 f201 	lsr.w	r2, r3, r1
   403de:	fa0c f404 	lsl.w	r4, ip, r4
   403e2:	fa2c f301 	lsr.w	r3, ip, r1
   403e6:	2100      	movs	r1, #0
   403e8:	4314      	orrs	r4, r2
   403ea:	e9c6 4300 	strd	r4, r3, [r6]
   403ee:	e70c      	b.n	4020a <__udivmoddi4+0x96>
   403f0:	4631      	mov	r1, r6
   403f2:	4630      	mov	r0, r6
   403f4:	e709      	b.n	4020a <__udivmoddi4+0x96>
   403f6:	1a84      	subs	r4, r0, r2
   403f8:	eb65 0303 	sbc.w	r3, r5, r3
   403fc:	2001      	movs	r0, #1
   403fe:	469a      	mov	sl, r3
   40400:	e756      	b.n	402b0 <__udivmoddi4+0x13c>
   40402:	f1ac 0c02 	sub.w	ip, ip, #2
   40406:	443d      	add	r5, r7
   40408:	e724      	b.n	40254 <__udivmoddi4+0xe0>
   4040a:	3802      	subs	r0, #2
   4040c:	443c      	add	r4, r7
   4040e:	e734      	b.n	4027a <__udivmoddi4+0x106>
   40410:	3802      	subs	r0, #2
   40412:	443c      	add	r4, r7
   40414:	e6ef      	b.n	401f6 <__udivmoddi4+0x82>
   40416:	f1ae 0e02 	sub.w	lr, lr, #2
   4041a:	443b      	add	r3, r7
   4041c:	e6d9      	b.n	401d2 <__udivmoddi4+0x5e>
   4041e:	4631      	mov	r1, r6
   40420:	e6f3      	b.n	4020a <__udivmoddi4+0x96>
   40422:	3802      	subs	r0, #2
   40424:	449c      	add	ip, r3
   40426:	e7c1      	b.n	403ac <__udivmoddi4+0x238>
   40428:	3802      	subs	r0, #2
   4042a:	443b      	add	r3, r7
   4042c:	e768      	b.n	40300 <__udivmoddi4+0x18c>
   4042e:	f1aa 0a02 	sub.w	sl, sl, #2
   40432:	449c      	add	ip, r3
   40434:	e7a7      	b.n	40386 <__udivmoddi4+0x212>
   40436:	3902      	subs	r1, #2
   40438:	443d      	add	r5, r7
   4043a:	e774      	b.n	40326 <__udivmoddi4+0x1b2>

0004043c <__aeabi_idiv0>:
   4043c:	4770      	bx	lr
   4043e:	bf00      	nop

00040440 <debug_hexstring.part.0>:
// Tokenize the data
RlpElement_t t = {
  .buff = &num0, .len = sizeof(num0)
};

static void debug_hexstring(const void *const address, size_t nBytes)
   40440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40442:	4604      	mov	r4, r0
     for (unsigned long int i = 1; i <= b; i++) {
        
       if(a[i-1] < 0x10)
          printf("0%x",a[i-1]);
        else
          printf("%x",a[i-1]);
   40444:	4e09      	ldr	r6, [pc, #36]	; (4046c <debug_hexstring.part.0+0x2c>)
          printf("0%x",a[i-1]);
   40446:	4f0a      	ldr	r7, [pc, #40]	; (40470 <debug_hexstring.part.0+0x30>)
   40448:	1845      	adds	r5, r0, r1
     for (unsigned long int i = 1; i <= b; i++) {
   4044a:	42ac      	cmp	r4, r5
   4044c:	d104      	bne.n	40458 <debug_hexstring.part.0+0x18>
     }
     printf("\n");
}
   4044e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
     printf("\n");
   40452:	4808      	ldr	r0, [pc, #32]	; (40474 <debug_hexstring.part.0+0x34>)
   40454:	f002 bdd4 	b.w	43000 <printf>
       if(a[i-1] < 0x10)
   40458:	f814 1b01 	ldrb.w	r1, [r4], #1
   4045c:	290f      	cmp	r1, #15
          printf("0%x",a[i-1]);
   4045e:	bf94      	ite	ls
   40460:	4638      	movls	r0, r7
          printf("%x",a[i-1]);
   40462:	4630      	movhi	r0, r6
   40464:	f002 fdcc 	bl	43000 <printf>
     for (unsigned long int i = 1; i <= b; i++) {
   40468:	e7ef      	b.n	4044a <debug_hexstring.part.0+0xa>
   4046a:	bf00      	nop
   4046c:	00049939 	.word	0x00049939
   40470:	00049938 	.word	0x00049938
   40474:	00049953 	.word	0x00049953

00040478 <main>:
    // Clear out the contents of what we hashed (in case it was secret)
    memset((char*)&context, 0, sizeof(SHA3_CTX));
}

int main() {
    uint8_t rlpTx[2048] = {0};
   40478:	2100      	movs	r1, #0
int main() {
   4047a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4047e:	f5ad 6d02 	sub.w	sp, sp, #2080	; 0x820
    uint8_t rlpTx[2048] = {0};
   40482:	f240 72fc 	movw	r2, #2044	; 0x7fc
   40486:	a809      	add	r0, sp, #36	; 0x24
   40488:	9108      	str	r1, [sp, #32]
   4048a:	f008 fa57 	bl	4893c <memset>
    int outputLen = 0;
    outputLen = rlp_encode_list(rlpTx, sizeof(rlpTx)/sizeof(rlpTx[0]), ethTxn, sizeof(ethTxn)/sizeof(ethTxn[0]));
   4048e:	2308      	movs	r3, #8
   40490:	f44f 6100 	mov.w	r1, #2048	; 0x800
   40494:	4a22      	ldr	r2, [pc, #136]	; (40520 <main+0xa8>)
   40496:	a808      	add	r0, sp, #32
   40498:	f007 fa66 	bl	47968 <rlp_encode_list>
    if(outputLen < 0)
   4049c:	1e04      	subs	r4, r0, #0
   4049e:	da30      	bge.n	40502 <main+0x8a>
      printf("error, return code: %d\r\n", outputLen);
   404a0:	4621      	mov	r1, r4
   404a2:	4820      	ldr	r0, [pc, #128]	; (40524 <main+0xac>)
   404a4:	f002 fdac 	bl	43000 <printf>
    myString = k_malloc(nBytes);
   404a8:	4620      	mov	r0, r4
   404aa:	f008 ff7b 	bl	493a4 <k_malloc>
   404ae:	4e1e      	ldr	r6, [pc, #120]	; (40528 <main+0xb0>)
   404b0:	6030      	str	r0, [r6, #0]
    if ((NULL == a) || (b <= 0)) return;
   404b2:	b194      	cbz	r4, 404da <main+0x62>
   404b4:	ad08      	add	r5, sp, #32
   404b6:	46a8      	mov	r8, r5
    for (unsigned long int i = 1; i <= b; i++) {
   404b8:	2701      	movs	r7, #1
      strncat(myString, &a[i-1], 1);
   404ba:	4641      	mov	r1, r8
   404bc:	2201      	movs	r2, #1
   404be:	6830      	ldr	r0, [r6, #0]
    for (unsigned long int i = 1; i <= b; i++) {
   404c0:	3701      	adds	r7, #1
      strncat(myString, &a[i-1], 1);
   404c2:	f008 fa1c 	bl	488fe <strncat>
    for (unsigned long int i = 1; i <= b; i++) {
   404c6:	42bc      	cmp	r4, r7
   404c8:	f108 0801 	add.w	r8, r8, #1
   404cc:	d2f5      	bcs.n	404ba <main+0x42>
    for (int i = 0, j = 0; i < nBytes; ++i, j += 2)
   404ce:	2700      	movs	r7, #0
      sprintf(myString + j, "%02x", a[i] &0xff);
   404d0:	f8df 8058 	ldr.w	r8, [pc, #88]	; 4052c <main+0xb4>
    for (int i = 0, j = 0; i < nBytes; ++i, j += 2)
   404d4:	42bc      	cmp	r4, r7
   404d6:	6830      	ldr	r0, [r6, #0]
   404d8:	d119      	bne.n	4050e <main+0x96>
    }
    convert_rlp_string_to_hex(rlpTx, outputLen);

    uint8_t hashed[32];
    
    ethers_keccak256(myString, strlen(myString), hashed);
   404da:	6834      	ldr	r4, [r6, #0]
   404dc:	4620      	mov	r0, r4
   404de:	f008 f9fe 	bl	488de <strlen>
   404e2:	466a      	mov	r2, sp
   404e4:	b281      	uxth	r1, r0
   404e6:	4620      	mov	r0, r4
   404e8:	f007 fa25 	bl	47936 <ethers_keccak256>
     if ((NULL == a) || (b <= 0)) return;
   404ec:	2120      	movs	r1, #32
   404ee:	4668      	mov	r0, sp
   404f0:	f7ff ffa6 	bl	40440 <debug_hexstring.part.0>
    debug_hexstring(hashed, 32);
    perform_ecdsa();
   404f4:	f000 fb52 	bl	40b9c <perform_ecdsa>
    //   printf("RLP encoded eth txn [%d B]:\r\n", len);
    //   debug_hexstring(rlpRaw, len);
    // }
  return 0;

}
   404f8:	2000      	movs	r0, #0
   404fa:	f50d 6d02 	add.w	sp, sp, #2080	; 0x820
   404fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     if ((NULL == a) || (b <= 0)) return;
   40502:	d0d1      	beq.n	404a8 <main+0x30>
   40504:	4621      	mov	r1, r4
   40506:	a808      	add	r0, sp, #32
   40508:	f7ff ff9a 	bl	40440 <debug_hexstring.part.0>
   4050c:	e7cc      	b.n	404a8 <main+0x30>
      sprintf(myString + j, "%02x", a[i] &0xff);
   4050e:	eb00 0047 	add.w	r0, r0, r7, lsl #1
   40512:	4641      	mov	r1, r8
   40514:	f815 2b01 	ldrb.w	r2, [r5], #1
   40518:	f002 fd5a 	bl	42fd0 <sprintf>
    for (int i = 0, j = 0; i < nBytes; ++i, j += 2)
   4051c:	3701      	adds	r7, #1
   4051e:	e7d9      	b.n	404d4 <main+0x5c>
   40520:	00049738 	.word	0x00049738
   40524:	0004993c 	.word	0x0004993c
   40528:	2001a8c8 	.word	0x2001a8c8
   4052c:	00049955 	.word	0x00049955

00040530 <rlp_encode_element>:
  return ERR_RLP_EBADARG;
}

// Returns length of output in bytes, or a negative error value
int rlp_encode_element(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, const RlpElement_t *const rlpElement)
{
   40530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   40532:	460d      	mov	r5, r1
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   40534:	2800      	cmp	r0, #0
   40536:	d06d      	beq.n	40614 <rlp_encode_element+0xe4>
   40538:	2a00      	cmp	r2, #0
   4053a:	d06b      	beq.n	40614 <rlp_encode_element+0xe4>
   4053c:	2900      	cmp	r1, #0
   4053e:	d069      	beq.n	40614 <rlp_encode_element+0xe4>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40540:	7811      	ldrb	r1, [r2, #0]
  if(rlpEncodedOutput == NULL || rlpElement == NULL || rlpEncodedOutputLen == 0 || 
   40542:	2900      	cmp	r1, #0
   40544:	d066      	beq.n	40614 <rlp_encode_element+0xe4>
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   40546:	1e8c      	subs	r4, r1, #2
   40548:	b2e4      	uxtb	r4, r4
   4054a:	2c07      	cmp	r4, #7
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   4054c:	6853      	ldr	r3, [r2, #4]
  if (RLP_TYPE_IS_INTEGER_TYPE(type))
   4054e:	d82a      	bhi.n	405a6 <rlp_encode_element+0x76>
      return buffSz == rlp_int_size_from_type(type);
   40550:	4935      	ldr	r1, [pc, #212]	; (40628 <rlp_encode_element+0xf8>)
   40552:	5d09      	ldrb	r1, [r1, r4]
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   40554:	428b      	cmp	r3, r1
    else if (type == RLP_TYPE_BYTE_ARRAY)
   40556:	d15d      	bne.n	40614 <rlp_encode_element+0xe4>
    return ERR_RLP_EBADARG;
  if(rlpEncodedOutputLen < (rlpElement->len + 1)) // extra byte for rlp encoding tag
   40558:	1c59      	adds	r1, r3, #1
   4055a:	42a9      	cmp	r1, r5
   4055c:	d860      	bhi.n	40620 <rlp_encode_element+0xf0>
    return ERR_RLP_ENOMEM;
  if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElement->buff, rlpElement->len)) // No overlapping memory regions
   4055e:	6891      	ldr	r1, [r2, #8]
    if( (aAddr == bAddr) ||
   40560:	4281      	cmp	r1, r0
   40562:	d05a      	beq.n	4061a <rlp_encode_element+0xea>
   40564:	d902      	bls.n	4056c <rlp_encode_element+0x3c>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   40566:	1942      	adds	r2, r0, r5
   40568:	4291      	cmp	r1, r2
   4056a:	d956      	bls.n	4061a <rlp_encode_element+0xea>
   4056c:	4281      	cmp	r1, r0
   4056e:	d202      	bcs.n	40576 <rlp_encode_element+0x46>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   40570:	18ca      	adds	r2, r1, r3
   40572:	4290      	cmp	r0, r2
   40574:	d951      	bls.n	4061a <rlp_encode_element+0xea>
  uint8_t *rlpOut = (uint8_t *)rlpEncodedOutput;
  uint8_t const *rlpElementBuff = (uint8_t *)rlpElement->buff;
  size_t rlpElementLen = rlpElement->len;
  size_t rlpEncodedLen = 0;

  if(RLP_TYPE_IS_INTEGER_TYPE(rlpElement->type)) {
   40576:	2c07      	cmp	r4, #7
   40578:	d81c      	bhi.n	405b4 <rlp_encode_element+0x84>
   4057a:	460e      	mov	r6, r1
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   4057c:	461c      	mov	r4, r3
    const uint8_t *buffBase = rlpElement->buff;
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   4057e:	2200      	movs	r2, #0
      if(buffBase[scanZero]) {
        rlpElementBuff = (buffBase + scanZero);
        rlpElementLen -= scanZero;
        break;
      } else if (scanZero == rlpElement->len - 1) {
   40580:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   40584:	4293      	cmp	r3, r2
   40586:	d008      	beq.n	4059a <rlp_encode_element+0x6a>
      if(buffBase[scanZero]) {
   40588:	4637      	mov	r7, r6
   4058a:	f897 e000 	ldrb.w	lr, [r7]
   4058e:	3601      	adds	r6, #1
   40590:	f1be 0f00 	cmp.w	lr, #0
   40594:	d009      	beq.n	405aa <rlp_encode_element+0x7a>
   40596:	4639      	mov	r1, r7
        rlpElementLen -= scanZero;
   40598:	1aa4      	subs	r4, r4, r2
        rlpElementLen = 0;
      }
    }
  }
  // Element Header Generation
  if(rlpElementLen == 0) {
   4059a:	b96c      	cbnz	r4, 405b8 <rlp_encode_element+0x88>
    rlpEncodedLen = 1;
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   4059c:	2380      	movs	r3, #128	; 0x80
    rlpEncodedLen = 1;
   4059e:	2401      	movs	r4, #1
    rlpOut[0] = (uint8_t) RLP_OFFSET_ITEM_SHORT;
   405a0:	7003      	strb	r3, [r0, #0]
    }
    // Payload
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
  }
  return rlpEncodedLen; // all was successful, return encoded length.
   405a2:	4620      	mov	r0, r4
}
   405a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (type == RLP_TYPE_BYTE_ARRAY)
   405a6:	2901      	cmp	r1, #1
   405a8:	e7d5      	b.n	40556 <rlp_encode_element+0x26>
        rlpElementLen = 0;
   405aa:	4594      	cmp	ip, r2
   405ac:	bf08      	it	eq
   405ae:	2400      	moveq	r4, #0
    for(size_t scanZero = 0; scanZero < rlpElement->len; scanZero++) { 
   405b0:	3201      	adds	r2, #1
   405b2:	e7e7      	b.n	40584 <rlp_encode_element+0x54>
     rlpElement->type == RLP_TYPE_INVALID || !rlp_type_mem_check(rlpElement->len, rlpElement->type))
   405b4:	461c      	mov	r4, r3
   405b6:	e7f0      	b.n	4059a <rlp_encode_element+0x6a>
  else if(rlpElementLen == 1 && (rlpElementBuff[0] == 0x00 || 
   405b8:	2c01      	cmp	r4, #1
   405ba:	d106      	bne.n	405ca <rlp_encode_element+0x9a>
   405bc:	f991 2000 	ldrsb.w	r2, [r1]
   405c0:	780b      	ldrb	r3, [r1, #0]
   405c2:	2a00      	cmp	r2, #0
   405c4:	db03      	blt.n	405ce <rlp_encode_element+0x9e>
    rlpOut[0] = rlpElementBuff[0];
   405c6:	7003      	strb	r3, [r0, #0]
   405c8:	e7eb      	b.n	405a2 <rlp_encode_element+0x72>
  else if (rlpElementLen <= RLP_EXTENDED_LENGTH_THRESHOLD) {
   405ca:	2c37      	cmp	r4, #55	; 0x37
   405cc:	d808      	bhi.n	405e0 <rlp_encode_element+0xb0>
    uint8_t length = (uint8_t) (RLP_OFFSET_ITEM_SHORT + rlpElementLen);
   405ce:	f1a4 0380 	sub.w	r3, r4, #128	; 0x80
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   405d2:	4622      	mov	r2, r4
    rlpOut[0] = length;
   405d4:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(rlpOut + 1, rlpElementBuff, rlpElementLen);
   405d8:	f008 f9a5 	bl	48926 <memcpy>
    rlpEncodedLen = rlpElementLen + 1;
   405dc:	3401      	adds	r4, #1
   405de:	e7e0      	b.n	405a2 <rlp_encode_element+0x72>
    int tmpLength = rlpElementLen;
   405e0:	4622      	mov	r2, r4
   405e2:	4627      	mov	r7, r4
    size_t lengthOfLength = (size_t) 0;
   405e4:	2300      	movs	r3, #0
    while (tmpLength != 0) {
   405e6:	123f      	asrs	r7, r7, #8
   405e8:	461e      	mov	r6, r3
        ++lengthOfLength;
   405ea:	f103 0301 	add.w	r3, r3, #1
    while (tmpLength != 0) {
   405ee:	d1fa      	bne.n	405e6 <rlp_encode_element+0xb6>
    if(rlpEncodedOutputLen < (rlpElementLen + lengthOfLength + 1))
   405f0:	3602      	adds	r6, #2
   405f2:	4434      	add	r4, r6
   405f4:	42ac      	cmp	r4, r5
   405f6:	d813      	bhi.n	40620 <rlp_encode_element+0xf0>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_ITEM_LONG + lengthOfLength);
   405f8:	f1a3 0549 	sub.w	r5, r3, #73	; 0x49
   405fc:	7005      	strb	r5, [r0, #0]
    for(int i = lengthOfLength; i > 0; --i) {
   405fe:	2b00      	cmp	r3, #0
   40600:	dc04      	bgt.n	4060c <rlp_encode_element+0xdc>
    memcpy(rlpOut + 1 + lengthOfLength, rlpElementBuff, (rlpElementLen + lengthOfLength + 1));
   40602:	4622      	mov	r2, r4
   40604:	4430      	add	r0, r6
   40606:	f008 f98e 	bl	48926 <memcpy>
    rlpEncodedLen = (rlpElementLen + lengthOfLength + 1);
   4060a:	e7ca      	b.n	405a2 <rlp_encode_element+0x72>
      rlpOut[i] = (uint8_t) tmpLength;
   4060c:	54c2      	strb	r2, [r0, r3]
      tmpLength = tmpLength >> 8;
   4060e:	1212      	asrs	r2, r2, #8
    for(int i = lengthOfLength; i > 0; --i) {
   40610:	3b01      	subs	r3, #1
   40612:	e7f4      	b.n	405fe <rlp_encode_element+0xce>
    return ERR_RLP_EBADARG;
   40614:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   40618:	e7c4      	b.n	405a4 <rlp_encode_element+0x74>
    return ERR_RLP_EILLEGALMEM;
   4061a:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   4061e:	e7c1      	b.n	405a4 <rlp_encode_element+0x74>
    return ERR_RLP_ENOMEM;
   40620:	f06f 007c 	mvn.w	r0, #124	; 0x7c
   40624:	e7be      	b.n	405a4 <rlp_encode_element+0x74>
   40626:	bf00      	nop
   40628:	0004995a 	.word	0x0004995a

0004062c <sha3_process_block>:
 *
 * @param hash the algorithm state
 * @param block the message block to process
 * @param block_size the size of the processed block in bytes
 */
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   4062c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   40630:	f1a0 0a08 	sub.w	sl, r0, #8
   40634:	4653      	mov	r3, sl
   40636:	b099      	sub	sp, #100	; 0x64
   40638:	3908      	subs	r1, #8
   4063a:	f100 0680 	add.w	r6, r0, #128	; 0x80
    for (uint8_t i = 0; i < 17; i++) {
        hash[i] ^= le2me_64(block[i]);
   4063e:	f853 4f08 	ldr.w	r4, [r3, #8]!
   40642:	f851 7f08 	ldr.w	r7, [r1, #8]!
   40646:	685a      	ldr	r2, [r3, #4]
   40648:	684d      	ldr	r5, [r1, #4]
   4064a:	407c      	eors	r4, r7
   4064c:	406a      	eors	r2, r5
    for (uint8_t i = 0; i < 17; i++) {
   4064e:	429e      	cmp	r6, r3
        hash[i] ^= le2me_64(block[i]);
   40650:	e9c3 4200 	strd	r4, r2, [r3]
    for (uint8_t i = 0; i < 17; i++) {
   40654:	d1f3      	bne.n	4063e <sha3_process_block+0x12>
   40656:	f04f 0b18 	mov.w	fp, #24
   4065a:	4b8f      	ldr	r3, [pc, #572]	; (40898 <sha3_process_block+0x26c>)
   4065c:	9301      	str	r3, [sp, #4]
   4065e:	f100 03c0 	add.w	r3, r0, #192	; 0xc0
   40662:	9302      	str	r3, [sp, #8]
   40664:	f100 03c8 	add.w	r3, r0, #200	; 0xc8
   40668:	9303      	str	r3, [sp, #12]
static void sha3_process_block(uint64_t hash[25], const uint64_t *block) {
   4066a:	4651      	mov	r1, sl
   4066c:	2700      	movs	r7, #0
   4066e:	ab04      	add	r3, sp, #16
        C[i] = A[i];
   40670:	2405      	movs	r4, #5
   40672:	f851 6f08 	ldr.w	r6, [r1, #8]!
   40676:	684d      	ldr	r5, [r1, #4]
   40678:	e9c3 6500 	strd	r6, r5, [r3]
   4067c:	3308      	adds	r3, #8
        for (uint8_t j = 5; j < 25; j += 5) { C[i] ^= A[i + j]; }
   4067e:	eb01 0cc4 	add.w	ip, r1, r4, lsl #3
   40682:	f851 2034 	ldr.w	r2, [r1, r4, lsl #3]
   40686:	f8dc c004 	ldr.w	ip, [ip, #4]
   4068a:	3405      	adds	r4, #5
   4068c:	2c19      	cmp	r4, #25
   4068e:	ea86 0602 	eor.w	r6, r6, r2
   40692:	ea85 050c 	eor.w	r5, r5, ip
   40696:	d1f2      	bne.n	4067e <sha3_process_block+0x52>
   40698:	3701      	adds	r7, #1
    for (uint8_t i = 0; i < 5; i++) {
   4069a:	2f05      	cmp	r7, #5
   4069c:	e943 6502 	strd	r6, r5, [r3, #-8]
   406a0:	d1e6      	bne.n	40670 <sha3_process_block+0x44>
   406a2:	ac0e      	add	r4, sp, #56	; 0x38
   406a4:	4621      	mov	r1, r4
   406a6:	2201      	movs	r2, #1
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   406a8:	f04f 0c05 	mov.w	ip, #5
   406ac:	fbb2 f3fc 	udiv	r3, r2, ip
   406b0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   406b4:	1ad3      	subs	r3, r2, r3
   406b6:	ad18      	add	r5, sp, #96	; 0x60
   406b8:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
   406bc:	e953 5714 	ldrd	r5, r7, [r3, #-80]	; 0x50
   406c0:	007e      	lsls	r6, r7, #1
   406c2:	ea46 76d5 	orr.w	r6, r6, r5, lsr #31
   406c6:	006b      	lsls	r3, r5, #1
   406c8:	1cd5      	adds	r5, r2, #3
   406ca:	ea43 73d7 	orr.w	r3, r3, r7, lsr #31
   406ce:	fbb5 f7fc 	udiv	r7, r5, ip
   406d2:	eb07 0787 	add.w	r7, r7, r7, lsl #2
   406d6:	1bed      	subs	r5, r5, r7
   406d8:	af18      	add	r7, sp, #96	; 0x60
   406da:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
   406de:	3201      	adds	r2, #1
   406e0:	e955 7514 	ldrd	r7, r5, [r5, #-80]	; 0x50
    for (uint8_t i = 0; i < 5; i++) {
   406e4:	2a06      	cmp	r2, #6
        D[i] = ROTL64(C[(i + 1) % 5], 1) ^ C[(i + 4) % 5];
   406e6:	ea83 0307 	eor.w	r3, r3, r7
   406ea:	ea86 0605 	eor.w	r6, r6, r5
   406ee:	e9c1 3600 	strd	r3, r6, [r1]
   406f2:	f101 0108 	add.w	r1, r1, #8
    for (uint8_t i = 0; i < 5; i++) {
   406f6:	d1d7      	bne.n	406a8 <sha3_process_block+0x7c>
   406f8:	2500      	movs	r5, #0
        for (uint8_t j = 0; j < 25; j += 5) { A[i + j] ^= D[i]; }
   406fa:	e9d4 c700 	ldrd	ip, r7, [r4]
   406fe:	2600      	movs	r6, #0
   40700:	3408      	adds	r4, #8
   40702:	eb00 01c5 	add.w	r1, r0, r5, lsl #3
   40706:	3601      	adds	r6, #1
   40708:	e9d1 2300 	ldrd	r2, r3, [r1]
   4070c:	2e05      	cmp	r6, #5
   4070e:	ea82 020c 	eor.w	r2, r2, ip
   40712:	ea83 0307 	eor.w	r3, r3, r7
   40716:	e9c1 2300 	strd	r2, r3, [r1]
   4071a:	f101 0128 	add.w	r1, r1, #40	; 0x28
   4071e:	d1f2      	bne.n	40706 <sha3_process_block+0xda>
    for (uint8_t i = 0; i < 5; i++) {
   40720:	3501      	adds	r5, #1
   40722:	2d05      	cmp	r5, #5
   40724:	d1e9      	bne.n	406fa <sha3_process_block+0xce>
        for (uint8_t i = 1; i < 25; i++) {
   40726:	4604      	mov	r4, r0
   40728:	f8df e174 	ldr.w	lr, [pc, #372]	; 408a0 <sha3_process_block+0x274>
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   4072c:	f854 2f08 	ldr.w	r2, [r4, #8]!
    return constants[type + index];
   40730:	f81e 3b01 	ldrb.w	r3, [lr], #1
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40734:	6865      	ldr	r5, [r4, #4]
   40736:	f1a3 0720 	sub.w	r7, r3, #32
   4073a:	fa02 f707 	lsl.w	r7, r2, r7
   4073e:	f1c3 0620 	rsb	r6, r3, #32
   40742:	fa05 f103 	lsl.w	r1, r5, r3
   40746:	fa22 f606 	lsr.w	r6, r2, r6
   4074a:	4339      	orrs	r1, r7
   4074c:	4331      	orrs	r1, r6
   4074e:	fa02 f603 	lsl.w	r6, r2, r3
   40752:	425b      	negs	r3, r3
   40754:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   40758:	f1c3 0c20 	rsb	ip, r3, #32
   4075c:	f1a3 0720 	sub.w	r7, r3, #32
   40760:	40da      	lsrs	r2, r3
   40762:	fa05 fc0c 	lsl.w	ip, r5, ip
   40766:	fa25 f303 	lsr.w	r3, r5, r3
   4076a:	4319      	orrs	r1, r3
   4076c:	ea42 020c 	orr.w	r2, r2, ip
        for (uint8_t i = 1; i < 25; i++) {
   40770:	9b02      	ldr	r3, [sp, #8]
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   40772:	fa25 f707 	lsr.w	r7, r5, r7
   40776:	433a      	orrs	r2, r7
   40778:	4332      	orrs	r2, r6
        for (uint8_t i = 1; i < 25; i++) {
   4077a:	42a3      	cmp	r3, r4
            state[i] = ROTL64(state[i], getConstant(TYPE_RHO_TRANSFORM, i - 1));
   4077c:	e9c4 2100 	strd	r2, r1, [r4]
        for (uint8_t i = 1; i < 25; i++) {
   40780:	d1d4      	bne.n	4072c <sha3_process_block+0x100>
    for (uint8_t i = 1; i < 24; i++) {
   40782:	2101      	movs	r1, #1
    uint64_t A1 = A[1];
   40784:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
    for (uint8_t i = 1; i < 24; i++) {
   40788:	4f44      	ldr	r7, [pc, #272]	; (4089c <sha3_process_block+0x270>)
    return constants[type + index];
   4078a:	463e      	mov	r6, r7
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   4078c:	787c      	ldrb	r4, [r7, #1]
   4078e:	7836      	ldrb	r6, [r6, #0]
    for (uint8_t i = 1; i < 24; i++) {
   40790:	3101      	adds	r1, #1
   40792:	b2c9      	uxtb	r1, r1
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   40794:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   40798:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
    for (uint8_t i = 1; i < 24; i++) {
   4079c:	2918      	cmp	r1, #24
        A[getConstant(TYPE_PI_TRANSFORM, i - 1)] = A[getConstant(TYPE_PI_TRANSFORM, i)];
   4079e:	e9d4 4500 	ldrd	r4, r5, [r4]
   407a2:	f107 0701 	add.w	r7, r7, #1
   407a6:	e9c6 4500 	strd	r4, r5, [r6]
    for (uint8_t i = 1; i < 24; i++) {
   407aa:	d1ee      	bne.n	4078a <sha3_process_block+0x15e>
    A[10] = A1;
   407ac:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
   407b0:	4603      	mov	r3, r0
        uint64_t A0 = A[0 + i], A1 = A[1 + i];
   407b2:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
   407b6:	e9d3 7600 	ldrd	r7, r6, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   407ba:	e9d3 ec06 	ldrd	lr, ip, [r3, #24]
        A[0 + i] ^= ~A1 & A[2 + i];
   407be:	691c      	ldr	r4, [r3, #16]
   407c0:	ea24 0501 	bic.w	r5, r4, r1
   407c4:	695c      	ldr	r4, [r3, #20]
   407c6:	407d      	eors	r5, r7
   407c8:	ea24 0402 	bic.w	r4, r4, r2
   407cc:	4074      	eors	r4, r6
   407ce:	e9c3 5400 	strd	r5, r4, [r3]
        A[1 + i] ^= ~A[2 + i] & A[3 + i];
   407d2:	691c      	ldr	r4, [r3, #16]
   407d4:	ea2e 0504 	bic.w	r5, lr, r4
   407d8:	695c      	ldr	r4, [r3, #20]
   407da:	404d      	eors	r5, r1
   407dc:	ea2c 0404 	bic.w	r4, ip, r4
   407e0:	4054      	eors	r4, r2
   407e2:	e9c3 5402 	strd	r5, r4, [r3, #8]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   407e6:	e9d3 5408 	ldrd	r5, r4, [r3, #32]
   407ea:	ea24 080c 	bic.w	r8, r4, ip
   407ee:	9400      	str	r4, [sp, #0]
   407f0:	691c      	ldr	r4, [r3, #16]
   407f2:	ea25 090e 	bic.w	r9, r5, lr
   407f6:	ea89 0904 	eor.w	r9, r9, r4
   407fa:	695c      	ldr	r4, [r3, #20]
        A[4 + i] ^= ~A0 & A1;
   407fc:	ea22 0206 	bic.w	r2, r2, r6
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   40800:	ea88 0804 	eor.w	r8, r8, r4
        A[3 + i] ^= ~A[4 + i] & A0;
   40804:	9c00      	ldr	r4, [sp, #0]
        A[2 + i] ^= ~A[3 + i] & A[4 + i];
   40806:	e9c3 9804 	strd	r9, r8, [r3, #16]
        A[4 + i] ^= ~A0 & A1;
   4080a:	ea21 0107 	bic.w	r1, r1, r7
        A[3 + i] ^= ~A[4 + i] & A0;
   4080e:	ea27 0905 	bic.w	r9, r7, r5
   40812:	ea26 0804 	bic.w	r8, r6, r4
   40816:	ea89 0e0e 	eor.w	lr, r9, lr
        A[4 + i] ^= ~A0 & A1;
   4081a:	4054      	eors	r4, r2
        A[3 + i] ^= ~A[4 + i] & A0;
   4081c:	ea88 0c0c 	eor.w	ip, r8, ip
    for (uint8_t i = 0; i < 25; i += 5) {
   40820:	9a03      	ldr	r2, [sp, #12]
        A[4 + i] ^= ~A0 & A1;
   40822:	404d      	eors	r5, r1
        A[3 + i] ^= ~A[4 + i] & A0;
   40824:	e9c3 ec06 	strd	lr, ip, [r3, #24]
        A[4 + i] ^= ~A0 & A1;
   40828:	e9c3 5408 	strd	r5, r4, [r3, #32]
    for (uint8_t i = 0; i < 25; i += 5) {
   4082c:	3328      	adds	r3, #40	; 0x28
   4082e:	429a      	cmp	r2, r3
   40830:	d1bf      	bne.n	407b2 <sha3_process_block+0x186>
    return constants[type + index];
   40832:	9b01      	ldr	r3, [sp, #4]
   40834:	f813 2b01 	ldrb.w	r2, [r3], #1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   40838:	f012 0140 	ands.w	r1, r2, #64	; 0x40
   4083c:	bf16      	itet	ne
   4083e:	2100      	movne	r1, #0
    uint64_t result = 0;
   40840:	460c      	moveq	r4, r1
    if (roundInfo & (1 << 6)) { result |= ((uint64_t)1 << 63); }
   40842:	f04f 4400 	movne.w	r4, #2147483648	; 0x80000000
    if (roundInfo & (1 << 5)) { result |= ((uint64_t)1 << 31); }
   40846:	f012 0f20 	tst.w	r2, #32
   4084a:	bf18      	it	ne
   4084c:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
    return constants[type + index];
   40850:	9301      	str	r3, [sp, #4]
    if (roundInfo & (1 << 4)) { result |= ((uint64_t)1 << 15); }
   40852:	06d3      	lsls	r3, r2, #27
   40854:	bf48      	it	mi
   40856:	f441 4100 	orrmi.w	r1, r1, #32768	; 0x8000
    if (roundInfo & (1 << 3)) { result |= ((uint64_t)1 << 7); }
   4085a:	0717      	lsls	r7, r2, #28
   4085c:	bf48      	it	mi
   4085e:	f041 0180 	orrmi.w	r1, r1, #128	; 0x80
    if (roundInfo & (1 << 2)) { result |= ((uint64_t)1 << 3); }
   40862:	0756      	lsls	r6, r2, #29
   40864:	bf48      	it	mi
   40866:	f041 0108 	orrmi.w	r1, r1, #8
    if (roundInfo & (1 << 1)) { result |= ((uint64_t)1 << 1); }
   4086a:	0795      	lsls	r5, r2, #30
   4086c:	bf48      	it	mi
   4086e:	f041 0102 	orrmi.w	r1, r1, #2
    if (roundInfo & (1 << 0)) { result |= ((uint64_t)1 << 0); }
   40872:	07d3      	lsls	r3, r2, #31
   40874:	bf48      	it	mi
   40876:	f041 0101 	orrmi.w	r1, r1, #1
        *state ^= get_round_constant(round);
   4087a:	e9d0 2300 	ldrd	r2, r3, [r0]
   4087e:	4063      	eors	r3, r4
   40880:	404a      	eors	r2, r1
   40882:	e9c0 2300 	strd	r2, r3, [r0]
    for (uint8_t round = 0; round < 24; round++) {
   40886:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   4088a:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   4088e:	f47f aeec 	bne.w	4066a <sha3_process_block+0x3e>
    }

    /* make a permutation of the hash */
    sha3_permutation(hash);
}
   40892:	b019      	add	sp, #100	; 0x64
   40894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   40898:	00049962 	.word	0x00049962
   4089c:	0004997a 	.word	0x0004997a
   408a0:	00049992 	.word	0x00049992

000408a4 <crypto_finish>:

	return APP_SUCCESS;
}

int crypto_finish(void)
{
   408a4:	b508      	push	{r3, lr}
	psa_status_t status;

	/* Destroy the key handle */
	status = psa_destroy_key(keypair_handle);
   408a6:	4b11      	ldr	r3, [pc, #68]	; (408ec <crypto_finish+0x48>)
   408a8:	6818      	ldr	r0, [r3, #0]
   408aa:	f006 ff31 	bl	47710 <psa_destroy_key>
	if (status != PSA_SUCCESS) {
   408ae:	4601      	mov	r1, r0
   408b0:	b160      	cbz	r0, 408cc <crypto_finish+0x28>
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
   408b2:	4a0f      	ldr	r2, [pc, #60]	; (408f0 <crypto_finish+0x4c>)
   408b4:	4b0f      	ldr	r3, [pc, #60]	; (408f4 <crypto_finish+0x50>)
   408b6:	1ad2      	subs	r2, r2, r3
   408b8:	08d2      	lsrs	r2, r2, #3
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   408ba:	0192      	lsls	r2, r2, #6
   408bc:	f042 0203 	orr.w	r2, r2, #3
		return APP_ERROR;
	}

	status = psa_destroy_key(pub_key_handle);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   408c0:	480d      	ldr	r0, [pc, #52]	; (408f8 <crypto_finish+0x54>)
   408c2:	f007 fccc 	bl	4825e <log_1>
		return APP_ERROR;
   408c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	return APP_SUCCESS;
}
   408ca:	bd08      	pop	{r3, pc}
	status = psa_destroy_key(pub_key_handle);
   408cc:	4b0b      	ldr	r3, [pc, #44]	; (408fc <crypto_finish+0x58>)
   408ce:	6818      	ldr	r0, [r3, #0]
   408d0:	f006 ff1e 	bl	47710 <psa_destroy_key>
	if (status != PSA_SUCCESS) {
   408d4:	2800      	cmp	r0, #0
   408d6:	d0f8      	beq.n	408ca <crypto_finish+0x26>
   408d8:	4a05      	ldr	r2, [pc, #20]	; (408f0 <crypto_finish+0x4c>)
   408da:	4b06      	ldr	r3, [pc, #24]	; (408f4 <crypto_finish+0x50>)
		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
   408dc:	4601      	mov	r1, r0
   408de:	1ad2      	subs	r2, r2, r3
   408e0:	08d2      	lsrs	r2, r2, #3
   408e2:	0192      	lsls	r2, r2, #6
   408e4:	f042 0203 	orr.w	r2, r2, #3
   408e8:	e7ea      	b.n	408c0 <crypto_finish+0x1c>
   408ea:	bf00      	nop
   408ec:	2001a8cc 	.word	0x2001a8cc
   408f0:	0004969c 	.word	0x0004969c
   408f4:	00049694 	.word	0x00049694
   408f8:	000499aa 	.word	0x000499aa
   408fc:	2001a8d0 	.word	0x2001a8d0

00040900 <generate_ecdsa_keypair>:

int generate_ecdsa_keypair(void)
{
   40900:	b530      	push	{r4, r5, lr}
   40902:	4b1b      	ldr	r3, [pc, #108]	; (40970 <generate_ecdsa_keypair+0x70>)
   40904:	4c1b      	ldr	r4, [pc, #108]	; (40974 <generate_ecdsa_keypair+0x74>)
   40906:	b087      	sub	sp, #28
   40908:	1ae4      	subs	r4, r4, r3
   4090a:	08e4      	lsrs	r4, r4, #3
	psa_status_t status;
	size_t olen;

	LOG_INF("Generating random ECDSA keypair...");
   4090c:	01a4      	lsls	r4, r4, #6
   4090e:	f044 0403 	orr.w	r4, r4, #3
   40912:	4621      	mov	r1, r4
   40914:	4818      	ldr	r0, [pc, #96]	; (40978 <generate_ecdsa_keypair+0x78>)
   40916:	f007 fc95 	bl	48244 <log_0>
}

static inline void psa_set_key_lifetime(psa_key_attributes_t *attributes,
                                        psa_key_lifetime_t lifetime)
{
    attributes->lifetime = lifetime;
   4091a:	2300      	movs	r3, #0
}

static inline void psa_set_key_algorithm(psa_key_attributes_t *attributes,
                                         psa_algorithm_t alg)
{
    attributes->alg = alg;
   4091c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    attributes->lifetime = lifetime;
   40920:	4a16      	ldr	r2, [pc, #88]	; (4097c <generate_ecdsa_keypair+0x7c>)
        attributes->id = 0;
   40922:	9303      	str	r3, [sp, #12]
    attributes->lifetime = lifetime;
   40924:	e9cd 2301 	strd	r2, r3, [sp, #4]

	/* Generate a random keypair. The keypair is not exposed to the application,
	 * we can use it to signing/verification the key handle.
	 */
	
	status = psa_generate_key(&key_attributes, &keypair_handle);
   40928:	4d15      	ldr	r5, [pc, #84]	; (40980 <generate_ecdsa_keypair+0x80>)
    attributes->alg = alg;
   4092a:	4b16      	ldr	r3, [pc, #88]	; (40984 <generate_ecdsa_keypair+0x84>)
   4092c:	a801      	add	r0, sp, #4
   4092e:	e9cd 1304 	strd	r1, r3, [sp, #16]
   40932:	4629      	mov	r1, r5
   40934:	f006 ffdc 	bl	478f0 <psa_generate_key>
	if (status != PSA_SUCCESS) {
   40938:	4601      	mov	r1, r0
   4093a:	b140      	cbz	r0, 4094e <generate_ecdsa_keypair+0x4e>
		LOG_INF("psa_generate_key failed! (Error: %d)", status);
   4093c:	4622      	mov	r2, r4
   4093e:	4812      	ldr	r0, [pc, #72]	; (40988 <generate_ecdsa_keypair+0x88>)
	}

	/* Export the public key */
	status = psa_export_public_key(keypair_handle, m_pub_key, sizeof(m_pub_key), &olen);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
   40940:	f007 fc8d 	bl	4825e <log_1>
		return APP_ERROR;
   40944:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

	/* After the key handle is acquired the attributes are not needed */
	psa_reset_key_attributes(&key_attributes);

	return APP_SUCCESS;
}
   40948:	4628      	mov	r0, r5
   4094a:	b007      	add	sp, #28
   4094c:	bd30      	pop	{r4, r5, pc}
	status = psa_export_public_key(keypair_handle, m_pub_key, sizeof(m_pub_key), &olen);
   4094e:	6828      	ldr	r0, [r5, #0]
   40950:	466b      	mov	r3, sp
   40952:	2241      	movs	r2, #65	; 0x41
   40954:	490d      	ldr	r1, [pc, #52]	; (4098c <generate_ecdsa_keypair+0x8c>)
   40956:	f006 ff11 	bl	4777c <psa_export_public_key>
	if (status != PSA_SUCCESS) {
   4095a:	4605      	mov	r5, r0
   4095c:	b118      	cbz	r0, 40966 <generate_ecdsa_keypair+0x66>
		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
   4095e:	4601      	mov	r1, r0
   40960:	4622      	mov	r2, r4
   40962:	480b      	ldr	r0, [pc, #44]	; (40990 <generate_ecdsa_keypair+0x90>)
   40964:	e7ec      	b.n	40940 <generate_ecdsa_keypair+0x40>
	psa_reset_key_attributes(&key_attributes);
   40966:	a801      	add	r0, sp, #4
   40968:	f006 feec 	bl	47744 <psa_reset_key_attributes>
	return APP_SUCCESS;
   4096c:	e7ec      	b.n	40948 <generate_ecdsa_keypair+0x48>
   4096e:	bf00      	nop
   40970:	00049694 	.word	0x00049694
   40974:	0004969c 	.word	0x0004969c
   40978:	000499ce 	.word	0x000499ce
   4097c:	01007112 	.word	0x01007112
   40980:	2001a8cc 	.word	0x2001a8cc
   40984:	06000609 	.word	0x06000609
   40988:	000499f1 	.word	0x000499f1
   4098c:	2001ae4f 	.word	0x2001ae4f
   40990:	00049a16 	.word	0x00049a16

00040994 <import_ecdsa_pub_key>:
    attributes->lifetime = lifetime;
   40994:	2300      	movs	r3, #0
    attributes->alg = alg;
   40996:	f44f 5100 	mov.w	r1, #8192	; 0x2000

int import_ecdsa_pub_key(void)
{
   4099a:	b510      	push	{r4, lr}
    attributes->lifetime = lifetime;
   4099c:	4a11      	ldr	r2, [pc, #68]	; (409e4 <import_ecdsa_pub_key+0x50>)
   4099e:	b086      	sub	sp, #24
   409a0:	e9cd 2301 	strd	r2, r3, [sp, #4]
        attributes->id = 0;
   409a4:	9303      	str	r3, [sp, #12]
    attributes->alg = alg;
   409a6:	4b10      	ldr	r3, [pc, #64]	; (409e8 <import_ecdsa_pub_key+0x54>)
	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(PSA_ECC_FAMILY_SECP_R1));
	psa_set_key_bits(&key_attributes, 256);

	status = psa_import_key(&key_attributes, m_pub_key, sizeof(m_pub_key), &pub_key_handle);
   409a8:	2241      	movs	r2, #65	; 0x41
   409aa:	e9cd 1304 	strd	r1, r3, [sp, #16]
   409ae:	a801      	add	r0, sp, #4
   409b0:	4b0e      	ldr	r3, [pc, #56]	; (409ec <import_ecdsa_pub_key+0x58>)
   409b2:	490f      	ldr	r1, [pc, #60]	; (409f0 <import_ecdsa_pub_key+0x5c>)
   409b4:	f006 fe88 	bl	476c8 <psa_import_key>
	if (status != PSA_SUCCESS) {
   409b8:	4604      	mov	r4, r0
   409ba:	b178      	cbz	r0, 409dc <import_ecdsa_pub_key+0x48>
   409bc:	4b0d      	ldr	r3, [pc, #52]	; (409f4 <import_ecdsa_pub_key+0x60>)
   409be:	4a0e      	ldr	r2, [pc, #56]	; (409f8 <import_ecdsa_pub_key+0x64>)
		LOG_INF("psa_import_key failed! (Error: %d)", status);
   409c0:	4601      	mov	r1, r0
   409c2:	1ad2      	subs	r2, r2, r3
   409c4:	08d2      	lsrs	r2, r2, #3
   409c6:	0192      	lsls	r2, r2, #6
   409c8:	480c      	ldr	r0, [pc, #48]	; (409fc <import_ecdsa_pub_key+0x68>)
   409ca:	f042 0203 	orr.w	r2, r2, #3
   409ce:	f007 fc46 	bl	4825e <log_1>
		return APP_ERROR;
   409d2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

	/* After the key handle is acquired the attributes are not needed */
	psa_reset_key_attributes(&key_attributes);

	return APP_SUCCESS;
}
   409d6:	4620      	mov	r0, r4
   409d8:	b006      	add	sp, #24
   409da:	bd10      	pop	{r4, pc}
	psa_reset_key_attributes(&key_attributes);
   409dc:	a801      	add	r0, sp, #4
   409de:	f006 feb1 	bl	47744 <psa_reset_key_attributes>
	return APP_SUCCESS;
   409e2:	e7f8      	b.n	409d6 <import_ecdsa_pub_key+0x42>
   409e4:	01004112 	.word	0x01004112
   409e8:	06000609 	.word	0x06000609
   409ec:	2001a8d0 	.word	0x2001a8d0
   409f0:	2001ae4f 	.word	0x2001ae4f
   409f4:	00049694 	.word	0x00049694
   409f8:	0004969c 	.word	0x0004969c
   409fc:	00049a40 	.word	0x00049a40

00040a00 <sign_message>:

int sign_message(void)
{
   40a00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	psa_status_t status;

	LOG_INF("Signing a message using ECDSA...");

	/* Compute the SHA256 hash*/
	status = psa_hash_compute(PSA_ALG_SHA_256,
   40a04:	2620      	movs	r6, #32
   40a06:	4b36      	ldr	r3, [pc, #216]	; (40ae0 <sign_message+0xe0>)
   40a08:	4c36      	ldr	r4, [pc, #216]	; (40ae4 <sign_message+0xe4>)
{
   40a0a:	b086      	sub	sp, #24
   40a0c:	1ae4      	subs	r4, r4, r3
   40a0e:	08e4      	lsrs	r4, r4, #3
	LOG_INF("Signing a message using ECDSA...");
   40a10:	01a4      	lsls	r4, r4, #6
   40a12:	f044 0403 	orr.w	r4, r4, #3
   40a16:	4621      	mov	r1, r4
   40a18:	4833      	ldr	r0, [pc, #204]	; (40ae8 <sign_message+0xe8>)
	status = psa_hash_compute(PSA_ALG_SHA_256,
   40a1a:	ad05      	add	r5, sp, #20
	LOG_INF("Signing a message using ECDSA...");
   40a1c:	f007 fc12 	bl	48244 <log_0>
	status = psa_hash_compute(PSA_ALG_SHA_256,
   40a20:	4932      	ldr	r1, [pc, #200]	; (40aec <sign_message+0xec>)
   40a22:	2264      	movs	r2, #100	; 0x64
   40a24:	4b32      	ldr	r3, [pc, #200]	; (40af0 <sign_message+0xf0>)
   40a26:	4833      	ldr	r0, [pc, #204]	; (40af4 <sign_message+0xf4>)
   40a28:	9501      	str	r5, [sp, #4]
   40a2a:	9600      	str	r6, [sp, #0]
   40a2c:	f006 fec8 	bl	477c0 <psa_hash_compute>
				  m_plain_text,
				  sizeof(m_plain_text),
				  m_hash,
				  sizeof(m_hash),
				  &output_len);
	if (status != PSA_SUCCESS) {
   40a30:	4601      	mov	r1, r0
   40a32:	b148      	cbz	r0, 40a48 <sign_message+0x48>
		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
   40a34:	4622      	mov	r2, r4
   40a36:	4830      	ldr	r0, [pc, #192]	; (40af8 <sign_message+0xf8>)
			       sizeof(m_hash),
			       m_signature,
			       sizeof(m_signature),
			       &output_len);
	if (status != PSA_SUCCESS) {
		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
   40a38:	f007 fc11 	bl	4825e <log_1>
		return APP_ERROR;
   40a3c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
	PRINT_HEX("SHA256 hash", m_hash, sizeof(m_hash));
	PRINT_HEX("Signature", m_signature, sizeof(m_signature));

	return APP_SUCCESS;
}
   40a40:	4628      	mov	r0, r5
   40a42:	b006      	add	sp, #24
   40a44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status = psa_sign_hash(keypair_handle,
   40a48:	2740      	movs	r7, #64	; 0x40
   40a4a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 40b24 <sign_message+0x124>
   40a4e:	482b      	ldr	r0, [pc, #172]	; (40afc <sign_message+0xfc>)
   40a50:	9502      	str	r5, [sp, #8]
   40a52:	9701      	str	r7, [sp, #4]
   40a54:	f8cd 8000 	str.w	r8, [sp]
   40a58:	4633      	mov	r3, r6
   40a5a:	4a25      	ldr	r2, [pc, #148]	; (40af0 <sign_message+0xf0>)
   40a5c:	4928      	ldr	r1, [pc, #160]	; (40b00 <sign_message+0x100>)
   40a5e:	6800      	ldr	r0, [r0, #0]
   40a60:	f006 fed6 	bl	47810 <psa_sign_hash>
	if (status != PSA_SUCCESS) {
   40a64:	4605      	mov	r5, r0
   40a66:	b118      	cbz	r0, 40a70 <sign_message+0x70>
		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
   40a68:	4601      	mov	r1, r0
   40a6a:	4622      	mov	r2, r4
   40a6c:	4825      	ldr	r0, [pc, #148]	; (40b04 <sign_message+0x104>)
   40a6e:	e7e3      	b.n	40a38 <sign_message+0x38>
	LOG_INF("Signing the message successful!");
   40a70:	4621      	mov	r1, r4
   40a72:	4825      	ldr	r0, [pc, #148]	; (40b08 <sign_message+0x108>)
   40a74:	f007 fbe6 	bl	48244 <log_0>
	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
   40a78:	4623      	mov	r3, r4
   40a7a:	2264      	movs	r2, #100	; 0x64
   40a7c:	4923      	ldr	r1, [pc, #140]	; (40b0c <sign_message+0x10c>)
   40a7e:	4824      	ldr	r0, [pc, #144]	; (40b10 <sign_message+0x110>)
   40a80:	f007 fc01 	bl	48286 <log_2>
   40a84:	4623      	mov	r3, r4
   40a86:	2264      	movs	r2, #100	; 0x64
   40a88:	4918      	ldr	r1, [pc, #96]	; (40aec <sign_message+0xec>)
   40a8a:	4822      	ldr	r0, [pc, #136]	; (40b14 <sign_message+0x114>)
   40a8c:	f007 fc30 	bl	482f0 <log_hexdump>
   40a90:	4622      	mov	r2, r4
   40a92:	491e      	ldr	r1, [pc, #120]	; (40b0c <sign_message+0x10c>)
   40a94:	4820      	ldr	r0, [pc, #128]	; (40b18 <sign_message+0x118>)
   40a96:	f007 fbe2 	bl	4825e <log_1>
	PRINT_HEX("SHA256 hash", m_hash, sizeof(m_hash));
   40a9a:	4623      	mov	r3, r4
   40a9c:	4632      	mov	r2, r6
   40a9e:	491f      	ldr	r1, [pc, #124]	; (40b1c <sign_message+0x11c>)
   40aa0:	481b      	ldr	r0, [pc, #108]	; (40b10 <sign_message+0x110>)
   40aa2:	f007 fbf0 	bl	48286 <log_2>
   40aa6:	4623      	mov	r3, r4
   40aa8:	4632      	mov	r2, r6
   40aaa:	4911      	ldr	r1, [pc, #68]	; (40af0 <sign_message+0xf0>)
   40aac:	4819      	ldr	r0, [pc, #100]	; (40b14 <sign_message+0x114>)
   40aae:	f007 fc1f 	bl	482f0 <log_hexdump>
   40ab2:	4622      	mov	r2, r4
   40ab4:	4919      	ldr	r1, [pc, #100]	; (40b1c <sign_message+0x11c>)
   40ab6:	4818      	ldr	r0, [pc, #96]	; (40b18 <sign_message+0x118>)
   40ab8:	f007 fbd1 	bl	4825e <log_1>
	PRINT_HEX("Signature", m_signature, sizeof(m_signature));
   40abc:	4623      	mov	r3, r4
   40abe:	463a      	mov	r2, r7
   40ac0:	4917      	ldr	r1, [pc, #92]	; (40b20 <sign_message+0x120>)
   40ac2:	4813      	ldr	r0, [pc, #76]	; (40b10 <sign_message+0x110>)
   40ac4:	f007 fbdf 	bl	48286 <log_2>
   40ac8:	463a      	mov	r2, r7
   40aca:	4641      	mov	r1, r8
   40acc:	4623      	mov	r3, r4
   40ace:	4811      	ldr	r0, [pc, #68]	; (40b14 <sign_message+0x114>)
   40ad0:	f007 fc0e 	bl	482f0 <log_hexdump>
   40ad4:	4622      	mov	r2, r4
   40ad6:	4912      	ldr	r1, [pc, #72]	; (40b20 <sign_message+0x120>)
   40ad8:	480f      	ldr	r0, [pc, #60]	; (40b18 <sign_message+0x118>)
   40ada:	f007 fbc0 	bl	4825e <log_1>
	return APP_SUCCESS;
   40ade:	e7af      	b.n	40a40 <sign_message+0x40>
   40ae0:	00049694 	.word	0x00049694
   40ae4:	0004969c 	.word	0x0004969c
   40ae8:	00049a63 	.word	0x00049a63
   40aec:	2001a5fa 	.word	0x2001a5fa
   40af0:	2001ae2f 	.word	0x2001ae2f
   40af4:	02000009 	.word	0x02000009
   40af8:	00049a84 	.word	0x00049a84
   40afc:	2001a8cc 	.word	0x2001a8cc
   40b00:	06000609 	.word	0x06000609
   40b04:	00049aa9 	.word	0x00049aa9
   40b08:	00049acb 	.word	0x00049acb
   40b0c:	00049aeb 	.word	0x00049aeb
   40b10:	00049af5 	.word	0x00049af5
   40b14:	00049b0d 	.word	0x00049b0d
   40b18:	00049b16 	.word	0x00049b16
   40b1c:	00049b28 	.word	0x00049b28
   40b20:	00049b34 	.word	0x00049b34
   40b24:	2001ae90 	.word	0x2001ae90

00040b28 <verify_message>:

int verify_message(void)
{
   40b28:	b537      	push	{r0, r1, r2, r4, r5, lr}
   40b2a:	4b13      	ldr	r3, [pc, #76]	; (40b78 <verify_message+0x50>)
   40b2c:	4c13      	ldr	r4, [pc, #76]	; (40b7c <verify_message+0x54>)
	psa_status_t status;

	LOG_INF("Verifying ECDSA signature...");
   40b2e:	4814      	ldr	r0, [pc, #80]	; (40b80 <verify_message+0x58>)
   40b30:	1ae4      	subs	r4, r4, r3
   40b32:	08e4      	lsrs	r4, r4, #3
   40b34:	01a4      	lsls	r4, r4, #6
   40b36:	f044 0403 	orr.w	r4, r4, #3
   40b3a:	4621      	mov	r1, r4
   40b3c:	f007 fb82 	bl	48244 <log_0>

	/* Verify the signature of the hash */
	status = psa_verify_hash(pub_key_handle,
   40b40:	2340      	movs	r3, #64	; 0x40
   40b42:	9301      	str	r3, [sp, #4]
   40b44:	4b0f      	ldr	r3, [pc, #60]	; (40b84 <verify_message+0x5c>)
   40b46:	4810      	ldr	r0, [pc, #64]	; (40b88 <verify_message+0x60>)
   40b48:	9300      	str	r3, [sp, #0]
   40b4a:	4a10      	ldr	r2, [pc, #64]	; (40b8c <verify_message+0x64>)
   40b4c:	2320      	movs	r3, #32
   40b4e:	4910      	ldr	r1, [pc, #64]	; (40b90 <verify_message+0x68>)
   40b50:	6800      	ldr	r0, [r0, #0]
   40b52:	f006 fe87 	bl	47864 <psa_verify_hash>
				 PSA_ALG_ECDSA(PSA_ALG_SHA_256),
				 m_hash,
				 sizeof(m_hash),
				 m_signature,
				 sizeof(m_signature));
	if (status != PSA_SUCCESS) {
   40b56:	4605      	mov	r5, r0
   40b58:	b148      	cbz	r0, 40b6e <verify_message+0x46>
		LOG_INF("psa_verify_hash failed! (Error: %d)", status);
   40b5a:	4601      	mov	r1, r0
   40b5c:	4622      	mov	r2, r4
   40b5e:	480d      	ldr	r0, [pc, #52]	; (40b94 <verify_message+0x6c>)
   40b60:	f007 fb7d 	bl	4825e <log_1>
		return APP_ERROR;
   40b64:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	}

	LOG_INF("Signature verification was successful!");

	return APP_SUCCESS;
}
   40b68:	4628      	mov	r0, r5
   40b6a:	b003      	add	sp, #12
   40b6c:	bd30      	pop	{r4, r5, pc}
	LOG_INF("Signature verification was successful!");
   40b6e:	4621      	mov	r1, r4
   40b70:	4809      	ldr	r0, [pc, #36]	; (40b98 <verify_message+0x70>)
   40b72:	f007 fb67 	bl	48244 <log_0>
	return APP_SUCCESS;
   40b76:	e7f7      	b.n	40b68 <verify_message+0x40>
   40b78:	00049694 	.word	0x00049694
   40b7c:	0004969c 	.word	0x0004969c
   40b80:	00049b3e 	.word	0x00049b3e
   40b84:	2001ae90 	.word	0x2001ae90
   40b88:	2001a8d0 	.word	0x2001a8d0
   40b8c:	2001ae2f 	.word	0x2001ae2f
   40b90:	06000609 	.word	0x06000609
   40b94:	00049b5b 	.word	0x00049b5b
   40b98:	00049b7f 	.word	0x00049b7f

00040b9c <perform_ecdsa>:

int perform_ecdsa(void)
{
   40b9c:	b538      	push	{r3, r4, r5, lr}
   40b9e:	4b18      	ldr	r3, [pc, #96]	; (40c00 <perform_ecdsa+0x64>)
   40ba0:	4c18      	ldr	r4, [pc, #96]	; (40c04 <perform_ecdsa+0x68>)
	int status;

	LOG_INF("Starting ECDSA example...");
   40ba2:	4819      	ldr	r0, [pc, #100]	; (40c08 <perform_ecdsa+0x6c>)
   40ba4:	1ae4      	subs	r4, r4, r3
   40ba6:	08e4      	lsrs	r4, r4, #3
   40ba8:	01a4      	lsls	r4, r4, #6
   40baa:	f044 0403 	orr.w	r4, r4, #3
   40bae:	4621      	mov	r1, r4
   40bb0:	f007 fb48 	bl	48244 <log_0>

	status = crypto_init();
   40bb4:	f006 ffb4 	bl	47b20 <crypto_init>
	if (status != APP_SUCCESS) {
   40bb8:	b138      	cbz	r0, 40bca <perform_ecdsa+0x2e>
		return APP_ERROR;
	}

	status = verify_message();
	if (status != APP_SUCCESS) {
		LOG_INF(APP_ERROR_MESSAGE);
   40bba:	4621      	mov	r1, r4
		return APP_ERROR;
	}

	status = crypto_finish();
	if (status != APP_SUCCESS) {
		LOG_INF(APP_ERROR_MESSAGE);
   40bbc:	4813      	ldr	r0, [pc, #76]	; (40c0c <perform_ecdsa+0x70>)
   40bbe:	f007 fb41 	bl	48244 <log_0>
		return APP_ERROR;
   40bc2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	}

	LOG_INF(APP_SUCCESS_MESSAGE);

	return APP_SUCCESS;
}
   40bc6:	4628      	mov	r0, r5
   40bc8:	bd38      	pop	{r3, r4, r5, pc}
	status = generate_ecdsa_keypair();
   40bca:	f7ff fe99 	bl	40900 <generate_ecdsa_keypair>
	if (status != APP_SUCCESS) {
   40bce:	2800      	cmp	r0, #0
   40bd0:	d1f3      	bne.n	40bba <perform_ecdsa+0x1e>
	status = import_ecdsa_pub_key();
   40bd2:	f7ff fedf 	bl	40994 <import_ecdsa_pub_key>
	if (status != APP_SUCCESS) {
   40bd6:	2800      	cmp	r0, #0
   40bd8:	d1ef      	bne.n	40bba <perform_ecdsa+0x1e>
	status = sign_message();
   40bda:	f7ff ff11 	bl	40a00 <sign_message>
	if (status != APP_SUCCESS) {
   40bde:	2800      	cmp	r0, #0
   40be0:	d1eb      	bne.n	40bba <perform_ecdsa+0x1e>
	status = verify_message();
   40be2:	f7ff ffa1 	bl	40b28 <verify_message>
	if (status != APP_SUCCESS) {
   40be6:	2800      	cmp	r0, #0
   40be8:	d1e7      	bne.n	40bba <perform_ecdsa+0x1e>
	status = crypto_finish();
   40bea:	f7ff fe5b 	bl	408a4 <crypto_finish>
		LOG_INF(APP_ERROR_MESSAGE);
   40bee:	4621      	mov	r1, r4
	if (status != APP_SUCCESS) {
   40bf0:	4605      	mov	r5, r0
   40bf2:	2800      	cmp	r0, #0
   40bf4:	d1e2      	bne.n	40bbc <perform_ecdsa+0x20>
	LOG_INF(APP_SUCCESS_MESSAGE);
   40bf6:	4806      	ldr	r0, [pc, #24]	; (40c10 <perform_ecdsa+0x74>)
   40bf8:	f007 fb24 	bl	48244 <log_0>
	return APP_SUCCESS;
   40bfc:	e7e3      	b.n	40bc6 <perform_ecdsa+0x2a>
   40bfe:	bf00      	nop
   40c00:	00049694 	.word	0x00049694
   40c04:	0004969c 	.word	0x0004969c
   40c08:	00049ba6 	.word	0x00049ba6
   40c0c:	00049bc0 	.word	0x00049bc0
   40c10:	00049bdb 	.word	0x00049bdb

00040c14 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   40c14:	680b      	ldr	r3, [r1, #0]
   40c16:	3301      	adds	r3, #1
   40c18:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   40c1a:	4b01      	ldr	r3, [pc, #4]	; (40c20 <char_out+0xc>)
   40c1c:	681b      	ldr	r3, [r3, #0]
   40c1e:	4718      	bx	r3
   40c20:	2001a560 	.word	0x2001a560

00040c24 <__printk_hook_install>:
	_char_out = fn;
   40c24:	4b01      	ldr	r3, [pc, #4]	; (40c2c <__printk_hook_install+0x8>)
   40c26:	6018      	str	r0, [r3, #0]
}
   40c28:	4770      	bx	lr
   40c2a:	bf00      	nop
   40c2c:	2001a560 	.word	0x2001a560

00040c30 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   40c30:	b507      	push	{r0, r1, r2, lr}
   40c32:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   40c34:	2100      	movs	r1, #0
{
   40c36:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   40c38:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   40c3a:	4803      	ldr	r0, [pc, #12]	; (40c48 <vprintk+0x18>)
   40c3c:	a901      	add	r1, sp, #4
   40c3e:	f000 f8ff 	bl	40e40 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   40c42:	b003      	add	sp, #12
   40c44:	f85d fb04 	ldr.w	pc, [sp], #4
   40c48:	00040c15 	.word	0x00040c15

00040c4c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   40c4c:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   40c4e:	2500      	movs	r5, #0
{
   40c50:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   40c52:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   40c56:	4604      	mov	r4, r0

	cbvprintf(str_out, &ctx, fmt, ap);
   40c58:	a901      	add	r1, sp, #4
   40c5a:	4805      	ldr	r0, [pc, #20]	; (40c70 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   40c5c:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
   40c5e:	f000 f8ef 	bl	40e40 <cbvprintf>

	if (ctx.count < ctx.max) {
   40c62:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   40c66:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   40c68:	bfb8      	it	lt
   40c6a:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   40c6c:	b005      	add	sp, #20
   40c6e:	bd30      	pop	{r4, r5, pc}
   40c70:	00047b71 	.word	0x00047b71

00040c74 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   40c74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40c78:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   40c7c:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   40c7e:	f019 0808 	ands.w	r8, r9, #8
{
   40c82:	4693      	mov	fp, r2
	if (processing) {
   40c84:	d00d      	beq.n	40ca2 <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   40c86:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   40c88:	bf0c      	ite	eq
   40c8a:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   40c8e:	f049 0920 	orrne.w	r9, r9, #32
   40c92:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   40c96:	f38b 8811 	msr	BASEPRI, fp
   40c9a:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   40c9e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40ca2:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   40ca6:	2902      	cmp	r1, #2
   40ca8:	d107      	bne.n	40cba <process_event+0x46>
			evt = process_recheck(mgr);
   40caa:	4620      	mov	r0, r4
   40cac:	f006 ff8d 	bl	47bca <process_recheck>
		if (evt == EVT_NOP) {
   40cb0:	2800      	cmp	r0, #0
   40cb2:	d0f0      	beq.n	40c96 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   40cb4:	2801      	cmp	r0, #1
   40cb6:	8b23      	ldrh	r3, [r4, #24]
   40cb8:	d150      	bne.n	40d5c <process_event+0xe8>
			res = mgr->last_res;
   40cba:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40cbc:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   40cbe:	2f00      	cmp	r7, #0
   40cc0:	da15      	bge.n	40cee <process_event+0x7a>
		*clients = mgr->clients;
   40cc2:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40cc4:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   40cc8:	e9c4 8800 	strd	r8, r8, [r4]
   40ccc:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   40cd0:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   40cd2:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   40cd4:	8b21      	ldrh	r1, [r4, #24]
   40cd6:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   40cda:	45ca      	cmp	sl, r9
   40cdc:	d002      	beq.n	40ce4 <process_event+0x70>
		if (do_monitors
   40cde:	68a3      	ldr	r3, [r4, #8]
   40ce0:	2b00      	cmp	r3, #0
   40ce2:	d15c      	bne.n	40d9e <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   40ce4:	b90d      	cbnz	r5, 40cea <process_event+0x76>
		    || (transit != NULL)) {
   40ce6:	2e00      	cmp	r6, #0
   40ce8:	d074      	beq.n	40dd4 <process_event+0x160>
   40cea:	2300      	movs	r3, #0
   40cec:	e058      	b.n	40da0 <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   40cee:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   40cf2:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   40cf4:	2a01      	cmp	r2, #1
   40cf6:	d820      	bhi.n	40d3a <process_event+0xc6>
		*clients = mgr->clients;
   40cf8:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   40cfc:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   40cfe:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   40d00:	b289      	uxth	r1, r1
	list->tail = NULL;
   40d02:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   40d06:	d10c      	bne.n	40d22 <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   40d08:	2d00      	cmp	r5, #0
   40d0a:	462b      	mov	r3, r5
   40d0c:	bf38      	it	cc
   40d0e:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   40d10:	b12b      	cbz	r3, 40d1e <process_event+0xaa>
				mgr->refs += 1U;
   40d12:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   40d14:	681b      	ldr	r3, [r3, #0]
   40d16:	3201      	adds	r2, #1
   40d18:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   40d1a:	2b00      	cmp	r3, #0
   40d1c:	d1f8      	bne.n	40d10 <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d1e:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   40d22:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   40d24:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   40d26:	f006 ff50 	bl	47bca <process_recheck>
   40d2a:	4606      	mov	r6, r0
   40d2c:	2800      	cmp	r0, #0
   40d2e:	d0d1      	beq.n	40cd4 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   40d30:	8b23      	ldrh	r3, [r4, #24]
   40d32:	f043 0320 	orr.w	r3, r3, #32
   40d36:	8323      	strh	r3, [r4, #24]
   40d38:	e7cb      	b.n	40cd2 <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   40d3a:	2b04      	cmp	r3, #4
   40d3c:	d10c      	bne.n	40d58 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d3e:	f021 0107 	bic.w	r1, r1, #7
   40d42:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   40d44:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   40d46:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   40d48:	f006 ff3f 	bl	47bca <process_recheck>
   40d4c:	4605      	mov	r5, r0
   40d4e:	2800      	cmp	r0, #0
   40d50:	d0bf      	beq.n	40cd2 <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   40d52:	f041 0120 	orr.w	r1, r1, #32
   40d56:	8321      	strh	r1, [r4, #24]
   40d58:	2500      	movs	r5, #0
   40d5a:	e7ba      	b.n	40cd2 <process_event+0x5e>
		} else if (evt == EVT_START) {
   40d5c:	2803      	cmp	r0, #3
   40d5e:	d109      	bne.n	40d74 <process_event+0x100>
			transit = mgr->transitions->start;
   40d60:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d62:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   40d66:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d68:	f043 0306 	orr.w	r3, r3, #6
}
   40d6c:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   40d6e:	8323      	strh	r3, [r4, #24]
		res = 0;
   40d70:	462f      	mov	r7, r5
   40d72:	e7af      	b.n	40cd4 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   40d74:	2804      	cmp	r0, #4
   40d76:	d106      	bne.n	40d86 <process_event+0x112>
			transit = mgr->transitions->stop;
   40d78:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d7a:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   40d7e:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d80:	f043 0304 	orr.w	r3, r3, #4
   40d84:	e7f2      	b.n	40d6c <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   40d86:	2805      	cmp	r0, #5
   40d88:	d106      	bne.n	40d98 <process_event+0x124>
			transit = mgr->transitions->reset;
   40d8a:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d8c:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   40d90:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   40d92:	f043 0305 	orr.w	r3, r3, #5
   40d96:	e7e9      	b.n	40d6c <process_event+0xf8>
   40d98:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   40d9a:	462e      	mov	r6, r5
   40d9c:	e7e8      	b.n	40d70 <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   40d9e:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   40da0:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   40da4:	8321      	strh	r1, [r4, #24]
   40da6:	f38b 8811 	msr	BASEPRI, fp
   40daa:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   40dae:	bb03      	cbnz	r3, 40df2 <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   40db0:	2d00      	cmp	r5, #0
   40db2:	d133      	bne.n	40e1c <process_event+0x1a8>
			if (transit != NULL) {
   40db4:	b116      	cbz	r6, 40dbc <process_event+0x148>
				transit(mgr, transition_complete);
   40db6:	4620      	mov	r0, r4
   40db8:	4920      	ldr	r1, [pc, #128]	; (40e3c <process_event+0x1c8>)
   40dba:	47b0      	blx	r6
	__asm__ volatile(
   40dbc:	f04f 0320 	mov.w	r3, #32
   40dc0:	f3ef 8b11 	mrs	fp, BASEPRI
   40dc4:	f383 8812 	msr	BASEPRI_MAX, r3
   40dc8:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   40dcc:	8b23      	ldrh	r3, [r4, #24]
   40dce:	f023 0308 	bic.w	r3, r3, #8
   40dd2:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   40dd4:	8b23      	ldrh	r3, [r4, #24]
   40dd6:	06da      	lsls	r2, r3, #27
   40dd8:	d528      	bpl.n	40e2c <process_event+0x1b8>
			evt = EVT_COMPLETE;
   40dda:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   40ddc:	f023 0310 	bic.w	r3, r3, #16
   40de0:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   40de2:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   40de6:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   40dea:	2900      	cmp	r1, #0
   40dec:	f47f af5b 	bne.w	40ca6 <process_event+0x32>
out:
   40df0:	e751      	b.n	40c96 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   40df2:	68a1      	ldr	r1, [r4, #8]
   40df4:	2900      	cmp	r1, #0
   40df6:	d0db      	beq.n	40db0 <process_event+0x13c>
	return node->next;
   40df8:	680b      	ldr	r3, [r1, #0]
   40dfa:	2b00      	cmp	r3, #0
   40dfc:	bf38      	it	cc
   40dfe:	2300      	movcc	r3, #0
   40e00:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   40e02:	4652      	mov	r2, sl
   40e04:	463b      	mov	r3, r7
   40e06:	4620      	mov	r0, r4
   40e08:	f8d1 b004 	ldr.w	fp, [r1, #4]
   40e0c:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   40e0e:	f1b9 0f00 	cmp.w	r9, #0
   40e12:	d0cd      	beq.n	40db0 <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   40e14:	4649      	mov	r1, r9
   40e16:	f8d9 3000 	ldr.w	r3, [r9]
   40e1a:	e7ee      	b.n	40dfa <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   40e1c:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   40e1e:	463b      	mov	r3, r7
   40e20:	4652      	mov	r2, sl
   40e22:	4620      	mov	r0, r4
   40e24:	682d      	ldr	r5, [r5, #0]
   40e26:	f006 feec 	bl	47c02 <notify_one>
   40e2a:	e7c1      	b.n	40db0 <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   40e2c:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   40e30:	bf1e      	ittt	ne
   40e32:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   40e36:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   40e38:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   40e3a:	e7d2      	b.n	40de2 <process_event+0x16e>
   40e3c:	00047c2f 	.word	0x00047c2f

00040e40 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   40e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   40e44:	468b      	mov	fp, r1
   40e46:	4692      	mov	sl, r2
   40e48:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   40e4a:	2500      	movs	r5, #0
{
   40e4c:	b091      	sub	sp, #68	; 0x44
   40e4e:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   40e50:	f89a 0000 	ldrb.w	r0, [sl]
   40e54:	b908      	cbnz	r0, 40e5a <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   40e56:	4628      	mov	r0, r5
   40e58:	e35e      	b.n	41518 <cbvprintf+0x6d8>
		if (*fp != '%') {
   40e5a:	2825      	cmp	r0, #37	; 0x25
   40e5c:	f10a 0701 	add.w	r7, sl, #1
   40e60:	d007      	beq.n	40e72 <cbvprintf+0x32>
			OUTC('%');
   40e62:	4659      	mov	r1, fp
   40e64:	9b02      	ldr	r3, [sp, #8]
   40e66:	4798      	blx	r3
   40e68:	2800      	cmp	r0, #0
   40e6a:	f2c0 8355 	blt.w	41518 <cbvprintf+0x6d8>
   40e6e:	3501      	adds	r5, #1
			break;
   40e70:	e210      	b.n	41294 <cbvprintf+0x454>
		} state = {
   40e72:	2218      	movs	r2, #24
   40e74:	2100      	movs	r1, #0
   40e76:	a80a      	add	r0, sp, #40	; 0x28
   40e78:	f007 fd60 	bl	4893c <memset>
	if (*sp == '%') {
   40e7c:	f89a 3001 	ldrb.w	r3, [sl, #1]
   40e80:	2b25      	cmp	r3, #37	; 0x25
   40e82:	d078      	beq.n	40f76 <cbvprintf+0x136>
   40e84:	2200      	movs	r2, #0
   40e86:	4694      	mov	ip, r2
   40e88:	4616      	mov	r6, r2
   40e8a:	4696      	mov	lr, r2
   40e8c:	4610      	mov	r0, r2
   40e8e:	4639      	mov	r1, r7
		switch (*sp) {
   40e90:	f817 3b01 	ldrb.w	r3, [r7], #1
   40e94:	2b2b      	cmp	r3, #43	; 0x2b
   40e96:	f000 809d 	beq.w	40fd4 <cbvprintf+0x194>
   40e9a:	f200 8094 	bhi.w	40fc6 <cbvprintf+0x186>
   40e9e:	2b20      	cmp	r3, #32
   40ea0:	f000 809b 	beq.w	40fda <cbvprintf+0x19a>
   40ea4:	2b23      	cmp	r3, #35	; 0x23
   40ea6:	f000 809a 	beq.w	40fde <cbvprintf+0x19e>
   40eaa:	b128      	cbz	r0, 40eb8 <cbvprintf+0x78>
   40eac:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40eb0:	f040 0004 	orr.w	r0, r0, #4
   40eb4:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40eb8:	f1be 0f00 	cmp.w	lr, #0
   40ebc:	d005      	beq.n	40eca <cbvprintf+0x8a>
   40ebe:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40ec2:	f040 0008 	orr.w	r0, r0, #8
   40ec6:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40eca:	b12e      	cbz	r6, 40ed8 <cbvprintf+0x98>
   40ecc:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40ed0:	f040 0010 	orr.w	r0, r0, #16
   40ed4:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40ed8:	f1bc 0f00 	cmp.w	ip, #0
   40edc:	d005      	beq.n	40eea <cbvprintf+0xaa>
   40ede:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   40ee2:	f040 0020 	orr.w	r0, r0, #32
   40ee6:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   40eea:	b12a      	cbz	r2, 40ef8 <cbvprintf+0xb8>
   40eec:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40ef0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   40ef4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   40ef8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   40efc:	f002 0044 	and.w	r0, r2, #68	; 0x44
   40f00:	2844      	cmp	r0, #68	; 0x44
   40f02:	d103      	bne.n	40f0c <cbvprintf+0xcc>
		conv->flag_zero = false;
   40f04:	f36f 1286 	bfc	r2, #6, #1
   40f08:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   40f0c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40f10:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   40f12:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   40f16:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   40f1a:	d17b      	bne.n	41014 <cbvprintf+0x1d4>
		conv->width_star = true;
   40f1c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40f20:	1c4b      	adds	r3, r1, #1
   40f22:	f042 0201 	orr.w	r2, r2, #1
   40f26:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   40f2a:	781a      	ldrb	r2, [r3, #0]
   40f2c:	2a2e      	cmp	r2, #46	; 0x2e
   40f2e:	bf0c      	ite	eq
   40f30:	2101      	moveq	r1, #1
   40f32:	2100      	movne	r1, #0
   40f34:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40f38:	f361 0241 	bfi	r2, r1, #1, #1
   40f3c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   40f40:	d174      	bne.n	4102c <cbvprintf+0x1ec>
	if (*sp == '*') {
   40f42:	785a      	ldrb	r2, [r3, #1]
   40f44:	2a2a      	cmp	r2, #42	; 0x2a
   40f46:	d06a      	beq.n	4101e <cbvprintf+0x1de>
	size_t val = 0;
   40f48:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   40f4a:	260a      	movs	r6, #10
   40f4c:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   40f4e:	4618      	mov	r0, r3
   40f50:	f810 2b01 	ldrb.w	r2, [r0], #1
   40f54:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40f58:	2f09      	cmp	r7, #9
   40f5a:	f240 808e 	bls.w	4107a <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   40f5e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   40f62:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   40f64:	f3c2 0040 	ubfx	r0, r2, #1, #1
   40f68:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   40f6c:	f361 0241 	bfi	r2, r1, #1, #1
   40f70:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   40f74:	e05a      	b.n	4102c <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   40f76:	f10a 0702 	add.w	r7, sl, #2
   40f7a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   40f7e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40f82:	07d9      	lsls	r1, r3, #31
   40f84:	f140 8149 	bpl.w	4121a <cbvprintf+0x3da>
			width = va_arg(ap, int);
   40f88:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   40f8c:	f1b9 0f00 	cmp.w	r9, #0
   40f90:	da07      	bge.n	40fa2 <cbvprintf+0x162>
				conv->flag_dash = true;
   40f92:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   40f96:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   40f9a:	f042 0204 	orr.w	r2, r2, #4
   40f9e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   40fa2:	075a      	lsls	r2, r3, #29
   40fa4:	f140 8142 	bpl.w	4122c <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   40fa8:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   40fac:	f1b8 0f00 	cmp.w	r8, #0
   40fb0:	f280 8141 	bge.w	41236 <cbvprintf+0x3f6>
				conv->prec_present = false;
   40fb4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   40fb8:	f36f 0341 	bfc	r3, #1, #1
   40fbc:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   40fc0:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   40fc4:	e137      	b.n	41236 <cbvprintf+0x3f6>
		switch (*sp) {
   40fc6:	2b2d      	cmp	r3, #45	; 0x2d
   40fc8:	d00c      	beq.n	40fe4 <cbvprintf+0x1a4>
   40fca:	2b30      	cmp	r3, #48	; 0x30
   40fcc:	f47f af6d 	bne.w	40eaa <cbvprintf+0x6a>
			conv->flag_zero = true;
   40fd0:	2201      	movs	r2, #1
	} while (loop);
   40fd2:	e75c      	b.n	40e8e <cbvprintf+0x4e>
			conv->flag_plus = true;
   40fd4:	f04f 0e01 	mov.w	lr, #1
   40fd8:	e759      	b.n	40e8e <cbvprintf+0x4e>
			conv->flag_space = true;
   40fda:	2601      	movs	r6, #1
   40fdc:	e757      	b.n	40e8e <cbvprintf+0x4e>
			conv->flag_hash = true;
   40fde:	f04f 0c01 	mov.w	ip, #1
   40fe2:	e754      	b.n	40e8e <cbvprintf+0x4e>
		switch (*sp) {
   40fe4:	2001      	movs	r0, #1
   40fe6:	e752      	b.n	40e8e <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   40fe8:	4633      	mov	r3, r6
   40fea:	fb0c 0202 	mla	r2, ip, r2, r0
   40fee:	3a30      	subs	r2, #48	; 0x30
   40ff0:	461e      	mov	r6, r3
   40ff2:	f816 0b01 	ldrb.w	r0, [r6], #1
   40ff6:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   40ffa:	2f09      	cmp	r7, #9
   40ffc:	d9f4      	bls.n	40fe8 <cbvprintf+0x1a8>
	if (sp != wp) {
   40ffe:	4299      	cmp	r1, r3
   41000:	d093      	beq.n	40f2a <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   41002:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   41006:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   41008:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   4100a:	f362 0141 	bfi	r1, r2, #1, #1
   4100e:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   41012:	e78a      	b.n	40f2a <cbvprintf+0xea>
   41014:	460b      	mov	r3, r1
	size_t val = 0;
   41016:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   41018:	f04f 0c0a 	mov.w	ip, #10
   4101c:	e7e8      	b.n	40ff0 <cbvprintf+0x1b0>
		conv->prec_star = true;
   4101e:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   41022:	3302      	adds	r3, #2
		conv->prec_star = true;
   41024:	f042 0204 	orr.w	r2, r2, #4
   41028:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   4102c:	461f      	mov	r7, r3
   4102e:	f817 2b01 	ldrb.w	r2, [r7], #1
   41032:	2a6c      	cmp	r2, #108	; 0x6c
   41034:	d041      	beq.n	410ba <cbvprintf+0x27a>
   41036:	d825      	bhi.n	41084 <cbvprintf+0x244>
   41038:	2a68      	cmp	r2, #104	; 0x68
   4103a:	d02b      	beq.n	41094 <cbvprintf+0x254>
   4103c:	2a6a      	cmp	r2, #106	; 0x6a
   4103e:	d046      	beq.n	410ce <cbvprintf+0x28e>
   41040:	2a4c      	cmp	r2, #76	; 0x4c
   41042:	d04c      	beq.n	410de <cbvprintf+0x29e>
   41044:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   41046:	f817 2b01 	ldrb.w	r2, [r7], #1
   4104a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   4104e:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   41050:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   41054:	f200 80d9 	bhi.w	4120a <cbvprintf+0x3ca>
   41058:	2a57      	cmp	r2, #87	; 0x57
   4105a:	d84d      	bhi.n	410f8 <cbvprintf+0x2b8>
   4105c:	2a41      	cmp	r2, #65	; 0x41
   4105e:	d003      	beq.n	41068 <cbvprintf+0x228>
   41060:	3a45      	subs	r2, #69	; 0x45
   41062:	2a02      	cmp	r2, #2
   41064:	f200 80d1 	bhi.w	4120a <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   41068:	2204      	movs	r2, #4
   4106a:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   4106e:	f362 0302 	bfi	r3, r2, #0, #3
   41072:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   41076:	2301      	movs	r3, #1
			break;
   41078:	e09e      	b.n	411b8 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   4107a:	fb06 2101 	mla	r1, r6, r1, r2
   4107e:	4603      	mov	r3, r0
   41080:	3930      	subs	r1, #48	; 0x30
   41082:	e764      	b.n	40f4e <cbvprintf+0x10e>
	switch (*sp) {
   41084:	2a74      	cmp	r2, #116	; 0x74
   41086:	d026      	beq.n	410d6 <cbvprintf+0x296>
   41088:	2a7a      	cmp	r2, #122	; 0x7a
   4108a:	d1db      	bne.n	41044 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   4108c:	2206      	movs	r2, #6
   4108e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   41092:	e00d      	b.n	410b0 <cbvprintf+0x270>
		if (*++sp == 'h') {
   41094:	785a      	ldrb	r2, [r3, #1]
   41096:	2a68      	cmp	r2, #104	; 0x68
   41098:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   4109c:	d106      	bne.n	410ac <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   4109e:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   410a0:	f361 02c6 	bfi	r2, r1, #3, #4
   410a4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   410a8:	1c9f      	adds	r7, r3, #2
   410aa:	e7cc      	b.n	41046 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   410ac:	4613      	mov	r3, r2
   410ae:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   410b0:	f362 03c6 	bfi	r3, r2, #3, #4
   410b4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   410b8:	e7c5      	b.n	41046 <cbvprintf+0x206>
		if (*++sp == 'l') {
   410ba:	785a      	ldrb	r2, [r3, #1]
   410bc:	2a6c      	cmp	r2, #108	; 0x6c
   410be:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   410c2:	d101      	bne.n	410c8 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   410c4:	2104      	movs	r1, #4
   410c6:	e7eb      	b.n	410a0 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   410c8:	4613      	mov	r3, r2
   410ca:	2203      	movs	r2, #3
   410cc:	e7f0      	b.n	410b0 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   410ce:	2205      	movs	r2, #5
   410d0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   410d4:	e7ec      	b.n	410b0 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   410d6:	2207      	movs	r2, #7
   410d8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   410dc:	e7e8      	b.n	410b0 <cbvprintf+0x270>
		conv->unsupported = true;
   410de:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   410e2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   410e6:	f023 0302 	bic.w	r3, r3, #2
   410ea:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   410ee:	f043 0302 	orr.w	r3, r3, #2
   410f2:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   410f6:	e7a6      	b.n	41046 <cbvprintf+0x206>
   410f8:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   410fc:	2920      	cmp	r1, #32
   410fe:	f200 8084 	bhi.w	4120a <cbvprintf+0x3ca>
   41102:	a001      	add	r0, pc, #4	; (adr r0, 41108 <cbvprintf+0x2c8>)
   41104:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   41108:	000411cd 	.word	0x000411cd
   4110c:	0004120b 	.word	0x0004120b
   41110:	0004120b 	.word	0x0004120b
   41114:	0004120b 	.word	0x0004120b
   41118:	0004120b 	.word	0x0004120b
   4111c:	0004120b 	.word	0x0004120b
   41120:	0004120b 	.word	0x0004120b
   41124:	0004120b 	.word	0x0004120b
   41128:	0004120b 	.word	0x0004120b
   4112c:	00041069 	.word	0x00041069
   41130:	0004120b 	.word	0x0004120b
   41134:	000411cd 	.word	0x000411cd
   41138:	0004118d 	.word	0x0004118d
   4113c:	00041069 	.word	0x00041069
   41140:	00041069 	.word	0x00041069
   41144:	00041069 	.word	0x00041069
   41148:	0004120b 	.word	0x0004120b
   4114c:	0004118d 	.word	0x0004118d
   41150:	0004120b 	.word	0x0004120b
   41154:	0004120b 	.word	0x0004120b
   41158:	0004120b 	.word	0x0004120b
   4115c:	0004120b 	.word	0x0004120b
   41160:	000411d5 	.word	0x000411d5
   41164:	000411cd 	.word	0x000411cd
   41168:	000411f1 	.word	0x000411f1
   4116c:	0004120b 	.word	0x0004120b
   41170:	0004120b 	.word	0x0004120b
   41174:	000411f1 	.word	0x000411f1
   41178:	0004120b 	.word	0x0004120b
   4117c:	000411cd 	.word	0x000411cd
   41180:	0004120b 	.word	0x0004120b
   41184:	0004120b 	.word	0x0004120b
   41188:	000411cd 	.word	0x000411cd
		conv->specifier_cat = SPECIFIER_SINT;
   4118c:	2001      	movs	r0, #1
   4118e:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   41192:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   41196:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   4119a:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   4119c:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   411a0:	bf02      	ittt	eq
   411a2:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   411a6:	f041 0101 	orreq.w	r1, r1, #1
   411aa:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   411ae:	2a63      	cmp	r2, #99	; 0x63
   411b0:	d131      	bne.n	41216 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   411b2:	3b00      	subs	r3, #0
   411b4:	bf18      	it	ne
   411b6:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   411b8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   411bc:	f3c2 0140 	ubfx	r1, r2, #1, #1
   411c0:	430b      	orrs	r3, r1
   411c2:	f363 0241 	bfi	r2, r3, #1, #1
   411c6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   411ca:	e6d8      	b.n	40f7e <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   411cc:	2002      	movs	r0, #2
   411ce:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   411d2:	e7de      	b.n	41192 <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   411d4:	2103      	movs	r1, #3
   411d6:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   411da:	f003 0378 	and.w	r3, r3, #120	; 0x78
   411de:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   411e2:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   411e6:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   411e8:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   411ec:	4143      	adcs	r3, r0
   411ee:	e7e3      	b.n	411b8 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   411f0:	2103      	movs	r1, #3
   411f2:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   411f6:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   411fa:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   411fe:	bf14      	ite	ne
   41200:	2301      	movne	r3, #1
   41202:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   41204:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   41208:	e7d6      	b.n	411b8 <cbvprintf+0x378>
		conv->invalid = true;
   4120a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   4120e:	f043 0301 	orr.w	r3, r3, #1
   41212:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   41216:	2300      	movs	r3, #0
   41218:	e7ce      	b.n	411b8 <cbvprintf+0x378>
		} else if (conv->width_present) {
   4121a:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   4121e:	2a00      	cmp	r2, #0
		int width = -1;
   41220:	bfac      	ite	ge
   41222:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
			width = conv->width_value;
   41226:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   4122a:	e6ba      	b.n	40fa2 <cbvprintf+0x162>
		} else if (conv->prec_present) {
   4122c:	079b      	lsls	r3, r3, #30
   4122e:	f57f aec7 	bpl.w	40fc0 <cbvprintf+0x180>
			precision = conv->prec_value;
   41232:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   41236:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   41238:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   4123c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   41240:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   41244:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   41248:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   4124a:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   4124e:	d136      	bne.n	412be <cbvprintf+0x47e>
			switch (length_mod) {
   41250:	1ed3      	subs	r3, r2, #3
   41252:	2b04      	cmp	r3, #4
   41254:	d820      	bhi.n	41298 <cbvprintf+0x458>
   41256:	e8df f003 	tbb	[pc, r3]
   4125a:	0703      	.short	0x0703
   4125c:	1f07      	.short	0x1f07
   4125e:	1f          	.byte	0x1f
   4125f:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   41260:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   41264:	17c1      	asrs	r1, r0, #31
   41266:	e004      	b.n	41272 <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   41268:	3407      	adds	r4, #7
   4126a:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   4126e:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   41272:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   41276:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   4127a:	f013 0603 	ands.w	r6, r3, #3
   4127e:	d054      	beq.n	4132a <cbvprintf+0x4ea>
			OUTS(sp, fp);
   41280:	463b      	mov	r3, r7
   41282:	4652      	mov	r2, sl
   41284:	4659      	mov	r1, fp
   41286:	9802      	ldr	r0, [sp, #8]
   41288:	f006 ff64 	bl	48154 <outs>
   4128c:	2800      	cmp	r0, #0
   4128e:	f2c0 8143 	blt.w	41518 <cbvprintf+0x6d8>
   41292:	4405      	add	r5, r0
			continue;
   41294:	46ba      	mov	sl, r7
   41296:	e5db      	b.n	40e50 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   41298:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   4129c:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   4129e:	ea4f 71e0 	mov.w	r1, r0, asr #31
   412a2:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   412a6:	d105      	bne.n	412b4 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   412a8:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   412ac:	930a      	str	r3, [sp, #40]	; 0x28
   412ae:	2300      	movs	r3, #0
   412b0:	930b      	str	r3, [sp, #44]	; 0x2c
   412b2:	e7e0      	b.n	41276 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   412b4:	2a02      	cmp	r2, #2
   412b6:	d1de      	bne.n	41276 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   412b8:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   412bc:	e7d2      	b.n	41264 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   412be:	2b02      	cmp	r3, #2
   412c0:	d123      	bne.n	4130a <cbvprintf+0x4ca>
			switch (length_mod) {
   412c2:	1ed3      	subs	r3, r2, #3
   412c4:	2b04      	cmp	r3, #4
   412c6:	d813      	bhi.n	412f0 <cbvprintf+0x4b0>
   412c8:	e8df f003 	tbb	[pc, r3]
   412cc:	120a0a03 	.word	0x120a0a03
   412d0:	12          	.byte	0x12
   412d1:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   412d2:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   412d4:	6820      	ldr	r0, [r4, #0]
   412d6:	1d23      	adds	r3, r4, #4
   412d8:	900a      	str	r0, [sp, #40]	; 0x28
   412da:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   412dc:	461c      	mov	r4, r3
   412de:	e7ca      	b.n	41276 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   412e0:	3407      	adds	r4, #7
   412e2:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   412e6:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   412ea:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   412ee:	e7f5      	b.n	412dc <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   412f0:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   412f4:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   412f6:	930a      	str	r3, [sp, #40]	; 0x28
   412f8:	f04f 0300 	mov.w	r3, #0
   412fc:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   412fe:	d0d3      	beq.n	412a8 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   41300:	2a02      	cmp	r2, #2
   41302:	d1b8      	bne.n	41276 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   41304:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   41308:	e7d0      	b.n	412ac <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   4130a:	2b04      	cmp	r3, #4
   4130c:	d107      	bne.n	4131e <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   4130e:	3407      	adds	r4, #7
   41310:	f024 0407 	bic.w	r4, r4, #7
   41314:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   41318:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   4131c:	e7ab      	b.n	41276 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   4131e:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   41320:	bf04      	itt	eq
   41322:	f854 3b04 	ldreq.w	r3, [r4], #4
   41326:	930a      	streq	r3, [sp, #40]	; 0x28
   41328:	e7a5      	b.n	41276 <cbvprintf+0x436>
		switch (conv->specifier) {
   4132a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   4132e:	2878      	cmp	r0, #120	; 0x78
   41330:	d8b0      	bhi.n	41294 <cbvprintf+0x454>
   41332:	2862      	cmp	r0, #98	; 0x62
   41334:	d822      	bhi.n	4137c <cbvprintf+0x53c>
   41336:	2825      	cmp	r0, #37	; 0x25
   41338:	f43f ad93 	beq.w	40e62 <cbvprintf+0x22>
   4133c:	2858      	cmp	r0, #88	; 0x58
   4133e:	d1a9      	bne.n	41294 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   41340:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   41344:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   41348:	9300      	str	r3, [sp, #0]
   4134a:	aa0c      	add	r2, sp, #48	; 0x30
   4134c:	ab04      	add	r3, sp, #16
   4134e:	f006 feb6 	bl	480be <encode_uint>
   41352:	4682      	mov	sl, r0
			if (precision >= 0) {
   41354:	f1b8 0f00 	cmp.w	r8, #0
   41358:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   4135c:	db0c      	blt.n	41378 <cbvprintf+0x538>
				conv->flag_zero = false;
   4135e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   41362:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   41366:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   4136a:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   4136c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   41370:	d902      	bls.n	41378 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   41372:	eba8 0303 	sub.w	r3, r8, r3
   41376:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   41378:	4680      	mov	r8, r0
   4137a:	e03d      	b.n	413f8 <cbvprintf+0x5b8>
   4137c:	3863      	subs	r0, #99	; 0x63
   4137e:	2815      	cmp	r0, #21
   41380:	d888      	bhi.n	41294 <cbvprintf+0x454>
   41382:	a101      	add	r1, pc, #4	; (adr r1, 41388 <cbvprintf+0x548>)
   41384:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   41388:	00041409 	.word	0x00041409
   4138c:	0004146d 	.word	0x0004146d
   41390:	00041295 	.word	0x00041295
   41394:	00041295 	.word	0x00041295
   41398:	00041295 	.word	0x00041295
   4139c:	00041295 	.word	0x00041295
   413a0:	0004146d 	.word	0x0004146d
   413a4:	00041295 	.word	0x00041295
   413a8:	00041295 	.word	0x00041295
   413ac:	00041295 	.word	0x00041295
   413b0:	00041295 	.word	0x00041295
   413b4:	000414cb 	.word	0x000414cb
   413b8:	00041499 	.word	0x00041499
   413bc:	0004149d 	.word	0x0004149d
   413c0:	00041295 	.word	0x00041295
   413c4:	00041295 	.word	0x00041295
   413c8:	000413e1 	.word	0x000413e1
   413cc:	00041295 	.word	0x00041295
   413d0:	00041499 	.word	0x00041499
   413d4:	00041295 	.word	0x00041295
   413d8:	00041295 	.word	0x00041295
   413dc:	00041499 	.word	0x00041499
			if (precision >= 0) {
   413e0:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   413e4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   413e8:	db0a      	blt.n	41400 <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   413ea:	4641      	mov	r1, r8
   413ec:	4650      	mov	r0, sl
   413ee:	f007 fa7d 	bl	488ec <strnlen>
		char sign = 0;
   413f2:	2600      	movs	r6, #0
			bpe = bps + len;
   413f4:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   413f8:	f1ba 0f00 	cmp.w	sl, #0
   413fc:	d10c      	bne.n	41418 <cbvprintf+0x5d8>
   413fe:	e749      	b.n	41294 <cbvprintf+0x454>
				len = strlen(bps);
   41400:	4650      	mov	r0, sl
   41402:	f007 fa6c 	bl	488de <strlen>
   41406:	e7f4      	b.n	413f2 <cbvprintf+0x5b2>
			break;
   41408:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   4140a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   4140c:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   41410:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   41414:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   41418:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   4141c:	b106      	cbz	r6, 41420 <cbvprintf+0x5e0>
			nj_len += 1U;
   4141e:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   41420:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   41424:	06d0      	lsls	r0, r2, #27
   41426:	d56b      	bpl.n	41500 <cbvprintf+0x6c0>
			nj_len += 2U;
   41428:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   4142a:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   4142c:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   4142e:	bf48      	it	mi
   41430:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   41432:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   41434:	bf48      	it	mi
   41436:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   41438:	f1b9 0f00 	cmp.w	r9, #0
   4143c:	dd79      	ble.n	41532 <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   4143e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   41442:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   41446:	f3c2 0380 	ubfx	r3, r2, #2, #1
   4144a:	9303      	str	r3, [sp, #12]
   4144c:	0753      	lsls	r3, r2, #29
   4144e:	d470      	bmi.n	41532 <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   41450:	0650      	lsls	r0, r2, #25
   41452:	d564      	bpl.n	4151e <cbvprintf+0x6de>
					if (sign != 0) {
   41454:	b146      	cbz	r6, 41468 <cbvprintf+0x628>
						OUTC(sign);
   41456:	4659      	mov	r1, fp
   41458:	4630      	mov	r0, r6
   4145a:	9b02      	ldr	r3, [sp, #8]
   4145c:	4798      	blx	r3
   4145e:	2800      	cmp	r0, #0
   41460:	db5a      	blt.n	41518 <cbvprintf+0x6d8>
						sign = 0;
   41462:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   41464:	3501      	adds	r5, #1
						sign = 0;
   41466:	461e      	mov	r6, r3
					pad = '0';
   41468:	2330      	movs	r3, #48	; 0x30
   4146a:	e059      	b.n	41520 <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   4146c:	071e      	lsls	r6, r3, #28
   4146e:	d411      	bmi.n	41494 <cbvprintf+0x654>
				sign = ' ';
   41470:	f013 0610 	ands.w	r6, r3, #16
   41474:	bf18      	it	ne
   41476:	2620      	movne	r6, #32
			sint = value->sint;
   41478:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   4147c:	2a00      	cmp	r2, #0
   4147e:	f173 0100 	sbcs.w	r1, r3, #0
   41482:	f6bf af5d 	bge.w	41340 <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   41486:	4252      	negs	r2, r2
   41488:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   4148c:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   4148e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   41492:	e755      	b.n	41340 <cbvprintf+0x500>
				sign = '+';
   41494:	262b      	movs	r6, #43	; 0x2b
   41496:	e7ef      	b.n	41478 <cbvprintf+0x638>
		switch (conv->specifier) {
   41498:	2600      	movs	r6, #0
   4149a:	e751      	b.n	41340 <cbvprintf+0x500>
			if (value->ptr != NULL) {
   4149c:	980a      	ldr	r0, [sp, #40]	; 0x28
   4149e:	b348      	cbz	r0, 414f4 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   414a0:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   414a4:	9300      	str	r3, [sp, #0]
   414a6:	2100      	movs	r1, #0
   414a8:	ab04      	add	r3, sp, #16
   414aa:	aa0c      	add	r2, sp, #48	; 0x30
   414ac:	f006 fe07 	bl	480be <encode_uint>
				conv->altform_0c = true;
   414b0:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   414b4:	4682      	mov	sl, r0
				conv->altform_0c = true;
   414b6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   414ba:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   414be:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   414c2:	2600      	movs	r6, #0
				conv->altform_0c = true;
   414c4:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   414c8:	e744      	b.n	41354 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   414ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   414cc:	2a07      	cmp	r2, #7
   414ce:	f63f aee1 	bhi.w	41294 <cbvprintf+0x454>
   414d2:	e8df f002 	tbb	[pc, r2]
   414d6:	040d      	.short	0x040d
   414d8:	08080d06 	.word	0x08080d06
   414dc:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   414de:	701d      	strb	r5, [r3, #0]
		break;
   414e0:	e6d8      	b.n	41294 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   414e2:	801d      	strh	r5, [r3, #0]
		break;
   414e4:	e6d6      	b.n	41294 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   414e6:	4628      	mov	r0, r5
   414e8:	17e9      	asrs	r1, r5, #31
   414ea:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   414ee:	e6d1      	b.n	41294 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   414f0:	601d      	str	r5, [r3, #0]
		break;
   414f2:	e6cf      	b.n	41294 <cbvprintf+0x454>
			bpe = bps + 5;
   414f4:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 415bc <cbvprintf+0x77c>
   414f8:	4606      	mov	r6, r0
			bps = "(nil)";
   414fa:	f1a8 0a05 	sub.w	sl, r8, #5
   414fe:	e78b      	b.n	41418 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   41500:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   41502:	bf48      	it	mi
   41504:	3301      	addmi	r3, #1
   41506:	e790      	b.n	4142a <cbvprintf+0x5ea>
					OUTC(pad);
   41508:	4618      	mov	r0, r3
   4150a:	9303      	str	r3, [sp, #12]
   4150c:	4659      	mov	r1, fp
   4150e:	9b02      	ldr	r3, [sp, #8]
   41510:	4798      	blx	r3
   41512:	2800      	cmp	r0, #0
   41514:	9b03      	ldr	r3, [sp, #12]
   41516:	da04      	bge.n	41522 <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   41518:	b011      	add	sp, #68	; 0x44
   4151a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   4151e:	2320      	movs	r3, #32
   41520:	444d      	add	r5, r9
   41522:	464a      	mov	r2, r9
				while (width-- > 0) {
   41524:	2a00      	cmp	r2, #0
   41526:	eba5 0109 	sub.w	r1, r5, r9
   4152a:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   4152e:	dceb      	bgt.n	41508 <cbvprintf+0x6c8>
   41530:	460d      	mov	r5, r1
		if (sign != 0) {
   41532:	b136      	cbz	r6, 41542 <cbvprintf+0x702>
			OUTC(sign);
   41534:	4659      	mov	r1, fp
   41536:	4630      	mov	r0, r6
   41538:	9b02      	ldr	r3, [sp, #8]
   4153a:	4798      	blx	r3
   4153c:	2800      	cmp	r0, #0
   4153e:	dbeb      	blt.n	41518 <cbvprintf+0x6d8>
   41540:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   41542:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   41546:	06d9      	lsls	r1, r3, #27
   41548:	d401      	bmi.n	4154e <cbvprintf+0x70e>
   4154a:	071a      	lsls	r2, r3, #28
   4154c:	d506      	bpl.n	4155c <cbvprintf+0x71c>
				OUTC('0');
   4154e:	4659      	mov	r1, fp
   41550:	2030      	movs	r0, #48	; 0x30
   41552:	9b02      	ldr	r3, [sp, #8]
   41554:	4798      	blx	r3
   41556:	2800      	cmp	r0, #0
   41558:	dbde      	blt.n	41518 <cbvprintf+0x6d8>
   4155a:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   4155c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   41560:	06db      	lsls	r3, r3, #27
   41562:	d507      	bpl.n	41574 <cbvprintf+0x734>
				OUTC(conv->specifier);
   41564:	4659      	mov	r1, fp
   41566:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   4156a:	9b02      	ldr	r3, [sp, #8]
   4156c:	4798      	blx	r3
   4156e:	2800      	cmp	r0, #0
   41570:	dbd2      	blt.n	41518 <cbvprintf+0x6d8>
   41572:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   41574:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   41576:	442e      	add	r6, r5
   41578:	1b73      	subs	r3, r6, r5
   4157a:	2b00      	cmp	r3, #0
   4157c:	dc16      	bgt.n	415ac <cbvprintf+0x76c>
			OUTS(bps, bpe);
   4157e:	4643      	mov	r3, r8
   41580:	4652      	mov	r2, sl
   41582:	4659      	mov	r1, fp
   41584:	9802      	ldr	r0, [sp, #8]
   41586:	f006 fde5 	bl	48154 <outs>
   4158a:	2800      	cmp	r0, #0
   4158c:	dbc4      	blt.n	41518 <cbvprintf+0x6d8>
   4158e:	4405      	add	r5, r0
		while (width > 0) {
   41590:	44a9      	add	r9, r5
   41592:	eba9 0305 	sub.w	r3, r9, r5
   41596:	2b00      	cmp	r3, #0
   41598:	f77f ae7c 	ble.w	41294 <cbvprintf+0x454>
			OUTC(' ');
   4159c:	4659      	mov	r1, fp
   4159e:	2020      	movs	r0, #32
   415a0:	9b02      	ldr	r3, [sp, #8]
   415a2:	4798      	blx	r3
   415a4:	2800      	cmp	r0, #0
   415a6:	dbb7      	blt.n	41518 <cbvprintf+0x6d8>
   415a8:	3501      	adds	r5, #1
			--width;
   415aa:	e7f2      	b.n	41592 <cbvprintf+0x752>
				OUTC('0');
   415ac:	4659      	mov	r1, fp
   415ae:	2030      	movs	r0, #48	; 0x30
   415b0:	9b02      	ldr	r3, [sp, #8]
   415b2:	4798      	blx	r3
   415b4:	2800      	cmp	r0, #0
   415b6:	dbaf      	blt.n	41518 <cbvprintf+0x6d8>
   415b8:	3501      	adds	r5, #1
   415ba:	e7dd      	b.n	41578 <cbvprintf+0x738>
   415bc:	00049c05 	.word	0x00049c05

000415c0 <nordicsemi_nrf91_init>:
   415c0:	f04f 0220 	mov.w	r2, #32
   415c4:	f3ef 8311 	mrs	r3, BASEPRI
   415c8:	f382 8812 	msr	BASEPRI_MAX, r2
   415cc:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   415d0:	2101      	movs	r1, #1
   415d2:	4a04      	ldr	r2, [pc, #16]	; (415e4 <nordicsemi_nrf91_init+0x24>)
   415d4:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   415d8:	f383 8811 	msr	BASEPRI, r3
   415dc:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   415e0:	2000      	movs	r0, #0
   415e2:	4770      	bx	lr
   415e4:	40039000 	.word	0x40039000

000415e8 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   415e8:	b120      	cbz	r0, 415f4 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   415ea:	4b03      	ldr	r3, [pc, #12]	; (415f8 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   415ec:	0180      	lsls	r0, r0, #6
   415ee:	f043 0301 	orr.w	r3, r3, #1
   415f2:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   415f4:	4770      	bx	lr
   415f6:	bf00      	nop
   415f8:	00049730 	.word	0x00049730

000415fc <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
   415fc:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   415fe:	2200      	movs	r2, #0
{
   41600:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
   41602:	490f      	ldr	r1, [pc, #60]	; (41640 <enable_logger+0x44>)
   41604:	480f      	ldr	r0, [pc, #60]	; (41644 <enable_logger+0x48>)
   41606:	f007 fe91 	bl	4932c <k_timer_init>
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke6(*(uintptr_t *)&new_thread, *(uintptr_t *)&stack, *(uintptr_t *)&stack_size, *(uintptr_t *)&entry, *(uintptr_t *)&p1, (uintptr_t) &more, K_SYSCALL_K_THREAD_CREATE);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   4160a:	2200      	movs	r2, #0
   4160c:	2300      	movs	r3, #0
   4160e:	2400      	movs	r4, #0
   41610:	e9cd 2306 	strd	r2, r3, [sp, #24]
   41614:	230e      	movs	r3, #14
   41616:	4d0c      	ldr	r5, [pc, #48]	; (41648 <enable_logger+0x4c>)
   41618:	e9cd 3403 	strd	r3, r4, [sp, #12]
   4161c:	f44f 7240 	mov.w	r2, #768	; 0x300
   41620:	4628      	mov	r0, r5
   41622:	e9cd 4401 	strd	r4, r4, [sp, #4]
   41626:	4b09      	ldr	r3, [pc, #36]	; (4164c <enable_logger+0x50>)
   41628:	4909      	ldr	r1, [pc, #36]	; (41650 <enable_logger+0x54>)
   4162a:	9400      	str	r4, [sp, #0]
   4162c:	f005 f930 	bl	46890 <z_impl_k_thread_create>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread, *(uintptr_t *)&str, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread, str);
   41630:	4908      	ldr	r1, [pc, #32]	; (41654 <enable_logger+0x58>)
   41632:	4628      	mov	r0, r5
   41634:	f007 fcf6 	bl	49024 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   41638:	4620      	mov	r0, r4
   4163a:	b009      	add	sp, #36	; 0x24
   4163c:	bd30      	pop	{r4, r5, pc}
   4163e:	bf00      	nop
   41640:	00041659 	.word	0x00041659
   41644:	2001a6d0 	.word	0x2001a6d0
   41648:	2001a708 	.word	0x2001a708
   4164c:	00041a39 	.word	0x00041a39
   41650:	20020c30 	.word	0x20020c30
   41654:	00049c0a 	.word	0x00049c0a

00041658 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   41658:	4801      	ldr	r0, [pc, #4]	; (41660 <log_process_thread_timer_expiry_fn+0x8>)
   4165a:	f005 ba67 	b.w	46b2c <z_impl_k_sem_give>
   4165e:	bf00      	nop
   41660:	2001a6c0 	.word	0x2001a6c0

00041664 <log_core_init>:
	panic_mode = false;
   41664:	2300      	movs	r3, #0
   41666:	4a0c      	ldr	r2, [pc, #48]	; (41698 <log_core_init+0x34>)
{
   41668:	b510      	push	{r4, lr}
	panic_mode = false;
   4166a:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
   4166c:	4a0b      	ldr	r2, [pc, #44]	; (4169c <log_core_init+0x38>)
	log_output_timestamp_freq_set(freq);
   4166e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	dropped_cnt = 0;
   41672:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
   41674:	4b0a      	ldr	r3, [pc, #40]	; (416a0 <log_core_init+0x3c>)
   41676:	4a0b      	ldr	r2, [pc, #44]	; (416a4 <log_core_init+0x40>)
   41678:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   4167a:	f000 fcb5 	bl	41fe8 <log_output_timestamp_freq_set>
		log_msg_pool_init();
   4167e:	f000 fa55 	bl	41b2c <log_msg_pool_init>
		log_list_init(&list);
   41682:	4809      	ldr	r0, [pc, #36]	; (416a8 <log_core_init+0x44>)
   41684:	f006 fd9b 	bl	481be <log_list_init>
}
   41688:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   4168c:	2304      	movs	r3, #4
   4168e:	2228      	movs	r2, #40	; 0x28
   41690:	4906      	ldr	r1, [pc, #24]	; (416ac <log_core_init+0x48>)
   41692:	4807      	ldr	r0, [pc, #28]	; (416b0 <log_core_init+0x4c>)
   41694:	f007 bc7c 	b.w	48f90 <k_mem_slab_init>
   41698:	2001aed1 	.word	0x2001aed1
   4169c:	2001a8d8 	.word	0x2001a8d8
   416a0:	2001a564 	.word	0x2001a564
   416a4:	000481fd 	.word	0x000481fd
   416a8:	2001a8e0 	.word	0x2001a8e0
   416ac:	20025c70 	.word	0x20025c70
   416b0:	2001a8e8 	.word	0x2001a8e8

000416b4 <log_init>:
{
   416b4:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   416b6:	4b10      	ldr	r3, [pc, #64]	; (416f8 <log_init+0x44>)
   416b8:	e8d3 5fef 	ldaex	r5, [r3]
   416bc:	1c6a      	adds	r2, r5, #1
   416be:	e8c3 2fe1 	stlex	r1, r2, [r3]
   416c2:	2900      	cmp	r1, #0
   416c4:	d1f8      	bne.n	416b8 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
   416c6:	b92d      	cbnz	r5, 416d4 <log_init+0x20>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   416c8:	4c0c      	ldr	r4, [pc, #48]	; (416fc <log_init+0x48>)
   416ca:	4e0d      	ldr	r6, [pc, #52]	; (41700 <log_init+0x4c>)
   416cc:	1b36      	subs	r6, r6, r4
   416ce:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   416d0:	42b5      	cmp	r5, r6
   416d2:	db00      	blt.n	416d6 <log_init+0x22>
}
   416d4:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   416d6:	7b23      	ldrb	r3, [r4, #12]
   416d8:	b153      	cbz	r3, 416f0 <log_init+0x3c>
			if (backend->api->init != NULL) {
   416da:	6823      	ldr	r3, [r4, #0]
   416dc:	699b      	ldr	r3, [r3, #24]
   416de:	b10b      	cbz	r3, 416e4 <log_init+0x30>
				backend->api->init(backend);
   416e0:	4620      	mov	r0, r4
   416e2:	4798      	blx	r3
			log_backend_enable(backend,
   416e4:	6863      	ldr	r3, [r4, #4]
   416e6:	2204      	movs	r2, #4
   416e8:	4620      	mov	r0, r4
   416ea:	6819      	ldr	r1, [r3, #0]
   416ec:	f000 fa10 	bl	41b10 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   416f0:	3501      	adds	r5, #1
   416f2:	3410      	adds	r4, #16
   416f4:	e7ec      	b.n	416d0 <log_init+0x1c>
   416f6:	bf00      	nop
   416f8:	2001a8dc 	.word	0x2001a8dc
   416fc:	000496ec 	.word	0x000496ec
   41700:	0004970c 	.word	0x0004970c

00041704 <get_msg>:
{
   41704:	b510      	push	{r4, lr}
	__asm__ volatile(
   41706:	f04f 0320 	mov.w	r3, #32
   4170a:	f3ef 8411 	mrs	r4, BASEPRI
   4170e:	f383 8812 	msr	BASEPRI_MAX, r3
   41712:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
   41716:	4804      	ldr	r0, [pc, #16]	; (41728 <get_msg+0x24>)
   41718:	f006 fd61 	bl	481de <log_list_head_get>
	__asm__ volatile(
   4171c:	f384 8811 	msr	BASEPRI, r4
   41720:	f3bf 8f6f 	isb	sy
}
   41724:	bd10      	pop	{r4, pc}
   41726:	bf00      	nop
   41728:	2001a8e0 	.word	0x2001a8e0

0004172c <z_log_notify_backend_enabled>:
{
   4172c:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
   4172e:	4c04      	ldr	r4, [pc, #16]	; (41740 <z_log_notify_backend_enabled+0x14>)
   41730:	7822      	ldrb	r2, [r4, #0]
   41732:	b912      	cbnz	r2, 4173a <z_log_notify_backend_enabled+0xe>
   41734:	4803      	ldr	r0, [pc, #12]	; (41744 <z_log_notify_backend_enabled+0x18>)
   41736:	f005 f9f9 	bl	46b2c <z_impl_k_sem_give>
	backend_attached = true;
   4173a:	2301      	movs	r3, #1
   4173c:	7023      	strb	r3, [r4, #0]
}
   4173e:	bd10      	pop	{r4, pc}
   41740:	2001aed0 	.word	0x2001aed0
   41744:	2001a6c0 	.word	0x2001a6c0

00041748 <z_log_dropped>:
   41748:	4b08      	ldr	r3, [pc, #32]	; (4176c <z_log_dropped+0x24>)
   4174a:	e8d3 2fef 	ldaex	r2, [r3]
   4174e:	3201      	adds	r2, #1
   41750:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41754:	2900      	cmp	r1, #0
   41756:	d1f8      	bne.n	4174a <z_log_dropped+0x2>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41758:	4b05      	ldr	r3, [pc, #20]	; (41770 <z_log_dropped+0x28>)
   4175a:	e8d3 2fef 	ldaex	r2, [r3]
   4175e:	3a01      	subs	r2, #1
   41760:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41764:	2900      	cmp	r1, #0
   41766:	d1f8      	bne.n	4175a <z_log_dropped+0x12>
}
   41768:	4770      	bx	lr
   4176a:	bf00      	nop
   4176c:	2001a8d8 	.word	0x2001a8d8
   41770:	2001a8d4 	.word	0x2001a8d4

00041774 <z_log_dropped_read_and_clear>:
}
   41774:	2000      	movs	r0, #0
   41776:	4602      	mov	r2, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   41778:	4b03      	ldr	r3, [pc, #12]	; (41788 <z_log_dropped_read_and_clear+0x14>)
   4177a:	e8d3 0fef 	ldaex	r0, [r3]
   4177e:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41782:	2900      	cmp	r1, #0
   41784:	d1f9      	bne.n	4177a <z_log_dropped_read_and_clear+0x6>
   41786:	4770      	bx	lr
   41788:	2001a8d8 	.word	0x2001a8d8

0004178c <dropped_notify>:
{
   4178c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
   4178e:	f7ff fff1 	bl	41774 <z_log_dropped_read_and_clear>
	for (int i = 0; i < log_backend_count_get(); i++) {
   41792:	2600      	movs	r6, #0
	uint32_t dropped = z_log_dropped_read_and_clear();
   41794:	4607      	mov	r7, r0
   41796:	4c09      	ldr	r4, [pc, #36]	; (417bc <dropped_notify+0x30>)
   41798:	4d09      	ldr	r5, [pc, #36]	; (417c0 <dropped_notify+0x34>)
   4179a:	1b2d      	subs	r5, r5, r4
   4179c:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   4179e:	42ae      	cmp	r6, r5
   417a0:	db00      	blt.n	417a4 <dropped_notify+0x18>
}
   417a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   417a4:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   417a6:	795b      	ldrb	r3, [r3, #5]
   417a8:	b12b      	cbz	r3, 417b6 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
   417aa:	6823      	ldr	r3, [r4, #0]
   417ac:	691b      	ldr	r3, [r3, #16]
   417ae:	b113      	cbz	r3, 417b6 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
   417b0:	4639      	mov	r1, r7
   417b2:	4620      	mov	r0, r4
   417b4:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   417b6:	3601      	adds	r6, #1
   417b8:	3410      	adds	r4, #16
   417ba:	e7f0      	b.n	4179e <dropped_notify+0x12>
   417bc:	000496ec 	.word	0x000496ec
   417c0:	0004970c 	.word	0x0004970c

000417c4 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   417c4:	4b14      	ldr	r3, [pc, #80]	; (41818 <z_log_strdup+0x54>)
{
   417c6:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
   417c8:	4298      	cmp	r0, r3
{
   417ca:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   417cc:	d302      	bcc.n	417d4 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   417ce:	4b13      	ldr	r3, [pc, #76]	; (4181c <z_log_strdup+0x58>)
   417d0:	4298      	cmp	r0, r3
   417d2:	d31c      	bcc.n	4180e <z_log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   417d4:	2200      	movs	r2, #0
   417d6:	2300      	movs	r3, #0
   417d8:	4811      	ldr	r0, [pc, #68]	; (41820 <z_log_strdup+0x5c>)
   417da:	a901      	add	r1, sp, #4
   417dc:	f004 fff8 	bl	467d0 <k_mem_slab_alloc>
	if (err != 0) {
   417e0:	4605      	mov	r5, r0
   417e2:	b9b8      	cbnz	r0, 41814 <z_log_strdup+0x50>
   417e4:	2201      	movs	r2, #1
   417e6:	9b01      	ldr	r3, [sp, #4]
   417e8:	e8d3 1fef 	ldaex	r1, [r3]
   417ec:	e8c3 2fe0 	stlex	r0, r2, [r3]
   417f0:	2800      	cmp	r0, #0
   417f2:	d1f9      	bne.n	417e8 <z_log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   417f4:	9801      	ldr	r0, [sp, #4]
   417f6:	4621      	mov	r1, r4
   417f8:	221f      	movs	r2, #31
   417fa:	3004      	adds	r0, #4
   417fc:	f007 f85c 	bl	488b8 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   41800:	237e      	movs	r3, #126	; 0x7e
   41802:	9c01      	ldr	r4, [sp, #4]
   41804:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   41808:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   4180c:	3404      	adds	r4, #4
}
   4180e:	4620      	mov	r0, r4
   41810:	b003      	add	sp, #12
   41812:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   41814:	4c03      	ldr	r4, [pc, #12]	; (41824 <z_log_strdup+0x60>)
   41816:	e7fa      	b.n	4180e <z_log_strdup+0x4a>
   41818:	000493bc 	.word	0x000493bc
   4181c:	0004a3fc 	.word	0x0004a3fc
   41820:	2001a8e8 	.word	0x2001a8e8
   41824:	00049c12 	.word	0x00049c12

00041828 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
   41828:	b148      	cbz	r0, 4183e <log_is_strdup+0x16>
   4182a:	4b05      	ldr	r3, [pc, #20]	; (41840 <log_is_strdup+0x18>)
   4182c:	4298      	cmp	r0, r3
   4182e:	d305      	bcc.n	4183c <log_is_strdup+0x14>
   41830:	33a0      	adds	r3, #160	; 0xa0
   41832:	4298      	cmp	r0, r3
   41834:	bf2c      	ite	cs
   41836:	2000      	movcs	r0, #0
   41838:	2001      	movcc	r0, #1
   4183a:	4770      	bx	lr
   4183c:	2000      	movs	r0, #0
}
   4183e:	4770      	bx	lr
   41840:	20025c70 	.word	0x20025c70

00041844 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
   41844:	4b41      	ldr	r3, [pc, #260]	; (4194c <z_impl_log_process+0x108>)
{
   41846:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   4184a:	781b      	ldrb	r3, [r3, #0]
{
   4184c:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   4184e:	b903      	cbnz	r3, 41852 <z_impl_log_process+0xe>
   41850:	b1a0      	cbz	r0, 4187c <z_impl_log_process+0x38>
	msg = get_msg();
   41852:	f7ff ff57 	bl	41704 <get_msg>
	if (msg.msg) {
   41856:	4605      	mov	r5, r0
   41858:	b118      	cbz	r0, 41862 <z_impl_log_process+0x1e>
		if (!bypass) {
   4185a:	b19c      	cbz	r4, 41884 <z_impl_log_process+0x40>
			log_msg_put(msg.msg);
   4185c:	4628      	mov	r0, r5
   4185e:	f006 fdd5 	bl	4840c <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
   41862:	b92c      	cbnz	r4, 41870 <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
   41864:	4b3a      	ldr	r3, [pc, #232]	; (41950 <z_impl_log_process+0x10c>)
	if (!bypass && z_log_dropped_pending()) {
   41866:	681b      	ldr	r3, [r3, #0]
   41868:	2b00      	cmp	r3, #0
   4186a:	dd01      	ble.n	41870 <z_impl_log_process+0x2c>
		dropped_notify();
   4186c:	f7ff ff8e 	bl	4178c <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   41870:	4838      	ldr	r0, [pc, #224]	; (41954 <z_impl_log_process+0x110>)
   41872:	f006 fcb2 	bl	481da <log_list_head_peek>
   41876:	1e04      	subs	r4, r0, #0
   41878:	bf18      	it	ne
   4187a:	2401      	movne	r4, #1
}
   4187c:	4620      	mov	r0, r4
   4187e:	b003      	add	sp, #12
   41880:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41884:	4b34      	ldr	r3, [pc, #208]	; (41958 <z_impl_log_process+0x114>)
   41886:	e8d3 2fef 	ldaex	r2, [r3]
   4188a:	3a01      	subs	r2, #1
   4188c:	e8c3 2fe1 	stlex	r1, r2, [r3]
   41890:	2900      	cmp	r1, #0
   41892:	d1f8      	bne.n	41886 <z_impl_log_process+0x42>
		    !panic_mode) {
   41894:	4b31      	ldr	r3, [pc, #196]	; (4195c <z_impl_log_process+0x118>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
   41896:	781b      	ldrb	r3, [r3, #0]
   41898:	b9bb      	cbnz	r3, 418ca <z_impl_log_process+0x86>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   4189a:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   4189c:	07db      	lsls	r3, r3, #31
   4189e:	d414      	bmi.n	418ca <z_impl_log_process+0x86>
	msg_str = log_msg_str_get(msg);
   418a0:	f006 fdc3 	bl	4842a <log_msg_str_get>
   418a4:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
   418a6:	4628      	mov	r0, r5
   418a8:	f006 fd8e 	bl	483c8 <log_msg_nargs_get>
   418ac:	4601      	mov	r1, r0
   418ae:	4640      	mov	r0, r8
   418b0:	f006 fca8 	bl	48204 <z_log_get_s_mask>
   418b4:	4606      	mov	r6, r0
   418b6:	4b2a      	ldr	r3, [pc, #168]	; (41960 <z_impl_log_process+0x11c>)
   418b8:	4a2a      	ldr	r2, [pc, #168]	; (41964 <z_impl_log_process+0x120>)
		if (!is_rodata(str) && !log_is_strdup(str) &&
   418ba:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 41978 <z_impl_log_process+0x134>
   418be:	1a9b      	subs	r3, r3, r2
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   418c0:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 4197c <z_impl_log_process+0x138>
   418c4:	ea4f 09d3 	mov.w	r9, r3, lsr #3
	while (mask) {
   418c8:	b936      	cbnz	r6, 418d8 <z_impl_log_process+0x94>
	return __log_backends_end - __log_backends_start;
   418ca:	4e27      	ldr	r6, [pc, #156]	; (41968 <z_impl_log_process+0x124>)
   418cc:	4f27      	ldr	r7, [pc, #156]	; (4196c <z_impl_log_process+0x128>)
   418ce:	f04f 0800 	mov.w	r8, #0
   418d2:	1bbf      	subs	r7, r7, r6
   418d4:	113f      	asrs	r7, r7, #4
   418d6:	e036      	b.n	41946 <z_impl_log_process+0x102>
		idx = 31 - __builtin_clz(mask);
   418d8:	fab6 f786 	clz	r7, r6
   418dc:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   418e0:	4639      	mov	r1, r7
   418e2:	4628      	mov	r0, r5
   418e4:	f006 fd73 	bl	483ce <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   418e8:	4b21      	ldr	r3, [pc, #132]	; (41970 <z_impl_log_process+0x12c>)
		str = (const char *)log_msg_arg_get(msg, idx);
   418ea:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   418ec:	4298      	cmp	r0, r3
   418ee:	d302      	bcc.n	418f6 <z_impl_log_process+0xb2>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   418f0:	4b20      	ldr	r3, [pc, #128]	; (41974 <z_impl_log_process+0x130>)
   418f2:	4298      	cmp	r0, r3
   418f4:	d316      	bcc.n	41924 <z_impl_log_process+0xe0>
   418f6:	4610      	mov	r0, r2
   418f8:	f7ff ff96 	bl	41828 <log_is_strdup>
   418fc:	b990      	cbnz	r0, 41924 <z_impl_log_process+0xe0>
   418fe:	4552      	cmp	r2, sl
   41900:	d010      	beq.n	41924 <z_impl_log_process+0xe0>
	return msg->hdr.ids.source_id;
   41902:	8969      	ldrh	r1, [r5, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   41904:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41908:	f000 f8f4 	bl	41af4 <log_source_name_get>
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   4190c:	ea4f 1389 	mov.w	r3, r9, lsl #6
   41910:	f043 0301 	orr.w	r3, r3, #1
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
   41914:	4602      	mov	r2, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
   41916:	f8ad 3000 	strh.w	r3, [sp]
   4191a:	4639      	mov	r1, r7
   4191c:	4643      	mov	r3, r8
   4191e:	4658      	mov	r0, fp
   41920:	f006 fcca 	bl	482b8 <log_3>
		mask &= ~BIT(idx);
   41924:	2301      	movs	r3, #1
   41926:	fa03 f707 	lsl.w	r7, r3, r7
   4192a:	ea26 0607 	bic.w	r6, r6, r7
   4192e:	e7cb      	b.n	418c8 <z_impl_log_process+0x84>
	return backend->cb->active;
   41930:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
   41932:	795b      	ldrb	r3, [r3, #5]
   41934:	b123      	cbz	r3, 41940 <z_impl_log_process+0xfc>
	backend->api->put(backend, msg);
   41936:	6833      	ldr	r3, [r6, #0]
   41938:	4629      	mov	r1, r5
   4193a:	4630      	mov	r0, r6
   4193c:	685b      	ldr	r3, [r3, #4]
   4193e:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   41940:	f108 0801 	add.w	r8, r8, #1
   41944:	3610      	adds	r6, #16
   41946:	45b8      	cmp	r8, r7
   41948:	dbf2      	blt.n	41930 <z_impl_log_process+0xec>
   4194a:	e787      	b.n	4185c <z_impl_log_process+0x18>
   4194c:	2001aed0 	.word	0x2001aed0
   41950:	2001a8d8 	.word	0x2001a8d8
   41954:	2001a8e0 	.word	0x2001a8e0
   41958:	2001a8d4 	.word	0x2001a8d4
   4195c:	2001aed1 	.word	0x2001aed1
   41960:	000496ac 	.word	0x000496ac
   41964:	00049694 	.word	0x00049694
   41968:	000496ec 	.word	0x000496ec
   4196c:	0004970c 	.word	0x0004970c
   41970:	000493bc 	.word	0x000493bc
   41974:	0004a3fc 	.word	0x0004a3fc
   41978:	00049c12 	.word	0x00049c12
   4197c:	00049c2c 	.word	0x00049c2c

00041980 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   41980:	4b26      	ldr	r3, [pc, #152]	; (41a1c <msg_finalize+0x9c>)
{
   41982:	b537      	push	{r0, r1, r2, r4, r5, lr}
	msg->hdr.timestamp = timestamp_func();
   41984:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   41986:	8141      	strh	r1, [r0, #10]
{
   41988:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
   4198a:	4798      	blx	r3
   4198c:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   4198e:	f04f 0320 	mov.w	r3, #32
   41992:	f3ef 8511 	mrs	r5, BASEPRI
   41996:	f383 8812 	msr	BASEPRI_MAX, r3
   4199a:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   4199e:	4820      	ldr	r0, [pc, #128]	; (41a20 <msg_finalize+0xa0>)
   419a0:	4621      	mov	r1, r4
   419a2:	f006 fc10 	bl	481c6 <log_list_add_tail>
	__asm__ volatile(
   419a6:	f385 8811 	msr	BASEPRI, r5
   419aa:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   419ae:	4b1d      	ldr	r3, [pc, #116]	; (41a24 <msg_finalize+0xa4>)
   419b0:	e8d3 2fef 	ldaex	r2, [r3]
   419b4:	1c51      	adds	r1, r2, #1
   419b6:	e8c3 1fe0 	stlex	r0, r1, [r3]
   419ba:	2800      	cmp	r0, #0
   419bc:	d1f8      	bne.n	419b0 <msg_finalize+0x30>
	if (panic_mode) {
   419be:	4b1a      	ldr	r3, [pc, #104]	; (41a28 <msg_finalize+0xa8>)
   419c0:	781b      	ldrb	r3, [r3, #0]
   419c2:	b183      	cbz	r3, 419e6 <msg_finalize+0x66>
	__asm__ volatile(
   419c4:	f04f 0320 	mov.w	r3, #32
   419c8:	f3ef 8411 	mrs	r4, BASEPRI
   419cc:	f383 8812 	msr	BASEPRI_MAX, r3
   419d0:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
   419d4:	2000      	movs	r0, #0
   419d6:	f7ff ff35 	bl	41844 <z_impl_log_process>
	__asm__ volatile(
   419da:	f384 8811 	msr	BASEPRI, r4
   419de:	f3bf 8f6f 	isb	sy
}
   419e2:	b003      	add	sp, #12
   419e4:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && cnt == 0) {
   419e6:	4b11      	ldr	r3, [pc, #68]	; (41a2c <msg_finalize+0xac>)
   419e8:	681b      	ldr	r3, [r3, #0]
   419ea:	2b00      	cmp	r3, #0
   419ec:	d0f9      	beq.n	419e2 <msg_finalize+0x62>
   419ee:	b952      	cbnz	r2, 41a06 <msg_finalize+0x86>
	z_impl_k_timer_start(timer, duration, period);
   419f0:	2200      	movs	r2, #0
   419f2:	2300      	movs	r3, #0
   419f4:	480e      	ldr	r0, [pc, #56]	; (41a30 <msg_finalize+0xb0>)
   419f6:	e9cd 2300 	strd	r2, r3, [sp]
   419fa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   419fe:	2300      	movs	r3, #0
   41a00:	f005 fde0 	bl	475c4 <z_impl_k_timer_start>
   41a04:	e7ed      	b.n	419e2 <msg_finalize+0x62>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   41a06:	2a0a      	cmp	r2, #10
   41a08:	d1eb      	bne.n	419e2 <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
   41a0a:	4809      	ldr	r0, [pc, #36]	; (41a30 <msg_finalize+0xb0>)
   41a0c:	f007 fc9a 	bl	49344 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   41a10:	4808      	ldr	r0, [pc, #32]	; (41a34 <msg_finalize+0xb4>)
}
   41a12:	b003      	add	sp, #12
   41a14:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   41a18:	f005 b888 	b.w	46b2c <z_impl_k_sem_give>
   41a1c:	2001a564 	.word	0x2001a564
   41a20:	2001a8e0 	.word	0x2001a8e0
   41a24:	2001a8d4 	.word	0x2001a8d4
   41a28:	2001aed1 	.word	0x2001aed1
   41a2c:	2001a904 	.word	0x2001a904
   41a30:	2001a6d0 	.word	0x2001a6d0
   41a34:	2001a6c0 	.word	0x2001a6c0

00041a38 <log_process_thread_func>:
{
   41a38:	b510      	push	{r4, lr}
	log_init();
   41a3a:	f7ff fe3b 	bl	416b4 <log_init>
	return z_impl_z_current_get();
   41a3e:	f005 fbaf 	bl	471a0 <z_impl_z_current_get>
	proc_tid = process_tid;
   41a42:	4b0c      	ldr	r3, [pc, #48]	; (41a74 <log_process_thread_func+0x3c>)
   41a44:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   41a46:	b130      	cbz	r0, 41a56 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   41a48:	4b0b      	ldr	r3, [pc, #44]	; (41a78 <log_process_thread_func+0x40>)
	    process_tid &&
   41a4a:	681b      	ldr	r3, [r3, #0]
   41a4c:	2b09      	cmp	r3, #9
   41a4e:	dd02      	ble.n	41a56 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   41a50:	480a      	ldr	r0, [pc, #40]	; (41a7c <log_process_thread_func+0x44>)
   41a52:	f005 f86b 	bl	46b2c <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   41a56:	4c09      	ldr	r4, [pc, #36]	; (41a7c <log_process_thread_func+0x44>)
   41a58:	2000      	movs	r0, #0
   41a5a:	f7ff fef3 	bl	41844 <z_impl_log_process>
		if (log_process(false) == false) {
   41a5e:	2800      	cmp	r0, #0
   41a60:	d1fa      	bne.n	41a58 <log_process_thread_func+0x20>
   41a62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   41a66:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41a6a:	4620      	mov	r0, r4
   41a6c:	f005 f87e 	bl	46b6c <z_impl_k_sem_take>
   41a70:	e7f2      	b.n	41a58 <log_process_thread_func+0x20>
   41a72:	bf00      	nop
   41a74:	2001a904 	.word	0x2001a904
   41a78:	2001a8d4 	.word	0x2001a8d4
   41a7c:	2001a6c0 	.word	0x2001a6c0

00041a80 <z_impl_log_panic>:
{
   41a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   41a82:	4f0e      	ldr	r7, [pc, #56]	; (41abc <z_impl_log_panic+0x3c>)
   41a84:	783d      	ldrb	r5, [r7, #0]
   41a86:	b975      	cbnz	r5, 41aa6 <z_impl_log_panic+0x26>
	log_init();
   41a88:	f7ff fe14 	bl	416b4 <log_init>
	return __log_backends_end - __log_backends_start;
   41a8c:	4c0c      	ldr	r4, [pc, #48]	; (41ac0 <z_impl_log_panic+0x40>)
   41a8e:	4e0d      	ldr	r6, [pc, #52]	; (41ac4 <z_impl_log_panic+0x44>)
   41a90:	1b36      	subs	r6, r6, r4
   41a92:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   41a94:	42b5      	cmp	r5, r6
   41a96:	db07      	blt.n	41aa8 <z_impl_log_panic+0x28>
   41a98:	2000      	movs	r0, #0
   41a9a:	f7ff fed3 	bl	41844 <z_impl_log_process>
		while (log_process(false) == true) {
   41a9e:	2800      	cmp	r0, #0
   41aa0:	d1fa      	bne.n	41a98 <z_impl_log_panic+0x18>
	panic_mode = true;
   41aa2:	2301      	movs	r3, #1
   41aa4:	703b      	strb	r3, [r7, #0]
}
   41aa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   41aa8:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   41aaa:	795b      	ldrb	r3, [r3, #5]
   41aac:	b11b      	cbz	r3, 41ab6 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   41aae:	6823      	ldr	r3, [r4, #0]
   41ab0:	4620      	mov	r0, r4
   41ab2:	695b      	ldr	r3, [r3, #20]
   41ab4:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   41ab6:	3501      	adds	r5, #1
   41ab8:	3410      	adds	r4, #16
   41aba:	e7eb      	b.n	41a94 <z_impl_log_panic+0x14>
   41abc:	2001aed1 	.word	0x2001aed1
   41ac0:	000496ec 	.word	0x000496ec
   41ac4:	0004970c 	.word	0x0004970c

00041ac8 <z_log_free>:
{
   41ac8:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   41aca:	3804      	subs	r0, #4
   41acc:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   41ace:	e8d0 3fef 	ldaex	r3, [r0]
   41ad2:	1e5a      	subs	r2, r3, #1
   41ad4:	e8c0 2fe1 	stlex	r1, r2, [r0]
   41ad8:	2900      	cmp	r1, #0
   41ada:	d1f8      	bne.n	41ace <z_log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
   41adc:	2b01      	cmp	r3, #1
   41ade:	d103      	bne.n	41ae8 <z_log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   41ae0:	4803      	ldr	r0, [pc, #12]	; (41af0 <z_log_free+0x28>)
   41ae2:	a901      	add	r1, sp, #4
   41ae4:	f007 fa6f 	bl	48fc6 <k_mem_slab_free>
}
   41ae8:	b003      	add	sp, #12
   41aea:	f85d fb04 	ldr.w	pc, [sp], #4
   41aee:	bf00      	nop
   41af0:	2001a8e8 	.word	0x2001a8e8

00041af4 <log_source_name_get>:
   41af4:	4a04      	ldr	r2, [pc, #16]	; (41b08 <log_source_name_get+0x14>)
   41af6:	4b05      	ldr	r3, [pc, #20]	; (41b0c <log_source_name_get+0x18>)
   41af8:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   41afa:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   41afe:	bf34      	ite	cc
   41b00:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
   41b04:	2000      	movcs	r0, #0
}
   41b06:	4770      	bx	lr
   41b08:	00049694 	.word	0x00049694
   41b0c:	000496ec 	.word	0x000496ec

00041b10 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   41b10:	4b05      	ldr	r3, [pc, #20]	; (41b28 <log_backend_enable+0x18>)

	log_backend_id_set(backend, id);
   41b12:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
   41b14:	1ac3      	subs	r3, r0, r3
   41b16:	111b      	asrs	r3, r3, #4
   41b18:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   41b1a:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
   41b1c:	2201      	movs	r2, #1
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);
   41b1e:	6843      	ldr	r3, [r0, #4]
	backend->cb->ctx = ctx;
   41b20:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
   41b22:	715a      	strb	r2, [r3, #5]

	z_log_notify_backend_enabled();
   41b24:	f7ff be02 	b.w	4172c <z_log_notify_backend_enabled>
   41b28:	000496ec 	.word	0x000496ec

00041b2c <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   41b2c:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   41b30:	2220      	movs	r2, #32
   41b32:	4902      	ldr	r1, [pc, #8]	; (41b3c <log_msg_pool_init+0x10>)
   41b34:	4802      	ldr	r0, [pc, #8]	; (41b40 <log_msg_pool_init+0x14>)
   41b36:	f007 ba2b 	b.w	48f90 <k_mem_slab_init>
   41b3a:	bf00      	nop
   41b3c:	20025d10 	.word	0x20025d10
   41b40:	2001a908 	.word	0x2001a908

00041b44 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
   41b44:	2300      	movs	r3, #0
{
   41b46:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   41b48:	4d09      	ldr	r5, [pc, #36]	; (41b70 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   41b4a:	9301      	str	r3, [sp, #4]
   41b4c:	2001      	movs	r0, #1
   41b4e:	f7ff fe79 	bl	41844 <z_impl_log_process>
   41b52:	4604      	mov	r4, r0
			z_log_dropped();
   41b54:	f7ff fdf8 	bl	41748 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   41b58:	2200      	movs	r2, #0
   41b5a:	2300      	movs	r3, #0
   41b5c:	4628      	mov	r0, r5
   41b5e:	a901      	add	r1, sp, #4
   41b60:	f004 fe36 	bl	467d0 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   41b64:	b108      	cbz	r0, 41b6a <log_msg_no_space_handle+0x26>
   41b66:	2c00      	cmp	r4, #0
   41b68:	d1f0      	bne.n	41b4c <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
   41b6a:	9801      	ldr	r0, [sp, #4]
   41b6c:	b003      	add	sp, #12
   41b6e:	bd30      	pop	{r4, r5, pc}
   41b70:	2001a908 	.word	0x2001a908

00041b74 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
   41b74:	2300      	movs	r3, #0
{
   41b76:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41b78:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
   41b7a:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   41b7c:	4806      	ldr	r0, [pc, #24]	; (41b98 <log_msg_chunk_alloc+0x24>)
   41b7e:	2300      	movs	r3, #0
   41b80:	a901      	add	r1, sp, #4
   41b82:	f004 fe25 	bl	467d0 <k_mem_slab_alloc>
	if (err != 0) {
   41b86:	b110      	cbz	r0, 41b8e <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
   41b88:	f7ff ffdc 	bl	41b44 <log_msg_no_space_handle>
   41b8c:	9001      	str	r0, [sp, #4]
}
   41b8e:	9801      	ldr	r0, [sp, #4]
   41b90:	b003      	add	sp, #12
   41b92:	f85d fb04 	ldr.w	pc, [sp], #4
   41b96:	bf00      	nop
   41b98:	2001a908 	.word	0x2001a908

00041b9c <msg_free>:
{
   41b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41b9e:	7a03      	ldrb	r3, [r0, #8]
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
   41ba0:	7a45      	ldrb	r5, [r0, #9]
{
   41ba2:	b085      	sub	sp, #20
   41ba4:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   41ba6:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
   41ba8:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   41bac:	d41c      	bmi.n	41be8 <msg_free+0x4c>
   41bae:	b1dd      	cbz	r5, 41be8 <msg_free+0x4c>
		uint32_t smask = 0U;
   41bb0:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
   41bb2:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
   41bb4:	4631      	mov	r1, r6
   41bb6:	9801      	ldr	r0, [sp, #4]
   41bb8:	f006 fc09 	bl	483ce <log_msg_arg_get>
   41bbc:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
   41bbe:	f7ff fe33 	bl	41828 <log_is_strdup>
   41bc2:	b170      	cbz	r0, 41be2 <msg_free+0x46>
				if (smask == 0U) {
   41bc4:	b934      	cbnz	r4, 41bd4 <msg_free+0x38>
					smask = z_log_get_s_mask(
   41bc6:	9b01      	ldr	r3, [sp, #4]
   41bc8:	4629      	mov	r1, r5
   41bca:	6918      	ldr	r0, [r3, #16]
   41bcc:	f006 fb1a 	bl	48204 <z_log_get_s_mask>
					if (smask == 0U) {
   41bd0:	4604      	mov	r4, r0
   41bd2:	b148      	cbz	r0, 41be8 <msg_free+0x4c>
				if (smask & BIT(i)) {
   41bd4:	fa24 f306 	lsr.w	r3, r4, r6
   41bd8:	07d9      	lsls	r1, r3, #31
   41bda:	d502      	bpl.n	41be2 <msg_free+0x46>
					z_log_free(buf);
   41bdc:	4638      	mov	r0, r7
   41bde:	f7ff ff73 	bl	41ac8 <z_log_free>
		for (i = 0U; i < nargs; i++) {
   41be2:	3601      	adds	r6, #1
   41be4:	42ae      	cmp	r6, r5
   41be6:	d3e5      	bcc.n	41bb4 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
   41be8:	9b01      	ldr	r3, [sp, #4]
   41bea:	7a1a      	ldrb	r2, [r3, #8]
   41bec:	0792      	lsls	r2, r2, #30
   41bee:	d504      	bpl.n	41bfa <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
   41bf0:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   41bf2:	4c08      	ldr	r4, [pc, #32]	; (41c14 <msg_free+0x78>)
   41bf4:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   41bf6:	9b03      	ldr	r3, [sp, #12]
   41bf8:	b92b      	cbnz	r3, 41c06 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   41bfa:	4806      	ldr	r0, [pc, #24]	; (41c14 <msg_free+0x78>)
   41bfc:	a901      	add	r1, sp, #4
   41bfe:	f007 f9e2 	bl	48fc6 <k_mem_slab_free>
}
   41c02:	b005      	add	sp, #20
   41c04:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
   41c06:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   41c08:	4620      	mov	r0, r4
   41c0a:	a903      	add	r1, sp, #12
   41c0c:	f007 f9db 	bl	48fc6 <k_mem_slab_free>
		cont = next;
   41c10:	9503      	str	r5, [sp, #12]
   41c12:	e7f0      	b.n	41bf6 <msg_free+0x5a>
   41c14:	2001a908 	.word	0x2001a908

00041c18 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
   41c18:	b40e      	push	{r1, r2, r3}
   41c1a:	b503      	push	{r0, r1, lr}
   41c1c:	ab03      	add	r3, sp, #12
   41c1e:	f853 2b04 	ldr.w	r2, [r3], #4
   41c22:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
   41c24:	4804      	ldr	r0, [pc, #16]	; (41c38 <print_formatted+0x20>)
	va_start(args, fmt);
   41c26:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
   41c28:	f7ff f90a 	bl	40e40 <cbvprintf>
	va_end(args);

	return length;
}
   41c2c:	b002      	add	sp, #8
   41c2e:	f85d eb04 	ldr.w	lr, [sp], #4
   41c32:	b003      	add	sp, #12
   41c34:	4770      	bx	lr
   41c36:	bf00      	nop
   41c38:	000487d1 	.word	0x000487d1

00041c3c <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
   41c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   41c40:	461f      	mov	r7, r3
   41c42:	b087      	sub	sp, #28
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   41c44:	f001 0301 	and.w	r3, r1, #1
{
   41c48:	9205      	str	r2, [sp, #20]
   41c4a:	4606      	mov	r6, r0
   41c4c:	4688      	mov	r8, r1
   41c4e:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
   41c52:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
   41c56:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   41c5a:	9304      	str	r3, [sp, #16]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   41c5c:	f001 0508 	and.w	r5, r1, #8
	const char *tag = z_log_get_tag();
   41c60:	f006 fb51 	bl	48306 <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
   41c64:	4602      	mov	r2, r0
   41c66:	2800      	cmp	r0, #0
   41c68:	d044      	beq.n	41cf4 <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
   41c6a:	4630      	mov	r0, r6
   41c6c:	4938      	ldr	r1, [pc, #224]	; (41d50 <prefix_print+0x114>)
   41c6e:	f7ff ffd3 	bl	41c18 <print_formatted>
   41c72:	4604      	mov	r4, r0
	}

	if (stamp) {
   41c74:	f1bb 0f00 	cmp.w	fp, #0
   41c78:	d008      	beq.n	41c8c <prefix_print+0x50>
	if (!format) {
   41c7a:	f018 0f44 	tst.w	r8, #68	; 0x44
   41c7e:	d13b      	bne.n	41cf8 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
   41c80:	463a      	mov	r2, r7
   41c82:	4630      	mov	r0, r6
   41c84:	4933      	ldr	r1, [pc, #204]	; (41d54 <prefix_print+0x118>)
   41c86:	f7ff ffc7 	bl	41c18 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
   41c8a:	4404      	add	r4, r0
	if (color) {
   41c8c:	9b04      	ldr	r3, [sp, #16]
   41c8e:	b153      	cbz	r3, 41ca6 <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
   41c90:	4b31      	ldr	r3, [pc, #196]	; (41d58 <prefix_print+0x11c>)
		print_formatted(output, "%s", log_color);
   41c92:	4630      	mov	r0, r6
		const char *log_color = start && (colors[level] != NULL) ?
   41c94:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
   41c98:	4b30      	ldr	r3, [pc, #192]	; (41d5c <prefix_print+0x120>)
   41c9a:	4931      	ldr	r1, [pc, #196]	; (41d60 <prefix_print+0x124>)
   41c9c:	2a00      	cmp	r2, #0
   41c9e:	bf08      	it	eq
   41ca0:	461a      	moveq	r2, r3
   41ca2:	f7ff ffb9 	bl	41c18 <print_formatted>
	if (level_on) {
   41ca6:	b13d      	cbz	r5, 41cb8 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
   41ca8:	4b2e      	ldr	r3, [pc, #184]	; (41d64 <prefix_print+0x128>)
   41caa:	4630      	mov	r0, r6
   41cac:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
   41cb0:	492d      	ldr	r1, [pc, #180]	; (41d68 <prefix_print+0x12c>)
   41cb2:	f7ff ffb1 	bl	41c18 <print_formatted>
   41cb6:	4605      	mov	r5, r0
	if (source_id >= 0) {
   41cb8:	f1ba 0f00 	cmp.w	sl, #0
   41cbc:	db16      	blt.n	41cec <prefix_print+0xb0>
		total += print_formatted(output,
   41cbe:	9b05      	ldr	r3, [sp, #20]
   41cc0:	2b00      	cmp	r3, #0
   41cc2:	d043      	beq.n	41d4c <prefix_print+0x110>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   41cc4:	2301      	movs	r3, #1
   41cc6:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
   41cca:	4b28      	ldr	r3, [pc, #160]	; (41d6c <prefix_print+0x130>)
   41ccc:	f019 0f10 	tst.w	r9, #16
   41cd0:	4f27      	ldr	r7, [pc, #156]	; (41d70 <prefix_print+0x134>)
   41cd2:	bf18      	it	ne
   41cd4:	461f      	movne	r7, r3
   41cd6:	4651      	mov	r1, sl
   41cd8:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
   41cdc:	f7ff ff0a 	bl	41af4 <log_source_name_get>
   41ce0:	4639      	mov	r1, r7
   41ce2:	4602      	mov	r2, r0
   41ce4:	4630      	mov	r0, r6
   41ce6:	f7ff ff97 	bl	41c18 <print_formatted>
   41cea:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
   41cec:	1928      	adds	r0, r5, r4
   41cee:	b007      	add	sp, #28
   41cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
   41cf4:	4604      	mov	r4, r0
   41cf6:	e7bd      	b.n	41c74 <prefix_print+0x38>
	} else if (freq != 0U) {
   41cf8:	4b1e      	ldr	r3, [pc, #120]	; (41d74 <prefix_print+0x138>)
   41cfa:	6818      	ldr	r0, [r3, #0]
   41cfc:	2800      	cmp	r0, #0
   41cfe:	d0c4      	beq.n	41c8a <prefix_print+0x4e>
		timestamp /= timestamp_div;
   41d00:	4b1d      	ldr	r3, [pc, #116]	; (41d78 <prefix_print+0x13c>)
   41d02:	f44f 6c61 	mov.w	ip, #3600	; 0xe10
   41d06:	6819      	ldr	r1, [r3, #0]
		mins = seconds / 60U;
   41d08:	f04f 0e3c 	mov.w	lr, #60	; 0x3c
		timestamp /= timestamp_div;
   41d0c:	fbb7 f7f1 	udiv	r7, r7, r1
		total_seconds = timestamp / freq;
   41d10:	fbb7 f1f0 	udiv	r1, r7, r0
		seconds -= hours * 3600U;
   41d14:	fbb1 f2fc 	udiv	r2, r1, ip
		remainder = timestamp % freq;
   41d18:	fb00 7711 	mls	r7, r0, r1, r7
   41d1c:	fb0c 1c12 	mls	ip, ip, r2, r1
		ms = (remainder * 1000U) / freq;
   41d20:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   41d24:	434f      	muls	r7, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   41d26:	fbb7 f8f0 	udiv	r8, r7, r0
   41d2a:	fb00 7718 	mls	r7, r0, r8, r7
		mins = seconds / 60U;
   41d2e:	fbbc f3fe 	udiv	r3, ip, lr
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   41d32:	434f      	muls	r7, r1
   41d34:	fbb7 f0f0 	udiv	r0, r7, r0
			length = print_formatted(output,
   41d38:	fb0e c113 	mls	r1, lr, r3, ip
   41d3c:	e9cd 8001 	strd	r8, r0, [sp, #4]
   41d40:	9100      	str	r1, [sp, #0]
   41d42:	4630      	mov	r0, r6
   41d44:	490d      	ldr	r1, [pc, #52]	; (41d7c <prefix_print+0x140>)
   41d46:	f7ff ff67 	bl	41c18 <print_formatted>
   41d4a:	e79e      	b.n	41c8a <prefix_print+0x4e>
		total += print_formatted(output,
   41d4c:	4f08      	ldr	r7, [pc, #32]	; (41d70 <prefix_print+0x134>)
   41d4e:	e7c2      	b.n	41cd6 <prefix_print+0x9a>
   41d50:	00049c7e 	.word	0x00049c7e
   41d54:	00049c82 	.word	0x00049c82
   41d58:	00049758 	.word	0x00049758
   41d5c:	00049c70 	.word	0x00049c70
   41d60:	00049ca7 	.word	0x00049ca7
   41d64:	0004976c 	.word	0x0004976c
   41d68:	00049caa 	.word	0x00049caa
   41d6c:	00049c7a 	.word	0x00049c7a
   41d70:	00049c75 	.word	0x00049c75
   41d74:	2001a924 	.word	0x2001a924
   41d78:	2001a928 	.word	0x2001a928
   41d7c:	00049c8b 	.word	0x00049c8b

00041d80 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
   41d80:	b538      	push	{r3, r4, r5, lr}
   41d82:	460c      	mov	r4, r1
	if (color) {
   41d84:	07e1      	lsls	r1, r4, #31
{
   41d86:	4605      	mov	r5, r0
	if (color) {
   41d88:	d503      	bpl.n	41d92 <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
   41d8a:	4a08      	ldr	r2, [pc, #32]	; (41dac <postfix_print+0x2c>)
   41d8c:	4908      	ldr	r1, [pc, #32]	; (41db0 <postfix_print+0x30>)
   41d8e:	f7ff ff43 	bl	41c18 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41d92:	06e2      	lsls	r2, r4, #27
   41d94:	d408      	bmi.n	41da8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41d96:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   41d98:	4628      	mov	r0, r5
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
   41d9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   41d9e:	bf4c      	ite	mi
   41da0:	4904      	ldrmi	r1, [pc, #16]	; (41db4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   41da2:	4905      	ldrpl	r1, [pc, #20]	; (41db8 <postfix_print+0x38>)
   41da4:	f7ff bf38 	b.w	41c18 <print_formatted>
}
   41da8:	bd38      	pop	{r3, r4, r5, pc}
   41daa:	bf00      	nop
   41dac:	00049c70 	.word	0x00049c70
   41db0:	00049ca7 	.word	0x00049ca7
   41db4:	00049953 	.word	0x00049953
   41db8:	00049952 	.word	0x00049952

00041dbc <hexdump_line_print>:
{
   41dbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   41dc0:	461d      	mov	r5, r3
   41dc2:	9b08      	ldr	r3, [sp, #32]
   41dc4:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41dc6:	06da      	lsls	r2, r3, #27
{
   41dc8:	4604      	mov	r4, r0
   41dca:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   41dcc:	d405      	bmi.n	41dda <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   41dce:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   41dd0:	bf4c      	ite	mi
   41dd2:	492a      	ldrmi	r1, [pc, #168]	; (41e7c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   41dd4:	492a      	ldrpl	r1, [pc, #168]	; (41e80 <hexdump_line_print+0xc4>)
   41dd6:	f7ff ff1f 	bl	41c18 <print_formatted>
{
   41dda:	f04f 0800 	mov.w	r8, #0
		print_formatted(output, " ");
   41dde:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 41e88 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   41de2:	45a8      	cmp	r8, r5
   41de4:	db2a      	blt.n	41e3c <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41de6:	2500      	movs	r5, #0
			print_formatted(output, "   ");
   41de8:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 41e8c <hexdump_line_print+0xd0>
			print_formatted(output, "%02x ", data[i]);
   41dec:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 41e90 <hexdump_line_print+0xd4>
			print_formatted(output, " ");
   41df0:	f8df a094 	ldr.w	sl, [pc, #148]	; 41e88 <hexdump_line_print+0xcc>
		if (i < length) {
   41df4:	42bd      	cmp	r5, r7
   41df6:	d22f      	bcs.n	41e58 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
   41df8:	4649      	mov	r1, r9
   41dfa:	4620      	mov	r0, r4
   41dfc:	5d72      	ldrb	r2, [r6, r5]
   41dfe:	f7ff ff0b 	bl	41c18 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41e02:	3501      	adds	r5, #1
   41e04:	2d10      	cmp	r5, #16
   41e06:	d120      	bne.n	41e4a <hexdump_line_print+0x8e>
	print_formatted(output, "|");
   41e08:	4620      	mov	r0, r4
   41e0a:	491e      	ldr	r1, [pc, #120]	; (41e84 <hexdump_line_print+0xc8>)
   41e0c:	f7ff ff04 	bl	41c18 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41e10:	2500      	movs	r5, #0
			print_formatted(output, " ");
   41e12:	f8df 8074 	ldr.w	r8, [pc, #116]	; 41e88 <hexdump_line_print+0xcc>
			print_formatted(output, "%c",
   41e16:	f8df 907c 	ldr.w	r9, [pc, #124]	; 41e94 <hexdump_line_print+0xd8>
		if (i < length) {
   41e1a:	42af      	cmp	r7, r5
   41e1c:	d928      	bls.n	41e70 <hexdump_line_print+0xb4>
			char c = (char)data[i];
   41e1e:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
   41e20:	4649      	mov	r1, r9
	return (int)((((unsigned)c) >= ' ') &&
   41e22:	f1a2 0320 	sub.w	r3, r2, #32
   41e26:	2b5f      	cmp	r3, #95	; 0x5f
   41e28:	bf28      	it	cs
   41e2a:	222e      	movcs	r2, #46	; 0x2e
   41e2c:	4620      	mov	r0, r4
   41e2e:	f7ff fef3 	bl	41c18 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   41e32:	3501      	adds	r5, #1
   41e34:	2d10      	cmp	r5, #16
   41e36:	d114      	bne.n	41e62 <hexdump_line_print+0xa6>
}
   41e38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
   41e3c:	4649      	mov	r1, r9
   41e3e:	4620      	mov	r0, r4
   41e40:	f7ff feea 	bl	41c18 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   41e44:	f108 0801 	add.w	r8, r8, #1
   41e48:	e7cb      	b.n	41de2 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
   41e4a:	076a      	lsls	r2, r5, #29
   41e4c:	d1d2      	bne.n	41df4 <hexdump_line_print+0x38>
			print_formatted(output, " ");
   41e4e:	4651      	mov	r1, sl
   41e50:	4620      	mov	r0, r4
   41e52:	f7ff fee1 	bl	41c18 <print_formatted>
   41e56:	e7cd      	b.n	41df4 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
   41e58:	4641      	mov	r1, r8
   41e5a:	4620      	mov	r0, r4
   41e5c:	f7ff fedc 	bl	41c18 <print_formatted>
   41e60:	e7cf      	b.n	41e02 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
   41e62:	076b      	lsls	r3, r5, #29
   41e64:	d1d9      	bne.n	41e1a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41e66:	4641      	mov	r1, r8
   41e68:	4620      	mov	r0, r4
   41e6a:	f7ff fed5 	bl	41c18 <print_formatted>
   41e6e:	e7d4      	b.n	41e1a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
   41e70:	4641      	mov	r1, r8
   41e72:	4620      	mov	r0, r4
   41e74:	f7ff fed0 	bl	41c18 <print_formatted>
   41e78:	e7db      	b.n	41e32 <hexdump_line_print+0x76>
   41e7a:	bf00      	nop
   41e7c:	00049953 	.word	0x00049953
   41e80:	00049952 	.word	0x00049952
   41e84:	00049cba 	.word	0x00049cba
   41e88:	00049cb8 	.word	0x00049cb8
   41e8c:	00049cb6 	.word	0x00049cb6
   41e90:	00049cb0 	.word	0x00049cb0
   41e94:	00049cbc 	.word	0x00049cbc

00041e98 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
   41e98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   41e9c:	7a8b      	ldrb	r3, [r1, #10]
   41e9e:	4617      	mov	r7, r2
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
   41ea0:	f013 0807 	ands.w	r8, r3, #7
{
   41ea4:	4605      	mov	r5, r0
   41ea6:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41ea8:	7a0a      	ldrb	r2, [r1, #8]
   41eaa:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(output, flags, std_msg, timestamp,
   41eac:	d021      	beq.n	41ef2 <log_output_msg_process+0x5a>
   41eae:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
   41eb0:	8949      	ldrh	r1, [r1, #10]
   41eb2:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   41eb6:	f3c1 1189 	ubfx	r1, r1, #6, #10
   41eba:	e9cd 8300 	strd	r8, r3, [sp]
   41ebe:	9102      	str	r1, [sp, #8]
   41ec0:	68f3      	ldr	r3, [r6, #12]
   41ec2:	4639      	mov	r1, r7
   41ec4:	f002 0201 	and.w	r2, r2, #1
   41ec8:	f7ff feb8 	bl	41c3c <prefix_print>
   41ecc:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   41ece:	7a34      	ldrb	r4, [r6, #8]
   41ed0:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   41ed2:	f014 0401 	ands.w	r4, r4, #1
   41ed6:	d00e      	beq.n	41ef6 <log_output_msg_process+0x5e>
		std_print(msg, output);
   41ed8:	4629      	mov	r1, r5
   41eda:	4630      	mov	r0, r6
   41edc:	f006 fb0e 	bl	484fc <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
   41ee0:	f1b8 0f00 	cmp.w	r8, #0
   41ee4:	d02b      	beq.n	41f3e <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
   41ee6:	4642      	mov	r2, r8
   41ee8:	4639      	mov	r1, r7
   41eea:	4628      	mov	r0, r5
   41eec:	f7ff ff48 	bl	41d80 <postfix_print>
   41ef0:	e025      	b.n	41f3e <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
   41ef2:	46c1      	mov	r9, r8
   41ef4:	e7eb      	b.n	41ece <log_output_msg_process+0x36>
	} else if (raw_string) {
   41ef6:	f1b8 0f00 	cmp.w	r8, #0
   41efa:	d126      	bne.n	41f4a <log_output_msg_process+0xb2>
	size_t offset = 0;
   41efc:	4627      	mov	r7, r4
		length = output->size;
   41efe:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41f00:	aa06      	add	r2, sp, #24
		length = output->size;
   41f02:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
   41f04:	4630      	mov	r0, r6
   41f06:	463b      	mov	r3, r7
   41f08:	68a9      	ldr	r1, [r5, #8]
   41f0a:	f006 fae3 	bl	484d4 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
   41f0e:	9a06      	ldr	r2, [sp, #24]
   41f10:	686b      	ldr	r3, [r5, #4]
   41f12:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   41f14:	b13a      	cbz	r2, 41f26 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
   41f16:	68ab      	ldr	r3, [r5, #8]
   41f18:	4413      	add	r3, r2
   41f1a:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   41f1e:	f1a4 030a 	sub.w	r3, r4, #10
   41f22:	425c      	negs	r4, r3
   41f24:	415c      	adcs	r4, r3
		log_output_flush(output);
   41f26:	4628      	mov	r0, r5
   41f28:	f006 fc45 	bl	487b6 <log_output_flush>
		offset += length;
   41f2c:	9b06      	ldr	r3, [sp, #24]
   41f2e:	441f      	add	r7, r3
	} while (length > 0);
   41f30:	2b00      	cmp	r3, #0
   41f32:	d1e4      	bne.n	41efe <log_output_msg_process+0x66>
	if (eol) {
   41f34:	b11c      	cbz	r4, 41f3e <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
   41f36:	4628      	mov	r0, r5
   41f38:	4913      	ldr	r1, [pc, #76]	; (41f88 <log_output_msg_process+0xf0>)
   41f3a:	f7ff fe6d 	bl	41c18 <print_formatted>
	}

	log_output_flush(output);
   41f3e:	4628      	mov	r0, r5
   41f40:	f006 fc39 	bl	487b6 <log_output_flush>
}
   41f44:	b00a      	add	sp, #40	; 0x28
   41f46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(output, "%s", log_msg_str_get(msg));
   41f4a:	4630      	mov	r0, r6
   41f4c:	f006 fa6d 	bl	4842a <log_msg_str_get>
   41f50:	490e      	ldr	r1, [pc, #56]	; (41f8c <log_output_msg_process+0xf4>)
   41f52:	4602      	mov	r2, r0
   41f54:	4628      	mov	r0, r5
   41f56:	f7ff fe5f 	bl	41c18 <print_formatted>
		length = sizeof(buf);
   41f5a:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41f5e:	aa05      	add	r2, sp, #20
   41f60:	4623      	mov	r3, r4
   41f62:	4630      	mov	r0, r6
   41f64:	a906      	add	r1, sp, #24
		length = sizeof(buf);
   41f66:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   41f6a:	f006 fab3 	bl	484d4 <log_msg_hexdump_data_get>
		if (length) {
   41f6e:	9a05      	ldr	r2, [sp, #20]
   41f70:	2a00      	cmp	r2, #0
   41f72:	d0b8      	beq.n	41ee6 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
   41f74:	464b      	mov	r3, r9
   41f76:	4628      	mov	r0, r5
   41f78:	9700      	str	r7, [sp, #0]
   41f7a:	a906      	add	r1, sp, #24
   41f7c:	f7ff ff1e 	bl	41dbc <hexdump_line_print>
			offset += length;
   41f80:	9b05      	ldr	r3, [sp, #20]
   41f82:	441c      	add	r4, r3
		length = sizeof(buf);
   41f84:	e7eb      	b.n	41f5e <log_output_msg_process+0xc6>
   41f86:	bf00      	nop
   41f88:	00049cbf 	.word	0x00049cbf
   41f8c:	00049ca7 	.word	0x00049ca7

00041f90 <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41f90:	f242 730f 	movw	r3, #9999	; 0x270f
{
   41f94:	b573      	push	{r0, r1, r4, r5, r6, lr}
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41f96:	428b      	cmp	r3, r1
   41f98:	bf28      	it	cs
   41f9a:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
   41f9c:	6805      	ldr	r5, [r0, #0]
{
   41f9e:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
   41fa0:	2105      	movs	r1, #5
   41fa2:	4668      	mov	r0, sp
   41fa4:	4a0d      	ldr	r2, [pc, #52]	; (41fdc <log_output_dropped_process+0x4c>)
   41fa6:	f005 fe03 	bl	47bb0 <snprintk>
   41faa:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
   41fac:	6863      	ldr	r3, [r4, #4]
   41fae:	4628      	mov	r0, r5
   41fb0:	220b      	movs	r2, #11
   41fb2:	685b      	ldr	r3, [r3, #4]
   41fb4:	490a      	ldr	r1, [pc, #40]	; (41fe0 <log_output_dropped_process+0x50>)
   41fb6:	f006 fa94 	bl	484e2 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
   41fba:	6863      	ldr	r3, [r4, #4]
   41fbc:	4632      	mov	r2, r6
   41fbe:	4669      	mov	r1, sp
   41fc0:	4628      	mov	r0, r5
   41fc2:	685b      	ldr	r3, [r3, #4]
   41fc4:	f006 fa8d 	bl	484e2 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
   41fc8:	6863      	ldr	r3, [r4, #4]
   41fca:	221b      	movs	r2, #27
   41fcc:	4628      	mov	r0, r5
   41fce:	685b      	ldr	r3, [r3, #4]
   41fd0:	4904      	ldr	r1, [pc, #16]	; (41fe4 <log_output_dropped_process+0x54>)
   41fd2:	f006 fa86 	bl	484e2 <buffer_write>
		     output->control_block->ctx);
}
   41fd6:	b002      	add	sp, #8
   41fd8:	bd70      	pop	{r4, r5, r6, pc}
   41fda:	bf00      	nop
   41fdc:	0004a336 	.word	0x0004a336
   41fe0:	00049cfd 	.word	0x00049cfd
   41fe4:	00049ce1 	.word	0x00049ce1

00041fe8 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
   41fe8:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   41fea:	2100      	movs	r1, #0
	timestamp_div = 1U;
   41fec:	4a07      	ldr	r2, [pc, #28]	; (4200c <log_output_timestamp_freq_set+0x24>)
{
   41fee:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   41ff0:	4c07      	ldr	r4, [pc, #28]	; (42010 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   41ff2:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   41ff4:	42a0      	cmp	r0, r4
   41ff6:	d804      	bhi.n	42002 <log_output_timestamp_freq_set+0x1a>
   41ff8:	b101      	cbz	r1, 41ffc <log_output_timestamp_freq_set+0x14>
   41ffa:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   41ffc:	4b05      	ldr	r3, [pc, #20]	; (42014 <log_output_timestamp_freq_set+0x2c>)
   41ffe:	6018      	str	r0, [r3, #0]
}
   42000:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
   42002:	2101      	movs	r1, #1
		frequency /= 2U;
   42004:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   42006:	005b      	lsls	r3, r3, #1
   42008:	e7f4      	b.n	41ff4 <log_output_timestamp_freq_set+0xc>
   4200a:	bf00      	nop
   4200c:	2001a928 	.word	0x2001a928
   42010:	000f4240 	.word	0x000f4240
   42014:	2001a924 	.word	0x2001a924

00042018 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
   42018:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4201a:	460d      	mov	r5, r1
   4201c:	4604      	mov	r4, r0
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
   4201e:	4f06      	ldr	r7, [pc, #24]	; (42038 <char_out+0x20>)
   42020:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
   42022:	42b4      	cmp	r4, r6
   42024:	d101      	bne.n	4202a <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
   42026:	4628      	mov	r0, r5
   42028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
   4202a:	6838      	ldr	r0, [r7, #0]
   4202c:	f814 1b01 	ldrb.w	r1, [r4], #1
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   42030:	6883      	ldr	r3, [r0, #8]
   42032:	685b      	ldr	r3, [r3, #4]
   42034:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
   42036:	e7f4      	b.n	42022 <char_out+0xa>
   42038:	2001a940 	.word	0x2001a940

0004203c <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   4203c:	4b01      	ldr	r3, [pc, #4]	; (42044 <log_backend_uart_init+0x8>)
   4203e:	4a02      	ldr	r2, [pc, #8]	; (42048 <log_backend_uart_init+0xc>)
   42040:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
   42042:	4770      	bx	lr
   42044:	2001a940 	.word	0x2001a940
   42048:	00049474 	.word	0x00049474

0004204c <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
   4204c:	2201      	movs	r2, #1
   4204e:	4b02      	ldr	r3, [pc, #8]	; (42058 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
   42050:	4802      	ldr	r0, [pc, #8]	; (4205c <panic+0x10>)
   42052:	701a      	strb	r2, [r3, #0]
   42054:	f006 bbaf 	b.w	487b6 <log_output_flush>
   42058:	2001aed2 	.word	0x2001aed2
   4205c:	0004979c 	.word	0x0004979c

00042060 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
   42060:	4801      	ldr	r0, [pc, #4]	; (42068 <dropped+0x8>)
   42062:	f7ff bf95 	b.w	41f90 <log_output_dropped_process>
   42066:	bf00      	nop
   42068:	0004979c 	.word	0x0004979c

0004206c <put>:
{
   4206c:	b510      	push	{r4, lr}
   4206e:	460c      	mov	r4, r1
	log_msg_get(msg);
   42070:	4608      	mov	r0, r1
   42072:	f006 f9a0 	bl	483b6 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   42076:	4621      	mov	r1, r4
   42078:	4804      	ldr	r0, [pc, #16]	; (4208c <put+0x20>)
   4207a:	220f      	movs	r2, #15
   4207c:	f7ff ff0c 	bl	41e98 <log_output_msg_process>
	log_msg_put(msg);
   42080:	4620      	mov	r0, r4
}
   42082:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   42086:	f006 b9c1 	b.w	4840c <log_msg_put>
   4208a:	bf00      	nop
   4208c:	0004979c 	.word	0x0004979c

00042090 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   42090:	2201      	movs	r2, #1
   42092:	4b01      	ldr	r3, [pc, #4]	; (42098 <log_backend_rtt_init+0x8>)
   42094:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   42096:	4770      	bx	lr
   42098:	2001aee4 	.word	0x2001aee4

0004209c <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
   4209c:	2201      	movs	r2, #1
   4209e:	4b02      	ldr	r3, [pc, #8]	; (420a8 <panic+0xc>)
	log_output_flush(output);
   420a0:	4802      	ldr	r0, [pc, #8]	; (420ac <panic+0x10>)
   420a2:	701a      	strb	r2, [r3, #0]
   420a4:	f006 bb87 	b.w	487b6 <log_output_flush>
   420a8:	2001aee5 	.word	0x2001aee5
   420ac:	000497c8 	.word	0x000497c8

000420b0 <dropped>:
	log_output_dropped_process(output, cnt);
   420b0:	4801      	ldr	r0, [pc, #4]	; (420b8 <dropped+0x8>)
   420b2:	f7ff bf6d 	b.w	41f90 <log_output_dropped_process>
   420b6:	bf00      	nop
   420b8:	000497c8 	.word	0x000497c8

000420bc <put>:
{
   420bc:	b510      	push	{r4, lr}
   420be:	460c      	mov	r4, r1
	log_msg_get(msg);
   420c0:	4608      	mov	r0, r1
   420c2:	f006 f978 	bl	483b6 <log_msg_get>
	log_output_msg_process(output, msg, flags);
   420c6:	4621      	mov	r1, r4
   420c8:	4804      	ldr	r0, [pc, #16]	; (420dc <put+0x20>)
   420ca:	220f      	movs	r2, #15
   420cc:	f7ff fee4 	bl	41e98 <log_output_msg_process>
	log_msg_put(msg);
   420d0:	4620      	mov	r0, r4
}
   420d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   420d6:	f006 b999 	b.w	4840c <log_msg_put>
   420da:	bf00      	nop
   420dc:	000497c8 	.word	0x000497c8

000420e0 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   420e0:	4b05      	ldr	r3, [pc, #20]	; (420f8 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
   420e2:	781b      	ldrb	r3, [r3, #0]
   420e4:	b11b      	cbz	r3, 420ee <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
   420e6:	f241 3088 	movw	r0, #5000	; 0x1388
   420ea:	f007 b8f2 	b.w	492d2 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
   420ee:	2005      	movs	r0, #5
   420f0:	2100      	movs	r1, #0
   420f2:	f005 b841 	b.w	47178 <z_impl_k_sleep>
   420f6:	bf00      	nop
   420f8:	2001aee5 	.word	0x2001aee5

000420fc <data_out_block_mode>:
{
   420fc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
   42100:	f8df 9094 	ldr.w	r9, [pc, #148]	; 42198 <data_out_block_mode+0x9c>
{
   42104:	4680      	mov	r8, r0
   42106:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
   42108:	2404      	movs	r4, #4
   4210a:	46cb      	mov	fp, r9
	return z_impl_k_mutex_lock(mutex, timeout);
   4210c:	f8df a08c 	ldr.w	sl, [pc, #140]	; 4219c <data_out_block_mode+0xa0>
		if (!is_sync_mode()) {
   42110:	f899 5000 	ldrb.w	r5, [r9]
   42114:	b9cd      	cbnz	r5, 4214a <data_out_block_mode+0x4e>
   42116:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4211a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   4211e:	4650      	mov	r0, sl
   42120:	f004 fc40 	bl	469a4 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   42124:	463a      	mov	r2, r7
   42126:	4641      	mov	r1, r8
   42128:	4628      	mov	r0, r5
   4212a:	f002 fd69 	bl	44c00 <SEGGER_RTT_WriteSkipNoLock>
   4212e:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   42130:	4650      	mov	r0, sl
   42132:	f004 fcb5 	bl	46aa0 <z_impl_k_mutex_unlock>
		if (ret) {
   42136:	4d17      	ldr	r5, [pc, #92]	; (42194 <data_out_block_mode+0x98>)
   42138:	b1fe      	cbz	r6, 4217a <data_out_block_mode+0x7e>
	host_present = true;
   4213a:	2301      	movs	r3, #1
   4213c:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
   4213e:	f89b 3000 	ldrb.w	r3, [fp]
   42142:	b96b      	cbnz	r3, 42160 <data_out_block_mode+0x64>
}
   42144:	4638      	mov	r0, r7
   42146:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   4214a:	463a      	mov	r2, r7
   4214c:	4641      	mov	r1, r8
   4214e:	2000      	movs	r0, #0
   42150:	f002 fd56 	bl	44c00 <SEGGER_RTT_WriteSkipNoLock>
   42154:	4606      	mov	r6, r0
   42156:	e7ee      	b.n	42136 <data_out_block_mode+0x3a>
	if (retry_cnt == 0) {
   42158:	b95c      	cbnz	r4, 42172 <data_out_block_mode+0x76>
		host_present = false;
   4215a:	702c      	strb	r4, [r5, #0]
   4215c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   42160:	2000      	movs	r0, #0
   42162:	f002 fd99 	bl	44c98 <SEGGER_RTT_HasDataUp>
   42166:	2800      	cmp	r0, #0
   42168:	d0ec      	beq.n	42144 <data_out_block_mode+0x48>
   4216a:	782b      	ldrb	r3, [r5, #0]
   4216c:	2b00      	cmp	r3, #0
   4216e:	d1f3      	bne.n	42158 <data_out_block_mode+0x5c>
   42170:	e7e8      	b.n	42144 <data_out_block_mode+0x48>
			on_failed_write(retry_cnt--);
   42172:	3c01      	subs	r4, #1
   42174:	f7ff ffb4 	bl	420e0 <on_failed_write.part.0>
   42178:	e7f2      	b.n	42160 <data_out_block_mode+0x64>
		} else if (host_present) {
   4217a:	782b      	ldrb	r3, [r5, #0]
   4217c:	b113      	cbz	r3, 42184 <data_out_block_mode+0x88>
	if (retry_cnt == 0) {
   4217e:	3c01      	subs	r4, #1
   42180:	d104      	bne.n	4218c <data_out_block_mode+0x90>
		host_present = false;
   42182:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   42184:	782b      	ldrb	r3, [r5, #0]
   42186:	2b00      	cmp	r3, #0
   42188:	d1c2      	bne.n	42110 <data_out_block_mode+0x14>
   4218a:	e7db      	b.n	42144 <data_out_block_mode+0x48>
   4218c:	f7ff ffa8 	bl	420e0 <on_failed_write.part.0>
   42190:	e7f8      	b.n	42184 <data_out_block_mode+0x88>
   42192:	bf00      	nop
   42194:	2001aee4 	.word	0x2001aee4
   42198:	2001aee5 	.word	0x2001aee5
   4219c:	2001a698 	.word	0x2001a698

000421a0 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   421a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   421a4:	4605      	mov	r5, r0
	__asm__ volatile(
   421a6:	f04f 0320 	mov.w	r3, #32
   421aa:	f3ef 8611 	mrs	r6, BASEPRI
   421ae:	f383 8812 	msr	BASEPRI_MAX, r3
   421b2:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   421b6:	4b10      	ldr	r3, [pc, #64]	; (421f8 <pm_state_notify+0x58>)
   421b8:	681c      	ldr	r4, [r3, #0]
   421ba:	2c00      	cmp	r4, #0
   421bc:	bf38      	it	cc
   421be:	2400      	movcc	r4, #0
   421c0:	b19c      	cbz	r4, 421ea <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   421c2:	f04f 090c 	mov.w	r9, #12
   421c6:	4f0d      	ldr	r7, [pc, #52]	; (421fc <pm_state_notify+0x5c>)
   421c8:	f8df 8034 	ldr.w	r8, [pc, #52]	; 42200 <pm_state_notify+0x60>
			callback = notifier->state_exit;
   421cc:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   421d0:	2d00      	cmp	r5, #0
   421d2:	bf08      	it	eq
   421d4:	4613      	moveq	r3, r2
		if (callback) {
   421d6:	b12b      	cbz	r3, 421e4 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   421d8:	f898 2014 	ldrb.w	r2, [r8, #20]
   421dc:	fb09 f202 	mul.w	r2, r9, r2
   421e0:	5cb8      	ldrb	r0, [r7, r2]
   421e2:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   421e4:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   421e6:	2c00      	cmp	r4, #0
   421e8:	d1f0      	bne.n	421cc <pm_state_notify+0x2c>
	__asm__ volatile(
   421ea:	f386 8811 	msr	BASEPRI, r6
   421ee:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   421f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   421f6:	bf00      	nop
   421f8:	2001a958 	.word	0x2001a958
   421fc:	2001a964 	.word	0x2001a964
   42200:	2001ade8 	.word	0x2001ade8

00042204 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   42204:	2201      	movs	r2, #1
   42206:	f000 031f 	and.w	r3, r0, #31
   4220a:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   4220c:	4b08      	ldr	r3, [pc, #32]	; (42230 <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   4220e:	0940      	lsrs	r0, r0, #5
   42210:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   42214:	e8d0 3fef 	ldaex	r3, [r0]
   42218:	ea43 0102 	orr.w	r1, r3, r2
   4221c:	e8c0 1fec 	stlex	ip, r1, [r0]
   42220:	f1bc 0f00 	cmp.w	ip, #0
   42224:	d1f6      	bne.n	42214 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   42226:	421a      	tst	r2, r3
}
   42228:	bf14      	ite	ne
   4222a:	2001      	movne	r0, #1
   4222c:	2000      	moveq	r0, #0
   4222e:	4770      	bx	lr
   42230:	2001a970 	.word	0x2001a970

00042234 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   42234:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   42236:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   42238:	4b1a      	ldr	r3, [pc, #104]	; (422a4 <pm_system_resume+0x70>)
{
   4223a:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   4223c:	7d1d      	ldrb	r5, [r3, #20]
   4223e:	f005 031f 	and.w	r3, r5, #31
   42242:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   42244:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   42246:	4b18      	ldr	r3, [pc, #96]	; (422a8 <pm_system_resume+0x74>)
   42248:	0969      	lsrs	r1, r5, #5
   4224a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   4224e:	e8d3 1fef 	ldaex	r1, [r3]
   42252:	ea01 0400 	and.w	r4, r1, r0
   42256:	e8c3 4fec 	stlex	ip, r4, [r3]
   4225a:	f1bc 0f00 	cmp.w	ip, #0
   4225e:	d1f6      	bne.n	4224e <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   42260:	4211      	tst	r1, r2
   42262:	d017      	beq.n	42294 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   42264:	220c      	movs	r2, #12
   42266:	4c11      	ldr	r4, [pc, #68]	; (422ac <pm_system_resume+0x78>)
   42268:	ab01      	add	r3, sp, #4
   4226a:	fb02 4205 	mla	r2, r2, r5, r4
   4226e:	ca07      	ldmia	r2, {r0, r1, r2}
   42270:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   42274:	4a0e      	ldr	r2, [pc, #56]	; (422b0 <pm_system_resume+0x7c>)
   42276:	b17a      	cbz	r2, 42298 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   42278:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   4227c:	f005 ff94 	bl	481a8 <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   42280:	2000      	movs	r0, #0
   42282:	f7ff ff8d 	bl	421a0 <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   42286:	230c      	movs	r3, #12
   42288:	2200      	movs	r2, #0
   4228a:	436b      	muls	r3, r5
   4228c:	18e1      	adds	r1, r4, r3
   4228e:	50e2      	str	r2, [r4, r3]
   42290:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   42294:	b005      	add	sp, #20
   42296:	bd30      	pop	{r4, r5, pc}
   42298:	f382 8811 	msr	BASEPRI, r2
   4229c:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   422a0:	e7ee      	b.n	42280 <pm_system_resume+0x4c>
   422a2:	bf00      	nop
   422a4:	2001ade8 	.word	0x2001ade8
   422a8:	2001a960 	.word	0x2001a960
   422ac:	2001a964 	.word	0x2001a964
   422b0:	000481a9 	.word	0x000481a9

000422b4 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   422b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   422b8:	4b39      	ldr	r3, [pc, #228]	; (423a0 <pm_system_suspend+0xec>)
{
   422ba:	4605      	mov	r5, r0
	uint8_t id = _current_cpu->id;
   422bc:	7d1c      	ldrb	r4, [r3, #20]
{
   422be:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   422c0:	4620      	mov	r0, r4
   422c2:	f7ff ff9f 	bl	42204 <atomic_test_and_set_bit.constprop.0>
   422c6:	4e37      	ldr	r6, [pc, #220]	; (423a4 <pm_system_suspend+0xf0>)
   422c8:	b960      	cbnz	r0, 422e4 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   422ca:	270c      	movs	r7, #12
   422cc:	46e8      	mov	r8, sp
   422ce:	fb07 6704 	mla	r7, r7, r4, r6
   422d2:	462a      	mov	r2, r5
   422d4:	4621      	mov	r1, r4
   422d6:	4640      	mov	r0, r8
   422d8:	f006 fa91 	bl	487fe <pm_policy_next_state>
   422dc:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
   422e0:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   422e4:	230c      	movs	r3, #12
   422e6:	4363      	muls	r3, r4
   422e8:	5cf0      	ldrb	r0, [r6, r3]
   422ea:	18f2      	adds	r2, r6, r3
   422ec:	0967      	lsrs	r7, r4, #5
   422ee:	f004 081f 	and.w	r8, r4, #31
   422f2:	2800      	cmp	r0, #0
   422f4:	d03b      	beq.n	4236e <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   422f6:	1c6b      	adds	r3, r5, #1
   422f8:	d014      	beq.n	42324 <pm_system_suspend+0x70>
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
   422fa:	f240 30e7 	movw	r0, #999	; 0x3e7
   422fe:	2100      	movs	r1, #0
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
		     k_us_to_ticks_ceil32(
   42300:	6893      	ldr	r3, [r2, #8]
   42302:	18c0      	adds	r0, r0, r3
   42304:	f141 0100 	adc.w	r1, r1, #0
		if (result32 && (t < BIT64(32))) {
   42308:	2901      	cmp	r1, #1
   4230a:	bf08      	it	eq
   4230c:	2800      	cmpeq	r0, #0
   4230e:	d241      	bcs.n	42394 <pm_system_suspend+0xe0>
			return ((uint32_t)t) / (from_hz / to_hz);
   42310:	f203 30e7 	addw	r0, r3, #999	; 0x3e7
   42314:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   42318:	fbb0 f0f3 	udiv	r0, r0, r3
		z_set_timeout_expiry(ticks -
   4231c:	2101      	movs	r1, #1
   4231e:	1a28      	subs	r0, r5, r0
   42320:	f006 ffb7 	bl	49292 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   42324:	f004 fc98 	bl	46c58 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   42328:	2001      	movs	r0, #1
   4232a:	f7ff ff39 	bl	421a0 <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   4232e:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   42330:	4b1d      	ldr	r3, [pc, #116]	; (423a8 <pm_system_suspend+0xf4>)
   42332:	fa02 f208 	lsl.w	r2, r2, r8
   42336:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   4233a:	e8d3 1fef 	ldaex	r1, [r3]
   4233e:	4311      	orrs	r1, r2
   42340:	e8c3 1fe0 	stlex	r0, r1, [r3]
   42344:	2800      	cmp	r0, #0
   42346:	d1f8      	bne.n	4233a <pm_system_suspend+0x86>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   42348:	230c      	movs	r3, #12
   4234a:	fb03 6404 	mla	r4, r3, r4, r6
   4234e:	ab05      	add	r3, sp, #20
   42350:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   42354:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   42358:	4a14      	ldr	r2, [pc, #80]	; (423ac <pm_system_suspend+0xf8>)
   4235a:	b11a      	cbz	r2, 42364 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
   4235c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   42360:	f005 ff0f 	bl	48182 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   42364:	f7ff ff66 	bl	42234 <pm_system_resume>
	k_sched_unlock();
   42368:	f004 fe50 	bl	4700c <k_sched_unlock>
	bool ret = true;
   4236c:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   4236e:	2301      	movs	r3, #1
   42370:	fa03 f808 	lsl.w	r8, r3, r8
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   42374:	ea6f 0808 	mvn.w	r8, r8
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   42378:	4b0d      	ldr	r3, [pc, #52]	; (423b0 <pm_system_suspend+0xfc>)
   4237a:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   4237e:	e8d7 3fef 	ldaex	r3, [r7]
   42382:	ea03 0308 	and.w	r3, r3, r8
   42386:	e8c7 3fe2 	stlex	r2, r3, [r7]
   4238a:	2a00      	cmp	r2, #0
   4238c:	d1f7      	bne.n	4237e <pm_system_suspend+0xca>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   4238e:	b008      	add	sp, #32
   42390:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else {
			return t / ((uint64_t)from_hz / to_hz);
   42394:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   42398:	2300      	movs	r3, #0
   4239a:	f7fd fed3 	bl	40144 <__aeabi_uldivmod>
   4239e:	e7bd      	b.n	4231c <pm_system_suspend+0x68>
   423a0:	2001ade8 	.word	0x2001ade8
   423a4:	2001a964 	.word	0x2001a964
   423a8:	2001a960 	.word	0x2001a960
   423ac:	00048183 	.word	0x00048183
   423b0:	2001a970 	.word	0x2001a970

000423b4 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   423b4:	4901      	ldr	r1, [pc, #4]	; (423bc <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   423b6:	2210      	movs	r2, #16
	str	r2, [r1]
   423b8:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   423ba:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   423bc:	e000ed10 	.word	0xe000ed10

000423c0 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   423c0:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   423c2:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   423c4:	f380 8811 	msr	BASEPRI, r0
	isb
   423c8:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   423cc:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   423d0:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   423d2:	b662      	cpsie	i
	isb
   423d4:	f3bf 8f6f 	isb	sy

	bx	lr
   423d8:	4770      	bx	lr
   423da:	bf00      	nop

000423dc <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   423dc:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   423de:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   423e0:	f381 8811 	msr	BASEPRI, r1

	wfe
   423e4:	bf20      	wfe

	msr	BASEPRI, r0
   423e6:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   423ea:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   423ec:	4770      	bx	lr
   423ee:	bf00      	nop

000423f0 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   423f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   423f2:	4606      	mov	r6, r0

	if (esf != NULL) {
   423f4:	460c      	mov	r4, r1
   423f6:	b301      	cbz	r1, 4243a <z_arm_fatal_error+0x4a>
   423f8:	4b13      	ldr	r3, [pc, #76]	; (42448 <z_arm_fatal_error+0x58>)
   423fa:	4d14      	ldr	r5, [pc, #80]	; (4244c <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   423fc:	4814      	ldr	r0, [pc, #80]	; (42450 <z_arm_fatal_error+0x60>)
   423fe:	1aed      	subs	r5, r5, r3
   42400:	08ed      	lsrs	r5, r5, #3
   42402:	01ad      	lsls	r5, r5, #6
   42404:	f045 0501 	orr.w	r5, r5, #1
   42408:	f8ad 5000 	strh.w	r5, [sp]
   4240c:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   42410:	6809      	ldr	r1, [r1, #0]
   42412:	f005 ff51 	bl	482b8 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   42416:	f8ad 5000 	strh.w	r5, [sp]
   4241a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   4241e:	68e1      	ldr	r1, [r4, #12]
   42420:	480c      	ldr	r0, [pc, #48]	; (42454 <z_arm_fatal_error+0x64>)
   42422:	f005 ff49 	bl	482b8 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   42426:	462a      	mov	r2, r5
   42428:	69e1      	ldr	r1, [r4, #28]
   4242a:	480b      	ldr	r0, [pc, #44]	; (42458 <z_arm_fatal_error+0x68>)
   4242c:	f005 ff17 	bl	4825e <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   42430:	462a      	mov	r2, r5
   42432:	69a1      	ldr	r1, [r4, #24]
   42434:	4809      	ldr	r0, [pc, #36]	; (4245c <z_arm_fatal_error+0x6c>)
   42436:	f005 ff12 	bl	4825e <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   4243a:	4621      	mov	r1, r4
   4243c:	4630      	mov	r0, r6
}
   4243e:	b002      	add	sp, #8
   42440:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
   42444:	f004 b86c 	b.w	46520 <z_fatal_error>
   42448:	00049694 	.word	0x00049694
   4244c:	000496cc 	.word	0x000496cc
   42450:	00049d36 	.word	0x00049d36
   42454:	00049d65 	.word	0x00049d65
   42458:	00049d94 	.word	0x00049d94
   4245c:	00049da3 	.word	0x00049da3

00042460 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   42460:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   42462:	2b00      	cmp	r3, #0
   42464:	db08      	blt.n	42478 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   42466:	2201      	movs	r2, #1
   42468:	f000 001f 	and.w	r0, r0, #31
   4246c:	fa02 f000 	lsl.w	r0, r2, r0
   42470:	4a02      	ldr	r2, [pc, #8]	; (4247c <arch_irq_enable+0x1c>)
   42472:	095b      	lsrs	r3, r3, #5
   42474:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   42478:	4770      	bx	lr
   4247a:	bf00      	nop
   4247c:	e000e100 	.word	0xe000e100

00042480 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   42480:	4b05      	ldr	r3, [pc, #20]	; (42498 <arch_irq_is_enabled+0x18>)
   42482:	0942      	lsrs	r2, r0, #5
   42484:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   42488:	2301      	movs	r3, #1
   4248a:	f000 001f 	and.w	r0, r0, #31
   4248e:	fa03 f000 	lsl.w	r0, r3, r0
}
   42492:	4010      	ands	r0, r2
   42494:	4770      	bx	lr
   42496:	bf00      	nop
   42498:	e000e100 	.word	0xe000e100

0004249c <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   4249c:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   4249e:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   424a0:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424a4:	bfac      	ite	ge
   424a6:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424aa:	4b06      	ldrlt	r3, [pc, #24]	; (424c4 <z_arm_irq_priority_set+0x28>)
   424ac:	ea4f 1141 	mov.w	r1, r1, lsl #5
   424b0:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424b2:	bfab      	itete	ge
   424b4:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424b8:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424bc:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   424c0:	5419      	strblt	r1, [r3, r0]
}
   424c2:	4770      	bx	lr
   424c4:	e000ed14 	.word	0xe000ed14

000424c8 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   424c8:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   424ca:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   424cc:	4b04      	ldr	r3, [pc, #16]	; (424e0 <_arch_isr_direct_pm+0x18>)
   424ce:	699a      	ldr	r2, [r3, #24]
   424d0:	b11a      	cbz	r2, 424da <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   424d2:	2200      	movs	r2, #0
   424d4:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   424d6:	f006 fdaa 	bl	4902e <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   424da:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   424dc:	bd08      	pop	{r3, pc}
   424de:	bf00      	nop
   424e0:	2001ade8 	.word	0x2001ade8

000424e4 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   424e4:	bf30      	wfi
    b z_SysNmiOnReset
   424e6:	f7ff bffd 	b.w	424e4 <z_SysNmiOnReset>
   424ea:	bf00      	nop

000424ec <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   424ec:	4a0b      	ldr	r2, [pc, #44]	; (4251c <z_arm_prep_c+0x30>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   424ee:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   424f0:	4b0b      	ldr	r3, [pc, #44]	; (42520 <z_arm_prep_c+0x34>)
   424f2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   424f6:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   424f8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   424fc:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   42500:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   42504:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   42508:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   4250c:	f004 f8ae 	bl	4666c <z_bss_zero>
	z_data_copy();
   42510:	f004 fe9e 	bl	47250 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   42514:	f000 fb06 	bl	42b24 <z_arm_interrupt_init>
	z_cstart();
   42518:	f004 f8b2 	bl	46680 <z_cstart>
   4251c:	00040000 	.word	0x00040000
   42520:	e000ed00 	.word	0xe000ed00

00042524 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   42524:	4a09      	ldr	r2, [pc, #36]	; (4254c <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   42526:	490a      	ldr	r1, [pc, #40]	; (42550 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   42528:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   4252a:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   4252c:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   4252e:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   42530:	4908      	ldr	r1, [pc, #32]	; (42554 <arch_swap+0x30>)
   42532:	684b      	ldr	r3, [r1, #4]
   42534:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   42538:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   4253a:	2300      	movs	r3, #0
   4253c:	f383 8811 	msr	BASEPRI, r3
   42540:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   42544:	6893      	ldr	r3, [r2, #8]
}
   42546:	6f98      	ldr	r0, [r3, #120]	; 0x78
   42548:	4770      	bx	lr
   4254a:	bf00      	nop
   4254c:	2001ade8 	.word	0x2001ade8
   42550:	00049920 	.word	0x00049920
   42554:	e000ed00 	.word	0xe000ed00

00042558 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   42558:	4915      	ldr	r1, [pc, #84]	; (425b0 <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   4255a:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   4255c:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   42560:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   42564:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   42566:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   4256a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   4256e:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   42570:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   42574:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   42578:	4f0e      	ldr	r7, [pc, #56]	; (425b4 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   4257a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   4257e:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   42580:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   42582:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   42584:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   42588:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   4258a:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   4258c:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   4258e:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   42592:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   42596:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   4259a:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   4259e:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   425a2:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   425a4:	f006 f93f 	bl	48826 <configure_builtin_stack_guard>
    pop {r2, lr}
   425a8:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   425ac:	4770      	bx	lr
   425ae:	0000      	.short	0x0000
    ldr r1, =_kernel
   425b0:	2001ade8 	.word	0x2001ade8
    ldr v4, =_SCS_ICSR
   425b4:	e000ed04 	.word	0xe000ed04

000425b8 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   425b8:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   425bc:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   425be:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   425c2:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   425c6:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   425c8:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   425cc:	2902      	cmp	r1, #2
    beq _oops
   425ce:	d0ff      	beq.n	425d0 <_oops>

000425d0 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   425d0:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   425d2:	f006 f919 	bl	48808 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   425d6:	bd01      	pop	{r0, pc}

000425d8 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   425d8:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   425dc:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   425de:	490c      	ldr	r1, [pc, #48]	; (42610 <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   425e0:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   425e4:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   425e6:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   425ea:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   425ee:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   425f0:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   425f4:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   425f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   425fc:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   42600:	2300      	movs	r3, #0
   42602:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   42604:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   42608:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   4260a:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   4260c:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   4260e:	4770      	bx	lr
   42610:	00047d21 	.word	0x00047d21

00042614 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   42614:	4b08      	ldr	r3, [pc, #32]	; (42638 <arch_switch_to_main_thread+0x24>)
   42616:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   42618:	6e43      	ldr	r3, [r0, #100]	; 0x64
   4261a:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   4261e:	4610      	mov	r0, r2
   42620:	f381 8809 	msr	PSP, r1
   42624:	2100      	movs	r1, #0
   42626:	b663      	cpsie	if
   42628:	f381 8811 	msr	BASEPRI, r1
   4262c:	f3bf 8f6f 	isb	sy
   42630:	2200      	movs	r2, #0
   42632:	2300      	movs	r3, #0
   42634:	f005 fb74 	bl	47d20 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   42638:	2001ade8 	.word	0x2001ade8

0004263c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   4263c:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   4263e:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   42640:	4a0b      	ldr	r2, [pc, #44]	; (42670 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   42642:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   42644:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   42646:	bf1e      	ittt	ne
	movne	r1, #0
   42648:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   4264a:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   4264c:	f006 fcef 	blne	4902e <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   42650:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   42652:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   42656:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   4265a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   4265e:	4905      	ldr	r1, [pc, #20]	; (42674 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   42660:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   42662:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   42664:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   42666:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   4266a:	4903      	ldr	r1, [pc, #12]	; (42678 <_isr_wrapper+0x3c>)
	bx r1
   4266c:	4708      	bx	r1
   4266e:	0000      	.short	0x0000
	ldr r2, =_kernel
   42670:	2001ade8 	.word	0x2001ade8
	ldr r1, =_sw_isr_table
   42674:	0004948c 	.word	0x0004948c
	ldr r1, =z_arm_int_exit
   42678:	0004267d 	.word	0x0004267d

0004267c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   4267c:	4b04      	ldr	r3, [pc, #16]	; (42690 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   4267e:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   42680:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   42682:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   42684:	d003      	beq.n	4268e <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   42686:	4903      	ldr	r1, [pc, #12]	; (42694 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   42688:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   4268c:	600a      	str	r2, [r1, #0]

0004268e <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   4268e:	4770      	bx	lr
	ldr r3, =_kernel
   42690:	2001ade8 	.word	0x2001ade8
	ldr r1, =_SCS_ICSR
   42694:	e000ed04 	.word	0xe000ed04

00042698 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
   42698:	b570      	push	{r4, r5, r6, lr}
   4269a:	4b28      	ldr	r3, [pc, #160]	; (4273c <usage_fault.isra.0+0xa4>)
   4269c:	4c28      	ldr	r4, [pc, #160]	; (42740 <usage_fault.isra.0+0xa8>)
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   4269e:	4d29      	ldr	r5, [pc, #164]	; (42744 <usage_fault.isra.0+0xac>)
   426a0:	1ae4      	subs	r4, r4, r3
   426a2:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
   426a4:	01a4      	lsls	r4, r4, #6
   426a6:	f044 0601 	orr.w	r6, r4, #1
   426aa:	4631      	mov	r1, r6
   426ac:	4826      	ldr	r0, [pc, #152]	; (42748 <usage_fault.isra.0+0xb0>)
   426ae:	f005 fdc9 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   426b2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   426b4:	0193      	lsls	r3, r2, #6
   426b6:	d503      	bpl.n	426c0 <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
   426b8:	4631      	mov	r1, r6
   426ba:	4824      	ldr	r0, [pc, #144]	; (4274c <usage_fault.isra.0+0xb4>)
   426bc:	f005 fdc2 	bl	48244 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   426c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
   426c2:	01dd      	lsls	r5, r3, #7
   426c4:	d504      	bpl.n	426d0 <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
   426c6:	4822      	ldr	r0, [pc, #136]	; (42750 <usage_fault.isra.0+0xb8>)
   426c8:	f044 0101 	orr.w	r1, r4, #1
   426cc:	f005 fdba 	bl	48244 <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   426d0:	4d1c      	ldr	r5, [pc, #112]	; (42744 <usage_fault.isra.0+0xac>)
   426d2:	6aae      	ldr	r6, [r5, #40]	; 0x28
   426d4:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   426d8:	d005      	beq.n	426e6 <usage_fault.isra.0+0x4e>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   426da:	481e      	ldr	r0, [pc, #120]	; (42754 <usage_fault.isra.0+0xbc>)
   426dc:	f044 0101 	orr.w	r1, r4, #1
   426e0:	f005 fdb0 	bl	48244 <log_0>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   426e4:	2602      	movs	r6, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   426e6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   426e8:	0318      	lsls	r0, r3, #12
   426ea:	d504      	bpl.n	426f6 <usage_fault.isra.0+0x5e>
		PR_FAULT_INFO("  No coprocessor instructions");
   426ec:	481a      	ldr	r0, [pc, #104]	; (42758 <usage_fault.isra.0+0xc0>)
   426ee:	f044 0101 	orr.w	r1, r4, #1
   426f2:	f005 fda7 	bl	48244 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   426f6:	4d13      	ldr	r5, [pc, #76]	; (42744 <usage_fault.isra.0+0xac>)
   426f8:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   426fa:	0351      	lsls	r1, r2, #13
   426fc:	d504      	bpl.n	42708 <usage_fault.isra.0+0x70>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   426fe:	4817      	ldr	r0, [pc, #92]	; (4275c <usage_fault.isra.0+0xc4>)
   42700:	f044 0101 	orr.w	r1, r4, #1
   42704:	f005 fd9e 	bl	48244 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   42708:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4270a:	039a      	lsls	r2, r3, #14
   4270c:	d504      	bpl.n	42718 <usage_fault.isra.0+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   4270e:	4814      	ldr	r0, [pc, #80]	; (42760 <usage_fault.isra.0+0xc8>)
   42710:	f044 0101 	orr.w	r1, r4, #1
   42714:	f005 fd96 	bl	48244 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   42718:	4d0a      	ldr	r5, [pc, #40]	; (42744 <usage_fault.isra.0+0xac>)
   4271a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4271c:	03db      	lsls	r3, r3, #15
   4271e:	d504      	bpl.n	4272a <usage_fault.isra.0+0x92>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   42720:	4810      	ldr	r0, [pc, #64]	; (42764 <usage_fault.isra.0+0xcc>)
   42722:	f044 0101 	orr.w	r1, r4, #1
   42726:	f005 fd8d 	bl	48244 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   4272a:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
   4272c:	4630      	mov	r0, r6
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   4272e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   42732:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   42736:	62ab      	str	r3, [r5, #40]	; 0x28
}
   42738:	bd70      	pop	{r4, r5, r6, pc}
   4273a:	bf00      	nop
   4273c:	00049694 	.word	0x00049694
   42740:	000496cc 	.word	0x000496cc
   42744:	e000ed00 	.word	0xe000ed00
   42748:	00049dd1 	.word	0x00049dd1
   4274c:	00049de9 	.word	0x00049de9
   42750:	00049dfc 	.word	0x00049dfc
   42754:	00049e16 	.word	0x00049e16
   42758:	00049e40 	.word	0x00049e40
   4275c:	00049e5e 	.word	0x00049e5e
   42760:	00049e83 	.word	0x00049e83
   42764:	00049e9d 	.word	0x00049e9d

00042768 <mem_manage_fault.isra.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   42768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4276c:	4b28      	ldr	r3, [pc, #160]	; (42810 <mem_manage_fault.isra.0+0xa8>)
   4276e:	4c29      	ldr	r4, [pc, #164]	; (42814 <mem_manage_fault.isra.0+0xac>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42770:	4d29      	ldr	r5, [pc, #164]	; (42818 <mem_manage_fault.isra.0+0xb0>)
   42772:	1ae4      	subs	r4, r4, r3
   42774:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
   42776:	01a4      	lsls	r4, r4, #6
   42778:	f044 0801 	orr.w	r8, r4, #1
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   4277c:	4607      	mov	r7, r0
   4277e:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   42780:	4826      	ldr	r0, [pc, #152]	; (4281c <mem_manage_fault.isra.0+0xb4>)
   42782:	4641      	mov	r1, r8
   42784:	f005 fd5e 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   42788:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   4278a:	06d0      	lsls	r0, r2, #27
   4278c:	d503      	bpl.n	42796 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
   4278e:	4641      	mov	r1, r8
   42790:	4823      	ldr	r0, [pc, #140]	; (42820 <mem_manage_fault.isra.0+0xb8>)
   42792:	f005 fd57 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   42796:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42798:	0719      	lsls	r1, r3, #28
   4279a:	d504      	bpl.n	427a6 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   4279c:	4821      	ldr	r0, [pc, #132]	; (42824 <mem_manage_fault.isra.0+0xbc>)
   4279e:	f044 0101 	orr.w	r1, r4, #1
   427a2:	f005 fd4f 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   427a6:	4d1c      	ldr	r5, [pc, #112]	; (42818 <mem_manage_fault.isra.0+0xb0>)
   427a8:	6aab      	ldr	r3, [r5, #40]	; 0x28
   427aa:	079a      	lsls	r2, r3, #30
   427ac:	d512      	bpl.n	427d4 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
   427ae:	f044 0801 	orr.w	r8, r4, #1
   427b2:	4641      	mov	r1, r8
   427b4:	481c      	ldr	r0, [pc, #112]	; (42828 <mem_manage_fault.isra.0+0xc0>)
   427b6:	f005 fd45 	bl	48244 <log_0>
		uint32_t temp = SCB->MMFAR;
   427ba:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   427bc:	6aab      	ldr	r3, [r5, #40]	; 0x28
   427be:	061b      	lsls	r3, r3, #24
   427c0:	d508      	bpl.n	427d4 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   427c2:	4642      	mov	r2, r8
   427c4:	4819      	ldr	r0, [pc, #100]	; (4282c <mem_manage_fault.isra.0+0xc4>)
   427c6:	f005 fd4a 	bl	4825e <log_1>
			if (from_hard_fault != 0) {
   427ca:	b11f      	cbz	r7, 427d4 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   427cc:	6aab      	ldr	r3, [r5, #40]	; 0x28
   427ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   427d2:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   427d4:	4d10      	ldr	r5, [pc, #64]	; (42818 <mem_manage_fault.isra.0+0xb0>)
   427d6:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   427d8:	07d0      	lsls	r0, r2, #31
   427da:	d504      	bpl.n	427e6 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
   427dc:	4814      	ldr	r0, [pc, #80]	; (42830 <mem_manage_fault.isra.0+0xc8>)
   427de:	f044 0101 	orr.w	r1, r4, #1
   427e2:	f005 fd2f 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   427e6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   427e8:	0699      	lsls	r1, r3, #26
   427ea:	d504      	bpl.n	427f6 <mem_manage_fault.isra.0+0x8e>
		PR_FAULT_INFO(
   427ec:	4811      	ldr	r0, [pc, #68]	; (42834 <mem_manage_fault.isra.0+0xcc>)
   427ee:	f044 0101 	orr.w	r1, r4, #1
   427f2:	f005 fd27 	bl	48244 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   427f6:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   427f8:	4b07      	ldr	r3, [pc, #28]	; (42818 <mem_manage_fault.isra.0+0xb0>)
   427fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   427fc:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   427fe:	bf58      	it	pl
   42800:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   42802:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   42804:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   42808:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   4280a:	7030      	strb	r0, [r6, #0]
}
   4280c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   42810:	00049694 	.word	0x00049694
   42814:	000496cc 	.word	0x000496cc
   42818:	e000ed00 	.word	0xe000ed00
   4281c:	00049ec8 	.word	0x00049ec8
   42820:	00049ede 	.word	0x00049ede
   42824:	00049f11 	.word	0x00049f11
   42828:	00049f24 	.word	0x00049f24
   4282c:	00049f3c 	.word	0x00049f3c
   42830:	00049f52 	.word	0x00049f52
   42834:	00049f71 	.word	0x00049f71

00042838 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   42838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4283c:	4b2a      	ldr	r3, [pc, #168]	; (428e8 <bus_fault.isra.0+0xb0>)
   4283e:	4c2b      	ldr	r4, [pc, #172]	; (428ec <bus_fault.isra.0+0xb4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   42840:	4d2b      	ldr	r5, [pc, #172]	; (428f0 <bus_fault.isra.0+0xb8>)
   42842:	1ae4      	subs	r4, r4, r3
   42844:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
   42846:	01a4      	lsls	r4, r4, #6
   42848:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   4284c:	4607      	mov	r7, r0
   4284e:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   42850:	4828      	ldr	r0, [pc, #160]	; (428f4 <bus_fault.isra.0+0xbc>)
   42852:	4641      	mov	r1, r8
   42854:	f005 fcf6 	bl	48244 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   42858:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   4285a:	04d1      	lsls	r1, r2, #19
   4285c:	d503      	bpl.n	42866 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
   4285e:	4641      	mov	r1, r8
   42860:	4825      	ldr	r0, [pc, #148]	; (428f8 <bus_fault.isra.0+0xc0>)
   42862:	f005 fcef 	bl	48244 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   42866:	6aab      	ldr	r3, [r5, #40]	; 0x28
   42868:	051a      	lsls	r2, r3, #20
   4286a:	d504      	bpl.n	42876 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
   4286c:	4823      	ldr	r0, [pc, #140]	; (428fc <bus_fault.isra.0+0xc4>)
   4286e:	f044 0101 	orr.w	r1, r4, #1
   42872:	f005 fce7 	bl	48244 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   42876:	4d1e      	ldr	r5, [pc, #120]	; (428f0 <bus_fault.isra.0+0xb8>)
   42878:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4287a:	059b      	lsls	r3, r3, #22
   4287c:	d512      	bpl.n	428a4 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
   4287e:	f044 0801 	orr.w	r8, r4, #1
   42882:	4641      	mov	r1, r8
   42884:	481e      	ldr	r0, [pc, #120]	; (42900 <bus_fault.isra.0+0xc8>)
   42886:	f005 fcdd 	bl	48244 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   4288a:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   4288c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4288e:	0418      	lsls	r0, r3, #16
   42890:	d508      	bpl.n	428a4 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   42892:	4642      	mov	r2, r8
   42894:	481b      	ldr	r0, [pc, #108]	; (42904 <bus_fault.isra.0+0xcc>)
   42896:	f005 fce2 	bl	4825e <log_1>
			if (from_hard_fault != 0) {
   4289a:	b11f      	cbz	r7, 428a4 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   4289c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   4289e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   428a2:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   428a4:	4d12      	ldr	r5, [pc, #72]	; (428f0 <bus_fault.isra.0+0xb8>)
   428a6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   428a8:	0559      	lsls	r1, r3, #21
   428aa:	d504      	bpl.n	428b6 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
   428ac:	4816      	ldr	r0, [pc, #88]	; (42908 <bus_fault.isra.0+0xd0>)
   428ae:	f044 0101 	orr.w	r1, r4, #1
   428b2:	f005 fcc7 	bl	48244 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   428b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   428b8:	05da      	lsls	r2, r3, #23
   428ba:	d50d      	bpl.n	428d8 <bus_fault.isra.0+0xa0>
		PR_FAULT_INFO("  Instruction bus error");
   428bc:	4813      	ldr	r0, [pc, #76]	; (4290c <bus_fault.isra.0+0xd4>)
   428be:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   428c2:	f005 fcbf 	bl	48244 <log_0>
	*recoverable = memory_fault_recoverable(esf, true);
   428c6:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   428c8:	4a09      	ldr	r2, [pc, #36]	; (428f0 <bus_fault.isra.0+0xb8>)
   428ca:	6a93      	ldr	r3, [r2, #40]	; 0x28
   428cc:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   428d0:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   428d2:	7030      	strb	r0, [r6, #0]
}
   428d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   428d8:	6aab      	ldr	r3, [r5, #40]	; 0x28
   428da:	049b      	lsls	r3, r3, #18
   428dc:	d5f3      	bpl.n	428c6 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   428de:	480c      	ldr	r0, [pc, #48]	; (42910 <bus_fault.isra.0+0xd8>)
   428e0:	f044 0101 	orr.w	r1, r4, #1
   428e4:	e7ed      	b.n	428c2 <bus_fault.isra.0+0x8a>
   428e6:	bf00      	nop
   428e8:	00049694 	.word	0x00049694
   428ec:	000496cc 	.word	0x000496cc
   428f0:	e000ed00 	.word	0xe000ed00
   428f4:	00049fa0 	.word	0x00049fa0
   428f8:	00049fb6 	.word	0x00049fb6
   428fc:	00049f11 	.word	0x00049f11
   42900:	00049fc7 	.word	0x00049fc7
   42904:	00049fe0 	.word	0x00049fe0
   42908:	00049ff5 	.word	0x00049ff5
   4290c:	0004a010 	.word	0x0004a010
   42910:	00049f71 	.word	0x00049f71

00042914 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   42914:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   42918:	4b68      	ldr	r3, [pc, #416]	; (42abc <z_arm_fault+0x1a8>)
{
   4291a:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   4291c:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   42920:	4689      	mov	r9, r1
   42922:	4614      	mov	r4, r2
   42924:	2700      	movs	r7, #0
   42926:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   42928:	f3c8 0608 	ubfx	r6, r8, #0, #9
   4292c:	f387 8811 	msr	BASEPRI, r7
   42930:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   42934:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   42938:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   4293c:	d124      	bne.n	42988 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   4293e:	07d0      	lsls	r0, r2, #31
   42940:	d422      	bmi.n	42988 <z_arm_fault+0x74>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   42942:	0651      	lsls	r1, r2, #25
   42944:	d403      	bmi.n	4294e <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   42946:	0722      	lsls	r2, r4, #28
   42948:	d40e      	bmi.n	42968 <z_arm_fault+0x54>
			*nested_exc = true;
   4294a:	2701      	movs	r7, #1
   4294c:	e00e      	b.n	4296c <z_arm_fault+0x58>
   4294e:	495c      	ldr	r1, [pc, #368]	; (42ac0 <z_arm_fault+0x1ac>)
   42950:	4b5c      	ldr	r3, [pc, #368]	; (42ac4 <z_arm_fault+0x1b0>)
		PR_FAULT_INFO("Exception occurred in Secure State");
   42952:	485d      	ldr	r0, [pc, #372]	; (42ac8 <z_arm_fault+0x1b4>)
   42954:	1a5b      	subs	r3, r3, r1
   42956:	08db      	lsrs	r3, r3, #3
   42958:	019b      	lsls	r3, r3, #6
   4295a:	f043 0101 	orr.w	r1, r3, #1
   4295e:	f005 fc71 	bl	48244 <log_0>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   42962:	f014 0704 	ands.w	r7, r4, #4
   42966:	d001      	beq.n	4296c <z_arm_fault+0x58>
			ptr_esf = (z_arch_esf_t *)psp;
   42968:	464d      	mov	r5, r9
	*nested_exc = false;
   4296a:	2700      	movs	r7, #0
	*recoverable = false;
   4296c:	2300      	movs	r3, #0
   4296e:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   42972:	1ef3      	subs	r3, r6, #3
   42974:	2b09      	cmp	r3, #9
   42976:	f200 8088 	bhi.w	42a8a <z_arm_fault+0x176>
   4297a:	e8df f003 	tbb	[pc, r3]
   4297e:	7507      	.short	0x7507
   42980:	86867279 	.word	0x86867279
   42984:	7d868686 	.word	0x7d868686
		return NULL;
   42988:	463d      	mov	r5, r7
   4298a:	e7ef      	b.n	4296c <z_arm_fault+0x58>
	*recoverable = false;
   4298c:	f04f 0800 	mov.w	r8, #0
   42990:	4a4b      	ldr	r2, [pc, #300]	; (42ac0 <z_arm_fault+0x1ac>)
   42992:	4e4c      	ldr	r6, [pc, #304]	; (42ac4 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** HARD FAULT *****");
   42994:	484d      	ldr	r0, [pc, #308]	; (42acc <z_arm_fault+0x1b8>)
   42996:	1ab6      	subs	r6, r6, r2
   42998:	08f6      	lsrs	r6, r6, #3
   4299a:	01b6      	lsls	r6, r6, #6
   4299c:	f046 0601 	orr.w	r6, r6, #1
   429a0:	4631      	mov	r1, r6
   429a2:	f005 fc4f 	bl	48244 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   429a6:	4b45      	ldr	r3, [pc, #276]	; (42abc <z_arm_fault+0x1a8>)
	*recoverable = false;
   429a8:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   429ac:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   429ae:	f014 0402 	ands.w	r4, r4, #2
   429b2:	d005      	beq.n	429c0 <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
   429b4:	4631      	mov	r1, r6
   429b6:	4846      	ldr	r0, [pc, #280]	; (42ad0 <z_arm_fault+0x1bc>)
	PR_FAULT_INFO(
   429b8:	f005 fc44 	bl	48244 <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   429bc:	2400      	movs	r4, #0
}
   429be:	e006      	b.n	429ce <z_arm_fault+0xba>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   429c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   429c2:	2a00      	cmp	r2, #0
   429c4:	da1d      	bge.n	42a02 <z_arm_fault+0xee>
		PR_EXC("  Debug event");
   429c6:	4631      	mov	r1, r6
   429c8:	4842      	ldr	r0, [pc, #264]	; (42ad4 <z_arm_fault+0x1c0>)
   429ca:	f005 fc3b 	bl	48244 <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   429ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
   429d2:	b99b      	cbnz	r3, 429fc <z_arm_fault+0xe8>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   429d4:	2220      	movs	r2, #32
   429d6:	4629      	mov	r1, r5
   429d8:	a802      	add	r0, sp, #8
   429da:	f005 ffa4 	bl	48926 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   429de:	9b09      	ldr	r3, [sp, #36]	; 0x24
   429e0:	2f00      	cmp	r7, #0
   429e2:	d066      	beq.n	42ab2 <z_arm_fault+0x19e>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   429e4:	f3c3 0208 	ubfx	r2, r3, #0, #9
   429e8:	b922      	cbnz	r2, 429f4 <z_arm_fault+0xe0>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   429ea:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   429ee:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   429f2:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   429f4:	4620      	mov	r0, r4
   429f6:	a902      	add	r1, sp, #8
   429f8:	f7ff fcfa 	bl	423f0 <z_arm_fatal_error>
}
   429fc:	b00b      	add	sp, #44	; 0x2c
   429fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   42a02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   42a04:	005b      	lsls	r3, r3, #1
   42a06:	d5e2      	bpl.n	429ce <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   42a08:	4631      	mov	r1, r6
   42a0a:	4833      	ldr	r0, [pc, #204]	; (42ad8 <z_arm_fault+0x1c4>)
   42a0c:	f005 fc1a 	bl	48244 <log_0>
	uint16_t fault_insn = *(ret_addr - 1);
   42a10:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   42a12:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   42a16:	f64d 7302 	movw	r3, #57090	; 0xdf02
   42a1a:	429a      	cmp	r2, r3
   42a1c:	d00c      	beq.n	42a38 <z_arm_fault+0x124>
		} else if (SCB_MMFSR != 0) {
   42a1e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   42a22:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   42a26:	781b      	ldrb	r3, [r3, #0]
   42a28:	b16b      	cbz	r3, 42a46 <z_arm_fault+0x132>
			reason = mem_manage_fault(esf, 1, recoverable);
   42a2a:	2001      	movs	r0, #1
   42a2c:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   42a30:	f7ff fe9a 	bl	42768 <mem_manage_fault.isra.0>
   42a34:	4604      	mov	r4, r0
		break;
   42a36:	e7ca      	b.n	429ce <z_arm_fault+0xba>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   42a38:	4632      	mov	r2, r6
   42a3a:	6829      	ldr	r1, [r5, #0]
   42a3c:	4827      	ldr	r0, [pc, #156]	; (42adc <z_arm_fault+0x1c8>)
   42a3e:	f005 fc0e 	bl	4825e <log_1>
			reason = esf->basic.r0;
   42a42:	682c      	ldr	r4, [r5, #0]
   42a44:	e7c3      	b.n	429ce <z_arm_fault+0xba>
		} else if (SCB_BFSR != 0) {
   42a46:	4b26      	ldr	r3, [pc, #152]	; (42ae0 <z_arm_fault+0x1cc>)
   42a48:	781b      	ldrb	r3, [r3, #0]
   42a4a:	b12b      	cbz	r3, 42a58 <z_arm_fault+0x144>
			reason = bus_fault(esf, 1, recoverable);
   42a4c:	2001      	movs	r0, #1
   42a4e:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   42a52:	f7ff fef1 	bl	42838 <bus_fault.isra.0>
   42a56:	e7ed      	b.n	42a34 <z_arm_fault+0x120>
		} else if (SCB_UFSR != 0) {
   42a58:	4b22      	ldr	r3, [pc, #136]	; (42ae4 <z_arm_fault+0x1d0>)
   42a5a:	881b      	ldrh	r3, [r3, #0]
   42a5c:	b29b      	uxth	r3, r3
   42a5e:	2b00      	cmp	r3, #0
   42a60:	d0b5      	beq.n	429ce <z_arm_fault+0xba>
		reason = usage_fault(esf);
   42a62:	f7ff fe19 	bl	42698 <usage_fault.isra.0>
   42a66:	e7e5      	b.n	42a34 <z_arm_fault+0x120>
		reason = mem_manage_fault(esf, 0, recoverable);
   42a68:	2000      	movs	r0, #0
   42a6a:	f10d 0107 	add.w	r1, sp, #7
   42a6e:	e7df      	b.n	42a30 <z_arm_fault+0x11c>
		reason = bus_fault(esf, 0, recoverable);
   42a70:	2000      	movs	r0, #0
   42a72:	f10d 0107 	add.w	r1, sp, #7
   42a76:	e7ec      	b.n	42a52 <z_arm_fault+0x13e>
   42a78:	4912      	ldr	r1, [pc, #72]	; (42ac4 <z_arm_fault+0x1b0>)
   42a7a:	4b11      	ldr	r3, [pc, #68]	; (42ac0 <z_arm_fault+0x1ac>)
	PR_FAULT_INFO(
   42a7c:	481a      	ldr	r0, [pc, #104]	; (42ae8 <z_arm_fault+0x1d4>)
   42a7e:	1ac9      	subs	r1, r1, r3
   42a80:	08c9      	lsrs	r1, r1, #3
   42a82:	0189      	lsls	r1, r1, #6
   42a84:	f041 0101 	orr.w	r1, r1, #1
   42a88:	e796      	b.n	429b8 <z_arm_fault+0xa4>
   42a8a:	4a0d      	ldr	r2, [pc, #52]	; (42ac0 <z_arm_fault+0x1ac>)
   42a8c:	4b0d      	ldr	r3, [pc, #52]	; (42ac4 <z_arm_fault+0x1b0>)
	PR_FAULT_INFO("***** %s %d) *****",
   42a8e:	4817      	ldr	r0, [pc, #92]	; (42aec <z_arm_fault+0x1d8>)
   42a90:	1a9b      	subs	r3, r3, r2
   42a92:	08db      	lsrs	r3, r3, #3
   42a94:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   42a98:	ea4f 1383 	mov.w	r3, r3, lsl #6
   42a9c:	4914      	ldr	r1, [pc, #80]	; (42af0 <z_arm_fault+0x1dc>)
   42a9e:	f043 0301 	orr.w	r3, r3, #1
   42aa2:	bf18      	it	ne
   42aa4:	4601      	movne	r1, r0
   42aa6:	f1a6 0210 	sub.w	r2, r6, #16
   42aaa:	4812      	ldr	r0, [pc, #72]	; (42af4 <z_arm_fault+0x1e0>)
   42aac:	f005 fbeb 	bl	48286 <log_2>
   42ab0:	e784      	b.n	429bc <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   42ab2:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   42ab6:	f023 0301 	bic.w	r3, r3, #1
   42aba:	e79a      	b.n	429f2 <z_arm_fault+0xde>
   42abc:	e000ed00 	.word	0xe000ed00
   42ac0:	00049694 	.word	0x00049694
   42ac4:	000496cc 	.word	0x000496cc
   42ac8:	0004a028 	.word	0x0004a028
   42acc:	0004a04b 	.word	0x0004a04b
   42ad0:	0004a062 	.word	0x0004a062
   42ad4:	0004a083 	.word	0x0004a083
   42ad8:	0004a091 	.word	0x0004a091
   42adc:	0004a0b0 	.word	0x0004a0b0
   42ae0:	e000ed29 	.word	0xe000ed29
   42ae4:	e000ed2a 	.word	0xe000ed2a
   42ae8:	0004a0cc 	.word	0x0004a0cc
   42aec:	0004a105 	.word	0x0004a105
   42af0:	0004a0f0 	.word	0x0004a0f0
   42af4:	0004a11e 	.word	0x0004a11e

00042af8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   42af8:	4b04      	ldr	r3, [pc, #16]	; (42b0c <z_arm_fault_init+0x14>)
   42afa:	695a      	ldr	r2, [r3, #20]
   42afc:	f042 0210 	orr.w	r2, r2, #16
   42b00:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   42b02:	695a      	ldr	r2, [r3, #20]
   42b04:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   42b08:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   42b0a:	4770      	bx	lr
   42b0c:	e000ed00 	.word	0xe000ed00

00042b10 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   42b10:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   42b14:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   42b18:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   42b1a:	4672      	mov	r2, lr
	bl z_arm_fault
   42b1c:	f7ff fefa 	bl	42914 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   42b20:	bd01      	pop	{r0, pc}
   42b22:	bf00      	nop

00042b24 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   42b24:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   42b26:	2120      	movs	r1, #32
   42b28:	4803      	ldr	r0, [pc, #12]	; (42b38 <z_arm_interrupt_init+0x14>)
   42b2a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   42b2c:	3301      	adds	r3, #1
   42b2e:	2b41      	cmp	r3, #65	; 0x41
   42b30:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   42b34:	d1f9      	bne.n	42b2a <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   42b36:	4770      	bx	lr
   42b38:	e000e100 	.word	0xe000e100

00042b3c <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   42b3c:	2000      	movs	r0, #0
    msr CONTROL, r0
   42b3e:	f380 8814 	msr	CONTROL, r0
    isb
   42b42:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   42b46:	2000      	movs	r0, #0
    msr MSPLIM, r0
   42b48:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   42b4c:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   42b50:	f006 fc2e 	bl	493b0 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   42b54:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   42b56:	490e      	ldr	r1, [pc, #56]	; (42b90 <__start+0x54>)
    str r0, [r1]
   42b58:	6008      	str	r0, [r1, #0]
    dsb
   42b5a:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42b5e:	480d      	ldr	r0, [pc, #52]	; (42b94 <__start+0x58>)
    msr msp, r0
   42b60:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   42b64:	f000 f82a 	bl	42bbc <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   42b68:	2020      	movs	r0, #32
    msr BASEPRI, r0
   42b6a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   42b6e:	480a      	ldr	r0, [pc, #40]	; (42b98 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   42b70:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   42b74:	1840      	adds	r0, r0, r1
    msr PSP, r0
   42b76:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   42b7a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   42b7e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   42b80:	4308      	orrs	r0, r1
    msr CONTROL, r0
   42b82:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   42b86:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   42b8a:	f7ff fcaf 	bl	424ec <z_arm_prep_c>
   42b8e:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   42b90:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   42b94:	20023330 	.word	0x20023330
    ldr r0, =z_interrupt_stacks
   42b98:	20023470 	.word	0x20023470

00042b9c <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   42b9c:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   42b9e:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   42ba0:	4a05      	ldr	r2, [pc, #20]	; (42bb8 <z_arm_clear_arm_mpu_config+0x1c>)
   42ba2:	6811      	ldr	r1, [r2, #0]
	int num_regions =
   42ba4:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
   42ba8:	428b      	cmp	r3, r1
   42baa:	d100      	bne.n	42bae <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
   42bac:	4770      	bx	lr
  mpu->RNR = rnr;
   42bae:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   42bb0:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
   42bb2:	3301      	adds	r3, #1
   42bb4:	e7f8      	b.n	42ba8 <z_arm_clear_arm_mpu_config+0xc>
   42bb6:	bf00      	nop
   42bb8:	e000ed90 	.word	0xe000ed90

00042bbc <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
   42bbc:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   42bbe:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   42bc0:	2400      	movs	r4, #0
   42bc2:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   42bc6:	f7ff ffe9 	bl	42b9c <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   42bca:	4a0e      	ldr	r2, [pc, #56]	; (42c04 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
   42bcc:	4623      	mov	r3, r4
   42bce:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
   42bd0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   42bd4:	f103 0020 	add.w	r0, r3, #32
   42bd8:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   42bda:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   42bdc:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   42be0:	d1f8      	bne.n	42bd4 <z_arm_init_arch_hw_at_boot+0x18>
   42be2:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   42be4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42be8:	f103 0260 	add.w	r2, r3, #96	; 0x60
   42bec:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   42bee:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   42bf0:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   42bf4:	d1f8      	bne.n	42be8 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   42bf6:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   42bf8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42bfc:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   42c00:	bd10      	pop	{r4, pc}
   42c02:	bf00      	nop
   42c04:	e000e100 	.word	0xe000e100

00042c08 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   42c08:	4b06      	ldr	r3, [pc, #24]	; (42c24 <z_impl_k_thread_abort+0x1c>)
   42c0a:	689b      	ldr	r3, [r3, #8]
   42c0c:	4283      	cmp	r3, r0
   42c0e:	d107      	bne.n	42c20 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   42c10:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   42c14:	b123      	cbz	r3, 42c20 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   42c16:	4a04      	ldr	r2, [pc, #16]	; (42c28 <z_impl_k_thread_abort+0x20>)
   42c18:	6853      	ldr	r3, [r2, #4]
   42c1a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   42c1e:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   42c20:	f004 bac4 	b.w	471ac <z_thread_abort>
   42c24:	2001ade8 	.word	0x2001ade8
   42c28:	e000ed00 	.word	0xe000ed00

00042c2c <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   42c2c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   42c2e:	4c09      	ldr	r4, [pc, #36]	; (42c54 <z_arm_configure_static_mpu_regions+0x28>)
   42c30:	4a09      	ldr	r2, [pc, #36]	; (42c58 <z_arm_configure_static_mpu_regions+0x2c>)
   42c32:	4623      	mov	r3, r4
   42c34:	2101      	movs	r1, #1
   42c36:	4809      	ldr	r0, [pc, #36]	; (42c5c <z_arm_configure_static_mpu_regions+0x30>)
   42c38:	f000 f912 	bl	42e60 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   42c3c:	2300      	movs	r3, #0
   42c3e:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   42c40:	4b07      	ldr	r3, [pc, #28]	; (42c60 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   42c42:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   42c44:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   42c46:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   42c48:	9301      	str	r3, [sp, #4]
   42c4a:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   42c4c:	f000 f912 	bl	42e74 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   42c50:	b004      	add	sp, #16
   42c52:	bd10      	pop	{r4, pc}
   42c54:	20040000 	.word	0x20040000
   42c58:	2001a500 	.word	0x2001a500
   42c5c:	000497d8 	.word	0x000497d8
   42c60:	2001a6d0 	.word	0x2001a6d0

00042c64 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   42c64:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42c66:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   42c68:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   42c6a:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   42c6e:	f004 031f 	and.w	r3, r4, #31
   42c72:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42c74:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42c76:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   42c78:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   42c7c:	4904      	ldr	r1, [pc, #16]	; (42c90 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   42c7e:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   42c82:	f043 0301 	orr.w	r3, r3, #1
   42c86:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   42c88:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   42c8a:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   42c8c:	bd10      	pop	{r4, pc}
   42c8e:	bf00      	nop
   42c90:	e000ed90 	.word	0xe000ed90

00042c94 <region_allocate_and_init>:

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   42c94:	280f      	cmp	r0, #15
{
   42c96:	b510      	push	{r4, lr}
	if (index > (get_num_regions() - 1U)) {
   42c98:	d90d      	bls.n	42cb6 <region_allocate_and_init+0x22>
   42c9a:	4b08      	ldr	r3, [pc, #32]	; (42cbc <region_allocate_and_init+0x28>)
   42c9c:	4a08      	ldr	r2, [pc, #32]	; (42cc0 <region_allocate_and_init+0x2c>)

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   42c9e:	4601      	mov	r1, r0
   42ca0:	1ad2      	subs	r2, r2, r3
   42ca2:	08d2      	lsrs	r2, r2, #3
   42ca4:	0192      	lsls	r2, r2, #6
   42ca6:	4807      	ldr	r0, [pc, #28]	; (42cc4 <region_allocate_and_init+0x30>)
   42ca8:	f042 0201 	orr.w	r2, r2, #1
   42cac:	f005 fad7 	bl	4825e <log_1>
		return -EINVAL;
   42cb0:	f06f 0015 	mvn.w	r0, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   42cb4:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   42cb6:	f7ff ffd5 	bl	42c64 <region_init>
	return index;
   42cba:	e7fb      	b.n	42cb4 <region_allocate_and_init+0x20>
   42cbc:	00049694 	.word	0x00049694
   42cc0:	000496bc 	.word	0x000496bc
   42cc4:	0004a135 	.word	0x0004a135

00042cc8 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42cc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42ccc:	4689      	mov	r9, r1
   42cce:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   42cd0:	4606      	mov	r6, r0
   42cd2:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = index;
   42cd6:	4d54      	ldr	r5, [pc, #336]	; (42e28 <mpu_configure_regions_and_partition.constprop.0+0x160>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   42cd8:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   42cda:	45c8      	cmp	r8, r9
   42cdc:	da33      	bge.n	42d46 <mpu_configure_regions_and_partition.constprop.0+0x7e>
		if (regions[i].size == 0U) {
   42cde:	f8d6 a004 	ldr.w	sl, [r6, #4]
   42ce2:	f1ba 0f00 	cmp.w	sl, #0
   42ce6:	d04d      	beq.n	42d84 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		&&
   42ce8:	f1ba 0f1f 	cmp.w	sl, #31
   42cec:	d91e      	bls.n	42d2c <mpu_configure_regions_and_partition.constprop.0+0x64>
		&&
   42cee:	f01a 0f1f 	tst.w	sl, #31
   42cf2:	d11b      	bne.n	42d2c <mpu_configure_regions_and_partition.constprop.0+0x64>
		((part->start &
   42cf4:	f8d6 b000 	ldr.w	fp, [r6]
		&&
   42cf8:	f01b 0f1f 	tst.w	fp, #31
   42cfc:	d116      	bne.n	42d2c <mpu_configure_regions_and_partition.constprop.0+0x64>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42cfe:	4658      	mov	r0, fp
   42d00:	f005 fd97 	bl	48832 <arm_cmse_mpu_region_get>
   42d04:	4607      	mov	r7, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42d06:	eb0a 000b 	add.w	r0, sl, fp
   42d0a:	3801      	subs	r0, #1
   42d0c:	f005 fd91 	bl	48832 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   42d10:	4287      	cmp	r7, r0
   42d12:	d01c      	beq.n	42d4e <mpu_configure_regions_and_partition.constprop.0+0x86>
	return -EINVAL;
   42d14:	f06f 0715 	mvn.w	r7, #21
   42d18:	4a44      	ldr	r2, [pc, #272]	; (42e2c <mpu_configure_regions_and_partition.constprop.0+0x164>)
   42d1a:	4b45      	ldr	r3, [pc, #276]	; (42e30 <mpu_configure_regions_and_partition.constprop.0+0x168>)
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   42d1c:	4639      	mov	r1, r7
   42d1e:	1ad2      	subs	r2, r2, r3
   42d20:	08d2      	lsrs	r2, r2, #3
   42d22:	0192      	lsls	r2, r2, #6
   42d24:	4843      	ldr	r0, [pc, #268]	; (42e34 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
   42d26:	f042 0201 	orr.w	r2, r2, #1
   42d2a:	e008      	b.n	42d3e <mpu_configure_regions_and_partition.constprop.0+0x76>
			LOG_ERR("Partition %u: sanity check failed.", i);
   42d2c:	4641      	mov	r1, r8
   42d2e:	4a3f      	ldr	r2, [pc, #252]	; (42e2c <mpu_configure_regions_and_partition.constprop.0+0x164>)
   42d30:	4b3f      	ldr	r3, [pc, #252]	; (42e30 <mpu_configure_regions_and_partition.constprop.0+0x168>)
   42d32:	4841      	ldr	r0, [pc, #260]	; (42e38 <mpu_configure_regions_and_partition.constprop.0+0x170>)
   42d34:	1ad2      	subs	r2, r2, r3
   42d36:	08d2      	lsrs	r2, r2, #3
   42d38:	0192      	lsls	r2, r2, #6
   42d3a:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
   42d3e:	f005 fa8e 	bl	4825e <log_1>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   42d42:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   42d46:	4620      	mov	r0, r4
   42d48:	b005      	add	sp, #20
   42d4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   42d4e:	f117 0f16 	cmn.w	r7, #22
   42d52:	d0e1      	beq.n	42d18 <mpu_configure_regions_and_partition.constprop.0+0x50>
			(u_reg_index > (reg_index - 1))) {
   42d54:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   42d56:	42bb      	cmp	r3, r7
   42d58:	dbde      	blt.n	42d18 <mpu_configure_regions_and_partition.constprop.0+0x50>
	MPU->RNR = index;
   42d5a:	60af      	str	r7, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   42d5c:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   42d5e:	60af      	str	r7, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42d60:	692b      	ldr	r3, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   42d62:	f021 011f 	bic.w	r1, r1, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   42d66:	f043 0b1f 	orr.w	fp, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42d6a:	e9d6 3200 	ldrd	r3, r2, [r6]
   42d6e:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   42d70:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   42d72:	f102 3aff 	add.w	sl, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   42d76:	d11a      	bne.n	42dae <mpu_configure_regions_and_partition.constprop.0+0xe6>
   42d78:	45d3      	cmp	fp, sl
   42d7a:	d107      	bne.n	42d8c <mpu_configure_regions_and_partition.constprop.0+0xc4>
			mpu_configure_region(u_reg_index, &regions[i]);
   42d7c:	4631      	mov	r1, r6
   42d7e:	b2f8      	uxtb	r0, r7
   42d80:	f005 fd60 	bl	48844 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   42d84:	f108 0801 	add.w	r8, r8, #1
   42d88:	360c      	adds	r6, #12
   42d8a:	e7a6      	b.n	42cda <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   42d8c:	4631      	mov	r1, r6
	MPU->RNR = index;
   42d8e:	60af      	str	r7, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42d90:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   42d92:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42d96:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   42d9a:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   42d9c:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   42d9e:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   42da0:	f005 fd50 	bl	48844 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42da4:	f110 0f16 	cmn.w	r0, #22
   42da8:	d0cb      	beq.n	42d42 <mpu_configure_regions_and_partition.constprop.0+0x7a>
			reg_index++;
   42daa:	1c44      	adds	r4, r0, #1
   42dac:	e7ea      	b.n	42d84 <mpu_configure_regions_and_partition.constprop.0+0xbc>
		} else if (reg_last == u_reg_last) {
   42dae:	3b01      	subs	r3, #1
   42db0:	45d3      	cmp	fp, sl
   42db2:	b2e0      	uxtb	r0, r4
   42db4:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   42db8:	60af      	str	r7, [r5, #8]
		} else if (reg_last == u_reg_last) {
   42dba:	d106      	bne.n	42dca <mpu_configure_regions_and_partition.constprop.0+0x102>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42dbc:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42dbe:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42dc0:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42dc4:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42dc6:	612b      	str	r3, [r5, #16]
			reg_index =
   42dc8:	e7ea      	b.n	42da0 <mpu_configure_regions_and_partition.constprop.0+0xd8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42dca:	6929      	ldr	r1, [r5, #16]
   42dcc:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   42dd0:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   42dd2:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   42dd4:	4631      	mov	r1, r6
   42dd6:	f005 fd35 	bl	48844 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   42dda:	f110 0f16 	cmn.w	r0, #22
   42dde:	d0b0      	beq.n	42d42 <mpu_configure_regions_and_partition.constprop.0+0x7a>
	MPU->RNR = index;
   42de0:	60af      	str	r7, [r5, #8]
	attr->rbar = MPU->RBAR &
   42de2:	68ea      	ldr	r2, [r5, #12]
   42de4:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   42de8:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
	attr->rbar = MPU->RBAR &
   42dec:	f362 0304 	bfi	r3, r2, #0, #5
   42df0:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42df4:	692b      	ldr	r3, [r5, #16]
   42df6:	f89d 2008 	ldrb.w	r2, [sp, #8]
   42dfa:	085b      	lsrs	r3, r3, #1
   42dfc:	f363 1247 	bfi	r2, r3, #5, #3
   42e00:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   42e04:	e9d6 3200 	ldrd	r3, r2, [r6]
   42e08:	4413      	add	r3, r2
   42e0a:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   42e0c:	f023 031f 	bic.w	r3, r3, #31
   42e10:	445b      	add	r3, fp
   42e12:	eba3 030a 	sub.w	r3, r3, sl
			reg_index++;
   42e16:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   42e18:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   42e1c:	4669      	mov	r1, sp
   42e1e:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   42e20:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   42e22:	f7ff ff37 	bl	42c94 <region_allocate_and_init>
   42e26:	e7bd      	b.n	42da4 <mpu_configure_regions_and_partition.constprop.0+0xdc>
   42e28:	e000ed90 	.word	0xe000ed90
   42e2c:	000496bc 	.word	0x000496bc
   42e30:	00049694 	.word	0x00049694
   42e34:	0004a17e 	.word	0x0004a17e
   42e38:	0004a15b 	.word	0x0004a15b

00042e3c <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   42e3c:	2205      	movs	r2, #5
   42e3e:	4b03      	ldr	r3, [pc, #12]	; (42e4c <arm_core_mpu_enable+0x10>)
   42e40:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   42e42:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   42e46:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   42e4a:	4770      	bx	lr
   42e4c:	e000ed90 	.word	0xe000ed90

00042e50 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   42e50:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   42e54:	2200      	movs	r2, #0
   42e56:	4b01      	ldr	r3, [pc, #4]	; (42e5c <arm_core_mpu_disable+0xc>)
   42e58:	605a      	str	r2, [r3, #4]
}
   42e5a:	4770      	bx	lr
   42e5c:	e000ed90 	.word	0xe000ed90

00042e60 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   42e60:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   42e62:	4c03      	ldr	r4, [pc, #12]	; (42e70 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   42e64:	7822      	ldrb	r2, [r4, #0]
   42e66:	f7ff ff2f 	bl	42cc8 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   42e6a:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   42e6c:	bd10      	pop	{r4, pc}
   42e6e:	bf00      	nop
   42e70:	2001aee6 	.word	0x2001aee6

00042e74 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   42e74:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42e78:	4d26      	ldr	r5, [pc, #152]	; (42f14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   42e7a:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42e7c:	4606      	mov	r6, r0
   42e7e:	f04f 0800 	mov.w	r8, #0
   42e82:	46ab      	mov	fp, r5
	MPU->RNR = index;
   42e84:	4f24      	ldr	r7, [pc, #144]	; (42f18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42e86:	45d0      	cmp	r8, sl
   42e88:	da1b      	bge.n	42ec2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   42e8a:	f8d6 9004 	ldr.w	r9, [r6, #4]
   42e8e:	f1b9 0f00 	cmp.w	r9, #0
   42e92:	d039      	beq.n	42f08 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   42e94:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42e96:	4608      	mov	r0, r1
   42e98:	9101      	str	r1, [sp, #4]
   42e9a:	f005 fcca 	bl	48832 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42e9e:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   42ea0:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   42ea2:	eb09 0001 	add.w	r0, r9, r1
   42ea6:	3801      	subs	r0, #1
   42ea8:	f005 fcc3 	bl	48832 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   42eac:	4284      	cmp	r4, r0
   42eae:	f04f 0214 	mov.w	r2, #20
   42eb2:	4b1a      	ldr	r3, [pc, #104]	; (42f1c <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   42eb4:	d008      	beq.n	42ec8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   42eb6:	f06f 0315 	mvn.w	r3, #21
   42eba:	fb02 f808 	mul.w	r8, r2, r8
   42ebe:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   42ec2:	b003      	add	sp, #12
   42ec4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   42ec8:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   42ecc:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   42ece:	d0f8      	beq.n	42ec2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   42ed0:	7819      	ldrb	r1, [r3, #0]
   42ed2:	42a1      	cmp	r1, r4
   42ed4:	ddf5      	ble.n	42ec2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   42ed6:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   42eda:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   42edc:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   42ede:	68fc      	ldr	r4, [r7, #12]
   42ee0:	f100 0108 	add.w	r1, r0, #8
   42ee4:	7b00      	ldrb	r0, [r0, #12]
   42ee6:	f364 0004 	bfi	r0, r4, #0, #5
   42eea:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   42eec:	6938      	ldr	r0, [r7, #16]
   42eee:	790c      	ldrb	r4, [r1, #4]
   42ef0:	0840      	lsrs	r0, r0, #1
   42ef2:	f360 1447 	bfi	r4, r0, #5, #3
   42ef6:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   42ef8:	68f9      	ldr	r1, [r7, #12]
   42efa:	f021 011f 	bic.w	r1, r1, #31
   42efe:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   42f00:	6939      	ldr	r1, [r7, #16]
   42f02:	f021 011f 	bic.w	r1, r1, #31
   42f06:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   42f08:	f108 0801 	add.w	r8, r8, #1
   42f0c:	3514      	adds	r5, #20
   42f0e:	360c      	adds	r6, #12
   42f10:	e7b9      	b.n	42e86 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   42f12:	bf00      	nop
   42f14:	2001a974 	.word	0x2001a974
   42f18:	e000ed90 	.word	0xe000ed90
   42f1c:	2001aee6 	.word	0x2001aee6

00042f20 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   42f20:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   42f22:	4c0e      	ldr	r4, [pc, #56]	; (42f5c <z_arm_mpu_init+0x3c>)
   42f24:	6825      	ldr	r5, [r4, #0]
   42f26:	2d10      	cmp	r5, #16
   42f28:	d814      	bhi.n	42f54 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   42f2a:	f7ff ff91 	bl	42e50 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42f2e:	2000      	movs	r0, #0
	MPU->MAIR0 =
   42f30:	4b0b      	ldr	r3, [pc, #44]	; (42f60 <z_arm_mpu_init+0x40>)
   42f32:	4a0c      	ldr	r2, [pc, #48]	; (42f64 <z_arm_mpu_init+0x44>)
   42f34:	631a      	str	r2, [r3, #48]	; 0x30
   42f36:	4285      	cmp	r5, r0
   42f38:	d105      	bne.n	42f46 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   42f3a:	4b0b      	ldr	r3, [pc, #44]	; (42f68 <z_arm_mpu_init+0x48>)
   42f3c:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   42f3e:	f7ff ff7d 	bl	42e3c <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   42f42:	2000      	movs	r0, #0
}
   42f44:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   42f46:	6861      	ldr	r1, [r4, #4]
   42f48:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   42f4c:	f7ff fe8a 	bl	42c64 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   42f50:	3001      	adds	r0, #1
   42f52:	e7f0      	b.n	42f36 <z_arm_mpu_init+0x16>
		return -1;
   42f54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42f58:	e7f4      	b.n	42f44 <z_arm_mpu_init+0x24>
   42f5a:	bf00      	nop
   42f5c:	000497e4 	.word	0x000497e4
   42f60:	e000ed90 	.word	0xe000ed90
   42f64:	0044ffaa 	.word	0x0044ffaa
   42f68:	2001aee6 	.word	0x2001aee6

00042f6c <malloc>:
}

SYS_INIT(malloc_prepare, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
   42f6c:	b508      	push	{r3, lr}
   42f6e:	4908      	ldr	r1, [pc, #32]	; (42f90 <malloc+0x24>)
   42f70:	4b08      	ldr	r3, [pc, #32]	; (42f94 <malloc+0x28>)
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
   42f72:	4809      	ldr	r0, [pc, #36]	; (42f98 <malloc+0x2c>)
   42f74:	1ac9      	subs	r1, r1, r3
   42f76:	08c9      	lsrs	r1, r1, #3
   42f78:	0189      	lsls	r1, r1, #6
   42f7a:	f041 0101 	orr.w	r1, r1, #1
   42f7e:	f005 f961 	bl	48244 <log_0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   42f82:	f003 fac7 	bl	46514 <z_impl_z_errno>
	errno = ENOMEM;
   42f86:	230c      	movs	r3, #12
   42f88:	6003      	str	r3, [r0, #0]

	return NULL;
}
   42f8a:	2000      	movs	r0, #0
   42f8c:	bd08      	pop	{r3, pc}
   42f8e:	bf00      	nop
   42f90:	000496cc 	.word	0x000496cc
   42f94:	00049694 	.word	0x00049694
   42f98:	0004a1a1 	.word	0x0004a1a1

00042f9c <_exit>:

#include <stdlib.h>
#include <zephyr.h>

void _exit(int status)
{
   42f9c:	b508      	push	{r3, lr}
	printk("exit\n");
   42f9e:	4802      	ldr	r0, [pc, #8]	; (42fa8 <_exit+0xc>)
   42fa0:	f004 fdf9 	bl	47b96 <printk>
	while (1) {
   42fa4:	e7fe      	b.n	42fa4 <_exit+0x8>
   42fa6:	bf00      	nop
   42fa8:	0004a1cc 	.word	0x0004a1cc

00042fac <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   42fac:	4b01      	ldr	r3, [pc, #4]	; (42fb4 <__stdout_hook_install+0x8>)
   42fae:	6018      	str	r0, [r3, #0]
}
   42fb0:	4770      	bx	lr
   42fb2:	bf00      	nop
   42fb4:	2001a568 	.word	0x2001a568

00042fb8 <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
   42fb8:	3902      	subs	r1, #2
   42fba:	2901      	cmp	r1, #1
   42fbc:	d802      	bhi.n	42fc4 <z_impl_zephyr_fputc+0xc>
   42fbe:	4b03      	ldr	r3, [pc, #12]	; (42fcc <z_impl_zephyr_fputc+0x14>)
   42fc0:	681b      	ldr	r3, [r3, #0]
   42fc2:	4718      	bx	r3
}
   42fc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   42fc8:	4770      	bx	lr
   42fca:	bf00      	nop
   42fcc:	2001a568 	.word	0x2001a568

00042fd0 <sprintf>:
	*(p.ptr) = 0;
	return r;
}

int sprintf(char *ZRESTRICT str, const char *ZRESTRICT format, ...)
{
   42fd0:	b40e      	push	{r1, r2, r3}
   42fd2:	b50f      	push	{r0, r1, r2, r3, lr}

	struct emitter p;
	int     r;

	p.ptr = str;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   42fd4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
   42fd8:	ab05      	add	r3, sp, #20
   42fda:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = str;
   42fde:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
   42fe0:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
   42fe2:	4806      	ldr	r0, [pc, #24]	; (42ffc <sprintf+0x2c>)
   42fe4:	a902      	add	r1, sp, #8
	va_start(vargs, format);
   42fe6:	9301      	str	r3, [sp, #4]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
   42fe8:	f7fd ff2a 	bl	40e40 <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
   42fec:	2200      	movs	r2, #0
   42fee:	9b02      	ldr	r3, [sp, #8]
   42ff0:	701a      	strb	r2, [r3, #0]
	return r;
}
   42ff2:	b004      	add	sp, #16
   42ff4:	f85d eb04 	ldr.w	lr, [sp], #4
   42ff8:	b003      	add	sp, #12
   42ffa:	4770      	bx	lr
   42ffc:	00048959 	.word	0x00048959

00043000 <printf>:

	return r;
}

int printf(const char *ZRESTRICT format, ...)
{
   43000:	b40f      	push	{r0, r1, r2, r3}
   43002:	b507      	push	{r0, r1, r2, lr}
   43004:	ab04      	add	r3, sp, #16
   43006:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   4300a:	2102      	movs	r1, #2
   4300c:	4804      	ldr	r0, [pc, #16]	; (43020 <printf+0x20>)
	va_start(vargs, format);
   4300e:	9301      	str	r3, [sp, #4]
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
   43010:	f7fd ff16 	bl	40e40 <cbvprintf>
	va_end(vargs);

	return r;
}
   43014:	b003      	add	sp, #12
   43016:	f85d eb04 	ldr.w	lr, [sp], #4
   4301a:	b004      	add	sp, #16
   4301c:	4770      	bx	lr
   4301e:	bf00      	nop
   43020:	00048955 	.word	0x00048955

00043024 <onoff_stop>:
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   43024:	b570      	push	{r4, r5, r6, lr}
   43026:	4604      	mov	r4, r0
	err = set_off_state(&subdata->flags, ctx);
   43028:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   4302a:	480d      	ldr	r0, [pc, #52]	; (43060 <onoff_stop+0x3c>)
{
   4302c:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
   4302e:	1a23      	subs	r3, r4, r0
   43030:	109a      	asrs	r2, r3, #2
   43032:	4b0c      	ldr	r3, [pc, #48]	; (43064 <onoff_stop+0x40>)
	err = set_off_state(&subdata->flags, ctx);
   43034:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   43036:	4353      	muls	r3, r2
   43038:	b2db      	uxtb	r3, r3
	err = set_off_state(&subdata->flags, ctx);
   4303a:	435d      	muls	r5, r3
   4303c:	f105 0340 	add.w	r3, r5, #64	; 0x40
   43040:	4418      	add	r0, r3
   43042:	f005 fc9f 	bl	48984 <set_off_state>
	if (err < 0) {
   43046:	1e01      	subs	r1, r0, #0
   43048:	db04      	blt.n	43054 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   4304a:	4b07      	ldr	r3, [pc, #28]	; (43068 <onoff_stop+0x44>)
   4304c:	442b      	add	r3, r5
   4304e:	685b      	ldr	r3, [r3, #4]
   43050:	4798      	blx	r3
	return 0;
   43052:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   43054:	4620      	mov	r0, r4
   43056:	4633      	mov	r3, r6
}
   43058:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   4305c:	4718      	bx	r3
   4305e:	bf00      	nop
   43060:	2001a998 	.word	0x2001a998
   43064:	b6db6db7 	.word	0xb6db6db7
   43068:	00049824 	.word	0x00049824

0004306c <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   4306c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   43070:	4c0f      	ldr	r4, [pc, #60]	; (430b0 <onoff_start+0x44>)
   43072:	4d10      	ldr	r5, [pc, #64]	; (430b4 <onoff_start+0x48>)
   43074:	1b03      	subs	r3, r0, r4
   43076:	109b      	asrs	r3, r3, #2
   43078:	435d      	muls	r5, r3
   4307a:	b2eb      	uxtb	r3, r5
	err = set_starting_state(&subdata->flags, ctx);
   4307c:	250c      	movs	r5, #12
   4307e:	435d      	muls	r5, r3
{
   43080:	4607      	mov	r7, r0
	err = set_starting_state(&subdata->flags, ctx);
   43082:	f105 0040 	add.w	r0, r5, #64	; 0x40
{
   43086:	460e      	mov	r6, r1
	err = set_starting_state(&subdata->flags, ctx);
   43088:	4420      	add	r0, r4
   4308a:	2140      	movs	r1, #64	; 0x40
   4308c:	f005 fc93 	bl	489b6 <set_starting_state>
	if (err < 0) {
   43090:	1e01      	subs	r1, r0, #0
   43092:	db08      	blt.n	430a6 <onoff_start+0x3a>
	subdata->cb = cb;
   43094:	4b08      	ldr	r3, [pc, #32]	; (430b8 <onoff_start+0x4c>)
   43096:	442c      	add	r4, r5
	subdata->user_data = user_data;
   43098:	e9c4 360e 	strd	r3, r6, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   4309c:	4b07      	ldr	r3, [pc, #28]	; (430bc <onoff_start+0x50>)
   4309e:	595b      	ldr	r3, [r3, r5]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   430a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   430a4:	4718      	bx	r3
		notify(mgr, err);
   430a6:	4638      	mov	r0, r7
   430a8:	4633      	mov	r3, r6
}
   430aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   430ae:	4718      	bx	r3
   430b0:	2001a998 	.word	0x2001a998
   430b4:	b6db6db7 	.word	0xb6db6db7
   430b8:	00048a19 	.word	0x00048a19
   430bc:	00049824 	.word	0x00049824

000430c0 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   430c0:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   430c2:	2200      	movs	r2, #0
   430c4:	2101      	movs	r1, #1
{
   430c6:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   430c8:	2005      	movs	r0, #5
   430ca:	f7ff f9e7 	bl	4249c <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   430ce:	2005      	movs	r0, #5
   430d0:	f7ff f9c6 	bl	42460 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   430d4:	480f      	ldr	r0, [pc, #60]	; (43114 <clk_init+0x54>)
   430d6:	f001 f8ef 	bl	442b8 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   430da:	4b0f      	ldr	r3, [pc, #60]	; (43118 <clk_init+0x58>)
   430dc:	4298      	cmp	r0, r3
   430de:	d115      	bne.n	4310c <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   430e0:	f005 fdd4 	bl	48c8c <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   430e4:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   430e6:	490d      	ldr	r1, [pc, #52]	; (4311c <clk_init+0x5c>)
   430e8:	4630      	mov	r0, r6
   430ea:	f004 fdbd 	bl	47c68 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   430ee:	2800      	cmp	r0, #0
   430f0:	db0b      	blt.n	4310a <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   430f2:	2501      	movs	r5, #1
   430f4:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   430f6:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   430f8:	4908      	ldr	r1, [pc, #32]	; (4311c <clk_init+0x5c>)
   430fa:	f104 001c 	add.w	r0, r4, #28
   430fe:	f004 fdb3 	bl	47c68 <onoff_manager_init>
		if (err < 0) {
   43102:	2800      	cmp	r0, #0
   43104:	db01      	blt.n	4310a <clk_init+0x4a>
	}

	return 0;
   43106:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   43108:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   4310a:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   4310c:	f06f 0004 	mvn.w	r0, #4
   43110:	e7fb      	b.n	4310a <clk_init+0x4a>
   43112:	bf00      	nop
   43114:	00043155 	.word	0x00043155
   43118:	0bad0000 	.word	0x0bad0000
   4311c:	0004983c 	.word	0x0004983c

00043120 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   43120:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   43122:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   43124:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   43126:	434b      	muls	r3, r1
   43128:	4808      	ldr	r0, [pc, #32]	; (4314c <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   4312a:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   4312c:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   4312e:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   43130:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   43134:	4418      	add	r0, r3
	sub_data->cb = NULL;
   43136:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   43138:	f005 fc5b 	bl	489f2 <set_on_state>
	if (callback) {
   4313c:	b12d      	cbz	r5, 4314a <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   4313e:	4632      	mov	r2, r6
   43140:	462b      	mov	r3, r5
}
   43142:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   43146:	4802      	ldr	r0, [pc, #8]	; (43150 <clkstarted_handle.constprop.0+0x30>)
   43148:	4718      	bx	r3
}
   4314a:	bd70      	pop	{r4, r5, r6, pc}
   4314c:	2001a998 	.word	0x2001a998
   43150:	0004942c 	.word	0x0004942c

00043154 <clock_event_handler>:
	switch (event) {
   43154:	b110      	cbz	r0, 4315c <clock_event_handler+0x8>
   43156:	2801      	cmp	r0, #1
   43158:	d004      	beq.n	43164 <clock_event_handler+0x10>
   4315a:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   4315c:	4b03      	ldr	r3, [pc, #12]	; (4316c <clock_event_handler+0x18>)
   4315e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   43160:	075b      	lsls	r3, r3, #29
   43162:	d101      	bne.n	43168 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   43164:	f7ff bfdc 	b.w	43120 <clkstarted_handle.constprop.0>
}
   43168:	4770      	bx	lr
   4316a:	bf00      	nop
   4316c:	2001a998 	.word	0x2001a998

00043170 <generic_hfclk_start>:
{
   43170:	b508      	push	{r3, lr}
	__asm__ volatile(
   43172:	f04f 0320 	mov.w	r3, #32
   43176:	f3ef 8111 	mrs	r1, BASEPRI
   4317a:	f383 8812 	msr	BASEPRI_MAX, r3
   4317e:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   43182:	4a11      	ldr	r2, [pc, #68]	; (431c8 <generic_hfclk_start+0x58>)
   43184:	6813      	ldr	r3, [r2, #0]
   43186:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   4318a:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   4318e:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   43190:	d00b      	beq.n	431aa <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   43192:	4a0e      	ldr	r2, [pc, #56]	; (431cc <generic_hfclk_start+0x5c>)
   43194:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   43198:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   4319c:	f013 0301 	ands.w	r3, r3, #1
   431a0:	d003      	beq.n	431aa <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   431a2:	480b      	ldr	r0, [pc, #44]	; (431d0 <generic_hfclk_start+0x60>)
   431a4:	f005 fc25 	bl	489f2 <set_on_state>
			already_started = true;
   431a8:	2301      	movs	r3, #1
	__asm__ volatile(
   431aa:	f381 8811 	msr	BASEPRI, r1
   431ae:	f3bf 8f6f 	isb	sy
	if (already_started) {
   431b2:	b123      	cbz	r3, 431be <generic_hfclk_start+0x4e>
}
   431b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   431b8:	2000      	movs	r0, #0
   431ba:	f7ff bfb1 	b.w	43120 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   431be:	2001      	movs	r0, #1
}
   431c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   431c4:	f001 b888 	b.w	442d8 <nrfx_clock_start>
   431c8:	2001a9e8 	.word	0x2001a9e8
   431cc:	40005000 	.word	0x40005000
   431d0:	2001a9d8 	.word	0x2001a9d8

000431d4 <generic_hfclk_stop>:
   431d4:	4b07      	ldr	r3, [pc, #28]	; (431f4 <generic_hfclk_stop+0x20>)
   431d6:	e8d3 2fef 	ldaex	r2, [r3]
   431da:	f022 0102 	bic.w	r1, r2, #2
   431de:	e8c3 1fe0 	stlex	r0, r1, [r3]
   431e2:	2800      	cmp	r0, #0
   431e4:	d1f7      	bne.n	431d6 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   431e6:	07d3      	lsls	r3, r2, #31
   431e8:	d402      	bmi.n	431f0 <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   431ea:	2001      	movs	r0, #1
   431ec:	f001 b8a6 	b.w	4433c <nrfx_clock_stop>
}
   431f0:	4770      	bx	lr
   431f2:	bf00      	nop
   431f4:	2001a9e8 	.word	0x2001a9e8

000431f8 <api_blocking_start>:
{
   431f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   431fa:	2200      	movs	r2, #0
   431fc:	2301      	movs	r3, #1
   431fe:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   43202:	466b      	mov	r3, sp
   43204:	4a08      	ldr	r2, [pc, #32]	; (43228 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   43206:	f8cd d000 	str.w	sp, [sp]
   4320a:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   4320e:	f005 fc29 	bl	48a64 <api_start>
	if (err < 0) {
   43212:	2800      	cmp	r0, #0
   43214:	db05      	blt.n	43222 <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   43216:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   4321a:	2300      	movs	r3, #0
   4321c:	4668      	mov	r0, sp
   4321e:	f003 fca5 	bl	46b6c <z_impl_k_sem_take>
}
   43222:	b005      	add	sp, #20
   43224:	f85d fb04 	ldr.w	pc, [sp], #4
   43228:	00048a37 	.word	0x00048a37

0004322c <z_nrf_clock_control_lf_on>:
{
   4322c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   43230:	2201      	movs	r2, #1
   43232:	4607      	mov	r7, r0
   43234:	4936      	ldr	r1, [pc, #216]	; (43310 <z_nrf_clock_control_lf_on+0xe4>)
   43236:	e8d1 3fef 	ldaex	r3, [r1]
   4323a:	e8c1 2fe0 	stlex	r0, r2, [r1]
   4323e:	2800      	cmp	r0, #0
   43240:	d1f9      	bne.n	43236 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   43242:	b933      	cbnz	r3, 43252 <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   43244:	4933      	ldr	r1, [pc, #204]	; (43314 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   43246:	4834      	ldr	r0, [pc, #208]	; (43318 <z_nrf_clock_control_lf_on+0xec>)
   43248:	604b      	str	r3, [r1, #4]
   4324a:	60cb      	str	r3, [r1, #12]
   4324c:	608a      	str	r2, [r1, #8]
   4324e:	f004 fd1e 	bl	47c8e <onoff_request>
	switch (start_mode) {
   43252:	1e7b      	subs	r3, r7, #1
   43254:	2b01      	cmp	r3, #1
   43256:	d82e      	bhi.n	432b6 <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   43258:	2f01      	cmp	r7, #1
   4325a:	d106      	bne.n	4326a <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   4325c:	4b2f      	ldr	r3, [pc, #188]	; (4331c <z_nrf_clock_control_lf_on+0xf0>)
   4325e:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   43262:	f003 0303 	and.w	r3, r3, #3
   43266:	2b02      	cmp	r3, #2
   43268:	d025      	beq.n	432b6 <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   4326a:	f005 fed5 	bl	49018 <k_is_in_isr>
   4326e:	4604      	mov	r4, r0
   43270:	b918      	cbnz	r0, 4327a <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   43272:	4b2b      	ldr	r3, [pc, #172]	; (43320 <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   43274:	781b      	ldrb	r3, [r3, #0]
   43276:	2b00      	cmp	r3, #0
   43278:	d144      	bne.n	43304 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   4327a:	f04f 0320 	mov.w	r3, #32
   4327e:	f3ef 8611 	mrs	r6, BASEPRI
   43282:	f383 8812 	msr	BASEPRI_MAX, r3
   43286:	f3bf 8f6f 	isb	sy
   4328a:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   4328c:	4d23      	ldr	r5, [pc, #140]	; (4331c <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   4328e:	f8df 809c 	ldr.w	r8, [pc, #156]	; 4332c <z_nrf_clock_control_lf_on+0x100>
   43292:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   43294:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   43298:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   4329c:	03d2      	lsls	r2, r2, #15
   4329e:	d50c      	bpl.n	432ba <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   432a0:	f003 0303 	and.w	r3, r3, #3
   432a4:	2b02      	cmp	r3, #2
   432a6:	d001      	beq.n	432ac <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   432a8:	2f01      	cmp	r7, #1
   432aa:	d106      	bne.n	432ba <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   432ac:	b334      	cbz	r4, 432fc <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   432ae:	f386 8811 	msr	BASEPRI, r6
   432b2:	f3bf 8f6f 	isb	sy
}
   432b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   432ba:	b1d4      	cbz	r4, 432f2 <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   432bc:	4630      	mov	r0, r6
   432be:	f7ff f88d 	bl	423dc <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   432c2:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   432c6:	b2db      	uxtb	r3, r3
   432c8:	2b01      	cmp	r3, #1
   432ca:	d1e3      	bne.n	43294 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   432cc:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   432d0:	2a00      	cmp	r2, #0
   432d2:	d0df      	beq.n	43294 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   432d4:	2200      	movs	r2, #0
   432d6:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   432da:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   432de:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   432e0:	2120      	movs	r1, #32
   432e2:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   432e6:	4a0f      	ldr	r2, [pc, #60]	; (43324 <z_nrf_clock_control_lf_on+0xf8>)
   432e8:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   432ec:	4a0e      	ldr	r2, [pc, #56]	; (43328 <z_nrf_clock_control_lf_on+0xfc>)
   432ee:	6013      	str	r3, [r2, #0]
}
   432f0:	e7d0      	b.n	43294 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   432f2:	2100      	movs	r1, #0
   432f4:	2001      	movs	r0, #1
   432f6:	f003 ff3f 	bl	47178 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   432fa:	e7e2      	b.n	432c2 <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   432fc:	2302      	movs	r3, #2
   432fe:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   43302:	e7d8      	b.n	432b6 <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   43304:	2202      	movs	r2, #2
   43306:	4b05      	ldr	r3, [pc, #20]	; (4331c <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   43308:	4606      	mov	r6, r0
   4330a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   4330e:	e7bd      	b.n	4328c <z_nrf_clock_control_lf_on+0x60>
   43310:	2001a9ec 	.word	0x2001a9ec
   43314:	2001a988 	.word	0x2001a988
   43318:	2001a9b4 	.word	0x2001a9b4
   4331c:	40005000 	.word	0x40005000
   43320:	20020c28 	.word	0x20020c28
   43324:	e000e100 	.word	0xe000e100
   43328:	40005008 	.word	0x40005008
   4332c:	40005104 	.word	0x40005104

00043330 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   43330:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   43332:	4808      	ldr	r0, [pc, #32]	; (43354 <uart_console_init+0x24>)
   43334:	4b08      	ldr	r3, [pc, #32]	; (43358 <uart_console_init+0x28>)
   43336:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   43338:	f005 fdaa 	bl	48e90 <z_device_ready>
   4333c:	b138      	cbz	r0, 4334e <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   4333e:	4807      	ldr	r0, [pc, #28]	; (4335c <uart_console_init+0x2c>)
   43340:	f7ff fe34 	bl	42fac <__stdout_hook_install>
	__printk_hook_install(console_out);
   43344:	4805      	ldr	r0, [pc, #20]	; (4335c <uart_console_init+0x2c>)
   43346:	f7fd fc6d 	bl	40c24 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   4334a:	2000      	movs	r0, #0
}
   4334c:	bd08      	pop	{r3, pc}
		return -ENODEV;
   4334e:	f06f 0012 	mvn.w	r0, #18
   43352:	e7fb      	b.n	4334c <uart_console_init+0x1c>
   43354:	00049474 	.word	0x00049474
   43358:	2001a9f0 	.word	0x2001a9f0
   4335c:	00043361 	.word	0x00043361

00043360 <console_out>:
	if ('\n' == c) {
   43360:	280a      	cmp	r0, #10
{
   43362:	b538      	push	{r3, r4, r5, lr}
   43364:	4604      	mov	r4, r0
   43366:	4d07      	ldr	r5, [pc, #28]	; (43384 <console_out+0x24>)
	if ('\n' == c) {
   43368:	d104      	bne.n	43374 <console_out+0x14>
   4336a:	6828      	ldr	r0, [r5, #0]
   4336c:	6883      	ldr	r3, [r0, #8]
   4336e:	210d      	movs	r1, #13
   43370:	685b      	ldr	r3, [r3, #4]
   43372:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   43374:	6828      	ldr	r0, [r5, #0]
   43376:	6883      	ldr	r3, [r0, #8]
   43378:	b2e1      	uxtb	r1, r4
   4337a:	685b      	ldr	r3, [r3, #4]
   4337c:	4798      	blx	r3
}
   4337e:	4620      	mov	r0, r4
   43380:	bd38      	pop	{r3, r4, r5, pc}
   43382:	bf00      	nop
   43384:	2001a9f0 	.word	0x2001a9f0

00043388 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   43388:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   4338a:	6840      	ldr	r0, [r0, #4]
   4338c:	f001 051f 	and.w	r5, r1, #31
   43390:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   43392:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   43396:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   4339a:	b085      	sub	sp, #20
   4339c:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   433a0:	d104      	bne.n	433ac <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   433a2:	4628      	mov	r0, r5
   433a4:	f001 fa88 	bl	448b8 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   433a8:	2000      	movs	r0, #0
   433aa:	e02c      	b.n	43406 <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   433ac:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   433b0:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   433b4:	d129      	bne.n	4340a <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   433b6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   433ba:	bf0c      	ite	eq
   433bc:	2304      	moveq	r3, #4
   433be:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   433c0:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   433c4:	6883      	ldr	r3, [r0, #8]
   433c6:	fa23 f101 	lsr.w	r1, r3, r1
   433ca:	07c9      	lsls	r1, r1, #31
   433cc:	d429      	bmi.n	43422 <gpio_nrfx_pin_interrupt_configure+0x9a>
   433ce:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   433d2:	d126      	bne.n	43422 <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   433d4:	4a1b      	ldr	r2, [pc, #108]	; (43444 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   433d6:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   433da:	3380      	adds	r3, #128	; 0x80
   433dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   433e0:	07db      	lsls	r3, r3, #31
   433e2:	d41e      	bmi.n	43422 <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   433e4:	f10d 0407 	add.w	r4, sp, #7
   433e8:	4621      	mov	r1, r4
   433ea:	4628      	mov	r0, r5
   433ec:	f001 f9d4 	bl	44798 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   433f0:	4b15      	ldr	r3, [pc, #84]	; (43448 <gpio_nrfx_pin_interrupt_configure+0xc0>)
   433f2:	4298      	cmp	r0, r3
   433f4:	d114      	bne.n	43420 <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   433f6:	4620      	mov	r0, r4
   433f8:	f001 fa18 	bl	4482c <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   433fc:	4b13      	ldr	r3, [pc, #76]	; (4344c <gpio_nrfx_pin_interrupt_configure+0xc4>)
   433fe:	4298      	cmp	r0, r3
   43400:	d00e      	beq.n	43420 <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   43402:	f06f 000b 	mvn.w	r0, #11
}
   43406:	b005      	add	sp, #20
   43408:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   4340a:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   4340e:	d005      	beq.n	4341c <gpio_nrfx_pin_interrupt_configure+0x94>
   43410:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   43414:	bf0c      	ite	eq
   43416:	2302      	moveq	r3, #2
   43418:	2301      	movne	r3, #1
   4341a:	e7d1      	b.n	433c0 <gpio_nrfx_pin_interrupt_configure+0x38>
   4341c:	2303      	movs	r3, #3
   4341e:	e7cf      	b.n	433c0 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   43420:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43422:	2300      	movs	r3, #0
   43424:	4628      	mov	r0, r5
   43426:	4619      	mov	r1, r3
   43428:	aa02      	add	r2, sp, #8
   4342a:	f001 f875 	bl	44518 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   4342e:	4b07      	ldr	r3, [pc, #28]	; (4344c <gpio_nrfx_pin_interrupt_configure+0xc4>)
   43430:	4298      	cmp	r0, r3
   43432:	d104      	bne.n	4343e <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   43434:	2101      	movs	r1, #1
   43436:	4628      	mov	r0, r5
   43438:	f001 f9fe 	bl	44838 <nrfx_gpiote_trigger_enable>
   4343c:	e7b4      	b.n	433a8 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   4343e:	f06f 0004 	mvn.w	r0, #4
   43442:	e7e0      	b.n	43406 <gpio_nrfx_pin_interrupt_configure+0x7e>
   43444:	40842500 	.word	0x40842500
   43448:	0bad0004 	.word	0x0bad0004
   4344c:	0bad0000 	.word	0x0bad0000

00043450 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   43450:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   43452:	f001 f9db 	bl	4480c <nrfx_gpiote_is_init>
   43456:	4604      	mov	r4, r0
   43458:	b968      	cbnz	r0, 43476 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   4345a:	f001 f9af 	bl	447bc <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   4345e:	4b08      	ldr	r3, [pc, #32]	; (43480 <gpio_nrfx_init+0x30>)
   43460:	4298      	cmp	r0, r3
   43462:	d10a      	bne.n	4347a <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   43464:	4621      	mov	r1, r4
   43466:	4807      	ldr	r0, [pc, #28]	; (43484 <gpio_nrfx_init+0x34>)
   43468:	f001 f990 	bl	4478c <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   4346c:	4622      	mov	r2, r4
   4346e:	2105      	movs	r1, #5
   43470:	2031      	movs	r0, #49	; 0x31
   43472:	f7ff f813 	bl	4249c <z_arm_irq_priority_set>
		return 0;
   43476:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   43478:	bd10      	pop	{r4, pc}
		return -EIO;
   4347a:	f06f 0004 	mvn.w	r0, #4
   4347e:	e7fb      	b.n	43478 <gpio_nrfx_init+0x28>
   43480:	0bad0000 	.word	0x0bad0000
   43484:	00043489 	.word	0x00043489

00043488 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   43488:	0943      	lsrs	r3, r0, #5
{
   4348a:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   4348c:	d117      	bne.n	434be <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   4348e:	4b0c      	ldr	r3, [pc, #48]	; (434c0 <nrfx_gpio_handler+0x38>)
   43490:	6859      	ldr	r1, [r3, #4]
   43492:	b1a1      	cbz	r1, 434be <nrfx_gpio_handler+0x36>
   43494:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   43496:	2501      	movs	r5, #1
   43498:	2c00      	cmp	r4, #0
   4349a:	bf38      	it	cc
   4349c:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   4349e:	4e09      	ldr	r6, [pc, #36]	; (434c4 <nrfx_gpio_handler+0x3c>)
   434a0:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   434a2:	688a      	ldr	r2, [r1, #8]
   434a4:	402a      	ands	r2, r5
   434a6:	d002      	beq.n	434ae <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   434a8:	4630      	mov	r0, r6
   434aa:	684b      	ldr	r3, [r1, #4]
   434ac:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   434ae:	b134      	cbz	r4, 434be <nrfx_gpio_handler+0x36>
	return node->next;
   434b0:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   434b2:	4621      	mov	r1, r4
   434b4:	2b00      	cmp	r3, #0
   434b6:	bf38      	it	cc
   434b8:	2300      	movcc	r3, #0
   434ba:	461c      	mov	r4, r3
   434bc:	e7f1      	b.n	434a2 <nrfx_gpio_handler+0x1a>
}
   434be:	bd70      	pop	{r4, r5, r6, pc}
   434c0:	2001a9f4 	.word	0x2001a9f4
   434c4:	00049444 	.word	0x00049444

000434c8 <gpio_nrfx_pin_configure>:
{
   434c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   434cc:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   434ce:	f001 051f 	and.w	r5, r1, #31
   434d2:	7b3b      	ldrb	r3, [r7, #12]
{
   434d4:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   434d6:	4614      	mov	r4, r2
{
   434d8:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   434da:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   434de:	b9ca      	cbnz	r2, 43514 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   434e0:	a902      	add	r1, sp, #8
   434e2:	4628      	mov	r0, r5
   434e4:	f001 f958 	bl	44798 <nrfx_gpiote_channel_get>
   434e8:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   434ea:	4628      	mov	r0, r5
   434ec:	f001 fa06 	bl	448fc <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   434f0:	4b47      	ldr	r3, [pc, #284]	; (43610 <gpio_nrfx_pin_configure+0x148>)
   434f2:	4298      	cmp	r0, r3
   434f4:	d004      	beq.n	43500 <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   434f6:	f06f 0004 	mvn.w	r0, #4
}
   434fa:	b005      	add	sp, #20
   434fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   43500:	4284      	cmp	r4, r0
   43502:	d105      	bne.n	43510 <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   43504:	f89d 0008 	ldrb.w	r0, [sp, #8]
   43508:	f001 f98a 	bl	44820 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   4350c:	42a0      	cmp	r0, r4
   4350e:	d1f2      	bne.n	434f6 <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   43510:	2000      	movs	r0, #0
   43512:	e7f2      	b.n	434fa <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   43514:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   43518:	f10d 0103 	add.w	r1, sp, #3
   4351c:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   4351e:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   43522:	f001 f939 	bl	44798 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   43526:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   43528:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   4352a:	4649      	mov	r1, r9
   4352c:	4628      	mov	r0, r5
   4352e:	aa02      	add	r2, sp, #8
   43530:	f000 fff2 	bl	44518 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   43534:	4b36      	ldr	r3, [pc, #216]	; (43610 <gpio_nrfx_pin_configure+0x148>)
   43536:	4298      	cmp	r0, r3
   43538:	d002      	beq.n	43540 <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   4353a:	f06f 0015 	mvn.w	r0, #21
   4353e:	e7dc      	b.n	434fa <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   43540:	4580      	cmp	r8, r0
   43542:	d103      	bne.n	4354c <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   43544:	f89d 0003 	ldrb.w	r0, [sp, #3]
   43548:	f001 f96a 	bl	44820 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   4354c:	05a3      	lsls	r3, r4, #22
   4354e:	d54c      	bpl.n	435ea <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43550:	4b30      	ldr	r3, [pc, #192]	; (43614 <gpio_nrfx_pin_configure+0x14c>)
   43552:	4a31      	ldr	r2, [pc, #196]	; (43618 <gpio_nrfx_pin_configure+0x150>)
   43554:	4023      	ands	r3, r4
   43556:	4293      	cmp	r3, r2
   43558:	d039      	beq.n	435ce <gpio_nrfx_pin_configure+0x106>
   4355a:	d80c      	bhi.n	43576 <gpio_nrfx_pin_configure+0xae>
   4355c:	2b06      	cmp	r3, #6
   4355e:	d014      	beq.n	4358a <gpio_nrfx_pin_configure+0xc2>
   43560:	d804      	bhi.n	4356c <gpio_nrfx_pin_configure+0xa4>
   43562:	b193      	cbz	r3, 4358a <gpio_nrfx_pin_configure+0xc2>
   43564:	2b02      	cmp	r3, #2
   43566:	d1e8      	bne.n	4353a <gpio_nrfx_pin_configure+0x72>
   43568:	2304      	movs	r3, #4
   4356a:	e00e      	b.n	4358a <gpio_nrfx_pin_configure+0xc2>
   4356c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   43570:	d1e3      	bne.n	4353a <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   43572:	2301      	movs	r3, #1
   43574:	e009      	b.n	4358a <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   43576:	4a29      	ldr	r2, [pc, #164]	; (4361c <gpio_nrfx_pin_configure+0x154>)
   43578:	4293      	cmp	r3, r2
   4357a:	d02a      	beq.n	435d2 <gpio_nrfx_pin_configure+0x10a>
   4357c:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   43580:	d029      	beq.n	435d6 <gpio_nrfx_pin_configure+0x10e>
   43582:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   43586:	d1d8      	bne.n	4353a <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   43588:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   4358a:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   4358e:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   43592:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   43596:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   43598:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   4359c:	bf4c      	ite	mi
   4359e:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   435a0:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   435a4:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   435a6:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   435aa:	d516      	bpl.n	435da <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   435ac:	2101      	movs	r1, #1
   435ae:	687b      	ldr	r3, [r7, #4]
   435b0:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   435b4:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   435b6:	2200      	movs	r2, #0
   435b8:	4628      	mov	r0, r5
   435ba:	a901      	add	r1, sp, #4
   435bc:	f001 f852 	bl	44664 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   435c0:	4b13      	ldr	r3, [pc, #76]	; (43610 <gpio_nrfx_pin_configure+0x148>)
   435c2:	4298      	cmp	r0, r3
   435c4:	bf14      	ite	ne
   435c6:	f06f 0015 	mvnne.w	r0, #21
   435ca:	2000      	moveq	r0, #0
   435cc:	e795      	b.n	434fa <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   435ce:	2307      	movs	r3, #7
   435d0:	e7db      	b.n	4358a <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   435d2:	2305      	movs	r3, #5
   435d4:	e7d9      	b.n	4358a <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   435d6:	2303      	movs	r3, #3
   435d8:	e7d7      	b.n	4358a <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   435da:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   435dc:	bf41      	itttt	mi
   435de:	2101      	movmi	r1, #1
   435e0:	687b      	ldrmi	r3, [r7, #4]
   435e2:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   435e6:	60de      	strmi	r6, [r3, #12]
}
   435e8:	e7e5      	b.n	435b6 <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   435ea:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   435ec:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   435f0:	bf4c      	ite	mi
   435f2:	2403      	movmi	r4, #3
   435f4:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   435f8:	461a      	mov	r2, r3
   435fa:	4628      	mov	r0, r5
   435fc:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   435fe:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   43602:	f000 ff89 	bl	44518 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   43606:	4b02      	ldr	r3, [pc, #8]	; (43610 <gpio_nrfx_pin_configure+0x148>)
   43608:	4298      	cmp	r0, r3
   4360a:	d081      	beq.n	43510 <gpio_nrfx_pin_configure+0x48>
   4360c:	e795      	b.n	4353a <gpio_nrfx_pin_configure+0x72>
   4360e:	bf00      	nop
   43610:	0bad0000 	.word	0x0bad0000
   43614:	00f00006 	.word	0x00f00006
   43618:	00100006 	.word	0x00100006
   4361c:	00400002 	.word	0x00400002

00043620 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   43620:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   43622:	794b      	ldrb	r3, [r1, #5]
   43624:	2b01      	cmp	r3, #1
   43626:	d026      	beq.n	43676 <uarte_nrfx_configure+0x56>
   43628:	2b03      	cmp	r3, #3
   4362a:	d121      	bne.n	43670 <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   4362c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   4362e:	798b      	ldrb	r3, [r1, #6]
   43630:	2b03      	cmp	r3, #3
   43632:	d11d      	bne.n	43670 <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   43634:	79cc      	ldrb	r4, [r1, #7]
   43636:	b10c      	cbz	r4, 4363c <uarte_nrfx_configure+0x1c>
   43638:	2c01      	cmp	r4, #1
   4363a:	d119      	bne.n	43670 <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   4363c:	790a      	ldrb	r2, [r1, #4]
   4363e:	b112      	cbz	r2, 43646 <uarte_nrfx_configure+0x26>
   43640:	2a02      	cmp	r2, #2
   43642:	d115      	bne.n	43670 <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   43644:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   43646:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   43648:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   4364a:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   4364e:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   43650:	d065      	beq.n	4371e <uarte_nrfx_configure+0xfe>
   43652:	d82d      	bhi.n	436b0 <uarte_nrfx_configure+0x90>
   43654:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   43658:	d064      	beq.n	43724 <uarte_nrfx_configure+0x104>
   4365a:	d816      	bhi.n	4368a <uarte_nrfx_configure+0x6a>
   4365c:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   43660:	d062      	beq.n	43728 <uarte_nrfx_configure+0x108>
   43662:	d80a      	bhi.n	4367a <uarte_nrfx_configure+0x5a>
   43664:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   43668:	d061      	beq.n	4372e <uarte_nrfx_configure+0x10e>
   4366a:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   4366e:	d061      	beq.n	43734 <uarte_nrfx_configure+0x114>
   43670:	f06f 0085 	mvn.w	r0, #133	; 0x85
   43674:	e052      	b.n	4371c <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   43676:	2600      	movs	r6, #0
   43678:	e7d9      	b.n	4362e <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   4367a:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   4367e:	d05c      	beq.n	4373a <uarte_nrfx_configure+0x11a>
   43680:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   43684:	d1f4      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   43686:	4b37      	ldr	r3, [pc, #220]	; (43764 <uarte_nrfx_configure+0x144>)
   43688:	e03c      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   4368a:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   4368e:	d057      	beq.n	43740 <uarte_nrfx_configure+0x120>
   43690:	d807      	bhi.n	436a2 <uarte_nrfx_configure+0x82>
   43692:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   43696:	d055      	beq.n	43744 <uarte_nrfx_configure+0x124>
   43698:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   4369c:	d1e8      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   4369e:	4b32      	ldr	r3, [pc, #200]	; (43768 <uarte_nrfx_configure+0x148>)
   436a0:	e030      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   436a2:	f647 2712 	movw	r7, #31250	; 0x7a12
   436a6:	42bb      	cmp	r3, r7
   436a8:	d1e2      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   436aa:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   436ae:	e029      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   436b0:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   436b4:	d048      	beq.n	43748 <uarte_nrfx_configure+0x128>
   436b6:	d813      	bhi.n	436e0 <uarte_nrfx_configure+0xc0>
   436b8:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   436bc:	d047      	beq.n	4374e <uarte_nrfx_configure+0x12e>
   436be:	d809      	bhi.n	436d4 <uarte_nrfx_configure+0xb4>
   436c0:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   436c4:	42bb      	cmp	r3, r7
   436c6:	d044      	beq.n	43752 <uarte_nrfx_configure+0x132>
   436c8:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   436cc:	d1d0      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   436ce:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   436d2:	e017      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   436d4:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   436d8:	d1ca      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   436da:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   436de:	e011      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   436e0:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   436e4:	d038      	beq.n	43758 <uarte_nrfx_configure+0x138>
   436e6:	d808      	bhi.n	436fa <uarte_nrfx_configure+0xda>
   436e8:	4f20      	ldr	r7, [pc, #128]	; (4376c <uarte_nrfx_configure+0x14c>)
   436ea:	42bb      	cmp	r3, r7
   436ec:	d037      	beq.n	4375e <uarte_nrfx_configure+0x13e>
   436ee:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   436f2:	d1bd      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   436f4:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   436f8:	e004      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   436fa:	4f1d      	ldr	r7, [pc, #116]	; (43770 <uarte_nrfx_configure+0x150>)
   436fc:	42bb      	cmp	r3, r7
   436fe:	d1b7      	bne.n	43670 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   43700:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   43704:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   43708:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   4370a:	4334      	orrs	r4, r6
   4370c:	4322      	orrs	r2, r4
   4370e:	3304      	adds	r3, #4
   43710:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   43712:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   43716:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   4371a:	2000      	movs	r0, #0
}
   4371c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   4371e:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   43722:	e7ef      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   43724:	4b13      	ldr	r3, [pc, #76]	; (43774 <uarte_nrfx_configure+0x154>)
   43726:	e7ed      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   43728:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   4372c:	e7ea      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   4372e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   43732:	e7e7      	b.n	43704 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   43734:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   43738:	e7e4      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   4373a:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   4373e:	e7e1      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   43740:	4b0d      	ldr	r3, [pc, #52]	; (43778 <uarte_nrfx_configure+0x158>)
   43742:	e7df      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   43744:	4b0d      	ldr	r3, [pc, #52]	; (4377c <uarte_nrfx_configure+0x15c>)
   43746:	e7dd      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   43748:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   4374c:	e7da      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   4374e:	4b0c      	ldr	r3, [pc, #48]	; (43780 <uarte_nrfx_configure+0x160>)
   43750:	e7d8      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   43752:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   43756:	e7d5      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   43758:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   4375c:	e7d2      	b.n	43704 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   4375e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   43762:	e7cf      	b.n	43704 <uarte_nrfx_configure+0xe4>
   43764:	0013b000 	.word	0x0013b000
   43768:	004ea000 	.word	0x004ea000
   4376c:	0003d090 	.word	0x0003d090
   43770:	000f4240 	.word	0x000f4240
   43774:	00275000 	.word	0x00275000
   43778:	0075c000 	.word	0x0075c000
   4377c:	003af000 	.word	0x003af000
   43780:	013a9000 	.word	0x013a9000

00043784 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   43784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   43786:	4605      	mov	r5, r0
   43788:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   4378a:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   4378c:	f005 fc44 	bl	49018 <k_is_in_isr>
   43790:	b910      	cbnz	r0, 43798 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   43792:	4b2c      	ldr	r3, [pc, #176]	; (43844 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   43794:	781b      	ldrb	r3, [r3, #0]
   43796:	b983      	cbnz	r3, 437ba <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   43798:	f04f 0320 	mov.w	r3, #32
   4379c:	f3ef 8411 	mrs	r4, BASEPRI
   437a0:	f383 8812 	msr	BASEPRI_MAX, r3
   437a4:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   437a8:	4628      	mov	r0, r5
   437aa:	f005 fa09 	bl	48bc0 <is_tx_ready>
   437ae:	bb28      	cbnz	r0, 437fc <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   437b0:	f384 8811 	msr	BASEPRI, r4
   437b4:	f3bf 8f6f 	isb	sy
}
   437b8:	e7ee      	b.n	43798 <uarte_nrfx_poll_out+0x14>
{
   437ba:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   437bc:	4628      	mov	r0, r5
   437be:	f005 f9ff 	bl	48bc0 <is_tx_ready>
   437c2:	b970      	cbnz	r0, 437e2 <uarte_nrfx_poll_out+0x5e>
   437c4:	2001      	movs	r0, #1
   437c6:	f005 fa5f 	bl	48c88 <nrfx_busy_wait>
   437ca:	3c01      	subs	r4, #1
   437cc:	d1f6      	bne.n	437bc <uarte_nrfx_poll_out+0x38>
   437ce:	2100      	movs	r1, #0
   437d0:	2001      	movs	r0, #1
   437d2:	f003 fcd1 	bl	47178 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   437d6:	e7f0      	b.n	437ba <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   437d8:	f384 8811 	msr	BASEPRI, r4
   437dc:	f3bf 8f6f 	isb	sy
}
   437e0:	e7f5      	b.n	437ce <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   437e2:	f04f 0320 	mov.w	r3, #32
   437e6:	f3ef 8411 	mrs	r4, BASEPRI
   437ea:	f383 8812 	msr	BASEPRI_MAX, r3
   437ee:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   437f2:	4628      	mov	r0, r5
   437f4:	f005 f9e4 	bl	48bc0 <is_tx_ready>
   437f8:	2800      	cmp	r0, #0
   437fa:	d0ed      	beq.n	437d8 <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   437fc:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   437fe:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   43802:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   43804:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   43806:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   4380a:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4380e:	2200      	movs	r2, #0
   43810:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   43814:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   43818:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   4381c:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   43820:	684a      	ldr	r2, [r1, #4]
   43822:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43824:	bf41      	itttt	mi
   43826:	2208      	movmi	r2, #8
   43828:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   4382c:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   43830:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43834:	2201      	movs	r2, #1
   43836:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   43838:	f384 8811 	msr	BASEPRI, r4
   4383c:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   43840:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   43842:	bf00      	nop
   43844:	20020c28 	.word	0x20020c28

00043848 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   43848:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4384c:	4606      	mov	r6, r0
   4384e:	2101      	movs	r1, #1
   43850:	2200      	movs	r2, #0
   43852:	2008      	movs	r0, #8
   43854:	f7fe fe22 	bl	4249c <z_arm_irq_priority_set>
   43858:	2008      	movs	r0, #8
   4385a:	f7fe fe01 	bl	42460 <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   4385e:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   43860:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   43862:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   43864:	683c      	ldr	r4, [r7, #0]
   43866:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   4386a:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   4386c:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4386e:	68d8      	ldr	r0, [r3, #12]
   43870:	1c41      	adds	r1, r0, #1
   43872:	d00b      	beq.n	4388c <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   43874:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   43876:	f8df c154 	ldr.w	ip, [pc, #340]	; 439cc <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   4387a:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   4387e:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   43880:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   43884:	2103      	movs	r1, #3
   43886:	3280      	adds	r2, #128	; 0x80
   43888:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   4388c:	6919      	ldr	r1, [r3, #16]
   4388e:	1c4a      	adds	r2, r1, #1
   43890:	d00d      	beq.n	438ae <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   43892:	7f1a      	ldrb	r2, [r3, #28]
   43894:	f8df c134 	ldr.w	ip, [pc, #308]	; 439cc <uarte_0_init+0x184>
   43898:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   4389a:	bf14      	ite	ne
   4389c:	f04f 0e0c 	movne.w	lr, #12
   438a0:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   438a4:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   438a8:	3280      	adds	r2, #128	; 0x80
   438aa:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   438ae:	f8d3 c014 	ldr.w	ip, [r3, #20]
   438b2:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   438b6:	d00e      	beq.n	438d6 <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   438b8:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   438bc:	f8df 810c 	ldr.w	r8, [pc, #268]	; 439cc <uarte_0_init+0x184>
    *p_pin = pin_number & 0x1F;
   438c0:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   438c4:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   438c8:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   438cc:	f04f 0e03 	mov.w	lr, #3
   438d0:	3280      	adds	r2, #128	; 0x80
   438d2:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   438d6:	f8d3 e018 	ldr.w	lr, [r3, #24]
   438da:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
   438de:	d00d      	beq.n	438fc <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   438e0:	7f5a      	ldrb	r2, [r3, #29]
   438e2:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 439cc <uarte_0_init+0x184>
   438e6:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   438e8:	bf14      	ite	ne
   438ea:	f04f 090c 	movne.w	r9, #12
   438ee:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   438f2:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   438f6:	3280      	adds	r2, #128	; 0x80
   438f8:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   438fc:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   438fe:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   43902:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   43906:	6931      	ldr	r1, [r6, #16]
   43908:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   4390a:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   4390e:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   43910:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   43914:	f7ff fe84 	bl	43620 <uarte_nrfx_configure>
	if (err) {
   43918:	4606      	mov	r6, r0
   4391a:	b9a8      	cbnz	r0, 43948 <uarte_0_init+0x100>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   4391c:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   4391e:	0799      	lsls	r1, r3, #30
   43920:	d522      	bpl.n	43968 <uarte_0_init+0x120>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   43922:	f105 0012 	add.w	r0, r5, #18
   43926:	f000 fd7d 	bl	44424 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   4392a:	4b23      	ldr	r3, [pc, #140]	; (439b8 <uarte_0_init+0x170>)
   4392c:	4298      	cmp	r0, r3
   4392e:	d00e      	beq.n	4394e <uarte_0_init+0x106>
   43930:	4b22      	ldr	r3, [pc, #136]	; (439bc <uarte_0_init+0x174>)
   43932:	4923      	ldr	r1, [pc, #140]	; (439c0 <uarte_0_init+0x178>)
		LOG_ERR("Failed to allocate PPI Channel");
   43934:	4823      	ldr	r0, [pc, #140]	; (439c4 <uarte_0_init+0x17c>)
   43936:	1ac9      	subs	r1, r1, r3
   43938:	08c9      	lsrs	r1, r1, #3
   4393a:	0189      	lsls	r1, r1, #6
   4393c:	f041 0101 	orr.w	r1, r1, #1
   43940:	f004 fc80 	bl	48244 <log_0>
		return -EIO;
   43944:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   43948:	4630      	mov	r0, r6
   4394a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   4394e:	7cab      	ldrb	r3, [r5, #18]
   43950:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   43954:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   43958:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   4395c:	2301      	movs	r3, #1
   4395e:	7caa      	ldrb	r2, [r5, #18]
   43960:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   43962:	4a19      	ldr	r2, [pc, #100]	; (439c8 <uarte_0_init+0x180>)
   43964:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   43968:	2308      	movs	r3, #8
   4396a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   4396e:	7a3b      	ldrb	r3, [r7, #8]
   43970:	b95b      	cbnz	r3, 4398a <uarte_0_init+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   43972:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   43976:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   4397a:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   4397e:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   43982:	2301      	movs	r3, #1
   43984:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   43988:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   4398a:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   4398c:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   4398e:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   43990:	bf5c      	itt	pl
   43992:	f44f 7280 	movpl.w	r2, #256	; 0x100
   43996:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   4399a:	06db      	lsls	r3, r3, #27
   4399c:	bf44      	itt	mi
   4399e:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   439a2:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   439a6:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   439a8:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   439ac:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   439b0:	2301      	movs	r3, #1
   439b2:	60a3      	str	r3, [r4, #8]
   439b4:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   439b6:	e7c7      	b.n	43948 <uarte_0_init+0x100>
   439b8:	0bad0000 	.word	0x0bad0000
   439bc:	00049694 	.word	0x00049694
   439c0:	000496e4 	.word	0x000496e4
   439c4:	0004a208 	.word	0x0004a208
   439c8:	40017000 	.word	0x40017000
   439cc:	40842500 	.word	0x40842500

000439d0 <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   439d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   439d2:	4e20      	ldr	r6, [pc, #128]	; (43a54 <sys_clock_timeout_handler+0x84>)
	return absolute_time & COUNTER_MAX;
   439d4:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   439d8:	e9d6 ce00 	ldrd	ip, lr, [r6]
   439dc:	ebb2 020c 	subs.w	r2, r2, ip

	last_count += dticks * CYC_PER_TICK;
   439e0:	f022 011f 	bic.w	r1, r2, #31
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   439e4:	eb63 030e 	sbc.w	r3, r3, lr
{
   439e8:	4604      	mov	r4, r0
	last_count += dticks * CYC_PER_TICK;
   439ea:	eb11 010c 	adds.w	r1, r1, ip
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   439ee:	ea4f 1052 	mov.w	r0, r2, lsr #5
	last_count += dticks * CYC_PER_TICK;
   439f2:	eb43 070e 	adc.w	r7, r3, lr
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   439f6:	ea40 60c3 	orr.w	r0, r0, r3, lsl #27
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   439fa:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   439fe:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
	last_count += dticks * CYC_PER_TICK;
   43a02:	e9c6 1700 	strd	r1, r7, [r6]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   43a06:	f04f 0600 	mov.w	r6, #0
	if (in_anchor_range(cc_value)) {
   43a0a:	d20a      	bcs.n	43a22 <sys_clock_timeout_handler+0x52>
		return true;
   43a0c:	2601      	movs	r6, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   43a0e:	4b12      	ldr	r3, [pc, #72]	; (43a58 <sys_clock_timeout_handler+0x88>)
   43a10:	6819      	ldr	r1, [r3, #0]
   43a12:	060a      	lsls	r2, r1, #24
   43a14:	0a0b      	lsrs	r3, r1, #8
   43a16:	1952      	adds	r2, r2, r5
   43a18:	4910      	ldr	r1, [pc, #64]	; (43a5c <sys_clock_timeout_handler+0x8c>)
   43a1a:	f143 0300 	adc.w	r3, r3, #0
   43a1e:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   43a22:	f003 fd07 	bl	47434 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   43a26:	00a3      	lsls	r3, r4, #2
   43a28:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   43a2c:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   43a30:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   43a34:	42aa      	cmp	r2, r5
   43a36:	d10b      	bne.n	43a50 <sys_clock_timeout_handler+0x80>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   43a38:	b91e      	cbnz	r6, 43a42 <sys_clock_timeout_handler+0x72>
    p_reg->CC[ch] = cc_val;
   43a3a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   43a3e:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43a42:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   43a46:	4b06      	ldr	r3, [pc, #24]	; (43a60 <sys_clock_timeout_handler+0x90>)
   43a48:	fa00 f404 	lsl.w	r4, r0, r4
   43a4c:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   43a50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   43a52:	bf00      	nop
   43a54:	2001a7a0 	.word	0x2001a7a0
   43a58:	2001aa08 	.word	0x2001aa08
   43a5c:	2001a788 	.word	0x2001a788
   43a60:	40015000 	.word	0x40015000

00043a64 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43a64:	2301      	movs	r3, #1
   43a66:	4083      	lsls	r3, r0
{
   43a68:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   43a6a:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43a6c:	4a0c      	ldr	r2, [pc, #48]	; (43aa0 <compare_int_lock+0x3c>)
   43a6e:	e8d2 1fef 	ldaex	r1, [r2]
   43a72:	ea01 0c04 	and.w	ip, r1, r4
   43a76:	e8c2 cfee 	stlex	lr, ip, [r2]
   43a7a:	f1be 0f00 	cmp.w	lr, #0
   43a7e:	d1f6      	bne.n	43a6e <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43a80:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   43a84:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   43a88:	4a06      	ldr	r2, [pc, #24]	; (43aa4 <compare_int_lock+0x40>)
   43a8a:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   43a8e:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   43a92:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   43a96:	420b      	tst	r3, r1
}
   43a98:	bf14      	ite	ne
   43a9a:	2001      	movne	r0, #1
   43a9c:	2000      	moveq	r0, #0
   43a9e:	bd10      	pop	{r4, pc}
   43aa0:	2001aa04 	.word	0x2001aa04
   43aa4:	40015000 	.word	0x40015000

00043aa8 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   43aa8:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43aaa:	4a0e      	ldr	r2, [pc, #56]	; (43ae4 <compare_int_unlock.part.0+0x3c>)
   43aac:	4083      	lsls	r3, r0
   43aae:	e8d2 1fef 	ldaex	r1, [r2]
   43ab2:	4319      	orrs	r1, r3
   43ab4:	e8c2 1fec 	stlex	ip, r1, [r2]
   43ab8:	f1bc 0f00 	cmp.w	ip, #0
   43abc:	d1f7      	bne.n	43aae <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43abe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   43ac2:	4a09      	ldr	r2, [pc, #36]	; (43ae8 <compare_int_unlock.part.0+0x40>)
   43ac4:	4083      	lsls	r3, r0
   43ac6:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   43aca:	4b08      	ldr	r3, [pc, #32]	; (43aec <compare_int_unlock.part.0+0x44>)
   43acc:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   43ad0:	fa23 f000 	lsr.w	r0, r3, r0
   43ad4:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43ad6:	bf42      	ittt	mi
   43ad8:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   43adc:	4b04      	ldrmi	r3, [pc, #16]	; (43af0 <compare_int_unlock.part.0+0x48>)
   43ade:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   43ae2:	4770      	bx	lr
   43ae4:	2001aa04 	.word	0x2001aa04
   43ae8:	40015000 	.word	0x40015000
   43aec:	2001aa00 	.word	0x2001aa00
   43af0:	e000e100 	.word	0xe000e100

00043af4 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   43af4:	4b0d      	ldr	r3, [pc, #52]	; (43b2c <z_nrf_rtc_timer_read+0x38>)
   43af6:	681b      	ldr	r3, [r3, #0]
   43af8:	0a19      	lsrs	r1, r3, #8
   43afa:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   43afc:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   43b00:	4b0b      	ldr	r3, [pc, #44]	; (43b30 <z_nrf_rtc_timer_read+0x3c>)
   43b02:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   43b06:	18c0      	adds	r0, r0, r3
   43b08:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   43b0c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   43b10:	d20a      	bcs.n	43b28 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   43b12:	4b08      	ldr	r3, [pc, #32]	; (43b34 <z_nrf_rtc_timer_read+0x40>)
   43b14:	e9d3 2300 	ldrd	r2, r3, [r3]
   43b18:	4299      	cmp	r1, r3
   43b1a:	bf08      	it	eq
   43b1c:	4290      	cmpeq	r0, r2
   43b1e:	d203      	bcs.n	43b28 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   43b20:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   43b24:	f141 0100 	adc.w	r1, r1, #0
}
   43b28:	4770      	bx	lr
   43b2a:	bf00      	nop
   43b2c:	2001aa08 	.word	0x2001aa08
   43b30:	40015000 	.word	0x40015000
   43b34:	2001a788 	.word	0x2001a788

00043b38 <compare_set>:
{
   43b38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43b3c:	4616      	mov	r6, r2
   43b3e:	461f      	mov	r7, r3
   43b40:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   43b42:	f7ff ff8f 	bl	43a64 <compare_int_lock>
   43b46:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   43b48:	f7ff ffd4 	bl	43af4 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   43b4c:	42b9      	cmp	r1, r7
   43b4e:	bf08      	it	eq
   43b50:	42b0      	cmpeq	r0, r6
   43b52:	d27b      	bcs.n	43c4c <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   43b54:	2300      	movs	r3, #0
   43b56:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   43b5a:	ebb6 0800 	subs.w	r8, r6, r0
   43b5e:	eb67 0901 	sbc.w	r9, r7, r1
   43b62:	454b      	cmp	r3, r9
   43b64:	bf08      	it	eq
   43b66:	4542      	cmpeq	r2, r8
   43b68:	d37d      	bcc.n	43c66 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   43b6a:	4b40      	ldr	r3, [pc, #256]	; (43c6c <compare_set+0x134>)
   43b6c:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   43b70:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   43b74:	429f      	cmp	r7, r3
   43b76:	bf08      	it	eq
   43b78:	4296      	cmpeq	r6, r2
   43b7a:	d051      	beq.n	43c20 <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43b7c:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   43b80:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   43b84:	4614      	mov	r4, r2
   43b86:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   43b8a:	f105 0850 	add.w	r8, r5, #80	; 0x50
   43b8e:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   43b92:	ea4f 0888 	mov.w	r8, r8, lsl #2
   43b96:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43b9a:	fa1f f888 	uxth.w	r8, r8
   43b9e:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   43ba2:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   43ba6:	4b32      	ldr	r3, [pc, #200]	; (43c70 <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43ba8:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   43bac:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   43bb0:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   43bb4:	eba0 000a 	sub.w	r0, r0, sl
   43bb8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43bbc:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   43bc0:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   43bc2:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   43bc6:	d105      	bne.n	43bd4 <compare_set+0x9c>
   43bc8:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   43bca:	2013      	movs	r0, #19
   43bcc:	f005 fb81 	bl	492d2 <z_impl_k_busy_wait>
   43bd0:	4b27      	ldr	r3, [pc, #156]	; (43c70 <compare_set+0x138>)
   43bd2:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   43bd4:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   43bd8:	eba4 000c 	sub.w	r0, r4, ip
   43bdc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43be0:	2100      	movs	r1, #0
			cc_val = now + 2;
   43be2:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43be6:	bf88      	it	hi
   43be8:	4664      	movhi	r4, ip
   43bea:	f8c8 1000 	str.w	r1, [r8]
   43bee:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   43bf2:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   43bf6:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   43bfa:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   43bfe:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   43c02:	4582      	cmp	sl, r0
   43c04:	d006      	beq.n	43c14 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   43c06:	1a20      	subs	r0, r4, r0
   43c08:	3802      	subs	r0, #2
   43c0a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   43c0e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43c12:	d819      	bhi.n	43c48 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   43c14:	1aa4      	subs	r4, r4, r2
   43c16:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   43c1a:	1932      	adds	r2, r6, r4
   43c1c:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   43c20:	4c12      	ldr	r4, [pc, #72]	; (43c6c <compare_set+0x134>)
   43c22:	0129      	lsls	r1, r5, #4
   43c24:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   43c28:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   43c2c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   43c2e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   43c30:	5062      	str	r2, [r4, r1]
	return ret;
   43c32:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   43c34:	6043      	str	r3, [r0, #4]
	if (key) {
   43c36:	9b00      	ldr	r3, [sp, #0]
   43c38:	b113      	cbz	r3, 43c40 <compare_set+0x108>
   43c3a:	4628      	mov	r0, r5
   43c3c:	f7ff ff34 	bl	43aa8 <compare_int_unlock.part.0>
}
   43c40:	4620      	mov	r0, r4
   43c42:	b003      	add	sp, #12
   43c44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   43c48:	4620      	mov	r0, r4
   43c4a:	e7b1      	b.n	43bb0 <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   43c4c:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   43c4e:	4a09      	ldr	r2, [pc, #36]	; (43c74 <compare_set+0x13c>)
   43c50:	40ab      	lsls	r3, r5
   43c52:	e8d2 1fef 	ldaex	r1, [r2]
   43c56:	4319      	orrs	r1, r3
   43c58:	e8c2 1fe0 	stlex	r0, r1, [r2]
   43c5c:	2800      	cmp	r0, #0
   43c5e:	d1f8      	bne.n	43c52 <compare_set+0x11a>
   43c60:	4632      	mov	r2, r6
   43c62:	463b      	mov	r3, r7
   43c64:	e7dc      	b.n	43c20 <compare_set+0xe8>
			return -EINVAL;
   43c66:	f06f 0415 	mvn.w	r4, #21
   43c6a:	e7e4      	b.n	43c36 <compare_set+0xfe>
   43c6c:	2001a790 	.word	0x2001a790
   43c70:	40015000 	.word	0x40015000
   43c74:	2001aa00 	.word	0x2001aa00

00043c78 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   43c78:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   43c7a:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   43c7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   43c80:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   43c84:	4d16      	ldr	r5, [pc, #88]	; (43ce0 <sys_clock_driver_init+0x68>)
   43c86:	4b17      	ldr	r3, [pc, #92]	; (43ce4 <sys_clock_driver_init+0x6c>)
   43c88:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   43c8c:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   43c90:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   43c94:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   43c96:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   43c9a:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   43c9e:	4b12      	ldr	r3, [pc, #72]	; (43ce8 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   43ca0:	2101      	movs	r1, #1
   43ca2:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   43ca6:	2015      	movs	r0, #21
   43ca8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   43cac:	4622      	mov	r2, r4
   43cae:	f7fe fbf5 	bl	4249c <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   43cb2:	2015      	movs	r0, #21
   43cb4:	f7fe fbd4 	bl	42460 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   43cb8:	2301      	movs	r3, #1
   43cba:	4a0c      	ldr	r2, [pc, #48]	; (43cec <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43cbc:	4620      	mov	r0, r4
   43cbe:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   43cc0:	4a0b      	ldr	r2, [pc, #44]	; (43cf0 <sys_clock_driver_init+0x78>)
   43cc2:	602b      	str	r3, [r5, #0]
   43cc4:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   43cc6:	4b0b      	ldr	r3, [pc, #44]	; (43cf4 <sys_clock_driver_init+0x7c>)
   43cc8:	4a0b      	ldr	r2, [pc, #44]	; (43cf8 <sys_clock_driver_init+0x80>)
   43cca:	9300      	str	r3, [sp, #0]
   43ccc:	9401      	str	r4, [sp, #4]
   43cce:	2300      	movs	r3, #0
   43cd0:	f7ff ff32 	bl	43b38 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   43cd4:	4630      	mov	r0, r6
   43cd6:	f7ff faa9 	bl	4322c <z_nrf_clock_control_lf_on>

	return 0;
}
   43cda:	4620      	mov	r0, r4
   43cdc:	b002      	add	sp, #8
   43cde:	bd70      	pop	{r4, r5, r6, pc}
   43ce0:	40015000 	.word	0x40015000
   43ce4:	2001a790 	.word	0x2001a790
   43ce8:	e000e100 	.word	0xe000e100
   43cec:	40015008 	.word	0x40015008
   43cf0:	2001aa04 	.word	0x2001aa04
   43cf4:	000439d1 	.word	0x000439d1
   43cf8:	007fffff 	.word	0x007fffff

00043cfc <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   43cfc:	4b33      	ldr	r3, [pc, #204]	; (43dcc <rtc_nrf_isr+0xd0>)
{
   43cfe:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   43d02:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   43d06:	079a      	lsls	r2, r3, #30
   43d08:	d509      	bpl.n	43d1e <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   43d0a:	4b31      	ldr	r3, [pc, #196]	; (43dd0 <rtc_nrf_isr+0xd4>)
   43d0c:	681a      	ldr	r2, [r3, #0]
   43d0e:	b132      	cbz	r2, 43d1e <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43d10:	2200      	movs	r2, #0
   43d12:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   43d14:	4a2f      	ldr	r2, [pc, #188]	; (43dd4 <rtc_nrf_isr+0xd8>)
   43d16:	681b      	ldr	r3, [r3, #0]
   43d18:	6813      	ldr	r3, [r2, #0]
   43d1a:	3301      	adds	r3, #1
   43d1c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   43d1e:	f04f 0320 	mov.w	r3, #32
   43d22:	f3ef 8211 	mrs	r2, BASEPRI
   43d26:	f383 8812 	msr	BASEPRI_MAX, r3
   43d2a:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   43d2e:	4b27      	ldr	r3, [pc, #156]	; (43dcc <rtc_nrf_isr+0xd0>)
   43d30:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   43d34:	03db      	lsls	r3, r3, #15
   43d36:	d50e      	bpl.n	43d56 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   43d38:	4b27      	ldr	r3, [pc, #156]	; (43dd8 <rtc_nrf_isr+0xdc>)
   43d3a:	e8d3 1fef 	ldaex	r1, [r3]
   43d3e:	f021 0001 	bic.w	r0, r1, #1
   43d42:	e8c3 0fe4 	stlex	r4, r0, [r3]
   43d46:	2c00      	cmp	r4, #0
   43d48:	d1f7      	bne.n	43d3a <rtc_nrf_isr+0x3e>
   43d4a:	4b24      	ldr	r3, [pc, #144]	; (43ddc <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43d4c:	2900      	cmp	r1, #0
   43d4e:	d136      	bne.n	43dbe <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   43d50:	6819      	ldr	r1, [r3, #0]
		if (result) {
   43d52:	2900      	cmp	r1, #0
   43d54:	d133      	bne.n	43dbe <rtc_nrf_isr+0xc2>
{
   43d56:	2300      	movs	r3, #0
	__asm__ volatile(
   43d58:	f382 8811 	msr	BASEPRI, r2
   43d5c:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   43d60:	b353      	cbz	r3, 43db8 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   43d62:	f7ff fec7 	bl	43af4 <z_nrf_rtc_timer_read>
   43d66:	4604      	mov	r4, r0
	__asm__ volatile(
   43d68:	f04f 0320 	mov.w	r3, #32
   43d6c:	f3ef 8011 	mrs	r0, BASEPRI
   43d70:	f383 8812 	msr	BASEPRI_MAX, r3
   43d74:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   43d78:	4b19      	ldr	r3, [pc, #100]	; (43de0 <rtc_nrf_isr+0xe4>)
   43d7a:	2200      	movs	r2, #0
   43d7c:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   43d80:	4549      	cmp	r1, r9
   43d82:	bf08      	it	eq
   43d84:	4544      	cmpeq	r4, r8
   43d86:	d31f      	bcc.n	43dc8 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   43d88:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43d8c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   43d90:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   43d94:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   43d96:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   43d9a:	e9c3 4502 	strd	r4, r5, [r3, #8]
   43d9e:	4b0b      	ldr	r3, [pc, #44]	; (43dcc <rtc_nrf_isr+0xd0>)
   43da0:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   43da4:	f380 8811 	msr	BASEPRI, r0
   43da8:	f3bf 8f6f 	isb	sy
		if (handler) {
   43dac:	b121      	cbz	r1, 43db8 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   43dae:	4642      	mov	r2, r8
   43db0:	464b      	mov	r3, r9
   43db2:	2000      	movs	r0, #0
   43db4:	9600      	str	r6, [sp, #0]
   43db6:	4788      	blx	r1
}
   43db8:	b002      	add	sp, #8
   43dba:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   43dbe:	2100      	movs	r1, #0
   43dc0:	6019      	str	r1, [r3, #0]
   43dc2:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   43dc4:	2301      	movs	r3, #1
}
   43dc6:	e7c7      	b.n	43d58 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   43dc8:	4611      	mov	r1, r2
   43dca:	e7eb      	b.n	43da4 <rtc_nrf_isr+0xa8>
   43dcc:	40015000 	.word	0x40015000
   43dd0:	40015104 	.word	0x40015104
   43dd4:	2001aa08 	.word	0x2001aa08
   43dd8:	2001aa00 	.word	0x2001aa00
   43ddc:	40015140 	.word	0x40015140
   43de0:	2001a790 	.word	0x2001a790

00043de4 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43de4:	4b15      	ldr	r3, [pc, #84]	; (43e3c <sys_clock_set_timeout+0x58>)
{
   43de6:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   43de8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   43dec:	bf08      	it	eq
   43dee:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43df0:	1e46      	subs	r6, r0, #1
   43df2:	2e00      	cmp	r6, #0
   43df4:	dd20      	ble.n	43e38 <sys_clock_set_timeout+0x54>
   43df6:	429e      	cmp	r6, r3
   43df8:	bfa8      	it	ge
   43dfa:	461e      	movge	r6, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   43dfc:	f7ff fe7a 	bl	43af4 <z_nrf_rtc_timer_read>
   43e00:	4b0f      	ldr	r3, [pc, #60]	; (43e40 <sys_clock_set_timeout+0x5c>)
   43e02:	e9d3 4500 	ldrd	r4, r5, [r3]
   43e06:	1b00      	subs	r0, r0, r4
		ticks = 0;
   43e08:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   43e0c:	bf28      	it	cs
   43e0e:	2600      	movcs	r6, #0
	cyc += (CYC_PER_TICK - 1);
   43e10:	3020      	adds	r0, #32
   43e12:	eb00 1246 	add.w	r2, r0, r6, lsl #5
	uint64_t target_time = cyc + last_count;
   43e16:	480b      	ldr	r0, [pc, #44]	; (43e44 <sys_clock_set_timeout+0x60>)
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
   43e18:	f022 021f 	bic.w	r2, r2, #31
	uint64_t target_time = cyc + last_count;
   43e1c:	4282      	cmp	r2, r0
   43e1e:	bf28      	it	cs
   43e20:	4602      	movcs	r2, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   43e22:	2000      	movs	r0, #0
   43e24:	4b08      	ldr	r3, [pc, #32]	; (43e48 <sys_clock_set_timeout+0x64>)
   43e26:	18a2      	adds	r2, r4, r2
   43e28:	9300      	str	r3, [sp, #0]
   43e2a:	9001      	str	r0, [sp, #4]
   43e2c:	f145 0300 	adc.w	r3, r5, #0
   43e30:	f7ff fe82 	bl	43b38 <compare_set>
}
   43e34:	b002      	add	sp, #8
   43e36:	bd70      	pop	{r4, r5, r6, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   43e38:	2600      	movs	r6, #0
   43e3a:	e7df      	b.n	43dfc <sys_clock_set_timeout+0x18>
   43e3c:	0003ffff 	.word	0x0003ffff
   43e40:	2001a7a0 	.word	0x2001a7a0
   43e44:	007fffe0 	.word	0x007fffe0
   43e48:	000439d1 	.word	0x000439d1

00043e4c <sys_clock_elapsed>:
{
   43e4c:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   43e4e:	f7ff fe51 	bl	43af4 <z_nrf_rtc_timer_read>
   43e52:	4a05      	ldr	r2, [pc, #20]	; (43e68 <sys_clock_elapsed+0x1c>)
   43e54:	e9d2 3200 	ldrd	r3, r2, [r2]
   43e58:	1ac0      	subs	r0, r0, r3
   43e5a:	eb61 0102 	sbc.w	r1, r1, r2
   43e5e:	0940      	lsrs	r0, r0, #5
}
   43e60:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
   43e64:	bd08      	pop	{r3, pc}
   43e66:	bf00      	nop
   43e68:	2001a7a0 	.word	0x2001a7a0

00043e6c <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   43e6c:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   43e6e:	4d19      	ldr	r5, [pc, #100]	; (43ed4 <_nrf_modem_lib_init+0x68>)
   43e70:	4c19      	ldr	r4, [pc, #100]	; (43ed8 <_nrf_modem_lib_init+0x6c>)
   43e72:	782b      	ldrb	r3, [r5, #0]
   43e74:	b933      	cbnz	r3, 43e84 <_nrf_modem_lib_init+0x18>
	list->tail = NULL;
   43e76:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   43e7a:	4818      	ldr	r0, [pc, #96]	; (43edc <_nrf_modem_lib_init+0x70>)
   43e7c:	f005 f8de 	bl	4903c <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   43e80:	2301      	movs	r3, #1
   43e82:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   43e84:	2200      	movs	r2, #0
   43e86:	202a      	movs	r0, #42	; 0x2a
   43e88:	4611      	mov	r1, r2
   43e8a:	f7fe fb07 	bl	4249c <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   43e8e:	2100      	movs	r1, #0
   43e90:	4813      	ldr	r0, [pc, #76]	; (43ee0 <_nrf_modem_lib_init+0x74>)
   43e92:	f002 f965 	bl	46160 <nrf_modem_init>
   43e96:	4b13      	ldr	r3, [pc, #76]	; (43ee4 <_nrf_modem_lib_init+0x78>)
   43e98:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   43e9a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   43e9e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43ea2:	480e      	ldr	r0, [pc, #56]	; (43edc <_nrf_modem_lib_init+0x70>)
   43ea4:	f002 fd7e 	bl	469a4 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   43ea8:	6820      	ldr	r0, [r4, #0]
   43eaa:	b170      	cbz	r0, 43eca <_nrf_modem_lib_init+0x5e>
	return node->next;
   43eac:	6804      	ldr	r4, [r0, #0]
   43eae:	2c00      	cmp	r4, #0
   43eb0:	bf38      	it	cc
   43eb2:	2400      	movcc	r4, #0
	z_impl_k_sem_give(sem);
   43eb4:	3004      	adds	r0, #4
   43eb6:	f002 fe39 	bl	46b2c <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   43eba:	b134      	cbz	r4, 43eca <_nrf_modem_lib_init+0x5e>
   43ebc:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   43ebe:	4620      	mov	r0, r4
   43ec0:	2b00      	cmp	r3, #0
   43ec2:	bf38      	it	cc
   43ec4:	2300      	movcc	r3, #0
   43ec6:	461c      	mov	r4, r3
   43ec8:	e7f4      	b.n	43eb4 <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   43eca:	4804      	ldr	r0, [pc, #16]	; (43edc <_nrf_modem_lib_init+0x70>)
   43ecc:	f002 fde8 	bl	46aa0 <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   43ed0:	2000      	movs	r0, #0
   43ed2:	bd38      	pop	{r3, r4, r5, pc}
   43ed4:	2001aee7 	.word	0x2001aee7
   43ed8:	2001aa10 	.word	0x2001aa10
   43edc:	2001aa18 	.word	0x2001aa18
   43ee0:	000498b8 	.word	0x000498b8
   43ee4:	2001aa0c 	.word	0x2001aa0c

00043ee8 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   43ee8:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   43eea:	4c0d      	ldr	r4, [pc, #52]	; (43f20 <thread_monitor_entry_get+0x38>)
{
   43eec:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   43eee:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   43ef0:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   43ef2:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   43ef4:	4b0b      	ldr	r3, [pc, #44]	; (43f24 <thread_monitor_entry_get+0x3c>)
   43ef6:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   43ef8:	6801      	ldr	r1, [r0, #0]
   43efa:	4291      	cmp	r1, r2
   43efc:	d00e      	beq.n	43f1c <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   43efe:	b151      	cbz	r1, 43f16 <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   43f00:	6841      	ldr	r1, [r0, #4]
   43f02:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   43f04:	42b1      	cmp	r1, r6
   43f06:	bfc4      	itt	gt
   43f08:	4604      	movgt	r4, r0
   43f0a:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   43f0c:	3d01      	subs	r5, #1
   43f0e:	f100 0008 	add.w	r0, r0, #8
   43f12:	d1f1      	bne.n	43ef8 <thread_monitor_entry_get+0x10>
   43f14:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   43f16:	3b01      	subs	r3, #1
	new_entry->id = id;
   43f18:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   43f1a:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   43f1c:	bd70      	pop	{r4, r5, r6, pc}
   43f1e:	bf00      	nop
   43f20:	2001aa84 	.word	0x2001aa84
   43f24:	2001aa60 	.word	0x2001aa60

00043f28 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43f28:	4668      	mov	r0, sp
   43f2a:	f020 0107 	bic.w	r1, r0, #7
   43f2e:	468d      	mov	sp, r1
   43f30:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   43f32:	4b0f      	ldr	r3, [pc, #60]	; (43f70 <rpc_proxy_irq_handler+0x48>)
   43f34:	e8d3 2fef 	ldaex	r2, [r3]
   43f38:	3201      	adds	r2, #1
   43f3a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   43f3e:	2900      	cmp	r1, #0
   43f40:	d1f8      	bne.n	43f34 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   43f42:	f001 f951 	bl	451e8 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   43f46:	4b0b      	ldr	r3, [pc, #44]	; (43f74 <rpc_proxy_irq_handler+0x4c>)
   43f48:	681c      	ldr	r4, [r3, #0]
   43f4a:	2c00      	cmp	r4, #0
   43f4c:	bf38      	it	cc
   43f4e:	2400      	movcc	r4, #0
   43f50:	b12c      	cbz	r4, 43f5e <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   43f52:	1d20      	adds	r0, r4, #4
   43f54:	f002 fdea 	bl	46b2c <z_impl_k_sem_give>
   43f58:	6824      	ldr	r4, [r4, #0]
   43f5a:	2c00      	cmp	r4, #0
   43f5c:	d1f8      	bne.n	43f50 <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   43f5e:	f7fe fab3 	bl	424c8 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   43f62:	f7fe fb8b 	bl	4267c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   43f66:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   43f6a:	4685      	mov	sp, r0
   43f6c:	4770      	bx	lr
   43f6e:	bf00      	nop
   43f70:	2001aa60 	.word	0x2001aa60
   43f74:	2001aa7c 	.word	0x2001aa7c

00043f78 <nrf_modem_os_timedwait>:
{
   43f78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   43f7c:	4688      	mov	r8, r1
   43f7e:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   43f80:	f005 f9a5 	bl	492ce <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   43f84:	f8d8 3000 	ldr.w	r3, [r8]
   43f88:	4604      	mov	r4, r0
   43f8a:	2b00      	cmp	r3, #0
   43f8c:	460d      	mov	r5, r1
   43f8e:	d103      	bne.n	43f98 <nrf_modem_os_timedwait+0x20>
	z_impl_k_yield();
   43f90:	f003 f864 	bl	4705c <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   43f94:	2074      	movs	r0, #116	; 0x74
   43f96:	e077      	b.n	44088 <nrf_modem_os_timedwait+0x110>
		*timeout = SYS_FOREVER_MS;
   43f98:	bfbc      	itt	lt
   43f9a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   43f9e:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   43fa2:	2201      	movs	r2, #1
   43fa4:	2100      	movs	r1, #0
   43fa6:	a802      	add	r0, sp, #8
   43fa8:	f005 f84f 	bl	4904a <z_impl_k_sem_init>
   43fac:	f10d 0904 	add.w	r9, sp, #4
	__asm__ volatile(
   43fb0:	f04f 0320 	mov.w	r3, #32
   43fb4:	f3ef 8b11 	mrs	fp, BASEPRI
   43fb8:	f383 8812 	msr	BASEPRI_MAX, r3
   43fbc:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   43fc0:	f003 f8ee 	bl	471a0 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   43fc4:	f7ff ff90 	bl	43ee8 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   43fc8:	4938      	ldr	r1, [pc, #224]	; (440ac <nrf_modem_os_timedwait+0x134>)
   43fca:	6843      	ldr	r3, [r0, #4]
   43fcc:	680a      	ldr	r2, [r1, #0]
   43fce:	468a      	mov	sl, r1
   43fd0:	4293      	cmp	r3, r2
   43fd2:	f04f 0300 	mov.w	r3, #0
   43fd6:	d108      	bne.n	43fea <nrf_modem_os_timedwait+0x72>
	parent->next = child;
   43fd8:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   43fda:	4b35      	ldr	r3, [pc, #212]	; (440b0 <nrf_modem_os_timedwait+0x138>)
   43fdc:	685a      	ldr	r2, [r3, #4]
   43fde:	2a00      	cmp	r2, #0
   43fe0:	d155      	bne.n	4408e <nrf_modem_os_timedwait+0x116>
	list->head = node;
   43fe2:	e9c3 9900 	strd	r9, r9, [r3]
		allow_to_sleep = true;
   43fe6:	2301      	movs	r3, #1
}
   43fe8:	e000      	b.n	43fec <nrf_modem_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   43fea:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   43fec:	f38b 8811 	msr	BASEPRI, fp
   43ff0:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   43ff4:	2b00      	cmp	r3, #0
   43ff6:	d046      	beq.n	44086 <nrf_modem_os_timedwait+0x10e>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   43ff8:	f8d8 2000 	ldr.w	r2, [r8]
   43ffc:	1c53      	adds	r3, r2, #1
   43ffe:	bf19      	ittee	ne
   44000:	ea22 72e2 	bicne.w	r2, r2, r2, asr #31
   44004:	17d3      	asrne	r3, r2, #31
   44006:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   4400a:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
	return z_impl_k_sem_take(sem, timeout);
   4400e:	a802      	add	r0, sp, #8
   44010:	f002 fdac 	bl	46b6c <z_impl_k_sem_take>
	__asm__ volatile(
   44014:	f04f 0320 	mov.w	r3, #32
   44018:	f3ef 8b11 	mrs	fp, BASEPRI
   4401c:	f383 8812 	msr	BASEPRI_MAX, r3
   44020:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   44024:	2000      	movs	r0, #0
   44026:	4b22      	ldr	r3, [pc, #136]	; (440b0 <nrf_modem_os_timedwait+0x138>)
   44028:	681a      	ldr	r2, [r3, #0]
   4402a:	b152      	cbz	r2, 44042 <nrf_modem_os_timedwait+0xca>
   4402c:	454a      	cmp	r2, r9
   4402e:	d139      	bne.n	440a4 <nrf_modem_os_timedwait+0x12c>
Z_GENLIST_REMOVE(slist, snode)
   44030:	9901      	ldr	r1, [sp, #4]
   44032:	bb88      	cbnz	r0, 44098 <nrf_modem_os_timedwait+0x120>
   44034:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   44036:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   44038:	4290      	cmp	r0, r2
   4403a:	d100      	bne.n	4403e <nrf_modem_os_timedwait+0xc6>
	list->tail = node;
   4403c:	6059      	str	r1, [r3, #4]
	parent->next = child;
   4403e:	2300      	movs	r3, #0
   44040:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   44042:	f003 f8ad 	bl	471a0 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   44046:	f7ff ff4f 	bl	43ee8 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   4404a:	f8da 3000 	ldr.w	r3, [sl]
   4404e:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   44050:	f38b 8811 	msr	BASEPRI, fp
   44054:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   44058:	f8d8 9000 	ldr.w	r9, [r8]
   4405c:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   44060:	d011      	beq.n	44086 <nrf_modem_os_timedwait+0x10e>
	return z_impl_k_uptime_ticks();
   44062:	f005 f934 	bl	492ce <z_impl_k_uptime_ticks>
	remaining = *timeout - k_uptime_delta(&start);
   44066:	eb14 0409 	adds.w	r4, r4, r9
   4406a:	eb45 75e9 	adc.w	r5, r5, r9, asr #31
   4406e:	1a26      	subs	r6, r4, r0
   44070:	eb65 0701 	sbc.w	r7, r5, r1
	*timeout = remaining > 0 ? remaining : 0;
   44074:	2e00      	cmp	r6, #0
   44076:	f177 0300 	sbcs.w	r3, r7, #0
   4407a:	bfb8      	it	lt
   4407c:	2600      	movlt	r6, #0
   4407e:	f8c8 6000 	str.w	r6, [r8]
	if (*timeout == 0) {
   44082:	2e00      	cmp	r6, #0
   44084:	d086      	beq.n	43f94 <nrf_modem_os_timedwait+0x1c>
	return 0;
   44086:	2000      	movs	r0, #0
}
   44088:	b007      	add	sp, #28
   4408a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   4408e:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   44092:	f8c3 9004 	str.w	r9, [r3, #4]
   44096:	e7a6      	b.n	43fe6 <nrf_modem_os_timedwait+0x6e>
	parent->next = child;
   44098:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   4409a:	6859      	ldr	r1, [r3, #4]
   4409c:	4291      	cmp	r1, r2
	list->tail = node;
   4409e:	bf08      	it	eq
   440a0:	6058      	streq	r0, [r3, #4]
}
   440a2:	e7cc      	b.n	4403e <nrf_modem_os_timedwait+0xc6>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   440a4:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   440a6:	6812      	ldr	r2, [r2, #0]
   440a8:	e7bf      	b.n	4402a <nrf_modem_os_timedwait+0xb2>
   440aa:	bf00      	nop
   440ac:	2001aa60 	.word	0x2001aa60
   440b0:	2001aa7c 	.word	0x2001aa7c

000440b4 <nrf_modem_os_sem_init>:
{
   440b4:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   440b6:	6804      	ldr	r4, [r0, #0]
   440b8:	4b09      	ldr	r3, [pc, #36]	; (440e0 <nrf_modem_os_sem_init+0x2c>)
   440ba:	b12c      	cbz	r4, 440c8 <nrf_modem_os_sem_init+0x14>
   440bc:	429c      	cmp	r4, r3
   440be:	d303      	bcc.n	440c8 <nrf_modem_os_sem_init+0x14>
   440c0:	f103 0530 	add.w	r5, r3, #48	; 0x30
   440c4:	42ac      	cmp	r4, r5
   440c6:	d306      	bcc.n	440d6 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   440c8:	4d06      	ldr	r5, [pc, #24]	; (440e4 <nrf_modem_os_sem_init+0x30>)
   440ca:	782c      	ldrb	r4, [r5, #0]
   440cc:	1c66      	adds	r6, r4, #1
   440ce:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   440d2:	702e      	strb	r6, [r5, #0]
   440d4:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   440d6:	6800      	ldr	r0, [r0, #0]
}
   440d8:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   440da:	f004 bfb6 	b.w	4904a <z_impl_k_sem_init>
   440de:	bf00      	nop
   440e0:	2001aa30 	.word	0x2001aa30
   440e4:	2001aee8 	.word	0x2001aee8

000440e8 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   440e8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   440ec:	4b01      	ldr	r3, [pc, #4]	; (440f4 <nrf_modem_os_application_irq_set+0xc>)
   440ee:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   440f2:	4770      	bx	lr
   440f4:	e000e100 	.word	0xe000e100

000440f8 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   440f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   440fc:	4b01      	ldr	r3, [pc, #4]	; (44104 <nrf_modem_os_application_irq_clear+0xc>)
   440fe:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   44102:	4770      	bx	lr
   44104:	e000e100 	.word	0xe000e100

00044108 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   44108:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   4410c:	4b01      	ldr	r3, [pc, #4]	; (44114 <nrf_modem_os_trace_irq_set+0xc>)
   4410e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   44112:	4770      	bx	lr
   44114:	e000e100 	.word	0xe000e100

00044118 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   44118:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   4411c:	4b01      	ldr	r3, [pc, #4]	; (44124 <nrf_modem_os_trace_irq_clear+0xc>)
   4411e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   44122:	4770      	bx	lr
   44124:	e000e100 	.word	0xe000e100

00044128 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   44128:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   4412a:	2200      	movs	r2, #0
   4412c:	2300      	movs	r3, #0
   4412e:	4801      	ldr	r0, [pc, #4]	; (44134 <nrf_modem_os_alloc+0xc>)
   44130:	f004 bf07 	b.w	48f42 <k_heap_alloc>
   44134:	2001a684 	.word	0x2001a684

00044138 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   44138:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   4413a:	4801      	ldr	r0, [pc, #4]	; (44140 <nrf_modem_os_free+0x8>)
   4413c:	f004 bf0b 	b.w	48f56 <k_heap_free>
   44140:	2001a684 	.word	0x2001a684

00044144 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   44144:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   44146:	2200      	movs	r2, #0
   44148:	2300      	movs	r3, #0
   4414a:	4801      	ldr	r0, [pc, #4]	; (44150 <nrf_modem_os_shm_tx_alloc+0xc>)
   4414c:	f004 bef9 	b.w	48f42 <k_heap_alloc>
   44150:	2001aa68 	.word	0x2001aa68

00044154 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   44154:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   44156:	4801      	ldr	r0, [pc, #4]	; (4415c <nrf_modem_os_shm_tx_free+0x8>)
   44158:	f004 befd 	b.w	48f56 <k_heap_free>
   4415c:	2001aa68 	.word	0x2001aa68

00044160 <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   44160:	b510      	push	{r4, lr}
	list->head = NULL;
   44162:	2400      	movs	r4, #0
   44164:	4b0e      	ldr	r3, [pc, #56]	; (441a0 <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   44166:	e9c3 4400 	strd	r4, r4, [r3]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   4416a:	4b0e      	ldr	r3, [pc, #56]	; (441a4 <nrf_modem_os_init+0x44>)
   4416c:	e8d3 2fef 	ldaex	r2, [r3]
   44170:	e8c3 4fe1 	stlex	r1, r4, [r3]
   44174:	2900      	cmp	r1, #0
   44176:	d1f9      	bne.n	4416c <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   44178:	f004 fd74 	bl	48c64 <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   4417c:	4621      	mov	r1, r4
   4417e:	2204      	movs	r2, #4
   44180:	4809      	ldr	r0, [pc, #36]	; (441a8 <nrf_modem_os_init+0x48>)
   44182:	f004 fbdb 	bl	4893c <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   44186:	4621      	mov	r1, r4
   44188:	2204      	movs	r2, #4
   4418a:	4808      	ldr	r0, [pc, #32]	; (441ac <nrf_modem_os_init+0x4c>)
   4418c:	f004 fbd6 	bl	4893c <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   44190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   44194:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   44198:	4905      	ldr	r1, [pc, #20]	; (441b0 <nrf_modem_os_init+0x50>)
   4419a:	4806      	ldr	r0, [pc, #24]	; (441b4 <nrf_modem_os_init+0x54>)
   4419c:	f004 be82 	b.w	48ea4 <k_heap_init>
   441a0:	2001aa7c 	.word	0x2001aa7c
   441a4:	2001aa60 	.word	0x2001aa60
   441a8:	2001aa2c 	.word	0x2001aa2c
   441ac:	2001aa64 	.word	0x2001aa64
   441b0:	200164e8 	.word	0x200164e8
   441b4:	2001aa68 	.word	0x2001aa68

000441b8 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   441b8:	b508      	push	{r3, lr}
	z_impl_log_panic();
   441ba:	f7fd fc61 	bl	41a80 <z_impl_log_panic>
   441be:	4b06      	ldr	r3, [pc, #24]	; (441d8 <k_sys_fatal_error_handler+0x20>)
   441c0:	4906      	ldr	r1, [pc, #24]	; (441dc <k_sys_fatal_error_handler+0x24>)
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   441c2:	4807      	ldr	r0, [pc, #28]	; (441e0 <k_sys_fatal_error_handler+0x28>)
   441c4:	1ac9      	subs	r1, r1, r3
   441c6:	08c9      	lsrs	r1, r1, #3
   441c8:	0189      	lsls	r1, r1, #6
   441ca:	f041 0101 	orr.w	r1, r1, #1
   441ce:	f004 f839 	bl	48244 <log_0>
		sys_arch_reboot(0);
   441d2:	2000      	movs	r0, #0
   441d4:	f004 fd55 	bl	48c82 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   441d8:	00049694 	.word	0x00049694
   441dc:	000496a4 	.word	0x000496a4
   441e0:	0004a25a 	.word	0x0004a25a

000441e4 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   441e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   441e6:	4604      	mov	r4, r0
   441e8:	b0a3      	sub	sp, #140	; 0x8c
   441ea:	460d      	mov	r5, r1
   441ec:	4616      	mov	r6, r2
   441ee:	461f      	mov	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   441f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   441f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   441f8:	480b      	ldr	r0, [pc, #44]	; (44228 <tfm_ns_interface_dispatch+0x44>)
   441fa:	f002 fbd3 	bl	469a4 <z_impl_k_mutex_lock>
	int32_t result;

	/* TF-M request protected by NS lock */
	if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   441fe:	b988      	cbnz	r0, 44224 <tfm_ns_interface_dispatch+0x40>
#endif

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   44200:	4668      	mov	r0, sp
   44202:	f004 fb14 	bl	4882e <z_arm_save_fp_context>
#endif

	result = fn(arg0, arg1, arg2, arg3);
   44206:	463a      	mov	r2, r7
   44208:	4631      	mov	r1, r6
   4420a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   4420c:	4628      	mov	r0, r5
   4420e:	47a0      	blx	r4
   44210:	4604      	mov	r4, r0

#if defined(CONFIG_ARM_NONSECURE_PREEMPTIBLE_SECURE_CALLS)
	z_arm_restore_fp_context(&context_buffer);
   44212:	4668      	mov	r0, sp
   44214:	f004 fb0c 	bl	48830 <z_arm_restore_fp_context>
	return z_impl_k_mutex_unlock(mutex);
   44218:	4803      	ldr	r0, [pc, #12]	; (44228 <tfm_ns_interface_dispatch+0x44>)
   4421a:	f002 fc41 	bl	46aa0 <z_impl_k_mutex_unlock>
#endif

	k_mutex_unlock(&tfm_mutex);

	return result;
}
   4421e:	4620      	mov	r0, r4
   44220:	b023      	add	sp, #140	; 0x8c
   44222:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (int32_t)TFM_ERROR_GENERIC;
   44224:	241f      	movs	r4, #31
   44226:	e7fa      	b.n	4421e <tfm_ns_interface_dispatch+0x3a>
   44228:	2001a6ac 	.word	0x2001a6ac

0004422c <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   4422c:	4b01      	ldr	r3, [pc, #4]	; (44234 <SystemInit+0x8>)
   4422e:	4a02      	ldr	r2, [pc, #8]	; (44238 <SystemInit+0xc>)
   44230:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   44232:	4770      	bx	lr
   44234:	2001a580 	.word	0x2001a580
   44238:	03d09000 	.word	0x03d09000

0004423c <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   4423c:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   4423e:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   44240:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   44242:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   44246:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   44248:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   4424c:	d010      	beq.n	44270 <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   4424e:	fa05 f204 	lsl.w	r2, r5, r4
   44252:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   44256:	e8d0 6fef 	ldaex	r6, [r0]
   4425a:	429e      	cmp	r6, r3
   4425c:	d104      	bne.n	44268 <nrfx_flag32_alloc+0x2c>
   4425e:	e8c0 2fec 	stlex	ip, r2, [r0]
   44262:	f1bc 0f00 	cmp.w	ip, #0
   44266:	d1f6      	bne.n	44256 <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   44268:	d1ea      	bne.n	44240 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   4426a:	4802      	ldr	r0, [pc, #8]	; (44274 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   4426c:	700c      	strb	r4, [r1, #0]
}
   4426e:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   44270:	4801      	ldr	r0, [pc, #4]	; (44278 <nrfx_flag32_alloc+0x3c>)
   44272:	e7fc      	b.n	4426e <nrfx_flag32_alloc+0x32>
   44274:	0bad0000 	.word	0x0bad0000
   44278:	0bad0002 	.word	0x0bad0002

0004427c <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   4427c:	6803      	ldr	r3, [r0, #0]
{
   4427e:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   44280:	40cb      	lsrs	r3, r1
   44282:	07db      	lsls	r3, r3, #31
   44284:	d411      	bmi.n	442aa <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   44286:	2301      	movs	r3, #1
   44288:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   4428c:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   4428e:	ea41 0203 	orr.w	r2, r1, r3
   44292:	e8d0 4fef 	ldaex	r4, [r0]
   44296:	429c      	cmp	r4, r3
   44298:	d104      	bne.n	442a4 <nrfx_flag32_free+0x28>
   4429a:	e8c0 2fec 	stlex	ip, r2, [r0]
   4429e:	f1bc 0f00 	cmp.w	ip, #0
   442a2:	d1f6      	bne.n	44292 <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   442a4:	d1f2      	bne.n	4428c <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   442a6:	4802      	ldr	r0, [pc, #8]	; (442b0 <nrfx_flag32_free+0x34>)
}
   442a8:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   442aa:	4802      	ldr	r0, [pc, #8]	; (442b4 <nrfx_flag32_free+0x38>)
   442ac:	e7fc      	b.n	442a8 <nrfx_flag32_free+0x2c>
   442ae:	bf00      	nop
   442b0:	0bad0000 	.word	0x0bad0000
   442b4:	0bad0004 	.word	0x0bad0004

000442b8 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   442b8:	4b04      	ldr	r3, [pc, #16]	; (442cc <nrfx_clock_init+0x14>)
   442ba:	791a      	ldrb	r2, [r3, #4]
   442bc:	b922      	cbnz	r2, 442c8 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   442be:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   442c0:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   442c2:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   442c4:	4802      	ldr	r0, [pc, #8]	; (442d0 <nrfx_clock_init+0x18>)
   442c6:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   442c8:	4802      	ldr	r0, [pc, #8]	; (442d4 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   442ca:	4770      	bx	lr
   442cc:	2001aad4 	.word	0x2001aad4
   442d0:	0bad0000 	.word	0x0bad0000
   442d4:	0bad000c 	.word	0x0bad000c

000442d8 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   442d8:	b110      	cbz	r0, 442e0 <nrfx_clock_start+0x8>
   442da:	2801      	cmp	r0, #1
   442dc:	d01e      	beq.n	4431c <nrfx_clock_start+0x44>
   442de:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   442e0:	4b13      	ldr	r3, [pc, #76]	; (44330 <nrfx_clock_start+0x58>)
   442e2:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   442e6:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   442ea:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   442ee:	4619      	mov	r1, r3
   442f0:	d010      	beq.n	44314 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   442f2:	f002 0203 	and.w	r2, r2, #3
   442f6:	2a02      	cmp	r2, #2
   442f8:	d10c      	bne.n	44314 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   442fa:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   442fe:	2200      	movs	r2, #0
   44300:	4b0c      	ldr	r3, [pc, #48]	; (44334 <nrfx_clock_start+0x5c>)
   44302:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   44304:	2202      	movs	r2, #2
   44306:	681b      	ldr	r3, [r3, #0]
   44308:	4b09      	ldr	r3, [pc, #36]	; (44330 <nrfx_clock_start+0x58>)
   4430a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4430e:	2201      	movs	r2, #1
   44310:	609a      	str	r2, [r3, #8]
}
   44312:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   44314:	2301      	movs	r3, #1
   44316:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   4431a:	e7f0      	b.n	442fe <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   4431c:	2200      	movs	r2, #0
   4431e:	4b06      	ldr	r3, [pc, #24]	; (44338 <nrfx_clock_start+0x60>)
   44320:	601a      	str	r2, [r3, #0]
   44322:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   44324:	4b02      	ldr	r3, [pc, #8]	; (44330 <nrfx_clock_start+0x58>)
   44326:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4432a:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   4432c:	4770      	bx	lr
   4432e:	bf00      	nop
   44330:	40005000 	.word	0x40005000
   44334:	40005104 	.word	0x40005104
   44338:	40005100 	.word	0x40005100

0004433c <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   4433c:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   4433e:	b110      	cbz	r0, 44346 <nrfx_clock_stop+0xa>
   44340:	2801      	cmp	r0, #1
   44342:	d016      	beq.n	44372 <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   44344:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   44346:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44348:	2101      	movs	r1, #1
   4434a:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   4434e:	4c16      	ldr	r4, [pc, #88]	; (443a8 <nrfx_clock_stop+0x6c>)
   44350:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44354:	4a15      	ldr	r2, [pc, #84]	; (443ac <nrfx_clock_stop+0x70>)
   44356:	6010      	str	r0, [r2, #0]
   44358:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   4435a:	4a15      	ldr	r2, [pc, #84]	; (443b0 <nrfx_clock_stop+0x74>)
   4435c:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   4435e:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   44362:	03db      	lsls	r3, r3, #15
   44364:	d5ee      	bpl.n	44344 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   44366:	2001      	movs	r0, #1
   44368:	f004 fc8e 	bl	48c88 <nrfx_busy_wait>
   4436c:	3d01      	subs	r5, #1
   4436e:	d1f6      	bne.n	4435e <nrfx_clock_stop+0x22>
   44370:	e7e8      	b.n	44344 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44372:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44374:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44378:	4b0e      	ldr	r3, [pc, #56]	; (443b4 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   4437a:	4c0b      	ldr	r4, [pc, #44]	; (443a8 <nrfx_clock_stop+0x6c>)
   4437c:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44380:	601a      	str	r2, [r3, #0]
   44382:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   44384:	4b0c      	ldr	r3, [pc, #48]	; (443b8 <nrfx_clock_stop+0x7c>)
   44386:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   44388:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   4438c:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   44390:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   44394:	03d2      	lsls	r2, r2, #15
   44396:	d5d5      	bpl.n	44344 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   44398:	2b00      	cmp	r3, #0
   4439a:	d0d3      	beq.n	44344 <nrfx_clock_stop+0x8>
   4439c:	2001      	movs	r0, #1
   4439e:	f004 fc73 	bl	48c88 <nrfx_busy_wait>
   443a2:	3d01      	subs	r5, #1
   443a4:	d1f0      	bne.n	44388 <nrfx_clock_stop+0x4c>
   443a6:	e7cd      	b.n	44344 <nrfx_clock_stop+0x8>
   443a8:	40005000 	.word	0x40005000
   443ac:	40005104 	.word	0x40005104
   443b0:	4000500c 	.word	0x4000500c
   443b4:	40005100 	.word	0x40005100
   443b8:	40005004 	.word	0x40005004

000443bc <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   443bc:	4b15      	ldr	r3, [pc, #84]	; (44414 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   443be:	b510      	push	{r4, lr}
   443c0:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   443c2:	b14a      	cbz	r2, 443d8 <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   443c4:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   443c6:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   443c8:	6018      	str	r0, [r3, #0]
   443ca:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   443cc:	4b12      	ldr	r3, [pc, #72]	; (44418 <nrfx_power_clock_irq_handler+0x5c>)
   443ce:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   443d2:	4b12      	ldr	r3, [pc, #72]	; (4441c <nrfx_power_clock_irq_handler+0x60>)
   443d4:	681b      	ldr	r3, [r3, #0]
   443d6:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   443d8:	4b11      	ldr	r3, [pc, #68]	; (44420 <nrfx_power_clock_irq_handler+0x64>)
   443da:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   443dc:	b182      	cbz	r2, 44400 <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   443de:	2200      	movs	r2, #0
   443e0:	601a      	str	r2, [r3, #0]
   443e2:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   443e4:	4b0c      	ldr	r3, [pc, #48]	; (44418 <nrfx_power_clock_irq_handler+0x5c>)
   443e6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   443ea:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   443ee:	f002 0203 	and.w	r2, r2, #3
   443f2:	2a01      	cmp	r2, #1
   443f4:	f04f 0102 	mov.w	r1, #2
   443f8:	d103      	bne.n	44402 <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   443fa:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   443fe:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   44400:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   44402:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   44406:	4b05      	ldr	r3, [pc, #20]	; (4441c <nrfx_power_clock_irq_handler+0x60>)
   44408:	2001      	movs	r0, #1
}
   4440a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   4440e:	681b      	ldr	r3, [r3, #0]
   44410:	4718      	bx	r3
   44412:	bf00      	nop
   44414:	40005100 	.word	0x40005100
   44418:	40005000 	.word	0x40005000
   4441c:	2001aad4 	.word	0x2001aad4
   44420:	40005104 	.word	0x40005104

00044424 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   44424:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   44426:	4801      	ldr	r0, [pc, #4]	; (4442c <nrfx_dppi_channel_alloc+0x8>)
   44428:	f7ff bf08 	b.w	4423c <nrfx_flag32_alloc>
   4442c:	2001a584 	.word	0x2001a584

00044430 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   44430:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   44432:	4c0d      	ldr	r4, [pc, #52]	; (44468 <call_handler+0x38>)
   44434:	f100 0308 	add.w	r3, r0, #8
   44438:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   4443c:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   4443e:	05da      	lsls	r2, r3, #23
{
   44440:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   44442:	d507      	bpl.n	44454 <call_handler+0x24>
   44444:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   44448:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   4444c:	6852      	ldr	r2, [r2, #4]
   4444e:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   44452:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   44454:	68a3      	ldr	r3, [r4, #8]
   44456:	b12b      	cbz	r3, 44464 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   44458:	4631      	mov	r1, r6
   4445a:	4628      	mov	r0, r5
   4445c:	68e2      	ldr	r2, [r4, #12]
    }
}
   4445e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   44462:	4718      	bx	r3
}
   44464:	bd70      	pop	{r4, r5, r6, pc}
   44466:	bf00      	nop
   44468:	2001a588 	.word	0x2001a588

0004446c <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   4446c:	4b12      	ldr	r3, [pc, #72]	; (444b8 <release_handler+0x4c>)
   4446e:	3008      	adds	r0, #8
   44470:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   44474:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   44476:	05d1      	lsls	r1, r2, #23
   44478:	d51b      	bpl.n	444b2 <release_handler+0x46>
   4447a:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   4447e:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   44482:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   44486:	2000      	movs	r0, #0
   44488:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   4448c:	f834 2b02 	ldrh.w	r2, [r4], #2
   44490:	f412 7f80 	tst.w	r2, #256	; 0x100
   44494:	d003      	beq.n	4449e <release_handler+0x32>
   44496:	f3c2 2243 	ubfx	r2, r2, #9, #4
   4449a:	4291      	cmp	r1, r2
   4449c:	d009      	beq.n	444b2 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   4449e:	3001      	adds	r0, #1
   444a0:	2820      	cmp	r0, #32
   444a2:	d1f3      	bne.n	4448c <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   444a4:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   444a6:	4805      	ldr	r0, [pc, #20]	; (444bc <release_handler+0x50>)
}
   444a8:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   444aa:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   444ae:	f7ff bee5 	b.w	4427c <nrfx_flag32_free>
}
   444b2:	bc10      	pop	{r4}
   444b4:	4770      	bx	lr
   444b6:	bf00      	nop
   444b8:	2001a588 	.word	0x2001a588
   444bc:	2001a5dc 	.word	0x2001a5dc

000444c0 <pin_handler_trigger_uninit>:
{
   444c0:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   444c2:	4c0c      	ldr	r4, [pc, #48]	; (444f4 <pin_handler_trigger_uninit+0x34>)
   444c4:	f100 0508 	add.w	r5, r0, #8
   444c8:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   444cc:	069a      	lsls	r2, r3, #26
   444ce:	d50a      	bpl.n	444e6 <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   444d0:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   444d2:	0b5b      	lsrs	r3, r3, #13
   444d4:	009b      	lsls	r3, r3, #2
   444d6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   444da:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   444de:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   444e2:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   444e6:	f7ff ffc1 	bl	4446c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   444ea:	2300      	movs	r3, #0
   444ec:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   444f0:	bd38      	pop	{r3, r4, r5, pc}
   444f2:	bf00      	nop
   444f4:	2001a588 	.word	0x2001a588

000444f8 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   444f8:	f000 021f 	and.w	r2, r0, #31
   444fc:	4805      	ldr	r0, [pc, #20]	; (44514 <nrf_gpio_cfg_sense_set+0x1c>)
   444fe:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44502:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   44506:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4450a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   4450e:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   44512:	4770      	bx	lr
   44514:	40842500 	.word	0x40842500

00044518 <nrfx_gpiote_input_configure>:
{
   44518:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   4451a:	4604      	mov	r4, r0
    if (p_input_config)
   4451c:	b1f9      	cbz	r1, 4455e <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4451e:	4f4c      	ldr	r7, [pc, #304]	; (44650 <nrfx_gpiote_input_configure+0x138>)
   44520:	f100 0c08 	add.w	ip, r0, #8
   44524:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   44528:	f000 0522 	and.w	r5, r0, #34	; 0x22
   4452c:	2d22      	cmp	r5, #34	; 0x22
   4452e:	d102      	bne.n	44536 <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   44530:	4848      	ldr	r0, [pc, #288]	; (44654 <nrfx_gpiote_input_configure+0x13c>)
}
   44532:	b003      	add	sp, #12
   44534:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44536:	4d48      	ldr	r5, [pc, #288]	; (44658 <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   44538:	f004 061f 	and.w	r6, r4, #31
   4453c:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44540:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   44544:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   44546:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   4454a:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   4454e:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   44552:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   44556:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   4455a:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   4455e:	b192      	cbz	r2, 44586 <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   44560:	483b      	ldr	r0, [pc, #236]	; (44650 <nrfx_gpiote_input_configure+0x138>)
   44562:	f104 0608 	add.w	r6, r4, #8
   44566:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   4456a:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   4456c:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   4456e:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   44570:	d50c      	bpl.n	4458c <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   44572:	2a00      	cmp	r2, #0
   44574:	d1dc      	bne.n	44530 <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   44576:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   4457a:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   4457e:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   44582:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   44586:	bbd3      	cbnz	r3, 445fe <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   44588:	4834      	ldr	r0, [pc, #208]	; (4465c <nrfx_gpiote_input_configure+0x144>)
   4458a:	e7d2      	b.n	44532 <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   4458c:	f021 0120 	bic.w	r1, r1, #32
   44590:	04c9      	lsls	r1, r1, #19
   44592:	0cc9      	lsrs	r1, r1, #19
   44594:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   44598:	2a00      	cmp	r2, #0
   4459a:	d0ec      	beq.n	44576 <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   4459c:	2d03      	cmp	r5, #3
   4459e:	d8c7      	bhi.n	44530 <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   445a0:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   445a4:	4662      	mov	r2, ip
   445a6:	0092      	lsls	r2, r2, #2
   445a8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   445ac:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   445b0:	b925      	cbnz	r5, 445bc <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   445b2:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   445b6:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   445ba:	e7dc      	b.n	44576 <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   445bc:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   445c0:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   445c4:	f027 0703 	bic.w	r7, r7, #3
   445c8:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   445cc:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   445d0:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   445d4:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   445d8:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   445dc:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   445e0:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   445e4:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   445e8:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   445ec:	ea47 070e 	orr.w	r7, r7, lr
   445f0:	f041 0120 	orr.w	r1, r1, #32
   445f4:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   445f8:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   445fc:	e7bb      	b.n	44576 <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   445fe:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   44600:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   44604:	f7ff ff32 	bl	4446c <release_handler>
    if (!handler)
   44608:	2e00      	cmp	r6, #0
   4460a:	d0bd      	beq.n	44588 <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   4460c:	4d10      	ldr	r5, [pc, #64]	; (44650 <nrfx_gpiote_input_configure+0x138>)
   4460e:	682b      	ldr	r3, [r5, #0]
   44610:	429e      	cmp	r6, r3
   44612:	d104      	bne.n	4461e <nrfx_gpiote_input_configure+0x106>
   44614:	686b      	ldr	r3, [r5, #4]
   44616:	429f      	cmp	r7, r3
   44618:	d101      	bne.n	4461e <nrfx_gpiote_input_configure+0x106>
   4461a:	2200      	movs	r2, #0
   4461c:	e009      	b.n	44632 <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   4461e:	4810      	ldr	r0, [pc, #64]	; (44660 <nrfx_gpiote_input_configure+0x148>)
   44620:	f10d 0107 	add.w	r1, sp, #7
   44624:	f7ff fe0a 	bl	4423c <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   44628:	4b0c      	ldr	r3, [pc, #48]	; (4465c <nrfx_gpiote_input_configure+0x144>)
   4462a:	4298      	cmp	r0, r3
   4462c:	d181      	bne.n	44532 <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   4462e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   44632:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44636:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   44638:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   4463a:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   4463e:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   44642:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   44646:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   4464a:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   4464e:	e79b      	b.n	44588 <nrfx_gpiote_input_configure+0x70>
   44650:	2001a588 	.word	0x2001a588
   44654:	0bad0004 	.word	0x0bad0004
   44658:	40842500 	.word	0x40842500
   4465c:	0bad0000 	.word	0x0bad0000
   44660:	2001a5dc 	.word	0x2001a5dc

00044664 <nrfx_gpiote_output_configure>:
{
   44664:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   44668:	2900      	cmp	r1, #0
   4466a:	d044      	beq.n	446f6 <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   4466c:	4e43      	ldr	r6, [pc, #268]	; (4477c <nrfx_gpiote_output_configure+0x118>)
   4466e:	f100 0c08 	add.w	ip, r0, #8
   44672:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   44676:	07ab      	lsls	r3, r5, #30
   44678:	d404      	bmi.n	44684 <nrfx_gpiote_output_configure+0x20>
   4467a:	06af      	lsls	r7, r5, #26
   4467c:	d502      	bpl.n	44684 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   4467e:	4840      	ldr	r0, [pc, #256]	; (44780 <nrfx_gpiote_output_configure+0x11c>)
}
   44680:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   44684:	f015 0f1c 	tst.w	r5, #28
   44688:	d002      	beq.n	44690 <nrfx_gpiote_output_configure+0x2c>
   4468a:	784b      	ldrb	r3, [r1, #1]
   4468c:	2b01      	cmp	r3, #1
   4468e:	d0f6      	beq.n	4467e <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   44690:	4b3c      	ldr	r3, [pc, #240]	; (44784 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   44692:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   44696:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   4469a:	bf14      	ite	ne
   4469c:	2402      	movne	r4, #2
   4469e:	2400      	moveq	r4, #0
   446a0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   446a4:	1c8b      	adds	r3, r1, #2
   446a6:	bf14      	ite	ne
   446a8:	f04f 090c 	movne.w	r9, #12
   446ac:	f04f 0900 	moveq.w	r9, #0
   446b0:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   446b4:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   446b8:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   446bc:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   446c0:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   446c4:	f1be 0f00 	cmp.w	lr, #0
   446c8:	d003      	beq.n	446d2 <nrfx_gpiote_output_configure+0x6e>
   446ca:	f891 e001 	ldrb.w	lr, [r1, #1]
   446ce:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   446d2:	b10b      	cbz	r3, 446d8 <nrfx_gpiote_output_configure+0x74>
   446d4:	788c      	ldrb	r4, [r1, #2]
   446d6:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   446d8:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   446da:	f045 0503 	orr.w	r5, r5, #3
   446de:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   446e2:	ea43 0308 	orr.w	r3, r3, r8
   446e6:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   446ea:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   446ee:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   446f2:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   446f6:	b90a      	cbnz	r2, 446fc <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   446f8:	4823      	ldr	r0, [pc, #140]	; (44788 <nrfx_gpiote_output_configure+0x124>)
   446fa:	e7c1      	b.n	44680 <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   446fc:	4d1f      	ldr	r5, [pc, #124]	; (4477c <nrfx_gpiote_output_configure+0x118>)
   446fe:	f100 0608 	add.w	r6, r0, #8
   44702:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   44706:	07a3      	lsls	r3, r4, #30
   44708:	d5b9      	bpl.n	4467e <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   4470a:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   4470c:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   4470e:	f024 0420 	bic.w	r4, r4, #32
   44712:	00b9      	lsls	r1, r7, #2
   44714:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   44718:	04e4      	lsls	r4, r4, #19
   4471a:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   4471e:	0ce4      	lsrs	r4, r4, #19
   44720:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44724:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   44728:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   4472c:	f892 c001 	ldrb.w	ip, [r2, #1]
   44730:	f1bc 0f00 	cmp.w	ip, #0
   44734:	d0e0      	beq.n	446f8 <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   44736:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   4473a:	7892      	ldrb	r2, [r2, #2]
   4473c:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   44740:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   44744:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44748:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   4474c:	0203      	lsls	r3, r0, #8
   4474e:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   44752:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44756:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   4475a:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   4475e:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   44760:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   44762:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   44766:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   4476a:	4313      	orrs	r3, r2
   4476c:	f044 0420 	orr.w	r4, r4, #32
   44770:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44774:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   44778:	e7be      	b.n	446f8 <nrfx_gpiote_output_configure+0x94>
   4477a:	bf00      	nop
   4477c:	2001a588 	.word	0x2001a588
   44780:	0bad0004 	.word	0x0bad0004
   44784:	40842500 	.word	0x40842500
   44788:	0bad0000 	.word	0x0bad0000

0004478c <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   4478c:	4b01      	ldr	r3, [pc, #4]	; (44794 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   4478e:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   44792:	4770      	bx	lr
   44794:	2001a588 	.word	0x2001a588

00044798 <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44798:	4b05      	ldr	r3, [pc, #20]	; (447b0 <nrfx_gpiote_channel_get+0x18>)
   4479a:	3008      	adds	r0, #8
   4479c:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   447a0:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   447a2:	bf43      	ittte	mi
   447a4:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   447a6:	4803      	ldrmi	r0, [pc, #12]	; (447b4 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   447a8:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   447aa:	4803      	ldrpl	r0, [pc, #12]	; (447b8 <nrfx_gpiote_channel_get+0x20>)
}
   447ac:	4770      	bx	lr
   447ae:	bf00      	nop
   447b0:	2001a588 	.word	0x2001a588
   447b4:	0bad0000 	.word	0x0bad0000
   447b8:	0bad0004 	.word	0x0bad0004

000447bc <nrfx_gpiote_init>:
{
   447bc:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   447be:	4c0e      	ldr	r4, [pc, #56]	; (447f8 <nrfx_gpiote_init+0x3c>)
   447c0:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   447c4:	b9b5      	cbnz	r5, 447f4 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   447c6:	2240      	movs	r2, #64	; 0x40
   447c8:	4629      	mov	r1, r5
   447ca:	f104 0010 	add.w	r0, r4, #16
   447ce:	f004 f8b5 	bl	4893c <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   447d2:	2031      	movs	r0, #49	; 0x31
   447d4:	f7fd fe44 	bl	42460 <arch_irq_enable>
    p_reg->INTENSET = mask;
   447d8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   447dc:	4b07      	ldr	r3, [pc, #28]	; (447fc <nrfx_gpiote_init+0x40>)
    return err_code;
   447de:	4808      	ldr	r0, [pc, #32]	; (44800 <nrfx_gpiote_init+0x44>)
   447e0:	601d      	str	r5, [r3, #0]
   447e2:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   447e4:	4b07      	ldr	r3, [pc, #28]	; (44804 <nrfx_gpiote_init+0x48>)
   447e6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   447ea:	2301      	movs	r3, #1
   447ec:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   447f0:	6563      	str	r3, [r4, #84]	; 0x54
}
   447f2:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   447f4:	4804      	ldr	r0, [pc, #16]	; (44808 <nrfx_gpiote_init+0x4c>)
   447f6:	e7fc      	b.n	447f2 <nrfx_gpiote_init+0x36>
   447f8:	2001a588 	.word	0x2001a588
   447fc:	4003117c 	.word	0x4003117c
   44800:	0bad0000 	.word	0x0bad0000
   44804:	40031000 	.word	0x40031000
   44808:	0bad0005 	.word	0x0bad0005

0004480c <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   4480c:	4b03      	ldr	r3, [pc, #12]	; (4481c <nrfx_gpiote_is_init+0x10>)
   4480e:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   44812:	3800      	subs	r0, #0
   44814:	bf18      	it	ne
   44816:	2001      	movne	r0, #1
   44818:	4770      	bx	lr
   4481a:	bf00      	nop
   4481c:	2001a588 	.word	0x2001a588

00044820 <nrfx_gpiote_channel_free>:
{
   44820:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   44822:	4801      	ldr	r0, [pc, #4]	; (44828 <nrfx_gpiote_channel_free+0x8>)
   44824:	f7ff bd2a 	b.w	4427c <nrfx_flag32_free>
   44828:	2001a5d8 	.word	0x2001a5d8

0004482c <nrfx_gpiote_channel_alloc>:
{
   4482c:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   4482e:	4801      	ldr	r0, [pc, #4]	; (44834 <nrfx_gpiote_channel_alloc+0x8>)
   44830:	f7ff bd04 	b.w	4423c <nrfx_flag32_alloc>
   44834:	2001a5d8 	.word	0x2001a5d8

00044838 <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   44838:	4b1b      	ldr	r3, [pc, #108]	; (448a8 <nrfx_gpiote_trigger_enable+0x70>)
   4483a:	f100 0208 	add.w	r2, r0, #8
   4483e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   44842:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   44844:	069a      	lsls	r2, r3, #26
   44846:	d51a      	bpl.n	4487e <nrfx_gpiote_trigger_enable+0x46>
   44848:	f013 0402 	ands.w	r4, r3, #2
   4484c:	d117      	bne.n	4487e <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   4484e:	4817      	ldr	r0, [pc, #92]	; (448ac <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   44850:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   44852:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44854:	5084      	str	r4, [r0, r2]
   44856:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   44858:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   4485c:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   44860:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   44864:	f040 0001 	orr.w	r0, r0, #1
   44868:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   4486c:	b129      	cbz	r1, 4487a <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   4486e:	2201      	movs	r2, #1
   44870:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   44874:	4a0e      	ldr	r2, [pc, #56]	; (448b0 <nrfx_gpiote_trigger_enable+0x78>)
   44876:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   4487a:	bc10      	pop	{r4}
   4487c:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   4487e:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   44882:	2b04      	cmp	r3, #4
   44884:	d00c      	beq.n	448a0 <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   44886:	2b05      	cmp	r3, #5
   44888:	d00c      	beq.n	448a4 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   4488a:	4b0a      	ldr	r3, [pc, #40]	; (448b4 <nrfx_gpiote_trigger_enable+0x7c>)
   4488c:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   4488e:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   44892:	40d9      	lsrs	r1, r3
   44894:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44898:	3102      	adds	r1, #2
}
   4489a:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   4489c:	f7ff be2c 	b.w	444f8 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   448a0:	2103      	movs	r1, #3
   448a2:	e7fa      	b.n	4489a <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   448a4:	2102      	movs	r1, #2
   448a6:	e7f8      	b.n	4489a <nrfx_gpiote_trigger_enable+0x62>
   448a8:	2001a588 	.word	0x2001a588
   448ac:	40031100 	.word	0x40031100
   448b0:	40031000 	.word	0x40031000
   448b4:	40842500 	.word	0x40842500

000448b8 <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   448b8:	4b0e      	ldr	r3, [pc, #56]	; (448f4 <nrfx_gpiote_trigger_disable+0x3c>)
   448ba:	f100 0208 	add.w	r2, r0, #8
   448be:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   448c2:	0699      	lsls	r1, r3, #26
   448c4:	d513      	bpl.n	448ee <nrfx_gpiote_trigger_disable+0x36>
   448c6:	079a      	lsls	r2, r3, #30
   448c8:	d411      	bmi.n	448ee <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   448ca:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   448cc:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   448ce:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   448d0:	4909      	ldr	r1, [pc, #36]	; (448f8 <nrfx_gpiote_trigger_disable+0x40>)
   448d2:	009b      	lsls	r3, r3, #2
   448d4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   448d8:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   448dc:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   448e0:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   448e4:	f022 0203 	bic.w	r2, r2, #3
   448e8:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   448ec:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   448ee:	2100      	movs	r1, #0
   448f0:	f7ff be02 	b.w	444f8 <nrf_gpio_cfg_sense_set>
   448f4:	2001a588 	.word	0x2001a588
   448f8:	40031000 	.word	0x40031000

000448fc <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   448fc:	4b0c      	ldr	r3, [pc, #48]	; (44930 <nrfx_gpiote_pin_uninit+0x34>)
   448fe:	f100 0208 	add.w	r2, r0, #8
   44902:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   44906:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   44908:	07db      	lsls	r3, r3, #31
{
   4490a:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   4490c:	d50d      	bpl.n	4492a <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   4490e:	f7ff ffd3 	bl	448b8 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   44912:	4620      	mov	r0, r4
   44914:	f7ff fdd4 	bl	444c0 <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   44918:	2202      	movs	r2, #2
   4491a:	4b06      	ldr	r3, [pc, #24]	; (44934 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   4491c:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   44920:	3480      	adds	r4, #128	; 0x80
   44922:	4805      	ldr	r0, [pc, #20]	; (44938 <nrfx_gpiote_pin_uninit+0x3c>)
   44924:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   44928:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   4492a:	4804      	ldr	r0, [pc, #16]	; (4493c <nrfx_gpiote_pin_uninit+0x40>)
   4492c:	e7fc      	b.n	44928 <nrfx_gpiote_pin_uninit+0x2c>
   4492e:	bf00      	nop
   44930:	2001a588 	.word	0x2001a588
   44934:	40842500 	.word	0x40842500
   44938:	0bad0000 	.word	0x0bad0000
   4493c:	0bad0004 	.word	0x0bad0004

00044940 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   44940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   44944:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   44946:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44948:	4634      	mov	r4, r6
{
   4494a:	4b4b      	ldr	r3, [pc, #300]	; (44a78 <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   4494c:	484b      	ldr	r0, [pc, #300]	; (44a7c <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   4494e:	494c      	ldr	r1, [pc, #304]	; (44a80 <nrfx_gpiote_irq_handler+0x140>)
{
   44950:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   44952:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   44954:	b135      	cbz	r5, 44964 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   44956:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   4495a:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   4495c:	bf1e      	ittt	ne
   4495e:	601c      	strne	r4, [r3, #0]
   44960:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   44962:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   44964:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   44966:	428b      	cmp	r3, r1
        mask <<= 1;
   44968:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   4496c:	d1f1      	bne.n	44952 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   4496e:	4f45      	ldr	r7, [pc, #276]	; (44a84 <nrfx_gpiote_irq_handler+0x144>)
   44970:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   44972:	b183      	cbz	r3, 44996 <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   44974:	4d44      	ldr	r5, [pc, #272]	; (44a88 <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   44976:	f10d 080c 	add.w	r8, sp, #12
   4497a:	6a2b      	ldr	r3, [r5, #32]
   4497c:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   4497e:	622b      	str	r3, [r5, #32]
   44980:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   44984:	9803      	ldr	r0, [sp, #12]
   44986:	b940      	cbnz	r0, 4499a <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   44988:	6038      	str	r0, [r7, #0]
   4498a:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   4498c:	6a2b      	ldr	r3, [r5, #32]
   4498e:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   44990:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   44992:	2b00      	cmp	r3, #0
   44994:	d1f4      	bne.n	44980 <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   44996:	2401      	movs	r4, #1
   44998:	e069      	b.n	44a6e <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   4499a:	fa90 faa0 	rbit	sl, r0
   4499e:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   449a2:	4a3a      	ldr	r2, [pc, #232]	; (44a8c <nrfx_gpiote_irq_handler+0x14c>)
   449a4:	f10a 0308 	add.w	r3, sl, #8
   449a8:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   449ac:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   449b0:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   449b4:	fa09 f403 	lsl.w	r4, r9, r3
   449b8:	f818 300c 	ldrb.w	r3, [r8, ip]
   449bc:	f3c1 0282 	ubfx	r2, r1, #2, #3
   449c0:	ea23 0304 	bic.w	r3, r3, r4
   449c4:	f808 300c 	strb.w	r3, [r8, ip]
   449c8:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   449cc:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   449d0:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   449d2:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   449d4:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   449d8:	d518      	bpl.n	44a0c <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   449da:	4611      	mov	r1, r2
   449dc:	4650      	mov	r0, sl
   449de:	9301      	str	r3, [sp, #4]
   449e0:	f7ff fd26 	bl	44430 <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   449e4:	9b01      	ldr	r3, [sp, #4]
   449e6:	b2e4      	uxtb	r4, r4
   449e8:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   449ec:	f3c3 4301 	ubfx	r3, r3, #16, #2
   449f0:	429c      	cmp	r4, r3
   449f2:	d107      	bne.n	44a04 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   449f4:	2100      	movs	r1, #0
   449f6:	4650      	mov	r0, sl
   449f8:	f7ff fd7e 	bl	444f8 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   449fc:	4621      	mov	r1, r4
   449fe:	4650      	mov	r0, sl
   44a00:	f7ff fd7a 	bl	444f8 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   44a04:	fa09 f00a 	lsl.w	r0, r9, sl
   44a08:	6228      	str	r0, [r5, #32]
}
   44a0a:	e7bb      	b.n	44984 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   44a0c:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   44a0e:	bf0c      	ite	eq
   44a10:	2103      	moveq	r1, #3
   44a12:	2102      	movne	r1, #2
   44a14:	4650      	mov	r0, sl
   44a16:	9201      	str	r2, [sp, #4]
   44a18:	f7ff fd6e 	bl	444f8 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   44a1c:	9a01      	ldr	r2, [sp, #4]
   44a1e:	2a03      	cmp	r2, #3
   44a20:	d004      	beq.n	44a2c <nrfx_gpiote_irq_handler+0xec>
   44a22:	2c02      	cmp	r4, #2
   44a24:	d107      	bne.n	44a36 <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   44a26:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   44a2a:	d1eb      	bne.n	44a04 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   44a2c:	4659      	mov	r1, fp
   44a2e:	4650      	mov	r0, sl
   44a30:	f7ff fcfe 	bl	44430 <call_handler>
   44a34:	e7e6      	b.n	44a04 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   44a36:	2c03      	cmp	r4, #3
   44a38:	d1e4      	bne.n	44a04 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   44a3a:	f1bb 0f02 	cmp.w	fp, #2
   44a3e:	e7f4      	b.n	44a2a <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   44a40:	fa96 f3a6 	rbit	r3, r6
   44a44:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   44a48:	fa04 f203 	lsl.w	r2, r4, r3
   44a4c:	009b      	lsls	r3, r3, #2
   44a4e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   44a52:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   44a56:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   44a5a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   44a5e:	f3c0 2004 	ubfx	r0, r0, #8, #5
   44a62:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   44a66:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   44a6a:	f7ff fce1 	bl	44430 <call_handler>
    while (mask)
   44a6e:	2e00      	cmp	r6, #0
   44a70:	d1e6      	bne.n	44a40 <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   44a72:	b005      	add	sp, #20
   44a74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44a78:	40031100 	.word	0x40031100
   44a7c:	40031000 	.word	0x40031000
   44a80:	40031120 	.word	0x40031120
   44a84:	4003117c 	.word	0x4003117c
   44a88:	40842500 	.word	0x40842500
   44a8c:	2001a588 	.word	0x2001a588

00044a90 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   44a90:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44a92:	4c08      	ldr	r4, [pc, #32]	; (44ab4 <nrfx_ipc_init+0x24>)
{
   44a94:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44a96:	7923      	ldrb	r3, [r4, #4]
{
   44a98:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   44a9a:	b943      	cbnz	r3, 44aae <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   44a9c:	202a      	movs	r0, #42	; 0x2a
   44a9e:	f7fd fcdf 	bl	42460 <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44aa2:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   44aa4:	4804      	ldr	r0, [pc, #16]	; (44ab8 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   44aa6:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   44aa8:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   44aaa:	60a5      	str	r5, [r4, #8]
}
   44aac:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   44aae:	4803      	ldr	r0, [pc, #12]	; (44abc <nrfx_ipc_init+0x2c>)
   44ab0:	e7fc      	b.n	44aac <nrfx_ipc_init+0x1c>
   44ab2:	bf00      	nop
   44ab4:	2001aadc 	.word	0x2001aadc
   44ab8:	0bad0000 	.word	0x0bad0000
   44abc:	0bad000c 	.word	0x0bad000c

00044ac0 <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44ac0:	2300      	movs	r3, #0
{
   44ac2:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   44ac4:	4a0d      	ldr	r2, [pc, #52]	; (44afc <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   44ac6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   44aca:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44ace:	3301      	adds	r3, #1
   44ad0:	2b08      	cmp	r3, #8
   44ad2:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   44ad6:	d1f6      	bne.n	44ac6 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   44ad8:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   44ada:	4a08      	ldr	r2, [pc, #32]	; (44afc <nrfx_ipc_config_load+0x3c>)
   44adc:	f100 0120 	add.w	r1, r0, #32
   44ae0:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   44ae4:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   44ae8:	3301      	adds	r3, #1
   44aea:	2b08      	cmp	r3, #8
   44aec:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   44af0:	d1f6      	bne.n	44ae0 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   44af2:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   44af4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   44af8:	bd30      	pop	{r4, r5, pc}
   44afa:	bf00      	nop
   44afc:	4002a000 	.word	0x4002a000

00044b00 <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   44b00:	2300      	movs	r3, #0
   44b02:	4a14      	ldr	r2, [pc, #80]	; (44b54 <nrfx_ipc_uninit+0x54>)
   44b04:	4914      	ldr	r1, [pc, #80]	; (44b58 <nrfx_ipc_uninit+0x58>)
   44b06:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   44b0a:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   44b0e:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   44b12:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   44b16:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   44b1a:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   44b1e:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   44b22:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   44b26:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   44b2a:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   44b2e:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   44b32:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   44b36:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   44b3a:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   44b3e:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   44b42:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   44b46:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   44b4a:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   44b4e:	4a03      	ldr	r2, [pc, #12]	; (44b5c <nrfx_ipc_uninit+0x5c>)
   44b50:	7113      	strb	r3, [r2, #4]
}
   44b52:	4770      	bx	lr
   44b54:	4002a004 	.word	0x4002a004
   44b58:	4002a000 	.word	0x4002a000
   44b5c:	2001aadc 	.word	0x2001aadc

00044b60 <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   44b60:	4b0c      	ldr	r3, [pc, #48]	; (44b94 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   44b62:	b430      	push	{r4, r5}
   44b64:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   44b68:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   44b6a:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44b6c:	2500      	movs	r5, #0
    while (bitmask)
   44b6e:	b923      	cbnz	r3, 44b7a <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   44b70:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   44b72:	4b09      	ldr	r3, [pc, #36]	; (44b98 <nrfx_ipc_irq_handler+0x38>)
   44b74:	681a      	ldr	r2, [r3, #0]
   44b76:	6899      	ldr	r1, [r3, #8]
   44b78:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   44b7a:	fa93 f2a3 	rbit	r2, r3
   44b7e:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   44b82:	fa04 f102 	lsl.w	r1, r4, r2
   44b86:	ea23 0301 	bic.w	r3, r3, r1
   44b8a:	4904      	ldr	r1, [pc, #16]	; (44b9c <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   44b8c:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   44b8e:	508d      	str	r5, [r1, r2]
}
   44b90:	e7ed      	b.n	44b6e <nrfx_ipc_irq_handler+0xe>
   44b92:	bf00      	nop
   44b94:	4002a000 	.word	0x4002a000
   44b98:	2001aadc 	.word	0x2001aadc
   44b9c:	4002a100 	.word	0x4002a100

00044ba0 <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44ba0:	2303      	movs	r3, #3
static void _DoInit(void) {
   44ba2:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44ba4:	4c10      	ldr	r4, [pc, #64]	; (44be8 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   44ba6:	4a11      	ldr	r2, [pc, #68]	; (44bec <_DoInit+0x4c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   44ba8:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   44baa:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   44bac:	4b10      	ldr	r3, [pc, #64]	; (44bf0 <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   44bae:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   44bb0:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   44bb2:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
   44bb6:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   44bb8:	2300      	movs	r3, #0
   44bba:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   44bbc:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   44bbe:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   44bc0:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   44bc2:	4a0c      	ldr	r2, [pc, #48]	; (44bf4 <_DoInit+0x54>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   44bc4:	490c      	ldr	r1, [pc, #48]	; (44bf8 <_DoInit+0x58>)
  p->aDown[0].pBuffer       = _acDownBuffer;
   44bc6:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44bc8:	2210      	movs	r2, #16
  STRCPY((char*)&p->acID[7], "RTT");
   44bca:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   44bcc:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   44bce:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   44bd0:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   44bd2:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   44bd4:	f003 fe66 	bl	488a4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   44bd8:	4620      	mov	r0, r4
   44bda:	4908      	ldr	r1, [pc, #32]	; (44bfc <_DoInit+0x5c>)
   44bdc:	f003 fe62 	bl	488a4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   44be0:	2320      	movs	r3, #32
   44be2:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   44be4:	bd10      	pop	{r4, pc}
   44be6:	bf00      	nop
   44be8:	2001aae8 	.word	0x2001aae8
   44bec:	0004a277 	.word	0x0004a277
   44bf0:	2001aef9 	.word	0x2001aef9
   44bf4:	2001aee9 	.word	0x2001aee9
   44bf8:	0004a280 	.word	0x0004a280
   44bfc:	0004a284 	.word	0x0004a284

00044c00 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44c00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   44c04:	f04f 0b18 	mov.w	fp, #24
   44c08:	4f22      	ldr	r7, [pc, #136]	; (44c94 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44c0a:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   44c0c:	fb0b 7200 	mla	r2, fp, r0, r7
   44c10:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   44c12:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44c14:	4606      	mov	r6, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   44c16:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   44c18:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   44c1a:	d834      	bhi.n	44c86 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   44c1c:	f8d2 a020 	ldr.w	sl, [r2, #32]
   44c20:	ebaa 0905 	sub.w	r9, sl, r5
   44c24:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
   44c28:	4294      	cmp	r4, r2
   44c2a:	d811      	bhi.n	44c50 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   44c2c:	f04f 0918 	mov.w	r9, #24
   44c30:	fb06 9309 	mla	r3, r6, r9, r9
   44c34:	443b      	add	r3, r7
   44c36:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   44c38:	4622      	mov	r2, r4
   44c3a:	4641      	mov	r1, r8
   44c3c:	4428      	add	r0, r5
   44c3e:	f003 fe72 	bl	48926 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   44c42:	fb09 7606 	mla	r6, r9, r6, r7
   44c46:	442c      	add	r4, r5
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
   44c48:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   44c4a:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   44c4c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   44c50:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   44c52:	429c      	cmp	r4, r3
   44c54:	d81b      	bhi.n	44c8e <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   44c56:	fb00 bb0b 	mla	fp, r0, fp, fp
   44c5a:	44bb      	add	fp, r7
   44c5c:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   44c60:	464a      	mov	r2, r9
   44c62:	4428      	add	r0, r5
   44c64:	442c      	add	r4, r5
   44c66:	f003 fe5e 	bl	48926 <memcpy>
      if (NumBytes) {
   44c6a:	ebb4 040a 	subs.w	r4, r4, sl
   44c6e:	d006      	beq.n	44c7e <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   44c70:	4622      	mov	r2, r4
   44c72:	f8db 0004 	ldr.w	r0, [fp, #4]
   44c76:	eb08 0109 	add.w	r1, r8, r9
   44c7a:	f003 fe54 	bl	48926 <memcpy>
      pRing->WrOff = NumBytes;
   44c7e:	2018      	movs	r0, #24
   44c80:	fb00 7606 	mla	r6, r0, r6, r7
   44c84:	e7e0      	b.n	44c48 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   44c86:	3b01      	subs	r3, #1
   44c88:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   44c8a:	42a3      	cmp	r3, r4
   44c8c:	d2ce      	bcs.n	44c2c <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   44c8e:	2000      	movs	r0, #0
   44c90:	e7dc      	b.n	44c4c <SEGGER_RTT_WriteSkipNoLock+0x4c>
   44c92:	bf00      	nop
   44c94:	2001aae8 	.word	0x2001aae8

00044c98 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   44c98:	2218      	movs	r2, #24
   44c9a:	4b03      	ldr	r3, [pc, #12]	; (44ca8 <SEGGER_RTT_HasDataUp+0x10>)
   44c9c:	fb02 3300 	mla	r3, r2, r0, r3
   44ca0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   44ca2:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   44ca4:	1a80      	subs	r0, r0, r2
   44ca6:	4770      	bx	lr
   44ca8:	2001aae8 	.word	0x2001aae8

00044cac <rpc_handle_data_message>:
   44cac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   44cb0:	4680      	mov	r8, r0
   44cb2:	4604      	mov	r4, r0
   44cb4:	2700      	movs	r7, #0
   44cb6:	f858 6b08 	ldr.w	r6, [r8], #8
   44cba:	4d0c      	ldr	r5, [pc, #48]	; (44cec <rpc_handle_data_message+0x40>)
   44cbc:	b2f6      	uxtb	r6, r6
   44cbe:	782b      	ldrb	r3, [r5, #0]
   44cc0:	42b3      	cmp	r3, r6
   44cc2:	d00a      	beq.n	44cda <rpc_handle_data_message+0x2e>
   44cc4:	3701      	adds	r7, #1
   44cc6:	2f04      	cmp	r7, #4
   44cc8:	f105 050c 	add.w	r5, r5, #12
   44ccc:	d1f7      	bne.n	44cbe <rpc_handle_data_message+0x12>
   44cce:	68a0      	ldr	r0, [r4, #8]
   44cd0:	b150      	cbz	r0, 44ce8 <rpc_handle_data_message+0x3c>
   44cd2:	f004 f82f 	bl	48d34 <rpc_transport_peer_data_free>
   44cd6:	2000      	movs	r0, #0
   44cd8:	e006      	b.n	44ce8 <rpc_handle_data_message+0x3c>
   44cda:	6821      	ldr	r1, [r4, #0]
   44cdc:	4640      	mov	r0, r8
   44cde:	686b      	ldr	r3, [r5, #4]
   44ce0:	0c09      	lsrs	r1, r1, #16
   44ce2:	4798      	blx	r3
   44ce4:	2802      	cmp	r0, #2
   44ce6:	d0ed      	beq.n	44cc4 <rpc_handle_data_message+0x18>
   44ce8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   44cec:	000498dc 	.word	0x000498dc

00044cf0 <trace_write>:
   44cf0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44cf4:	4f53      	ldr	r7, [pc, #332]	; (44e44 <trace_write+0x154>)
   44cf6:	4605      	mov	r5, r0
   44cf8:	2100      	movs	r1, #0
   44cfa:	6838      	ldr	r0, [r7, #0]
   44cfc:	f003 ffa0 	bl	48c40 <nrf_modem_os_sem_take>
   44d00:	4604      	mov	r4, r0
   44d02:	2800      	cmp	r0, #0
   44d04:	d14c      	bne.n	44da0 <trace_write+0xb0>
   44d06:	782b      	ldrb	r3, [r5, #0]
   44d08:	f8d5 8008 	ldr.w	r8, [r5, #8]
   44d0c:	2b62      	cmp	r3, #98	; 0x62
   44d0e:	d043      	beq.n	44d98 <trace_write+0xa8>
   44d10:	2b63      	cmp	r3, #99	; 0x63
   44d12:	d043      	beq.n	44d9c <trace_write+0xac>
   44d14:	2b61      	cmp	r3, #97	; 0x61
   44d16:	d102      	bne.n	44d1e <trace_write+0x2e>
   44d18:	4b4b      	ldr	r3, [pc, #300]	; (44e48 <trace_write+0x158>)
   44d1a:	881c      	ldrh	r4, [r3, #0]
   44d1c:	b2a4      	uxth	r4, r4
   44d1e:	6838      	ldr	r0, [r7, #0]
   44d20:	f003 ff8c 	bl	48c3c <nrf_modem_os_sem_give>
   44d24:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   44d28:	6929      	ldr	r1, [r5, #16]
   44d2a:	eba8 080a 	sub.w	r8, r8, sl
   44d2e:	eba1 030a 	sub.w	r3, r1, sl
   44d32:	b29b      	uxth	r3, r3
   44d34:	fa14 f488 	uxtah	r4, r4, r8
   44d38:	fbb4 f2f3 	udiv	r2, r4, r3
   44d3c:	fb03 4412 	mls	r4, r3, r2, r4
   44d40:	686a      	ldr	r2, [r5, #4]
   44d42:	eba2 020a 	sub.w	r2, r2, sl
   44d46:	fa13 f282 	uxtah	r2, r3, r2
   44d4a:	1b12      	subs	r2, r2, r4
   44d4c:	fb92 f0f3 	sdiv	r0, r2, r3
   44d50:	fb03 2210 	mls	r2, r3, r0, r2
   44d54:	fa1f f982 	uxth.w	r9, r2
   44d58:	fa14 f282 	uxtah	r2, r4, r2
   44d5c:	4293      	cmp	r3, r2
   44d5e:	44a2      	add	sl, r4
   44d60:	da22      	bge.n	44da8 <trace_write+0xb8>
   44d62:	eba1 030a 	sub.w	r3, r1, sl
   44d66:	b29b      	uxth	r3, r3
   44d68:	eba9 0403 	sub.w	r4, r9, r3
   44d6c:	4699      	mov	r9, r3
   44d6e:	b2a4      	uxth	r4, r4
   44d70:	f1b9 0f00 	cmp.w	r9, #0
   44d74:	d064      	beq.n	44e40 <trace_write+0x150>
   44d76:	2005      	movs	r0, #5
   44d78:	f7ff f9d6 	bl	44128 <nrf_modem_os_alloc>
   44d7c:	4680      	mov	r8, r0
   44d7e:	2800      	cmp	r0, #0
   44d80:	d05e      	beq.n	44e40 <trace_write+0x150>
   44d82:	b19c      	cbz	r4, 44dac <trace_write+0xbc>
   44d84:	2005      	movs	r0, #5
   44d86:	f7ff f9cf 	bl	44128 <nrf_modem_os_alloc>
   44d8a:	4606      	mov	r6, r0
   44d8c:	b970      	cbnz	r0, 44dac <trace_write+0xbc>
   44d8e:	4640      	mov	r0, r8
   44d90:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44d94:	f7ff b9d0 	b.w	44138 <nrf_modem_os_free>
   44d98:	4b2c      	ldr	r3, [pc, #176]	; (44e4c <trace_write+0x15c>)
   44d9a:	e7be      	b.n	44d1a <trace_write+0x2a>
   44d9c:	4b2c      	ldr	r3, [pc, #176]	; (44e50 <trace_write+0x160>)
   44d9e:	e7bc      	b.n	44d1a <trace_write+0x2a>
   44da0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44da4:	f7ff b9b0 	b.w	44108 <nrf_modem_os_trace_irq_set>
   44da8:	2400      	movs	r4, #0
   44daa:	e7e1      	b.n	44d70 <trace_write+0x80>
   44dac:	2100      	movs	r1, #0
   44dae:	6838      	ldr	r0, [r7, #0]
   44db0:	f003 ff46 	bl	48c40 <nrf_modem_os_sem_take>
   44db4:	b140      	cbz	r0, 44dc8 <trace_write+0xd8>
   44db6:	f7ff f9a7 	bl	44108 <nrf_modem_os_trace_irq_set>
   44dba:	4640      	mov	r0, r8
   44dbc:	f7ff f9bc 	bl	44138 <nrf_modem_os_free>
   44dc0:	2c00      	cmp	r4, #0
   44dc2:	d03d      	beq.n	44e40 <trace_write+0x150>
   44dc4:	4630      	mov	r0, r6
   44dc6:	e7e3      	b.n	44d90 <trace_write+0xa0>
   44dc8:	782b      	ldrb	r3, [r5, #0]
   44dca:	2b62      	cmp	r3, #98	; 0x62
   44dcc:	d034      	beq.n	44e38 <trace_write+0x148>
   44dce:	2b63      	cmp	r3, #99	; 0x63
   44dd0:	d034      	beq.n	44e3c <trace_write+0x14c>
   44dd2:	2b61      	cmp	r3, #97	; 0x61
   44dd4:	d107      	bne.n	44de6 <trace_write+0xf6>
   44dd6:	4a1c      	ldr	r2, [pc, #112]	; (44e48 <trace_write+0x158>)
   44dd8:	8813      	ldrh	r3, [r2, #0]
   44dda:	eb04 0109 	add.w	r1, r4, r9
   44dde:	fa11 f383 	uxtah	r3, r1, r3
   44de2:	b29b      	uxth	r3, r3
   44de4:	8013      	strh	r3, [r2, #0]
   44de6:	6838      	ldr	r0, [r7, #0]
   44de8:	f06f 0b10 	mvn.w	fp, #16
   44dec:	f06f 0741 	mvn.w	r7, #65	; 0x41
   44df0:	f003 ff24 	bl	48c3c <nrf_modem_os_sem_give>
   44df4:	f888 b000 	strb.w	fp, [r8]
   44df8:	f888 7001 	strb.w	r7, [r8, #1]
   44dfc:	782b      	ldrb	r3, [r5, #0]
   44dfe:	2105      	movs	r1, #5
   44e00:	4640      	mov	r0, r8
   44e02:	f888 3004 	strb.w	r3, [r8, #4]
   44e06:	f8a8 9002 	strh.w	r9, [r8, #2]
   44e0a:	f003 ff36 	bl	48c7a <nrf_modem_os_trace_put>
   44e0e:	4649      	mov	r1, r9
   44e10:	4650      	mov	r0, sl
   44e12:	f003 ff32 	bl	48c7a <nrf_modem_os_trace_put>
   44e16:	b19c      	cbz	r4, 44e40 <trace_write+0x150>
   44e18:	f886 b000 	strb.w	fp, [r6]
   44e1c:	7077      	strb	r7, [r6, #1]
   44e1e:	782b      	ldrb	r3, [r5, #0]
   44e20:	2105      	movs	r1, #5
   44e22:	4630      	mov	r0, r6
   44e24:	7133      	strb	r3, [r6, #4]
   44e26:	8074      	strh	r4, [r6, #2]
   44e28:	f003 ff27 	bl	48c7a <nrf_modem_os_trace_put>
   44e2c:	4621      	mov	r1, r4
   44e2e:	68e8      	ldr	r0, [r5, #12]
   44e30:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44e34:	f003 bf21 	b.w	48c7a <nrf_modem_os_trace_put>
   44e38:	4a04      	ldr	r2, [pc, #16]	; (44e4c <trace_write+0x15c>)
   44e3a:	e7cd      	b.n	44dd8 <trace_write+0xe8>
   44e3c:	4a04      	ldr	r2, [pc, #16]	; (44e50 <trace_write+0x160>)
   44e3e:	e7cb      	b.n	44dd8 <trace_write+0xe8>
   44e40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44e44:	2001aba0 	.word	0x2001aba0
   44e48:	2001ae24 	.word	0x2001ae24
   44e4c:	2001ae20 	.word	0x2001ae20
   44e50:	2001ae22 	.word	0x2001ae22

00044e54 <ipc_trace_init>:
   44e54:	2300      	movs	r3, #0
   44e56:	4a08      	ldr	r2, [pc, #32]	; (44e78 <ipc_trace_init+0x24>)
   44e58:	b510      	push	{r4, lr}
   44e5a:	8013      	strh	r3, [r2, #0]
   44e5c:	4a07      	ldr	r2, [pc, #28]	; (44e7c <ipc_trace_init+0x28>)
   44e5e:	4604      	mov	r4, r0
   44e60:	8013      	strh	r3, [r2, #0]
   44e62:	4a07      	ldr	r2, [pc, #28]	; (44e80 <ipc_trace_init+0x2c>)
   44e64:	4807      	ldr	r0, [pc, #28]	; (44e84 <ipc_trace_init+0x30>)
   44e66:	8013      	strh	r3, [r2, #0]
   44e68:	2201      	movs	r2, #1
   44e6a:	4611      	mov	r1, r2
   44e6c:	f7ff f922 	bl	440b4 <nrf_modem_os_sem_init>
   44e70:	4b05      	ldr	r3, [pc, #20]	; (44e88 <ipc_trace_init+0x34>)
   44e72:	601c      	str	r4, [r3, #0]
   44e74:	bd10      	pop	{r4, pc}
   44e76:	bf00      	nop
   44e78:	2001ae24 	.word	0x2001ae24
   44e7c:	2001ae20 	.word	0x2001ae20
   44e80:	2001ae22 	.word	0x2001ae22
   44e84:	2001aba0 	.word	0x2001aba0
   44e88:	2001ab9c 	.word	0x2001ab9c

00044e8c <nrf_modem_trace_irq_handler>:
   44e8c:	b508      	push	{r3, lr}
   44e8e:	4b10      	ldr	r3, [pc, #64]	; (44ed0 <nrf_modem_trace_irq_handler+0x44>)
   44e90:	781b      	ldrb	r3, [r3, #0]
   44e92:	b90b      	cbnz	r3, 44e98 <nrf_modem_trace_irq_handler+0xc>
   44e94:	f7ff f940 	bl	44118 <nrf_modem_os_trace_irq_clear>
   44e98:	4b0e      	ldr	r3, [pc, #56]	; (44ed4 <nrf_modem_trace_irq_handler+0x48>)
   44e9a:	6818      	ldr	r0, [r3, #0]
   44e9c:	6842      	ldr	r2, [r0, #4]
   44e9e:	6883      	ldr	r3, [r0, #8]
   44ea0:	429a      	cmp	r2, r3
   44ea2:	d001      	beq.n	44ea8 <nrf_modem_trace_irq_handler+0x1c>
   44ea4:	f7ff ff24 	bl	44cf0 <trace_write>
   44ea8:	4b0b      	ldr	r3, [pc, #44]	; (44ed8 <nrf_modem_trace_irq_handler+0x4c>)
   44eaa:	6818      	ldr	r0, [r3, #0]
   44eac:	6882      	ldr	r2, [r0, #8]
   44eae:	6843      	ldr	r3, [r0, #4]
   44eb0:	429a      	cmp	r2, r3
   44eb2:	d001      	beq.n	44eb8 <nrf_modem_trace_irq_handler+0x2c>
   44eb4:	f7ff ff1c 	bl	44cf0 <trace_write>
   44eb8:	4b08      	ldr	r3, [pc, #32]	; (44edc <nrf_modem_trace_irq_handler+0x50>)
   44eba:	6818      	ldr	r0, [r3, #0]
   44ebc:	6882      	ldr	r2, [r0, #8]
   44ebe:	6843      	ldr	r3, [r0, #4]
   44ec0:	429a      	cmp	r2, r3
   44ec2:	d003      	beq.n	44ecc <nrf_modem_trace_irq_handler+0x40>
   44ec4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   44ec8:	f7ff bf12 	b.w	44cf0 <trace_write>
   44ecc:	bd08      	pop	{r3, pc}
   44ece:	bf00      	nop
   44ed0:	2001eaf9 	.word	0x2001eaf9
   44ed4:	2001ab98 	.word	0x2001ab98
   44ed8:	2001ab90 	.word	0x2001ab90
   44edc:	2001ab94 	.word	0x2001ab94

00044ee0 <ipc_trace_handle>:
   44ee0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44ee4:	4b43      	ldr	r3, [pc, #268]	; (44ff4 <ipc_trace_handle+0x114>)
   44ee6:	681b      	ldr	r3, [r3, #0]
   44ee8:	6919      	ldr	r1, [r3, #16]
   44eea:	f8d3 a014 	ldr.w	sl, [r3, #20]
   44eee:	7c1a      	ldrb	r2, [r3, #16]
   44ef0:	2200      	movs	r2, #0
   44ef2:	741a      	strb	r2, [r3, #16]
   44ef4:	7c58      	ldrb	r0, [r3, #17]
   44ef6:	745a      	strb	r2, [r3, #17]
   44ef8:	7c98      	ldrb	r0, [r3, #18]
   44efa:	749a      	strb	r2, [r3, #18]
   44efc:	7cd8      	ldrb	r0, [r3, #19]
   44efe:	74da      	strb	r2, [r3, #19]
   44f00:	7d18      	ldrb	r0, [r3, #20]
   44f02:	751a      	strb	r2, [r3, #20]
   44f04:	7d58      	ldrb	r0, [r3, #21]
   44f06:	755a      	strb	r2, [r3, #21]
   44f08:	7d98      	ldrb	r0, [r3, #22]
   44f0a:	759a      	strb	r2, [r3, #22]
   44f0c:	7dd8      	ldrb	r0, [r3, #23]
   44f0e:	75da      	strb	r2, [r3, #23]
   44f10:	2900      	cmp	r1, #0
   44f12:	d033      	beq.n	44f7c <ipc_trace_handle+0x9c>
   44f14:	3901      	subs	r1, #1
   44f16:	2903      	cmp	r1, #3
   44f18:	d830      	bhi.n	44f7c <ipc_trace_handle+0x9c>
   44f1a:	e8df f001 	tbb	[pc, r1]
   44f1e:	6502      	.short	0x6502
   44f20:	534c      	.short	0x534c
   44f22:	4a35      	ldr	r2, [pc, #212]	; (44ff8 <ipc_trace_handle+0x118>)
   44f24:	7811      	ldrb	r1, [r2, #0]
   44f26:	b109      	cbz	r1, 44f2c <ipc_trace_handle+0x4c>
   44f28:	2100      	movs	r1, #0
   44f2a:	7011      	strb	r1, [r2, #0]
   44f2c:	2200      	movs	r2, #0
   44f2e:	4691      	mov	r9, r2
   44f30:	4617      	mov	r7, r2
   44f32:	4614      	mov	r4, r2
   44f34:	4d31      	ldr	r5, [pc, #196]	; (44ffc <ipc_trace_handle+0x11c>)
   44f36:	4932      	ldr	r1, [pc, #200]	; (45000 <ipc_trace_handle+0x120>)
   44f38:	4832      	ldr	r0, [pc, #200]	; (45004 <ipc_trace_handle+0x124>)
   44f3a:	f8d5 e000 	ldr.w	lr, [r5]
   44f3e:	f8d1 8000 	ldr.w	r8, [r1]
   44f42:	6806      	ldr	r6, [r0, #0]
   44f44:	f8da b008 	ldr.w	fp, [sl, #8]
   44f48:	9501      	str	r5, [sp, #4]
   44f4a:	45a3      	cmp	fp, r4
   44f4c:	d119      	bne.n	44f82 <ipc_trace_handle+0xa2>
   44f4e:	b107      	cbz	r7, 44f52 <ipc_trace_handle+0x72>
   44f50:	6006      	str	r6, [r0, #0]
   44f52:	f1b9 0f00 	cmp.w	r9, #0
   44f56:	d001      	beq.n	44f5c <ipc_trace_handle+0x7c>
   44f58:	f8c1 8000 	str.w	r8, [r1]
   44f5c:	b112      	cbz	r2, 44f64 <ipc_trace_handle+0x84>
   44f5e:	9a01      	ldr	r2, [sp, #4]
   44f60:	f8c2 e000 	str.w	lr, [r2]
   44f64:	7a1a      	ldrb	r2, [r3, #8]
   44f66:	2101      	movs	r1, #1
   44f68:	2200      	movs	r2, #0
   44f6a:	7219      	strb	r1, [r3, #8]
   44f6c:	7a59      	ldrb	r1, [r3, #9]
   44f6e:	725a      	strb	r2, [r3, #9]
   44f70:	7a99      	ldrb	r1, [r3, #10]
   44f72:	729a      	strb	r2, [r3, #10]
   44f74:	7ada      	ldrb	r2, [r3, #11]
   44f76:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   44f7a:	72da      	strb	r2, [r3, #11]
   44f7c:	b003      	add	sp, #12
   44f7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44f82:	1ca5      	adds	r5, r4, #2
   44f84:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   44f88:	686d      	ldr	r5, [r5, #4]
   44f8a:	f895 c000 	ldrb.w	ip, [r5]
   44f8e:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   44f92:	d009      	beq.n	44fa8 <ipc_trace_handle+0xc8>
   44f94:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   44f98:	d00a      	beq.n	44fb0 <ipc_trace_handle+0xd0>
   44f9a:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   44f9e:	bf04      	itt	eq
   44fa0:	462e      	moveq	r6, r5
   44fa2:	2701      	moveq	r7, #1
   44fa4:	3401      	adds	r4, #1
   44fa6:	e7d0      	b.n	44f4a <ipc_trace_handle+0x6a>
   44fa8:	46a8      	mov	r8, r5
   44faa:	f04f 0901 	mov.w	r9, #1
   44fae:	e7f9      	b.n	44fa4 <ipc_trace_handle+0xc4>
   44fb0:	46ae      	mov	lr, r5
   44fb2:	2201      	movs	r2, #1
   44fb4:	e7f6      	b.n	44fa4 <ipc_trace_handle+0xc4>
   44fb6:	2101      	movs	r1, #1
   44fb8:	4a0f      	ldr	r2, [pc, #60]	; (44ff8 <ipc_trace_handle+0x118>)
   44fba:	7011      	strb	r1, [r2, #0]
   44fbc:	7a1a      	ldrb	r2, [r3, #8]
   44fbe:	2103      	movs	r1, #3
   44fc0:	2200      	movs	r2, #0
   44fc2:	e7d2      	b.n	44f6a <ipc_trace_handle+0x8a>
   44fc4:	7a19      	ldrb	r1, [r3, #8]
   44fc6:	2104      	movs	r1, #4
   44fc8:	7219      	strb	r1, [r3, #8]
   44fca:	7a59      	ldrb	r1, [r3, #9]
   44fcc:	725a      	strb	r2, [r3, #9]
   44fce:	7a99      	ldrb	r1, [r3, #10]
   44fd0:	729a      	strb	r2, [r3, #10]
   44fd2:	7ad9      	ldrb	r1, [r3, #11]
   44fd4:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   44fd8:	72d9      	strb	r1, [r3, #11]
   44fda:	4b07      	ldr	r3, [pc, #28]	; (44ff8 <ipc_trace_handle+0x118>)
   44fdc:	701a      	strb	r2, [r3, #0]
   44fde:	b003      	add	sp, #12
   44fe0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44fe4:	f7ff bf52 	b.w	44e8c <nrf_modem_trace_irq_handler>
   44fe8:	b003      	add	sp, #12
   44fea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   44fee:	f7ff b88b 	b.w	44108 <nrf_modem_os_trace_irq_set>
   44ff2:	bf00      	nop
   44ff4:	2001ab9c 	.word	0x2001ab9c
   44ff8:	2001eaf9 	.word	0x2001eaf9
   44ffc:	2001ab94 	.word	0x2001ab94
   45000:	2001ab90 	.word	0x2001ab90
   45004:	2001ab98 	.word	0x2001ab98

00045008 <rpc_trace_coredump_in_progress>:
   45008:	4b01      	ldr	r3, [pc, #4]	; (45010 <rpc_trace_coredump_in_progress+0x8>)
   4500a:	7818      	ldrb	r0, [r3, #0]
   4500c:	4770      	bx	lr
   4500e:	bf00      	nop
   45010:	2001eaf9 	.word	0x2001eaf9

00045014 <handle_modem_rpc_msg>:
   45014:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45018:	4606      	mov	r6, r0
   4501a:	460f      	mov	r7, r1
   4501c:	2500      	movs	r5, #0
   4501e:	f8df 8074 	ldr.w	r8, [pc, #116]	; 45094 <handle_modem_rpc_msg+0x80>
   45022:	6833      	ldr	r3, [r6, #0]
   45024:	42ab      	cmp	r3, r5
   45026:	d801      	bhi.n	4502c <handle_modem_rpc_msg+0x18>
   45028:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4502c:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   45030:	68a3      	ldr	r3, [r4, #8]
   45032:	b1fb      	cbz	r3, 45074 <handle_modem_rpc_msg+0x60>
   45034:	6863      	ldr	r3, [r4, #4]
   45036:	b2db      	uxtb	r3, r3
   45038:	2b01      	cmp	r3, #1
   4503a:	d11b      	bne.n	45074 <handle_modem_rpc_msg+0x60>
   4503c:	6862      	ldr	r2, [r4, #4]
   4503e:	f8b8 3000 	ldrh.w	r3, [r8]
   45042:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   45046:	d115      	bne.n	45074 <handle_modem_rpc_msg+0x60>
   45048:	2f02      	cmp	r7, #2
   4504a:	68a0      	ldr	r0, [r4, #8]
   4504c:	d114      	bne.n	45078 <handle_modem_rpc_msg+0x64>
   4504e:	f7ff fe2d 	bl	44cac <rpc_handle_data_message>
   45052:	2802      	cmp	r0, #2
   45054:	d00e      	beq.n	45074 <handle_modem_rpc_msg+0x60>
   45056:	2801      	cmp	r0, #1
   45058:	d113      	bne.n	45082 <handle_modem_rpc_msg+0x6e>
   4505a:	6863      	ldr	r3, [r4, #4]
   4505c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   45060:	f043 0302 	orr.w	r3, r3, #2
   45064:	6063      	str	r3, [r4, #4]
   45066:	f8b8 3000 	ldrh.w	r3, [r8]
   4506a:	3301      	adds	r3, #1
   4506c:	f8a8 3000 	strh.w	r3, [r8]
   45070:	f7ff f83a 	bl	440e8 <nrf_modem_os_application_irq_set>
   45074:	3501      	adds	r5, #1
   45076:	e7d4      	b.n	45022 <handle_modem_rpc_msg+0xe>
   45078:	6801      	ldr	r1, [r0, #0]
   4507a:	0c09      	lsrs	r1, r1, #16
   4507c:	f003 fe18 	bl	48cb0 <rpc_handle_ctrl_message>
   45080:	e7e7      	b.n	45052 <handle_modem_rpc_msg+0x3e>
   45082:	2800      	cmp	r0, #0
   45084:	d1ef      	bne.n	45066 <handle_modem_rpc_msg+0x52>
   45086:	6863      	ldr	r3, [r4, #4]
   45088:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   4508c:	f043 0303 	orr.w	r3, r3, #3
   45090:	e7e8      	b.n	45064 <handle_modem_rpc_msg+0x50>
   45092:	bf00      	nop
   45094:	2001ae26 	.word	0x2001ae26

00045098 <rpc_transport_ipc_msg_alloc>:
   45098:	b570      	push	{r4, r5, r6, lr}
   4509a:	4616      	mov	r6, r2
   4509c:	2400      	movs	r4, #0
   4509e:	6803      	ldr	r3, [r0, #0]
   450a0:	42a3      	cmp	r3, r4
   450a2:	d101      	bne.n	450a8 <rpc_transport_ipc_msg_alloc+0x10>
   450a4:	2300      	movs	r3, #0
   450a6:	e01c      	b.n	450e2 <rpc_transport_ipc_msg_alloc+0x4a>
   450a8:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   450ac:	6855      	ldr	r5, [r2, #4]
   450ae:	b2ed      	uxtb	r5, r5
   450b0:	2d03      	cmp	r5, #3
   450b2:	d118      	bne.n	450e6 <rpc_transport_ipc_msg_alloc+0x4e>
   450b4:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   450b8:	6093      	str	r3, [r2, #8]
   450ba:	6851      	ldr	r1, [r2, #4]
   450bc:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   450c0:	6051      	str	r1, [r2, #4]
   450c2:	490c      	ldr	r1, [pc, #48]	; (450f4 <rpc_transport_ipc_msg_alloc+0x5c>)
   450c4:	8808      	ldrh	r0, [r1, #0]
   450c6:	1c44      	adds	r4, r0, #1
   450c8:	800c      	strh	r4, [r1, #0]
   450ca:	6851      	ldr	r1, [r2, #4]
   450cc:	b289      	uxth	r1, r1
   450ce:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   450d2:	6051      	str	r1, [r2, #4]
   450d4:	4618      	mov	r0, r3
   450d6:	2240      	movs	r2, #64	; 0x40
   450d8:	2100      	movs	r1, #0
   450da:	f003 fc2f 	bl	4893c <memset>
   450de:	4603      	mov	r3, r0
   450e0:	6046      	str	r6, [r0, #4]
   450e2:	4618      	mov	r0, r3
   450e4:	bd70      	pop	{r4, r5, r6, pc}
   450e6:	b915      	cbnz	r5, 450ee <rpc_transport_ipc_msg_alloc+0x56>
   450e8:	6895      	ldr	r5, [r2, #8]
   450ea:	2d00      	cmp	r5, #0
   450ec:	d0e2      	beq.n	450b4 <rpc_transport_ipc_msg_alloc+0x1c>
   450ee:	3401      	adds	r4, #1
   450f0:	e7d6      	b.n	450a0 <rpc_transport_ipc_msg_alloc+0x8>
   450f2:	bf00      	nop
   450f4:	2001ae28 	.word	0x2001ae28

000450f8 <rpc_transport_ipc_data_msg_send>:
   450f8:	b508      	push	{r3, lr}
   450fa:	4b0b      	ldr	r3, [pc, #44]	; (45128 <rpc_transport_ipc_data_msg_send+0x30>)
   450fc:	681b      	ldr	r3, [r3, #0]
   450fe:	1ac0      	subs	r0, r0, r3
   45100:	4b0a      	ldr	r3, [pc, #40]	; (4512c <rpc_transport_ipc_data_msg_send+0x34>)
   45102:	f3c0 1089 	ubfx	r0, r0, #6, #10
   45106:	681b      	ldr	r3, [r3, #0]
   45108:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   4510c:	6843      	ldr	r3, [r0, #4]
   4510e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   45112:	f043 0301 	orr.w	r3, r3, #1
   45116:	6043      	str	r3, [r0, #4]
   45118:	2003      	movs	r0, #3
   4511a:	f003 fd8b 	bl	48c34 <nrf_modem_os_busywait>
   4511e:	2201      	movs	r2, #1
   45120:	4b03      	ldr	r3, [pc, #12]	; (45130 <rpc_transport_ipc_data_msg_send+0x38>)
   45122:	601a      	str	r2, [r3, #0]
   45124:	bd08      	pop	{r3, pc}
   45126:	bf00      	nop
   45128:	2001abbc 	.word	0x2001abbc
   4512c:	2001abc0 	.word	0x2001abc0
   45130:	4002a00c 	.word	0x4002a00c

00045134 <rpc_transport_ipc_ctrl_msg_send>:
   45134:	b508      	push	{r3, lr}
   45136:	4b0b      	ldr	r3, [pc, #44]	; (45164 <rpc_transport_ipc_ctrl_msg_send+0x30>)
   45138:	681b      	ldr	r3, [r3, #0]
   4513a:	1ac0      	subs	r0, r0, r3
   4513c:	4b0a      	ldr	r3, [pc, #40]	; (45168 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   4513e:	f3c0 1089 	ubfx	r0, r0, #6, #10
   45142:	681b      	ldr	r3, [r3, #0]
   45144:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   45148:	6843      	ldr	r3, [r0, #4]
   4514a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   4514e:	f043 0301 	orr.w	r3, r3, #1
   45152:	6043      	str	r3, [r0, #4]
   45154:	2003      	movs	r0, #3
   45156:	f003 fd6d 	bl	48c34 <nrf_modem_os_busywait>
   4515a:	2201      	movs	r2, #1
   4515c:	4b03      	ldr	r3, [pc, #12]	; (4516c <rpc_transport_ipc_ctrl_msg_send+0x38>)
   4515e:	601a      	str	r2, [r3, #0]
   45160:	bd08      	pop	{r3, pc}
   45162:	bf00      	nop
   45164:	2001abb4 	.word	0x2001abb4
   45168:	2001abb8 	.word	0x2001abb8
   4516c:	4002a004 	.word	0x4002a004

00045170 <rpc_transport_ipc_data_msg_alloc>:
   45170:	4b05      	ldr	r3, [pc, #20]	; (45188 <rpc_transport_ipc_data_msg_alloc+0x18>)
   45172:	781b      	ldrb	r3, [r3, #0]
   45174:	b933      	cbnz	r3, 45184 <rpc_transport_ipc_data_msg_alloc+0x14>
   45176:	4b05      	ldr	r3, [pc, #20]	; (4518c <rpc_transport_ipc_data_msg_alloc+0x1c>)
   45178:	2202      	movs	r2, #2
   4517a:	6819      	ldr	r1, [r3, #0]
   4517c:	4b04      	ldr	r3, [pc, #16]	; (45190 <rpc_transport_ipc_data_msg_alloc+0x20>)
   4517e:	6818      	ldr	r0, [r3, #0]
   45180:	f7ff bf8a 	b.w	45098 <rpc_transport_ipc_msg_alloc>
   45184:	2000      	movs	r0, #0
   45186:	4770      	bx	lr
   45188:	2001eafb 	.word	0x2001eafb
   4518c:	2001abbc 	.word	0x2001abbc
   45190:	2001abc0 	.word	0x2001abc0

00045194 <rpc_transport_ipc_ctrl_msg_alloc>:
   45194:	230a      	movs	r3, #10
   45196:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45198:	4c0c      	ldr	r4, [pc, #48]	; (451cc <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   4519a:	4d0d      	ldr	r5, [pc, #52]	; (451d0 <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   4519c:	9301      	str	r3, [sp, #4]
   4519e:	2201      	movs	r2, #1
   451a0:	6821      	ldr	r1, [r4, #0]
   451a2:	6828      	ldr	r0, [r5, #0]
   451a4:	f7ff ff78 	bl	45098 <rpc_transport_ipc_msg_alloc>
   451a8:	b968      	cbnz	r0, 451c6 <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   451aa:	f003 fd45 	bl	48c38 <nrf_modem_os_is_in_isr>
   451ae:	b918      	cbnz	r0, 451b8 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   451b0:	a901      	add	r1, sp, #4
   451b2:	f7fe fee1 	bl	43f78 <nrf_modem_os_timedwait>
   451b6:	e7f2      	b.n	4519e <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   451b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   451bc:	9b01      	ldr	r3, [sp, #4]
   451be:	4358      	muls	r0, r3
   451c0:	f003 fd38 	bl	48c34 <nrf_modem_os_busywait>
   451c4:	e7eb      	b.n	4519e <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   451c6:	b003      	add	sp, #12
   451c8:	bd30      	pop	{r4, r5, pc}
   451ca:	bf00      	nop
   451cc:	2001abb4 	.word	0x2001abb4
   451d0:	2001abb8 	.word	0x2001abb8

000451d4 <rpc_transport_ipc_data_alloc>:
   451d4:	4b03      	ldr	r3, [pc, #12]	; (451e4 <rpc_transport_ipc_data_alloc+0x10>)
   451d6:	781b      	ldrb	r3, [r3, #0]
   451d8:	b90b      	cbnz	r3, 451de <rpc_transport_ipc_data_alloc+0xa>
   451da:	f7fe bfb3 	b.w	44144 <nrf_modem_os_shm_tx_alloc>
   451de:	2000      	movs	r0, #0
   451e0:	4770      	bx	lr
   451e2:	bf00      	nop
   451e4:	2001eafb 	.word	0x2001eafb

000451e8 <nrf_modem_application_irq_handler>:
   451e8:	b510      	push	{r4, lr}
   451ea:	4c06      	ldr	r4, [pc, #24]	; (45204 <nrf_modem_application_irq_handler+0x1c>)
   451ec:	f7fe ff84 	bl	440f8 <nrf_modem_os_application_irq_clear>
   451f0:	6820      	ldr	r0, [r4, #0]
   451f2:	2101      	movs	r1, #1
   451f4:	f7ff ff0e 	bl	45014 <handle_modem_rpc_msg>
   451f8:	6860      	ldr	r0, [r4, #4]
   451fa:	2102      	movs	r1, #2
   451fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   45200:	f7ff bf08 	b.w	45014 <handle_modem_rpc_msg>
   45204:	2001aba8 	.word	0x2001aba8

00045208 <rpc_transport_ipc_msg_free>:
   45208:	2300      	movs	r3, #0
   4520a:	4911      	ldr	r1, [pc, #68]	; (45250 <rpc_transport_ipc_msg_free+0x48>)
   4520c:	b530      	push	{r4, r5, lr}
   4520e:	680a      	ldr	r2, [r1, #0]
   45210:	6814      	ldr	r4, [r2, #0]
   45212:	42a3      	cmp	r3, r4
   45214:	d10b      	bne.n	4522e <rpc_transport_ipc_msg_free+0x26>
   45216:	2300      	movs	r3, #0
   45218:	684a      	ldr	r2, [r1, #4]
   4521a:	6811      	ldr	r1, [r2, #0]
   4521c:	428b      	cmp	r3, r1
   4521e:	d015      	beq.n	4524c <rpc_transport_ipc_msg_free+0x44>
   45220:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   45224:	68a4      	ldr	r4, [r4, #8]
   45226:	42a0      	cmp	r0, r4
   45228:	d008      	beq.n	4523c <rpc_transport_ipc_msg_free+0x34>
   4522a:	3301      	adds	r3, #1
   4522c:	e7f6      	b.n	4521c <rpc_transport_ipc_msg_free+0x14>
   4522e:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   45232:	68ad      	ldr	r5, [r5, #8]
   45234:	42a8      	cmp	r0, r5
   45236:	d001      	beq.n	4523c <rpc_transport_ipc_msg_free+0x34>
   45238:	3301      	adds	r3, #1
   4523a:	e7ea      	b.n	45212 <rpc_transport_ipc_msg_free+0xa>
   4523c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   45240:	685a      	ldr	r2, [r3, #4]
   45242:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   45246:	f042 0203 	orr.w	r2, r2, #3
   4524a:	605a      	str	r2, [r3, #4]
   4524c:	bd30      	pop	{r4, r5, pc}
   4524e:	bf00      	nop
   45250:	2001aba8 	.word	0x2001aba8

00045254 <rpc_transport_ipc_init>:
   45254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   45258:	2200      	movs	r2, #0
   4525a:	b095      	sub	sp, #84	; 0x54
   4525c:	4605      	mov	r5, r0
   4525e:	494d      	ldr	r1, [pc, #308]	; (45394 <rpc_transport_ipc_init+0x140>)
   45260:	7900      	ldrb	r0, [r0, #4]
   45262:	f7ff fc15 	bl	44a90 <nrfx_ipc_init>
   45266:	2238      	movs	r2, #56	; 0x38
   45268:	2100      	movs	r1, #0
   4526a:	a803      	add	r0, sp, #12
   4526c:	f003 fb66 	bl	4893c <memset>
   45270:	2302      	movs	r3, #2
   45272:	9304      	str	r3, [sp, #16]
   45274:	2308      	movs	r3, #8
   45276:	9306      	str	r3, [sp, #24]
   45278:	2320      	movs	r3, #32
   4527a:	9308      	str	r3, [sp, #32]
   4527c:	2301      	movs	r3, #1
   4527e:	930b      	str	r3, [sp, #44]	; 0x2c
   45280:	2304      	movs	r3, #4
   45282:	930d      	str	r3, [sp, #52]	; 0x34
   45284:	2310      	movs	r3, #16
   45286:	f04f 0c40 	mov.w	ip, #64	; 0x40
   4528a:	930f      	str	r3, [sp, #60]	; 0x3c
   4528c:	2380      	movs	r3, #128	; 0x80
   4528e:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   45292:	23d5      	movs	r3, #213	; 0xd5
   45294:	a803      	add	r0, sp, #12
   45296:	9313      	str	r3, [sp, #76]	; 0x4c
   45298:	f7ff fc12 	bl	44ac0 <nrfx_ipc_config_load>
   4529c:	682b      	ldr	r3, [r5, #0]
   4529e:	2100      	movs	r1, #0
   452a0:	685a      	ldr	r2, [r3, #4]
   452a2:	6818      	ldr	r0, [r3, #0]
   452a4:	f003 fb4a 	bl	4893c <memset>
   452a8:	682a      	ldr	r2, [r5, #0]
   452aa:	6814      	ldr	r4, [r2, #0]
   452ac:	69d3      	ldr	r3, [r2, #28]
   452ae:	f104 0660 	add.w	r6, r4, #96	; 0x60
   452b2:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   452b6:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   452ba:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   452be:	f104 0920 	add.w	r9, r4, #32
   452c2:	2b00      	cmp	r3, #0
   452c4:	d060      	beq.n	45388 <rpc_transport_ipc_init+0x134>
   452c6:	f104 0840 	add.w	r8, r4, #64	; 0x40
   452ca:	4933      	ldr	r1, [pc, #204]	; (45398 <rpc_transport_ipc_init+0x144>)
   452cc:	f8c1 9000 	str.w	r9, [r1]
   452d0:	b13b      	cbz	r3, 452e2 <rpc_transport_ipc_init+0x8e>
   452d2:	6992      	ldr	r2, [r2, #24]
   452d4:	4640      	mov	r0, r8
   452d6:	f8c8 2004 	str.w	r2, [r8, #4]
   452da:	f8c8 3000 	str.w	r3, [r8]
   452de:	f7ff fdb9 	bl	44e54 <ipc_trace_init>
   452e2:	6828      	ldr	r0, [r5, #0]
   452e4:	2300      	movs	r3, #0
   452e6:	6902      	ldr	r2, [r0, #16]
   452e8:	2101      	movs	r1, #1
   452ea:	6062      	str	r2, [r4, #4]
   452ec:	6942      	ldr	r2, [r0, #20]
   452ee:	70a1      	strb	r1, [r4, #2]
   452f0:	60a2      	str	r2, [r4, #8]
   452f2:	4a2a      	ldr	r2, [pc, #168]	; (4539c <rpc_transport_ipc_init+0x148>)
   452f4:	7023      	strb	r3, [r4, #0]
   452f6:	6017      	str	r7, [r2, #0]
   452f8:	4a29      	ldr	r2, [pc, #164]	; (453a0 <rpc_transport_ipc_init+0x14c>)
   452fa:	7063      	strb	r3, [r4, #1]
   452fc:	6016      	str	r6, [r2, #0]
   452fe:	2208      	movs	r2, #8
   45300:	70e3      	strb	r3, [r4, #3]
   45302:	60e6      	str	r6, [r4, #12]
   45304:	6127      	str	r7, [r4, #16]
   45306:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   4530a:	f8c4 9014 	str.w	r9, [r4, #20]
   4530e:	f8c4 8018 	str.w	r8, [r4, #24]
   45312:	707b      	strb	r3, [r7, #1]
   45314:	70bb      	strb	r3, [r7, #2]
   45316:	70fb      	strb	r3, [r7, #3]
   45318:	2714      	movs	r7, #20
   4531a:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   4531e:	4a21      	ldr	r2, [pc, #132]	; (453a4 <rpc_transport_ipc_init+0x150>)
   45320:	4d21      	ldr	r5, [pc, #132]	; (453a8 <rpc_transport_ipc_init+0x154>)
   45322:	f8c2 b000 	str.w	fp, [r2]
   45326:	4a21      	ldr	r2, [pc, #132]	; (453ac <rpc_transport_ipc_init+0x158>)
   45328:	7073      	strb	r3, [r6, #1]
   4532a:	f8c2 a000 	str.w	sl, [r2]
   4532e:	4a20      	ldr	r2, [pc, #128]	; (453b0 <rpc_transport_ipc_init+0x15c>)
   45330:	70b3      	strb	r3, [r6, #2]
   45332:	70f3      	strb	r3, [r6, #3]
   45334:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   45338:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   4533c:	4c1d      	ldr	r4, [pc, #116]	; (453b4 <rpc_transport_ipc_init+0x160>)
   4533e:	7029      	strb	r1, [r5, #0]
   45340:	491d      	ldr	r1, [pc, #116]	; (453b8 <rpc_transport_ipc_init+0x164>)
   45342:	6023      	str	r3, [r4, #0]
   45344:	9302      	str	r3, [sp, #8]
   45346:	600b      	str	r3, [r1, #0]
   45348:	680b      	ldr	r3, [r1, #0]
   4534a:	4e1c      	ldr	r6, [pc, #112]	; (453bc <rpc_transport_ipc_init+0x168>)
   4534c:	9302      	str	r3, [sp, #8]
   4534e:	9b02      	ldr	r3, [sp, #8]
   45350:	2000      	movs	r0, #0
   45352:	a901      	add	r1, sp, #4
   45354:	9701      	str	r7, [sp, #4]
   45356:	f7fe fe0f 	bl	43f78 <nrf_modem_os_timedwait>
   4535a:	9b01      	ldr	r3, [sp, #4]
   4535c:	3b14      	subs	r3, #20
   4535e:	441e      	add	r6, r3
   45360:	782b      	ldrb	r3, [r5, #0]
   45362:	2b01      	cmp	r3, #1
   45364:	d104      	bne.n	45370 <rpc_transport_ipc_init+0x11c>
   45366:	2e00      	cmp	r6, #0
   45368:	d1f2      	bne.n	45350 <rpc_transport_ipc_init+0xfc>
   4536a:	f06f 0373 	mvn.w	r3, #115	; 0x73
   4536e:	6023      	str	r3, [r4, #0]
   45370:	6824      	ldr	r4, [r4, #0]
   45372:	b95c      	cbnz	r4, 4538c <rpc_transport_ipc_init+0x138>
   45374:	4b12      	ldr	r3, [pc, #72]	; (453c0 <rpc_transport_ipc_init+0x16c>)
   45376:	701c      	strb	r4, [r3, #0]
   45378:	4b12      	ldr	r3, [pc, #72]	; (453c4 <rpc_transport_ipc_init+0x170>)
   4537a:	801c      	strh	r4, [r3, #0]
   4537c:	4b12      	ldr	r3, [pc, #72]	; (453c8 <rpc_transport_ipc_init+0x174>)
   4537e:	801c      	strh	r4, [r3, #0]
   45380:	4620      	mov	r0, r4
   45382:	b015      	add	sp, #84	; 0x54
   45384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45388:	4698      	mov	r8, r3
   4538a:	e79e      	b.n	452ca <rpc_transport_ipc_init+0x76>
   4538c:	f7ff fbb8 	bl	44b00 <nrfx_ipc_uninit>
   45390:	e7f6      	b.n	45380 <rpc_transport_ipc_init+0x12c>
   45392:	bf00      	nop
   45394:	000453cd 	.word	0x000453cd
   45398:	2001abb0 	.word	0x2001abb0
   4539c:	2001abc0 	.word	0x2001abc0
   453a0:	2001abb8 	.word	0x2001abb8
   453a4:	2001abbc 	.word	0x2001abbc
   453a8:	2001eafa 	.word	0x2001eafa
   453ac:	2001abb4 	.word	0x2001abb4
   453b0:	4002a000 	.word	0x4002a000
   453b4:	2001aba4 	.word	0x2001aba4
   453b8:	40005610 	.word	0x40005610
   453bc:	000249f0 	.word	0x000249f0
   453c0:	2001eafb 	.word	0x2001eafb
   453c4:	2001ae28 	.word	0x2001ae28
   453c8:	2001ae26 	.word	0x2001ae26

000453cc <ipc_irq_handler>:
   453cc:	b570      	push	{r4, r5, r6, lr}
   453ce:	4604      	mov	r4, r0
   453d0:	0620      	lsls	r0, r4, #24
   453d2:	d50c      	bpl.n	453ee <ipc_irq_handler+0x22>
   453d4:	f7ff fd84 	bl	44ee0 <ipc_trace_handle>
   453d8:	f7ff fe16 	bl	45008 <rpc_trace_coredump_in_progress>
   453dc:	b138      	cbz	r0, 453ee <ipc_irq_handler+0x22>
   453de:	22e0      	movs	r2, #224	; 0xe0
   453e0:	4b3e      	ldr	r3, [pc, #248]	; (454dc <ipc_irq_handler+0x110>)
   453e2:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   453e6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   453ea:	605a      	str	r2, [r3, #4]
   453ec:	bd70      	pop	{r4, r5, r6, pc}
   453ee:	07e1      	lsls	r1, r4, #31
   453f0:	d548      	bpl.n	45484 <ipc_irq_handler+0xb8>
   453f2:	f248 0202 	movw	r2, #32770	; 0x8002
   453f6:	4b3a      	ldr	r3, [pc, #232]	; (454e0 <ipc_irq_handler+0x114>)
   453f8:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   453fc:	4293      	cmp	r3, r2
   453fe:	d035      	beq.n	4546c <ipc_irq_handler+0xa0>
   45400:	d81b      	bhi.n	4543a <ipc_irq_handler+0x6e>
   45402:	f243 0232 	movw	r2, #12338	; 0x3032
   45406:	4293      	cmp	r3, r2
   45408:	d036      	beq.n	45478 <ipc_irq_handler+0xac>
   4540a:	d80b      	bhi.n	45424 <ipc_irq_handler+0x58>
   4540c:	3b01      	subs	r3, #1
   4540e:	2b01      	cmp	r3, #1
   45410:	d8ec      	bhi.n	453ec <ipc_irq_handler+0x20>
   45412:	2203      	movs	r2, #3
   45414:	200e      	movs	r0, #14
   45416:	4b33      	ldr	r3, [pc, #204]	; (454e4 <ipc_irq_handler+0x118>)
   45418:	701a      	strb	r2, [r3, #0]
   4541a:	4b33      	ldr	r3, [pc, #204]	; (454e8 <ipc_irq_handler+0x11c>)
   4541c:	6018      	str	r0, [r3, #0]
   4541e:	f003 fd15 	bl	48e4c <rpc_transport_ipc_fault_handler>
   45422:	e7e3      	b.n	453ec <ipc_irq_handler+0x20>
   45424:	f248 0201 	movw	r2, #32769	; 0x8001
   45428:	4293      	cmp	r3, r2
   4542a:	d1df      	bne.n	453ec <ipc_irq_handler+0x20>
   4542c:	2203      	movs	r2, #3
   4542e:	4b2d      	ldr	r3, [pc, #180]	; (454e4 <ipc_irq_handler+0x118>)
   45430:	701a      	strb	r2, [r3, #0]
   45432:	2216      	movs	r2, #22
   45434:	4b2c      	ldr	r3, [pc, #176]	; (454e8 <ipc_irq_handler+0x11c>)
   45436:	601a      	str	r2, [r3, #0]
   45438:	e7d8      	b.n	453ec <ipc_irq_handler+0x20>
   4543a:	4a2c      	ldr	r2, [pc, #176]	; (454ec <ipc_irq_handler+0x120>)
   4543c:	4293      	cmp	r3, r2
   4543e:	d80c      	bhi.n	4545a <ipc_irq_handler+0x8e>
   45440:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   45444:	d80c      	bhi.n	45460 <ipc_irq_handler+0x94>
   45446:	f248 0203 	movw	r2, #32771	; 0x8003
   4544a:	4293      	cmp	r3, r2
   4544c:	d1ce      	bne.n	453ec <ipc_irq_handler+0x20>
   4544e:	2203      	movs	r2, #3
   45450:	4b24      	ldr	r3, [pc, #144]	; (454e4 <ipc_irq_handler+0x118>)
   45452:	701a      	strb	r2, [r3, #0]
   45454:	220c      	movs	r2, #12
   45456:	4b24      	ldr	r3, [pc, #144]	; (454e8 <ipc_irq_handler+0x11c>)
   45458:	e7ed      	b.n	45436 <ipc_irq_handler+0x6a>
   4545a:	4a25      	ldr	r2, [pc, #148]	; (454f0 <ipc_irq_handler+0x124>)
   4545c:	4293      	cmp	r3, r2
   4545e:	d1c5      	bne.n	453ec <ipc_irq_handler+0x20>
   45460:	2103      	movs	r1, #3
   45462:	4a20      	ldr	r2, [pc, #128]	; (454e4 <ipc_irq_handler+0x118>)
   45464:	7011      	strb	r1, [r2, #0]
   45466:	4a20      	ldr	r2, [pc, #128]	; (454e8 <ipc_irq_handler+0x11c>)
   45468:	6013      	str	r3, [r2, #0]
   4546a:	e7bf      	b.n	453ec <ipc_irq_handler+0x20>
   4546c:	2203      	movs	r2, #3
   4546e:	4b1d      	ldr	r3, [pc, #116]	; (454e4 <ipc_irq_handler+0x118>)
   45470:	701a      	strb	r2, [r3, #0]
   45472:	225f      	movs	r2, #95	; 0x5f
   45474:	4b1c      	ldr	r3, [pc, #112]	; (454e8 <ipc_irq_handler+0x11c>)
   45476:	e7de      	b.n	45436 <ipc_irq_handler+0x6a>
   45478:	2203      	movs	r2, #3
   4547a:	4b1a      	ldr	r3, [pc, #104]	; (454e4 <ipc_irq_handler+0x118>)
   4547c:	701a      	strb	r2, [r3, #0]
   4547e:	2205      	movs	r2, #5
   45480:	4b19      	ldr	r3, [pc, #100]	; (454e8 <ipc_irq_handler+0x11c>)
   45482:	e7d8      	b.n	45436 <ipc_irq_handler+0x6a>
   45484:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   45488:	d003      	beq.n	45492 <ipc_irq_handler+0xc6>
   4548a:	2202      	movs	r2, #2
   4548c:	4b15      	ldr	r3, [pc, #84]	; (454e4 <ipc_irq_handler+0x118>)
   4548e:	701a      	strb	r2, [r3, #0]
   45490:	e7ac      	b.n	453ec <ipc_irq_handler+0x20>
   45492:	0762      	lsls	r2, r4, #29
   45494:	d505      	bpl.n	454a2 <ipc_irq_handler+0xd6>
   45496:	4b13      	ldr	r3, [pc, #76]	; (454e4 <ipc_irq_handler+0x118>)
   45498:	781a      	ldrb	r2, [r3, #0]
   4549a:	461e      	mov	r6, r3
   4549c:	b93a      	cbnz	r2, 454ae <ipc_irq_handler+0xe2>
   4549e:	f7fe fe23 	bl	440e8 <nrf_modem_os_application_irq_set>
   454a2:	06e3      	lsls	r3, r4, #27
   454a4:	d5a2      	bpl.n	453ec <ipc_irq_handler+0x20>
   454a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   454aa:	f7fe be1d 	b.w	440e8 <nrf_modem_os_application_irq_set>
   454ae:	2a01      	cmp	r2, #1
   454b0:	d1f7      	bne.n	454a2 <ipc_irq_handler+0xd6>
   454b2:	4a10      	ldr	r2, [pc, #64]	; (454f4 <ipc_irq_handler+0x128>)
   454b4:	4810      	ldr	r0, [pc, #64]	; (454f8 <ipc_irq_handler+0x12c>)
   454b6:	6812      	ldr	r2, [r2, #0]
   454b8:	6891      	ldr	r1, [r2, #8]
   454ba:	6041      	str	r1, [r0, #4]
   454bc:	6852      	ldr	r2, [r2, #4]
   454be:	6002      	str	r2, [r0, #0]
   454c0:	b121      	cbz	r1, 454cc <ipc_irq_handler+0x100>
   454c2:	b11a      	cbz	r2, 454cc <ipc_irq_handler+0x100>
   454c4:	6809      	ldr	r1, [r1, #0]
   454c6:	b109      	cbz	r1, 454cc <ipc_irq_handler+0x100>
   454c8:	6812      	ldr	r2, [r2, #0]
   454ca:	b92a      	cbnz	r2, 454d8 <ipc_irq_handler+0x10c>
   454cc:	2303      	movs	r3, #3
   454ce:	2205      	movs	r2, #5
   454d0:	7033      	strb	r3, [r6, #0]
   454d2:	4b05      	ldr	r3, [pc, #20]	; (454e8 <ipc_irq_handler+0x11c>)
   454d4:	601a      	str	r2, [r3, #0]
   454d6:	e7e4      	b.n	454a2 <ipc_irq_handler+0xd6>
   454d8:	701d      	strb	r5, [r3, #0]
   454da:	e7e2      	b.n	454a2 <ipc_irq_handler+0xd6>
   454dc:	e000e100 	.word	0xe000e100
   454e0:	4002a000 	.word	0x4002a000
   454e4:	2001eafa 	.word	0x2001eafa
   454e8:	2001aba4 	.word	0x2001aba4
   454ec:	04400004 	.word	0x04400004
   454f0:	05500001 	.word	0x05500001
   454f4:	2001abb0 	.word	0x2001abb0
   454f8:	2001aba8 	.word	0x2001aba8

000454fc <interface_init>:
   454fc:	b508      	push	{r3, lr}
   454fe:	f44f 72b0 	mov.w	r2, #352	; 0x160
   45502:	2100      	movs	r1, #0
   45504:	4802      	ldr	r0, [pc, #8]	; (45510 <interface_init+0x14>)
   45506:	f003 fa19 	bl	4893c <memset>
   4550a:	2000      	movs	r0, #0
   4550c:	bd08      	pop	{r3, pc}
   4550e:	bf00      	nop
   45510:	2001abc4 	.word	0x2001abc4

00045514 <interface_socket_wait>:
   45514:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45518:	4615      	mov	r5, r2
   4551a:	222c      	movs	r2, #44	; 0x2c
   4551c:	4350      	muls	r0, r2
   4551e:	461e      	mov	r6, r3
   45520:	4b0e      	ldr	r3, [pc, #56]	; (4555c <interface_socket_wait+0x48>)
   45522:	460c      	mov	r4, r1
   45524:	181f      	adds	r7, r3, r0
   45526:	581b      	ldr	r3, [r3, r0]
   45528:	402b      	ands	r3, r5
   4552a:	428b      	cmp	r3, r1
   4552c:	d102      	bne.n	45534 <interface_socket_wait+0x20>
   4552e:	2000      	movs	r0, #0
   45530:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45534:	687b      	ldr	r3, [r7, #4]
   45536:	2b00      	cmp	r3, #0
   45538:	d1f9      	bne.n	4552e <interface_socket_wait+0x1a>
   4553a:	46b8      	mov	r8, r7
   4553c:	f8d8 3000 	ldr.w	r3, [r8]
   45540:	402b      	ands	r3, r5
   45542:	42a3      	cmp	r3, r4
   45544:	d0f3      	beq.n	4552e <interface_socket_wait+0x1a>
   45546:	f8d8 3004 	ldr.w	r3, [r8, #4]
   4554a:	2b00      	cmp	r3, #0
   4554c:	d1ef      	bne.n	4552e <interface_socket_wait+0x1a>
   4554e:	4631      	mov	r1, r6
   45550:	4638      	mov	r0, r7
   45552:	f7fe fd11 	bl	43f78 <nrf_modem_os_timedwait>
   45556:	2800      	cmp	r0, #0
   45558:	d0f0      	beq.n	4553c <interface_socket_wait+0x28>
   4555a:	e7e9      	b.n	45530 <interface_socket_wait+0x1c>
   4555c:	2001abc4 	.word	0x2001abc4

00045560 <interface_sockets_aux_state_set>:
   45560:	4a0d      	ldr	r2, [pc, #52]	; (45598 <interface_sockets_aux_state_set+0x38>)
   45562:	b570      	push	{r4, r5, r6, lr}
   45564:	2300      	movs	r3, #0
   45566:	4611      	mov	r1, r2
   45568:	252c      	movs	r5, #44	; 0x2c
   4556a:	fb05 f403 	mul.w	r4, r5, r3
   4556e:	590c      	ldr	r4, [r1, r4]
   45570:	b15c      	cbz	r4, 4558a <interface_sockets_aux_state_set+0x2a>
   45572:	68d4      	ldr	r4, [r2, #12]
   45574:	f024 0608 	bic.w	r6, r4, #8
   45578:	2e02      	cmp	r6, #2
   4557a:	d001      	beq.n	45580 <interface_sockets_aux_state_set+0x20>
   4557c:	2c05      	cmp	r4, #5
   4557e:	d104      	bne.n	4558a <interface_sockets_aux_state_set+0x2a>
   45580:	fb05 f603 	mul.w	r6, r5, r3
   45584:	598c      	ldr	r4, [r1, r6]
   45586:	4304      	orrs	r4, r0
   45588:	518c      	str	r4, [r1, r6]
   4558a:	3301      	adds	r3, #1
   4558c:	2b08      	cmp	r3, #8
   4558e:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   45592:	d1ea      	bne.n	4556a <interface_sockets_aux_state_set+0xa>
   45594:	bd70      	pop	{r4, r5, r6, pc}
   45596:	bf00      	nop
   45598:	2001abc4 	.word	0x2001abc4

0004559c <interface_sockets_aux_state_clear>:
   4559c:	4a0d      	ldr	r2, [pc, #52]	; (455d4 <interface_sockets_aux_state_clear+0x38>)
   4559e:	b570      	push	{r4, r5, r6, lr}
   455a0:	2300      	movs	r3, #0
   455a2:	4611      	mov	r1, r2
   455a4:	252c      	movs	r5, #44	; 0x2c
   455a6:	43c0      	mvns	r0, r0
   455a8:	fb05 f403 	mul.w	r4, r5, r3
   455ac:	590c      	ldr	r4, [r1, r4]
   455ae:	b15c      	cbz	r4, 455c8 <interface_sockets_aux_state_clear+0x2c>
   455b0:	68d4      	ldr	r4, [r2, #12]
   455b2:	f024 0608 	bic.w	r6, r4, #8
   455b6:	2e02      	cmp	r6, #2
   455b8:	d001      	beq.n	455be <interface_sockets_aux_state_clear+0x22>
   455ba:	2c05      	cmp	r4, #5
   455bc:	d104      	bne.n	455c8 <interface_sockets_aux_state_clear+0x2c>
   455be:	fb05 f603 	mul.w	r6, r5, r3
   455c2:	598c      	ldr	r4, [r1, r6]
   455c4:	4004      	ands	r4, r0
   455c6:	518c      	str	r4, [r1, r6]
   455c8:	3301      	adds	r3, #1
   455ca:	2b08      	cmp	r3, #8
   455cc:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   455d0:	d1ea      	bne.n	455a8 <interface_sockets_aux_state_clear+0xc>
   455d2:	bd70      	pop	{r4, r5, r6, pc}
   455d4:	2001abc4 	.word	0x2001abc4

000455d8 <interface_from_internal_id_search>:
   455d8:	4b0a      	ldr	r3, [pc, #40]	; (45604 <interface_from_internal_id_search+0x2c>)
   455da:	4602      	mov	r2, r0
   455dc:	b530      	push	{r4, r5, lr}
   455de:	2000      	movs	r0, #0
   455e0:	461c      	mov	r4, r3
   455e2:	212c      	movs	r1, #44	; 0x2c
   455e4:	fb01 f500 	mul.w	r5, r1, r0
   455e8:	5965      	ldr	r5, [r4, r5]
   455ea:	b115      	cbz	r5, 455f2 <interface_from_internal_id_search+0x1a>
   455ec:	699d      	ldr	r5, [r3, #24]
   455ee:	4295      	cmp	r5, r2
   455f0:	d006      	beq.n	45600 <interface_from_internal_id_search+0x28>
   455f2:	3001      	adds	r0, #1
   455f4:	2808      	cmp	r0, #8
   455f6:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   455fa:	d1f3      	bne.n	455e4 <interface_from_internal_id_search+0xc>
   455fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   45600:	bd30      	pop	{r4, r5, pc}
   45602:	bf00      	nop
   45604:	2001abc4 	.word	0x2001abc4

00045608 <interface_socket_from_handle_get>:
   45608:	2807      	cmp	r0, #7
   4560a:	d808      	bhi.n	4561e <interface_socket_from_handle_get+0x16>
   4560c:	232c      	movs	r3, #44	; 0x2c
   4560e:	4343      	muls	r3, r0
   45610:	4a04      	ldr	r2, [pc, #16]	; (45624 <interface_socket_from_handle_get+0x1c>)
   45612:	18d0      	adds	r0, r2, r3
   45614:	58d3      	ldr	r3, [r2, r3]
   45616:	2b00      	cmp	r3, #0
   45618:	bf08      	it	eq
   4561a:	2000      	moveq	r0, #0
   4561c:	4770      	bx	lr
   4561e:	2000      	movs	r0, #0
   45620:	4770      	bx	lr
   45622:	bf00      	nop
   45624:	2001abc4 	.word	0x2001abc4

00045628 <rpc_error_to_nrf_errno>:
   45628:	286a      	cmp	r0, #106	; 0x6a
   4562a:	bf9a      	itte	ls
   4562c:	4b01      	ldrls	r3, [pc, #4]	; (45634 <rpc_error_to_nrf_errno+0xc>)
   4562e:	5c18      	ldrbls	r0, [r3, r0]
   45630:	205f      	movhi	r0, #95	; 0x5f
   45632:	4770      	bx	lr
   45634:	0004a290 	.word	0x0004a290

00045638 <rpc_error_to_nrf_gai_errno>:
   45638:	2805      	cmp	r0, #5
   4563a:	d013      	beq.n	45664 <rpc_error_to_nrf_gai_errno+0x2c>
   4563c:	d807      	bhi.n	4564e <rpc_error_to_nrf_gai_errno+0x16>
   4563e:	b170      	cbz	r0, 4565e <rpc_error_to_nrf_gai_errno+0x26>
   45640:	4b0b      	ldr	r3, [pc, #44]	; (45670 <rpc_error_to_nrf_gai_errno+0x38>)
   45642:	5c1b      	ldrb	r3, [r3, r0]
   45644:	4a0b      	ldr	r2, [pc, #44]	; (45674 <rpc_error_to_nrf_gai_errno+0x3c>)
   45646:	f240 1015 	movw	r0, #277	; 0x115
   4564a:	6013      	str	r3, [r2, #0]
   4564c:	4770      	bx	lr
   4564e:	2806      	cmp	r0, #6
   45650:	d00b      	beq.n	4566a <rpc_error_to_nrf_gai_errno+0x32>
   45652:	280d      	cmp	r0, #13
   45654:	d009      	beq.n	4566a <rpc_error_to_nrf_gai_errno+0x32>
   45656:	286a      	cmp	r0, #106	; 0x6a
   45658:	d9f2      	bls.n	45640 <rpc_error_to_nrf_gai_errno+0x8>
   4565a:	235f      	movs	r3, #95	; 0x5f
   4565c:	e7f2      	b.n	45644 <rpc_error_to_nrf_gai_errno+0xc>
   4565e:	4b05      	ldr	r3, [pc, #20]	; (45674 <rpc_error_to_nrf_gai_errno+0x3c>)
   45660:	6018      	str	r0, [r3, #0]
   45662:	4770      	bx	lr
   45664:	f44f 708a 	mov.w	r0, #276	; 0x114
   45668:	4770      	bx	lr
   4566a:	f240 1011 	movw	r0, #273	; 0x111
   4566e:	4770      	bx	lr
   45670:	0004a290 	.word	0x0004a290
   45674:	2001ad2c 	.word	0x2001ad2c

00045678 <ip_interface_init>:
   45678:	b510      	push	{r4, lr}
   4567a:	2400      	movs	r4, #0
   4567c:	4b06      	ldr	r3, [pc, #24]	; (45698 <ip_interface_init+0x20>)
   4567e:	2220      	movs	r2, #32
   45680:	601c      	str	r4, [r3, #0]
   45682:	4b06      	ldr	r3, [pc, #24]	; (4569c <ip_interface_init+0x24>)
   45684:	4621      	mov	r1, r4
   45686:	4806      	ldr	r0, [pc, #24]	; (456a0 <ip_interface_init+0x28>)
   45688:	601c      	str	r4, [r3, #0]
   4568a:	f003 f957 	bl	4893c <memset>
   4568e:	2201      	movs	r2, #1
   45690:	4b04      	ldr	r3, [pc, #16]	; (456a4 <ip_interface_init+0x2c>)
   45692:	4620      	mov	r0, r4
   45694:	701a      	strb	r2, [r3, #0]
   45696:	bd10      	pop	{r4, pc}
   45698:	2001ad38 	.word	0x2001ad38
   4569c:	2001ad34 	.word	0x2001ad34
   456a0:	2001ad3c 	.word	0x2001ad3c
   456a4:	2001eafd 	.word	0x2001eafd

000456a8 <rpc_ip_event_handler>:
   456a8:	f248 030f 	movw	r3, #32783	; 0x800f
   456ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   456b0:	4299      	cmp	r1, r3
   456b2:	4604      	mov	r4, r0
   456b4:	460e      	mov	r6, r1
   456b6:	b089      	sub	sp, #36	; 0x24
   456b8:	f000 80a4 	beq.w	45804 <rpc_ip_event_handler+0x15c>
   456bc:	f249 0304 	movw	r3, #36868	; 0x9004
   456c0:	4299      	cmp	r1, r3
   456c2:	f000 80ab 	beq.w	4581c <rpc_ip_event_handler+0x174>
   456c6:	f248 030d 	movw	r3, #32781	; 0x800d
   456ca:	4299      	cmp	r1, r3
   456cc:	f040 80b8 	bne.w	45840 <rpc_ip_event_handler+0x198>
   456d0:	4bbc      	ldr	r3, [pc, #752]	; (459c4 <rpc_ip_event_handler+0x31c>)
   456d2:	681a      	ldr	r2, [r3, #0]
   456d4:	9303      	str	r3, [sp, #12]
   456d6:	2a01      	cmp	r2, #1
   456d8:	d12d      	bne.n	45736 <rpc_ip_event_handler+0x8e>
   456da:	6940      	ldr	r0, [r0, #20]
   456dc:	2800      	cmp	r0, #0
   456de:	f040 808c 	bne.w	457fa <rpc_ip_event_handler+0x152>
   456e2:	f8d4 a018 	ldr.w	sl, [r4, #24]
   456e6:	f8d4 8000 	ldr.w	r8, [r4]
   456ea:	ea4f 134a 	mov.w	r3, sl, lsl #5
   456ee:	4618      	mov	r0, r3
   456f0:	9301      	str	r3, [sp, #4]
   456f2:	f7fe fd19 	bl	44128 <nrf_modem_os_alloc>
   456f6:	4607      	mov	r7, r0
   456f8:	b310      	cbz	r0, 45740 <rpc_ip_event_handler+0x98>
   456fa:	2024      	movs	r0, #36	; 0x24
   456fc:	fb00 f00a 	mul.w	r0, r0, sl
   45700:	f7fe fd12 	bl	44128 <nrf_modem_os_alloc>
   45704:	4605      	mov	r5, r0
   45706:	b1e8      	cbz	r0, 45744 <rpc_ip_event_handler+0x9c>
   45708:	2604      	movs	r6, #4
   4570a:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   4570e:	f107 0920 	add.w	r9, r7, #32
   45712:	9302      	str	r3, [sp, #8]
   45714:	9b02      	ldr	r3, [sp, #8]
   45716:	42ab      	cmp	r3, r5
   45718:	d118      	bne.n	4574c <rpc_ip_event_handler+0xa4>
   4571a:	f1ba 0f00 	cmp.w	sl, #0
   4571e:	d005      	beq.n	4572c <rpc_ip_event_handler+0x84>
   45720:	9b01      	ldr	r3, [sp, #4]
   45722:	443b      	add	r3, r7
   45724:	4699      	mov	r9, r3
   45726:	2300      	movs	r3, #0
   45728:	f849 3c04 	str.w	r3, [r9, #-4]
   4572c:	4ba6      	ldr	r3, [pc, #664]	; (459c8 <rpc_ip_event_handler+0x320>)
   4572e:	601f      	str	r7, [r3, #0]
   45730:	2302      	movs	r3, #2
   45732:	9a03      	ldr	r2, [sp, #12]
   45734:	6013      	str	r3, [r2, #0]
   45736:	6820      	ldr	r0, [r4, #0]
   45738:	2800      	cmp	r0, #0
   4573a:	f040 81c7 	bne.w	45acc <rpc_ip_event_handler+0x424>
   4573e:	e1c7      	b.n	45ad0 <rpc_ip_event_handler+0x428>
   45740:	f7fe fcfa 	bl	44138 <nrf_modem_os_free>
   45744:	220c      	movs	r2, #12
   45746:	4ba1      	ldr	r3, [pc, #644]	; (459cc <rpc_ip_event_handler+0x324>)
   45748:	601a      	str	r2, [r3, #0]
   4574a:	e7ef      	b.n	4572c <rpc_ip_event_handler+0x84>
   4574c:	f858 2006 	ldr.w	r2, [r8, r6]
   45750:	eb08 0106 	add.w	r1, r8, r6
   45754:	f849 2c20 	str.w	r2, [r9, #-32]
   45758:	eb08 0206 	add.w	r2, r8, r6
   4575c:	6852      	ldr	r2, [r2, #4]
   4575e:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   45762:	3a01      	subs	r2, #1
   45764:	2a04      	cmp	r2, #4
   45766:	bf8c      	ite	hi
   45768:	2200      	movhi	r2, #0
   4576a:	4b99      	ldrls	r3, [pc, #612]	; (459d0 <rpc_ip_event_handler+0x328>)
   4576c:	f106 0614 	add.w	r6, r6, #20
   45770:	bf98      	it	ls
   45772:	569a      	ldrsbls	r2, [r3, r2]
   45774:	4b97      	ldr	r3, [pc, #604]	; (459d4 <rpc_ip_event_handler+0x32c>)
   45776:	f849 2c1c 	str.w	r2, [r9, #-28]
   4577a:	681a      	ldr	r2, [r3, #0]
   4577c:	4b96      	ldr	r3, [pc, #600]	; (459d8 <rpc_ip_event_handler+0x330>)
   4577e:	f849 2c18 	str.w	r2, [r9, #-24]
   45782:	681a      	ldr	r2, [r3, #0]
   45784:	f849 2c14 	str.w	r2, [r9, #-20]
   45788:	8a0a      	ldrh	r2, [r1, #16]
   4578a:	4994      	ldr	r1, [pc, #592]	; (459dc <rpc_ip_event_handler+0x334>)
   4578c:	2a04      	cmp	r2, #4
   4578e:	8808      	ldrh	r0, [r1, #0]
   45790:	f849 2c10 	str.w	r2, [r9, #-16]
   45794:	f849 5c0c 	str.w	r5, [r9, #-12]
   45798:	eb08 0106 	add.w	r1, r8, r6
   4579c:	d121      	bne.n	457e2 <rpc_ip_event_handler+0x13a>
   4579e:	2202      	movs	r2, #2
   457a0:	606a      	str	r2, [r5, #4]
   457a2:	2210      	movs	r2, #16
   457a4:	8128      	strh	r0, [r5, #8]
   457a6:	702a      	strb	r2, [r5, #0]
   457a8:	680a      	ldr	r2, [r1, #0]
   457aa:	60ea      	str	r2, [r5, #12]
   457ac:	f859 2c10 	ldr.w	r2, [r9, #-16]
   457b0:	f10b 0001 	add.w	r0, fp, #1
   457b4:	4416      	add	r6, r2
   457b6:	f7fe fcb7 	bl	44128 <nrf_modem_os_alloc>
   457ba:	f849 0c08 	str.w	r0, [r9, #-8]
   457be:	b148      	cbz	r0, 457d4 <rpc_ip_event_handler+0x12c>
   457c0:	465a      	mov	r2, fp
   457c2:	eb08 0106 	add.w	r1, r8, r6
   457c6:	f003 f8ae 	bl	48926 <memcpy>
   457ca:	2100      	movs	r1, #0
   457cc:	f859 2c08 	ldr.w	r2, [r9, #-8]
   457d0:	f802 100b 	strb.w	r1, [r2, fp]
   457d4:	f849 9c04 	str.w	r9, [r9, #-4]
   457d8:	445e      	add	r6, fp
   457da:	f109 0920 	add.w	r9, r9, #32
   457de:	3508      	adds	r5, #8
   457e0:	e798      	b.n	45714 <rpc_ip_event_handler+0x6c>
   457e2:	230a      	movs	r3, #10
   457e4:	f04f 0c24 	mov.w	ip, #36	; 0x24
   457e8:	8128      	strh	r0, [r5, #8]
   457ea:	606b      	str	r3, [r5, #4]
   457ec:	f885 c000 	strb.w	ip, [r5]
   457f0:	f105 0010 	add.w	r0, r5, #16
   457f4:	f003 f897 	bl	48926 <memcpy>
   457f8:	e7d8      	b.n	457ac <rpc_ip_event_handler+0x104>
   457fa:	f7ff ff1d 	bl	45638 <rpc_error_to_nrf_gai_errno>
   457fe:	4b73      	ldr	r3, [pc, #460]	; (459cc <rpc_ip_event_handler+0x324>)
   45800:	6018      	str	r0, [r3, #0]
   45802:	e795      	b.n	45730 <rpc_ip_event_handler+0x88>
   45804:	6943      	ldr	r3, [r0, #20]
   45806:	2b6a      	cmp	r3, #106	; 0x6a
   45808:	bf8e      	itee	hi
   4580a:	235f      	movhi	r3, #95	; 0x5f
   4580c:	4a74      	ldrls	r2, [pc, #464]	; (459e0 <rpc_ip_event_handler+0x338>)
   4580e:	5cd3      	ldrbls	r3, [r2, r3]
   45810:	4a74      	ldr	r2, [pc, #464]	; (459e4 <rpc_ip_event_handler+0x33c>)
   45812:	6013      	str	r3, [r2, #0]
   45814:	4b74      	ldr	r3, [pc, #464]	; (459e8 <rpc_ip_event_handler+0x340>)
   45816:	2201      	movs	r2, #1
   45818:	701a      	strb	r2, [r3, #0]
   4581a:	e159      	b.n	45ad0 <rpc_ip_event_handler+0x428>
   4581c:	6903      	ldr	r3, [r0, #16]
   4581e:	2b03      	cmp	r3, #3
   45820:	d807      	bhi.n	45832 <rpc_ip_event_handler+0x18a>
   45822:	e8df f003 	tbb	[pc, r3]
   45826:	0802      	.short	0x0802
   45828:	0802      	.short	0x0802
   4582a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   4582e:	f7ff fe97 	bl	45560 <interface_sockets_aux_state_set>
   45832:	4b6e      	ldr	r3, [pc, #440]	; (459ec <rpc_ip_event_handler+0x344>)
   45834:	e7ef      	b.n	45816 <rpc_ip_event_handler+0x16e>
   45836:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   4583a:	f7ff feaf 	bl	4559c <interface_sockets_aux_state_clear>
   4583e:	e7f8      	b.n	45832 <rpc_ip_event_handler+0x18a>
   45840:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   45844:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   45848:	68c0      	ldr	r0, [r0, #12]
   4584a:	d13b      	bne.n	458c4 <rpc_ip_event_handler+0x21c>
   4584c:	f7ff fec4 	bl	455d8 <interface_from_internal_id_search>
   45850:	4607      	mov	r7, r0
   45852:	4638      	mov	r0, r7
   45854:	f7ff fed8 	bl	45608 <interface_socket_from_handle_get>
   45858:	4605      	mov	r5, r0
   4585a:	2800      	cmp	r0, #0
   4585c:	f43f af6b 	beq.w	45736 <rpc_ip_event_handler+0x8e>
   45860:	4601      	mov	r1, r0
   45862:	4633      	mov	r3, r6
   45864:	4622      	mov	r2, r4
   45866:	4638      	mov	r0, r7
   45868:	f000 f9f4 	bl	45c54 <tls_rpc_ip_event_handler>
   4586c:	2800      	cmp	r0, #0
   4586e:	f000 812f 	beq.w	45ad0 <rpc_ip_event_handler+0x428>
   45872:	f248 030c 	movw	r3, #32780	; 0x800c
   45876:	429e      	cmp	r6, r3
   45878:	d826      	bhi.n	458c8 <rpc_ip_event_handler+0x220>
   4587a:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   4587e:	f67f af5a 	bls.w	45736 <rpc_ip_event_handler+0x8e>
   45882:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   45886:	3e01      	subs	r6, #1
   45888:	2e0b      	cmp	r6, #11
   4588a:	f63f af54 	bhi.w	45736 <rpc_ip_event_handler+0x8e>
   4588e:	a301      	add	r3, pc, #4	; (adr r3, 45894 <rpc_ip_event_handler+0x1ec>)
   45890:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   45894:	00045959 	.word	0x00045959
   45898:	00045a0d 	.word	0x00045a0d
   4589c:	00045b29 	.word	0x00045b29
   458a0:	00045b47 	.word	0x00045b47
   458a4:	000459f1 	.word	0x000459f1
   458a8:	00045ad9 	.word	0x00045ad9
   458ac:	00045ad9 	.word	0x00045ad9
   458b0:	00045a51 	.word	0x00045a51
   458b4:	00045973 	.word	0x00045973
   458b8:	00045737 	.word	0x00045737
   458bc:	00045737 	.word	0x00045737
   458c0:	00045a7b 	.word	0x00045a7b
   458c4:	0c07      	lsrs	r7, r0, #16
   458c6:	e7c4      	b.n	45852 <rpc_ip_event_handler+0x1aa>
   458c8:	f249 0302 	movw	r3, #36866	; 0x9002
   458cc:	429e      	cmp	r6, r3
   458ce:	f000 80cc 	beq.w	45a6a <rpc_ip_event_handler+0x3c2>
   458d2:	f249 0303 	movw	r3, #36867	; 0x9003
   458d6:	429e      	cmp	r6, r3
   458d8:	d05b      	beq.n	45992 <rpc_ip_event_handler+0x2ea>
   458da:	f249 0301 	movw	r3, #36865	; 0x9001
   458de:	429e      	cmp	r6, r3
   458e0:	f47f af29 	bne.w	45736 <rpc_ip_event_handler+0x8e>
   458e4:	682e      	ldr	r6, [r5, #0]
   458e6:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   458ea:	f000 80ee 	beq.w	45aca <rpc_ip_event_handler+0x422>
   458ee:	68a3      	ldr	r3, [r4, #8]
   458f0:	2b04      	cmp	r3, #4
   458f2:	f240 80e7 	bls.w	45ac4 <rpc_ip_event_handler+0x41c>
   458f6:	8a63      	ldrh	r3, [r4, #18]
   458f8:	2b00      	cmp	r3, #0
   458fa:	f000 80e4 	beq.w	45ac6 <rpc_ip_event_handler+0x41e>
   458fe:	2b10      	cmp	r3, #16
   45900:	f040 80cc 	bne.w	45a9c <rpc_ip_event_handler+0x3f4>
   45904:	2024      	movs	r0, #36	; 0x24
   45906:	f7fe fc0f 	bl	44128 <nrf_modem_os_alloc>
   4590a:	b318      	cbz	r0, 45954 <rpc_ip_event_handler+0x2ac>
   4590c:	230a      	movs	r3, #10
   4590e:	6043      	str	r3, [r0, #4]
   45910:	2324      	movs	r3, #36	; 0x24
   45912:	7003      	strb	r3, [r0, #0]
   45914:	7c62      	ldrb	r2, [r4, #17]
   45916:	7c23      	ldrb	r3, [r4, #16]
   45918:	f104 0124 	add.w	r1, r4, #36	; 0x24
   4591c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   45920:	8103      	strh	r3, [r0, #8]
   45922:	f100 0210 	add.w	r2, r0, #16
   45926:	f104 0314 	add.w	r3, r4, #20
   4592a:	f853 6b04 	ldr.w	r6, [r3], #4
   4592e:	428b      	cmp	r3, r1
   45930:	f842 6b04 	str.w	r6, [r2], #4
   45934:	d1f9      	bne.n	4592a <rpc_ip_event_handler+0x282>
   45936:	2324      	movs	r3, #36	; 0x24
   45938:	6822      	ldr	r2, [r4, #0]
   4593a:	9307      	str	r3, [sp, #28]
   4593c:	9204      	str	r2, [sp, #16]
   4593e:	6862      	ldr	r2, [r4, #4]
   45940:	a904      	add	r1, sp, #16
   45942:	e9cd 2005 	strd	r2, r0, [sp, #20]
   45946:	69e8      	ldr	r0, [r5, #28]
   45948:	6803      	ldr	r3, [r0, #0]
   4594a:	685b      	ldr	r3, [r3, #4]
   4594c:	4798      	blx	r3
   4594e:	3001      	adds	r0, #1
   45950:	f040 808f 	bne.w	45a72 <rpc_ip_event_handler+0x3ca>
   45954:	2002      	movs	r0, #2
   45956:	e0bc      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45958:	682b      	ldr	r3, [r5, #0]
   4595a:	2b01      	cmp	r3, #1
   4595c:	f040 80b8 	bne.w	45ad0 <rpc_ip_event_handler+0x428>
   45960:	6960      	ldr	r0, [r4, #20]
   45962:	2800      	cmp	r0, #0
   45964:	f040 80e9 	bne.w	45b3a <rpc_ip_event_handler+0x492>
   45968:	2302      	movs	r3, #2
   4596a:	602b      	str	r3, [r5, #0]
   4596c:	69a3      	ldr	r3, [r4, #24]
   4596e:	61ab      	str	r3, [r5, #24]
   45970:	e0af      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45972:	682b      	ldr	r3, [r5, #0]
   45974:	b29b      	uxth	r3, r3
   45976:	2b0d      	cmp	r3, #13
   45978:	f040 80aa 	bne.w	45ad0 <rpc_ip_event_handler+0x428>
   4597c:	6960      	ldr	r0, [r4, #20]
   4597e:	2800      	cmp	r0, #0
   45980:	f040 80db 	bne.w	45b3a <rpc_ip_event_handler+0x492>
   45984:	682b      	ldr	r3, [r5, #0]
   45986:	0c1b      	lsrs	r3, r3, #16
   45988:	041b      	lsls	r3, r3, #16
   4598a:	f043 030e 	orr.w	r3, r3, #14
   4598e:	602b      	str	r3, [r5, #0]
   45990:	e09f      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45992:	682b      	ldr	r3, [r5, #0]
   45994:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   45998:	602b      	str	r3, [r5, #0]
   4599a:	682b      	ldr	r3, [r5, #0]
   4599c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   459a0:	602b      	str	r3, [r5, #0]
   459a2:	6923      	ldr	r3, [r4, #16]
   459a4:	2b6c      	cmp	r3, #108	; 0x6c
   459a6:	d107      	bne.n	459b8 <rpc_ip_event_handler+0x310>
   459a8:	682b      	ldr	r3, [r5, #0]
   459aa:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   459ae:	602b      	str	r3, [r5, #0]
   459b0:	2380      	movs	r3, #128	; 0x80
   459b2:	606b      	str	r3, [r5, #4]
   459b4:	60ab      	str	r3, [r5, #8]
   459b6:	e08b      	b.n	45ad0 <rpc_ip_event_handler+0x428>
   459b8:	2b6a      	cmp	r3, #106	; 0x6a
   459ba:	bf96      	itet	ls
   459bc:	4a08      	ldrls	r2, [pc, #32]	; (459e0 <rpc_ip_event_handler+0x338>)
   459be:	235f      	movhi	r3, #95	; 0x5f
   459c0:	5cd3      	ldrbls	r3, [r2, r3]
   459c2:	e7f6      	b.n	459b2 <rpc_ip_event_handler+0x30a>
   459c4:	2001ad34 	.word	0x2001ad34
   459c8:	2001ad38 	.word	0x2001ad38
   459cc:	2001ad30 	.word	0x2001ad30
   459d0:	0004a28b 	.word	0x0004a28b
   459d4:	2001ad28 	.word	0x2001ad28
   459d8:	2001ad24 	.word	0x2001ad24
   459dc:	2001ae2a 	.word	0x2001ae2a
   459e0:	0004a290 	.word	0x0004a290
   459e4:	2001ad5c 	.word	0x2001ad5c
   459e8:	2001eafe 	.word	0x2001eafe
   459ec:	2001eafc 	.word	0x2001eafc
   459f0:	682b      	ldr	r3, [r5, #0]
   459f2:	b29b      	uxth	r3, r3
   459f4:	2b03      	cmp	r3, #3
   459f6:	d16b      	bne.n	45ad0 <rpc_ip_event_handler+0x428>
   459f8:	6960      	ldr	r0, [r4, #20]
   459fa:	2800      	cmp	r0, #0
   459fc:	f040 809d 	bne.w	45b3a <rpc_ip_event_handler+0x492>
   45a00:	682b      	ldr	r3, [r5, #0]
   45a02:	0c1b      	lsrs	r3, r3, #16
   45a04:	041b      	lsls	r3, r3, #16
   45a06:	f043 0304 	orr.w	r3, r3, #4
   45a0a:	e7c0      	b.n	4598e <rpc_ip_event_handler+0x2e6>
   45a0c:	682b      	ldr	r3, [r5, #0]
   45a0e:	0099      	lsls	r1, r3, #2
   45a10:	d55e      	bpl.n	45ad0 <rpc_ip_event_handler+0x428>
   45a12:	682b      	ldr	r3, [r5, #0]
   45a14:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45a18:	602b      	str	r3, [r5, #0]
   45a1a:	6960      	ldr	r0, [r4, #20]
   45a1c:	b968      	cbnz	r0, 45a3a <rpc_ip_event_handler+0x392>
   45a1e:	682b      	ldr	r3, [r5, #0]
   45a20:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   45a24:	602b      	str	r3, [r5, #0]
   45a26:	682b      	ldr	r3, [r5, #0]
   45a28:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   45a2c:	602b      	str	r3, [r5, #0]
   45a2e:	682b      	ldr	r3, [r5, #0]
   45a30:	0c1b      	lsrs	r3, r3, #16
   45a32:	041b      	lsls	r3, r3, #16
   45a34:	f043 0305 	orr.w	r3, r3, #5
   45a38:	e7a9      	b.n	4598e <rpc_ip_event_handler+0x2e6>
   45a3a:	286a      	cmp	r0, #106	; 0x6a
   45a3c:	bf8e      	itee	hi
   45a3e:	235f      	movhi	r3, #95	; 0x5f
   45a40:	4b4c      	ldrls	r3, [pc, #304]	; (45b74 <rpc_ip_event_handler+0x4cc>)
   45a42:	5c1b      	ldrbls	r3, [r3, r0]
   45a44:	606b      	str	r3, [r5, #4]
   45a46:	682b      	ldr	r3, [r5, #0]
   45a48:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45a4c:	602b      	str	r3, [r5, #0]
   45a4e:	e03f      	b.n	45ad0 <rpc_ip_event_handler+0x428>
   45a50:	682b      	ldr	r3, [r5, #0]
   45a52:	b29b      	uxth	r3, r3
   45a54:	2b06      	cmp	r3, #6
   45a56:	d13b      	bne.n	45ad0 <rpc_ip_event_handler+0x428>
   45a58:	6960      	ldr	r0, [r4, #20]
   45a5a:	2800      	cmp	r0, #0
   45a5c:	d16d      	bne.n	45b3a <rpc_ip_event_handler+0x492>
   45a5e:	682b      	ldr	r3, [r5, #0]
   45a60:	0c1b      	lsrs	r3, r3, #16
   45a62:	041b      	lsls	r3, r3, #16
   45a64:	f043 0307 	orr.w	r3, r3, #7
   45a68:	e791      	b.n	4598e <rpc_ip_event_handler+0x2e6>
   45a6a:	682b      	ldr	r3, [r5, #0]
   45a6c:	b29b      	uxth	r3, r3
   45a6e:	2b07      	cmp	r3, #7
   45a70:	d12e      	bne.n	45ad0 <rpc_ip_event_handler+0x428>
   45a72:	682b      	ldr	r3, [r5, #0]
   45a74:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   45a78:	e7e8      	b.n	45a4c <rpc_ip_event_handler+0x3a4>
   45a7a:	682b      	ldr	r3, [r5, #0]
   45a7c:	b29b      	uxth	r3, r3
   45a7e:	2b08      	cmp	r3, #8
   45a80:	d126      	bne.n	45ad0 <rpc_ip_event_handler+0x428>
   45a82:	6963      	ldr	r3, [r4, #20]
   45a84:	2b00      	cmp	r3, #0
   45a86:	d16d      	bne.n	45b64 <rpc_ip_event_handler+0x4bc>
   45a88:	4b3b      	ldr	r3, [pc, #236]	; (45b78 <rpc_ip_event_handler+0x4d0>)
   45a8a:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   45a8e:	682b      	ldr	r3, [r5, #0]
   45a90:	0c1b      	lsrs	r3, r3, #16
   45a92:	041b      	lsls	r3, r3, #16
   45a94:	f043 0309 	orr.w	r3, r3, #9
   45a98:	602b      	str	r3, [r5, #0]
   45a9a:	e032      	b.n	45b02 <rpc_ip_event_handler+0x45a>
   45a9c:	2b04      	cmp	r3, #4
   45a9e:	d114      	bne.n	45aca <rpc_ip_event_handler+0x422>
   45aa0:	2010      	movs	r0, #16
   45aa2:	f7fe fb41 	bl	44128 <nrf_modem_os_alloc>
   45aa6:	2800      	cmp	r0, #0
   45aa8:	f43f af54 	beq.w	45954 <rpc_ip_event_handler+0x2ac>
   45aac:	2302      	movs	r3, #2
   45aae:	6043      	str	r3, [r0, #4]
   45ab0:	2310      	movs	r3, #16
   45ab2:	7003      	strb	r3, [r0, #0]
   45ab4:	7c22      	ldrb	r2, [r4, #16]
   45ab6:	7c61      	ldrb	r1, [r4, #17]
   45ab8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   45abc:	8102      	strh	r2, [r0, #8]
   45abe:	6962      	ldr	r2, [r4, #20]
   45ac0:	60c2      	str	r2, [r0, #12]
   45ac2:	e739      	b.n	45938 <rpc_ip_event_handler+0x290>
   45ac4:	2300      	movs	r3, #0
   45ac6:	4618      	mov	r0, r3
   45ac8:	e736      	b.n	45938 <rpc_ip_event_handler+0x290>
   45aca:	6820      	ldr	r0, [r4, #0]
   45acc:	f003 f95c 	bl	48d88 <rpc_client_data_free>
   45ad0:	2000      	movs	r0, #0
   45ad2:	b009      	add	sp, #36	; 0x24
   45ad4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   45ad8:	4b27      	ldr	r3, [pc, #156]	; (45b78 <rpc_ip_event_handler+0x4d0>)
   45ada:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   45ade:	6963      	ldr	r3, [r4, #20]
   45ae0:	b17b      	cbz	r3, 45b02 <rpc_ip_event_handler+0x45a>
   45ae2:	2b6b      	cmp	r3, #107	; 0x6b
   45ae4:	d10f      	bne.n	45b06 <rpc_ip_event_handler+0x45e>
   45ae6:	6928      	ldr	r0, [r5, #16]
   45ae8:	220c      	movs	r2, #12
   45aea:	2801      	cmp	r0, #1
   45aec:	682b      	ldr	r3, [r5, #0]
   45aee:	d104      	bne.n	45afa <rpc_ip_event_handler+0x452>
   45af0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   45af4:	602b      	str	r3, [r5, #0]
   45af6:	606a      	str	r2, [r5, #4]
   45af8:	e7eb      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45afa:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45afe:	602b      	str	r3, [r5, #0]
   45b00:	606a      	str	r2, [r5, #4]
   45b02:	2001      	movs	r0, #1
   45b04:	e7e5      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45b06:	f023 0002 	bic.w	r0, r3, #2
   45b0a:	2801      	cmp	r0, #1
   45b0c:	d102      	bne.n	45b14 <rpc_ip_event_handler+0x46c>
   45b0e:	230c      	movs	r3, #12
   45b10:	606b      	str	r3, [r5, #4]
   45b12:	e7de      	b.n	45ad2 <rpc_ip_event_handler+0x42a>
   45b14:	2b6a      	cmp	r3, #106	; 0x6a
   45b16:	bf8e      	itee	hi
   45b18:	235f      	movhi	r3, #95	; 0x5f
   45b1a:	4a16      	ldrls	r2, [pc, #88]	; (45b74 <rpc_ip_event_handler+0x4cc>)
   45b1c:	5cd3      	ldrbls	r3, [r2, r3]
   45b1e:	606b      	str	r3, [r5, #4]
   45b20:	682b      	ldr	r3, [r5, #0]
   45b22:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45b26:	e7b7      	b.n	45a98 <rpc_ip_event_handler+0x3f0>
   45b28:	682b      	ldr	r3, [r5, #0]
   45b2a:	025a      	lsls	r2, r3, #9
   45b2c:	d5d0      	bpl.n	45ad0 <rpc_ip_event_handler+0x428>
   45b2e:	6960      	ldr	r0, [r4, #20]
   45b30:	b918      	cbnz	r0, 45b3a <rpc_ip_event_handler+0x492>
   45b32:	682b      	ldr	r3, [r5, #0]
   45b34:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   45b38:	e729      	b.n	4598e <rpc_ip_event_handler+0x2e6>
   45b3a:	286a      	cmp	r0, #106	; 0x6a
   45b3c:	d817      	bhi.n	45b6e <rpc_ip_event_handler+0x4c6>
   45b3e:	4b0d      	ldr	r3, [pc, #52]	; (45b74 <rpc_ip_event_handler+0x4cc>)
   45b40:	5c1b      	ldrb	r3, [r3, r0]
   45b42:	606b      	str	r3, [r5, #4]
   45b44:	e7c4      	b.n	45ad0 <rpc_ip_event_handler+0x428>
   45b46:	682b      	ldr	r3, [r5, #0]
   45b48:	01db      	lsls	r3, r3, #7
   45b4a:	d5c1      	bpl.n	45ad0 <rpc_ip_event_handler+0x428>
   45b4c:	6963      	ldr	r3, [r4, #20]
   45b4e:	b94b      	cbnz	r3, 45b64 <rpc_ip_event_handler+0x4bc>
   45b50:	6820      	ldr	r0, [r4, #0]
   45b52:	b118      	cbz	r0, 45b5c <rpc_ip_event_handler+0x4b4>
   45b54:	2001      	movs	r0, #1
   45b56:	4b08      	ldr	r3, [pc, #32]	; (45b78 <rpc_ip_event_handler+0x4d0>)
   45b58:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   45b5c:	682b      	ldr	r3, [r5, #0]
   45b5e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   45b62:	e714      	b.n	4598e <rpc_ip_event_handler+0x2e6>
   45b64:	2b6a      	cmp	r3, #106	; 0x6a
   45b66:	d802      	bhi.n	45b6e <rpc_ip_event_handler+0x4c6>
   45b68:	4a02      	ldr	r2, [pc, #8]	; (45b74 <rpc_ip_event_handler+0x4cc>)
   45b6a:	5cd3      	ldrb	r3, [r2, r3]
   45b6c:	e7e9      	b.n	45b42 <rpc_ip_event_handler+0x49a>
   45b6e:	235f      	movs	r3, #95	; 0x5f
   45b70:	e7e7      	b.n	45b42 <rpc_ip_event_handler+0x49a>
   45b72:	bf00      	nop
   45b74:	0004a290 	.word	0x0004a290
   45b78:	2001ad3c 	.word	0x2001ad3c

00045b7c <hostname_free>:
   45b7c:	b538      	push	{r3, r4, r5, lr}
   45b7e:	4c07      	ldr	r4, [pc, #28]	; (45b9c <hostname_free+0x20>)
   45b80:	4605      	mov	r5, r0
   45b82:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   45b86:	b138      	cbz	r0, 45b98 <hostname_free+0x1c>
   45b88:	f7fe fad6 	bl	44138 <nrf_modem_os_free>
   45b8c:	2300      	movs	r3, #0
   45b8e:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   45b92:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   45b96:	6063      	str	r3, [r4, #4]
   45b98:	bd38      	pop	{r3, r4, r5, pc}
   45b9a:	bf00      	nop
   45b9c:	2001ad60 	.word	0x2001ad60

00045ba0 <secure_socket_attach_initiate>:
   45ba0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   45ba4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   45ba8:	f8df 8094 	ldr.w	r8, [pc, #148]	; 45c40 <secure_socket_attach_initiate+0xa0>
   45bac:	9301      	str	r3, [sp, #4]
   45bae:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   45bb2:	460d      	mov	r5, r1
   45bb4:	4616      	mov	r6, r2
   45bb6:	f8d9 3004 	ldr.w	r3, [r9, #4]
   45bba:	f247 0281 	movw	r2, #28801	; 0x7081
   45bbe:	6989      	ldr	r1, [r1, #24]
   45bc0:	4607      	mov	r7, r0
   45bc2:	f003 f8e3 	bl	48d8c <ip_interface_request_create>
   45bc6:	4604      	mov	r4, r0
   45bc8:	b398      	cbz	r0, 45c32 <secure_socket_attach_initiate+0x92>
   45bca:	f8d9 2004 	ldr.w	r2, [r9, #4]
   45bce:	b122      	cbz	r2, 45bda <secure_socket_attach_initiate+0x3a>
   45bd0:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   45bd4:	6800      	ldr	r0, [r0, #0]
   45bd6:	f002 fea6 	bl	48926 <memcpy>
   45bda:	2324      	movs	r3, #36	; 0x24
   45bdc:	4a17      	ldr	r2, [pc, #92]	; (45c3c <secure_socket_attach_initiate+0x9c>)
   45bde:	fb03 2307 	mla	r3, r3, r7, r2
   45be2:	f104 0214 	add.w	r2, r4, #20
   45be6:	f103 0124 	add.w	r1, r3, #36	; 0x24
   45bea:	f853 0b04 	ldr.w	r0, [r3], #4
   45bee:	428b      	cmp	r3, r1
   45bf0:	f842 0b04 	str.w	r0, [r2], #4
   45bf4:	d1f9      	bne.n	45bea <secure_socket_attach_initiate+0x4a>
   45bf6:	68a3      	ldr	r3, [r4, #8]
   45bf8:	4622      	mov	r2, r4
   45bfa:	3324      	adds	r3, #36	; 0x24
   45bfc:	60a3      	str	r3, [r4, #8]
   45bfe:	682b      	ldr	r3, [r5, #0]
   45c00:	f247 0181 	movw	r1, #28801	; 0x7081
   45c04:	0c1b      	lsrs	r3, r3, #16
   45c06:	041b      	lsls	r3, r3, #16
   45c08:	f043 030a 	orr.w	r3, r3, #10
   45c0c:	602b      	str	r3, [r5, #0]
   45c0e:	2004      	movs	r0, #4
   45c10:	f003 f8b3 	bl	48d7a <rpc_client_request_send>
   45c14:	682b      	ldr	r3, [r5, #0]
   45c16:	00db      	lsls	r3, r3, #3
   45c18:	d40d      	bmi.n	45c36 <secure_socket_attach_initiate+0x96>
   45c1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   45c1e:	210b      	movs	r1, #11
   45c20:	4638      	mov	r0, r7
   45c22:	ab01      	add	r3, sp, #4
   45c24:	f003 f8c5 	bl	48db2 <ip_interface_wait>
   45c28:	b100      	cbz	r0, 45c2c <secure_socket_attach_initiate+0x8c>
   45c2a:	602e      	str	r6, [r5, #0]
   45c2c:	b003      	add	sp, #12
   45c2e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   45c32:	200c      	movs	r0, #12
   45c34:	e7fa      	b.n	45c2c <secure_socket_attach_initiate+0x8c>
   45c36:	2077      	movs	r0, #119	; 0x77
   45c38:	e7f8      	b.n	45c2c <secure_socket_attach_initiate+0x8c>
   45c3a:	bf00      	nop
   45c3c:	2001eb00 	.word	0x2001eb00
   45c40:	2001ad60 	.word	0x2001ad60

00045c44 <tls_interface_init>:
   45c44:	2201      	movs	r2, #1
   45c46:	4b02      	ldr	r3, [pc, #8]	; (45c50 <tls_interface_init+0xc>)
   45c48:	2000      	movs	r0, #0
   45c4a:	701a      	strb	r2, [r3, #0]
   45c4c:	4770      	bx	lr
   45c4e:	bf00      	nop
   45c50:	2001eaff 	.word	0x2001eaff

00045c54 <tls_rpc_ip_event_handler>:
   45c54:	b570      	push	{r4, r5, r6, lr}
   45c56:	460c      	mov	r4, r1
   45c58:	f248 0181 	movw	r1, #32897	; 0x8081
   45c5c:	428b      	cmp	r3, r1
   45c5e:	4606      	mov	r6, r0
   45c60:	d035      	beq.n	45cce <tls_rpc_ip_event_handler+0x7a>
   45c62:	f249 0182 	movw	r1, #36994	; 0x9082
   45c66:	428b      	cmp	r3, r1
   45c68:	d040      	beq.n	45cec <tls_rpc_ip_event_handler+0x98>
   45c6a:	f248 0102 	movw	r1, #32770	; 0x8002
   45c6e:	428b      	cmp	r3, r1
   45c70:	d161      	bne.n	45d36 <tls_rpc_ip_event_handler+0xe2>
   45c72:	2c00      	cmp	r4, #0
   45c74:	d05f      	beq.n	45d36 <tls_rpc_ip_event_handler+0xe2>
   45c76:	6963      	ldr	r3, [r4, #20]
   45c78:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   45c7c:	d002      	beq.n	45c84 <tls_rpc_ip_event_handler+0x30>
   45c7e:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   45c82:	d158      	bne.n	45d36 <tls_rpc_ip_event_handler+0xe2>
   45c84:	6823      	ldr	r3, [r4, #0]
   45c86:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   45c8a:	6023      	str	r3, [r4, #0]
   45c8c:	6955      	ldr	r5, [r2, #20]
   45c8e:	2d00      	cmp	r5, #0
   45c90:	d14d      	bne.n	45d2e <tls_rpc_ip_event_handler+0xda>
   45c92:	6823      	ldr	r3, [r4, #0]
   45c94:	0c1b      	lsrs	r3, r3, #16
   45c96:	041b      	lsls	r3, r3, #16
   45c98:	f043 0305 	orr.w	r3, r3, #5
   45c9c:	6023      	str	r3, [r4, #0]
   45c9e:	6823      	ldr	r3, [r4, #0]
   45ca0:	00db      	lsls	r3, r3, #3
   45ca2:	d401      	bmi.n	45ca8 <tls_rpc_ip_event_handler+0x54>
   45ca4:	2000      	movs	r0, #0
   45ca6:	e020      	b.n	45cea <tls_rpc_ip_event_handler+0x96>
   45ca8:	2324      	movs	r3, #36	; 0x24
   45caa:	4373      	muls	r3, r6
   45cac:	4a23      	ldr	r2, [pc, #140]	; (45d3c <tls_rpc_ip_event_handler+0xe8>)
   45cae:	5cd3      	ldrb	r3, [r2, r3]
   45cb0:	2b02      	cmp	r3, #2
   45cb2:	d1f7      	bne.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cb4:	4621      	mov	r1, r4
   45cb6:	4630      	mov	r0, r6
   45cb8:	f003 f88b 	bl	48dd2 <secure_client_socket>
   45cbc:	2800      	cmp	r0, #0
   45cbe:	d0f1      	beq.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cc0:	2877      	cmp	r0, #119	; 0x77
   45cc2:	d0ef      	beq.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cc4:	6060      	str	r0, [r4, #4]
   45cc6:	6823      	ldr	r3, [r4, #0]
   45cc8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   45ccc:	e02d      	b.n	45d2a <tls_rpc_ip_event_handler+0xd6>
   45cce:	2c00      	cmp	r4, #0
   45cd0:	d0e8      	beq.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cd2:	6823      	ldr	r3, [r4, #0]
   45cd4:	b29b      	uxth	r3, r3
   45cd6:	2b0a      	cmp	r3, #10
   45cd8:	d1e4      	bne.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cda:	6950      	ldr	r0, [r2, #20]
   45cdc:	bb40      	cbnz	r0, 45d30 <tls_rpc_ip_event_handler+0xdc>
   45cde:	6823      	ldr	r3, [r4, #0]
   45ce0:	0c1b      	lsrs	r3, r3, #16
   45ce2:	041b      	lsls	r3, r3, #16
   45ce4:	f043 030b 	orr.w	r3, r3, #11
   45ce8:	6023      	str	r3, [r4, #0]
   45cea:	bd70      	pop	{r4, r5, r6, pc}
   45cec:	2c00      	cmp	r4, #0
   45cee:	d0d9      	beq.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cf0:	6823      	ldr	r3, [r4, #0]
   45cf2:	b29b      	uxth	r3, r3
   45cf4:	2b0b      	cmp	r3, #11
   45cf6:	d1d5      	bne.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45cf8:	6915      	ldr	r5, [r2, #16]
   45cfa:	b9c5      	cbnz	r5, 45d2e <tls_rpc_ip_event_handler+0xda>
   45cfc:	6823      	ldr	r3, [r4, #0]
   45cfe:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   45d02:	6023      	str	r3, [r4, #0]
   45d04:	f7ff ff3a 	bl	45b7c <hostname_free>
   45d08:	6823      	ldr	r3, [r4, #0]
   45d0a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   45d0e:	6023      	str	r3, [r4, #0]
   45d10:	6823      	ldr	r3, [r4, #0]
   45d12:	0c1b      	lsrs	r3, r3, #16
   45d14:	041b      	lsls	r3, r3, #16
   45d16:	f043 030c 	orr.w	r3, r3, #12
   45d1a:	6023      	str	r3, [r4, #0]
   45d1c:	6823      	ldr	r3, [r4, #0]
   45d1e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   45d22:	6023      	str	r3, [r4, #0]
   45d24:	6823      	ldr	r3, [r4, #0]
   45d26:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   45d2a:	6023      	str	r3, [r4, #0]
   45d2c:	e7ba      	b.n	45ca4 <tls_rpc_ip_event_handler+0x50>
   45d2e:	4628      	mov	r0, r5
   45d30:	f7ff fc7a 	bl	45628 <rpc_error_to_nrf_errno>
   45d34:	e7c6      	b.n	45cc4 <tls_rpc_ip_event_handler+0x70>
   45d36:	2001      	movs	r0, #1
   45d38:	e7d7      	b.n	45cea <tls_rpc_ip_event_handler+0x96>
   45d3a:	bf00      	nop
   45d3c:	2001eb00 	.word	0x2001eb00

00045d40 <at_cmd_send>:
   45d40:	b537      	push	{r0, r1, r2, r4, r5, lr}
   45d42:	4615      	mov	r5, r2
   45d44:	f06f 0258 	mvn.w	r2, #88	; 0x58
   45d48:	2300      	movs	r3, #0
   45d4a:	7302      	strb	r2, [r0, #12]
   45d4c:	2204      	movs	r2, #4
   45d4e:	4c0d      	ldr	r4, [pc, #52]	; (45d84 <at_cmd_send+0x44>)
   45d50:	7343      	strb	r3, [r0, #13]
   45d52:	7383      	strb	r3, [r0, #14]
   45d54:	73c3      	strb	r3, [r0, #15]
   45d56:	7202      	strb	r2, [r0, #8]
   45d58:	7243      	strb	r3, [r0, #9]
   45d5a:	7283      	strb	r3, [r0, #10]
   45d5c:	72c3      	strb	r3, [r0, #11]
   45d5e:	4602      	mov	r2, r0
   45d60:	b289      	uxth	r1, r1
   45d62:	2003      	movs	r0, #3
   45d64:	7023      	strb	r3, [r4, #0]
   45d66:	f003 f808 	bl	48d7a <rpc_client_request_send>
   45d6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   45d6e:	9301      	str	r3, [sp, #4]
   45d70:	7823      	ldrb	r3, [r4, #0]
   45d72:	42ab      	cmp	r3, r5
   45d74:	d101      	bne.n	45d7a <at_cmd_send+0x3a>
   45d76:	b003      	add	sp, #12
   45d78:	bd30      	pop	{r4, r5, pc}
   45d7a:	a901      	add	r1, sp, #4
   45d7c:	2000      	movs	r0, #0
   45d7e:	f7fe f8fb 	bl	43f78 <nrf_modem_os_timedwait>
   45d82:	e7f5      	b.n	45d70 <at_cmd_send+0x30>
   45d84:	2001ec20 	.word	0x2001ec20

00045d88 <nrf_modem_at_init>:
   45d88:	2201      	movs	r2, #1
   45d8a:	b508      	push	{r3, lr}
   45d8c:	4611      	mov	r1, r2
   45d8e:	4808      	ldr	r0, [pc, #32]	; (45db0 <nrf_modem_at_init+0x28>)
   45d90:	f7fe f990 	bl	440b4 <nrf_modem_os_sem_init>
   45d94:	2000      	movs	r0, #0
   45d96:	f002 ffea 	bl	48d6e <rpc_client_request_alloc>
   45d9a:	b128      	cbz	r0, 45da8 <nrf_modem_at_init+0x20>
   45d9c:	2201      	movs	r2, #1
   45d9e:	2105      	movs	r1, #5
   45da0:	f7ff ffce 	bl	45d40 <at_cmd_send>
   45da4:	2000      	movs	r0, #0
   45da6:	bd08      	pop	{r3, pc}
   45da8:	f06f 000b 	mvn.w	r0, #11
   45dac:	e7fb      	b.n	45da6 <nrf_modem_at_init+0x1e>
   45dae:	bf00      	nop
   45db0:	2001ada0 	.word	0x2001ada0

00045db4 <rpc_at_event_handler>:
   45db4:	b570      	push	{r4, r5, r6, lr}
   45db6:	68c3      	ldr	r3, [r0, #12]
   45db8:	4605      	mov	r5, r0
   45dba:	2ba7      	cmp	r3, #167	; 0xa7
   45dbc:	d003      	beq.n	45dc6 <rpc_at_event_handler+0x12>
   45dbe:	6828      	ldr	r0, [r5, #0]
   45dc0:	f002 ffe2 	bl	48d88 <rpc_client_data_free>
   45dc4:	e008      	b.n	45dd8 <rpc_at_event_handler+0x24>
   45dc6:	2903      	cmp	r1, #3
   45dc8:	d008      	beq.n	45ddc <rpc_at_event_handler+0x28>
   45dca:	2904      	cmp	r1, #4
   45dcc:	d019      	beq.n	45e02 <rpc_at_event_handler+0x4e>
   45dce:	2902      	cmp	r1, #2
   45dd0:	d102      	bne.n	45dd8 <rpc_at_event_handler+0x24>
   45dd2:	2201      	movs	r2, #1
   45dd4:	4b0e      	ldr	r3, [pc, #56]	; (45e10 <rpc_at_event_handler+0x5c>)
   45dd6:	701a      	strb	r2, [r3, #0]
   45dd8:	2000      	movs	r0, #0
   45dda:	e00a      	b.n	45df2 <rpc_at_event_handler+0x3e>
   45ddc:	4e0d      	ldr	r6, [pc, #52]	; (45e14 <rpc_at_event_handler+0x60>)
   45dde:	6833      	ldr	r3, [r6, #0]
   45de0:	b143      	cbz	r3, 45df4 <rpc_at_event_handler+0x40>
   45de2:	2400      	movs	r4, #0
   45de4:	6800      	ldr	r0, [r0, #0]
   45de6:	4798      	blx	r3
   45de8:	6828      	ldr	r0, [r5, #0]
   45dea:	6034      	str	r4, [r6, #0]
   45dec:	f002 ffcc 	bl	48d88 <rpc_client_data_free>
   45df0:	b2e0      	uxtb	r0, r4
   45df2:	bd70      	pop	{r4, r5, r6, pc}
   45df4:	2202      	movs	r2, #2
   45df6:	4b08      	ldr	r3, [pc, #32]	; (45e18 <rpc_at_event_handler+0x64>)
   45df8:	2401      	movs	r4, #1
   45dfa:	6018      	str	r0, [r3, #0]
   45dfc:	4b04      	ldr	r3, [pc, #16]	; (45e10 <rpc_at_event_handler+0x5c>)
   45dfe:	701a      	strb	r2, [r3, #0]
   45e00:	e7f6      	b.n	45df0 <rpc_at_event_handler+0x3c>
   45e02:	4b06      	ldr	r3, [pc, #24]	; (45e1c <rpc_at_event_handler+0x68>)
   45e04:	681b      	ldr	r3, [r3, #0]
   45e06:	2b00      	cmp	r3, #0
   45e08:	d0d9      	beq.n	45dbe <rpc_at_event_handler+0xa>
   45e0a:	6800      	ldr	r0, [r0, #0]
   45e0c:	4798      	blx	r3
   45e0e:	e7d6      	b.n	45dbe <rpc_at_event_handler+0xa>
   45e10:	2001ec20 	.word	0x2001ec20
   45e14:	2001adac 	.word	0x2001adac
   45e18:	2001ada8 	.word	0x2001ada8
   45e1c:	2001ada4 	.word	0x2001ada4

00045e20 <rpc_dfu_event_handler>:
   45e20:	b510      	push	{r4, lr}
   45e22:	4604      	mov	r4, r0
   45e24:	6800      	ldr	r0, [r0, #0]
   45e26:	b108      	cbz	r0, 45e2c <rpc_dfu_event_handler+0xc>
   45e28:	f002 ffae 	bl	48d88 <rpc_client_data_free>
   45e2c:	4b05      	ldr	r3, [pc, #20]	; (45e44 <rpc_dfu_event_handler+0x24>)
   45e2e:	68e2      	ldr	r2, [r4, #12]
   45e30:	429a      	cmp	r2, r3
   45e32:	bf05      	ittet	eq
   45e34:	2001      	moveq	r0, #1
   45e36:	4b04      	ldreq	r3, [pc, #16]	; (45e48 <rpc_dfu_event_handler+0x28>)
   45e38:	2000      	movne	r0, #0
   45e3a:	7018      	strbeq	r0, [r3, #0]
   45e3c:	bf04      	itt	eq
   45e3e:	4b03      	ldreq	r3, [pc, #12]	; (45e4c <rpc_dfu_event_handler+0x2c>)
   45e40:	601c      	streq	r4, [r3, #0]
   45e42:	bd10      	pop	{r4, pc}
   45e44:	15abe11a 	.word	0x15abe11a
   45e48:	2001ec21 	.word	0x2001ec21
   45e4c:	2001adb0 	.word	0x2001adb0

00045e50 <rpc_gnss_event_handler>:
   45e50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   45e54:	6804      	ldr	r4, [r0, #0]
   45e56:	4607      	mov	r7, r0
   45e58:	460d      	mov	r5, r1
   45e5a:	2c00      	cmp	r4, #0
   45e5c:	f000 8086 	beq.w	45f6c <rpc_gnss_event_handler+0x11c>
   45e60:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   45e64:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   45e68:	d142      	bne.n	45ef0 <rpc_gnss_event_handler+0xa0>
   45e6a:	4b5f      	ldr	r3, [pc, #380]	; (45fe8 <rpc_gnss_event_handler+0x198>)
   45e6c:	781a      	ldrb	r2, [r3, #0]
   45e6e:	4698      	mov	r8, r3
   45e70:	2a01      	cmp	r2, #1
   45e72:	d131      	bne.n	45ed8 <rpc_gnss_event_handler+0x88>
   45e74:	4a5d      	ldr	r2, [pc, #372]	; (45fec <rpc_gnss_event_handler+0x19c>)
   45e76:	6821      	ldr	r1, [r4, #0]
   45e78:	8812      	ldrh	r2, [r2, #0]
   45e7a:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   45e7e:	d12b      	bne.n	45ed8 <rpc_gnss_event_handler+0x88>
   45e80:	6862      	ldr	r2, [r4, #4]
   45e82:	bb6a      	cbnz	r2, 45ee0 <rpc_gnss_event_handler+0x90>
   45e84:	4b5a      	ldr	r3, [pc, #360]	; (45ff0 <rpc_gnss_event_handler+0x1a0>)
   45e86:	681e      	ldr	r6, [r3, #0]
   45e88:	b31e      	cbz	r6, 45ed2 <rpc_gnss_event_handler+0x82>
   45e8a:	f242 0309 	movw	r3, #8201	; 0x2009
   45e8e:	429d      	cmp	r5, r3
   45e90:	d11f      	bne.n	45ed2 <rpc_gnss_event_handler+0x82>
   45e92:	4630      	mov	r0, r6
   45e94:	8923      	ldrh	r3, [r4, #8]
   45e96:	2280      	movs	r2, #128	; 0x80
   45e98:	f840 3b04 	str.w	r3, [r0], #4
   45e9c:	f104 010a 	add.w	r1, r4, #10
   45ea0:	f002 fd41 	bl	48926 <memcpy>
   45ea4:	2280      	movs	r2, #128	; 0x80
   45ea6:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   45eaa:	f106 0084 	add.w	r0, r6, #132	; 0x84
   45eae:	f002 fd3a 	bl	48926 <memcpy>
   45eb2:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   45eb6:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   45eba:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   45ebe:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   45ec2:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   45ec6:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   45eca:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   45ece:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   45ed2:	2300      	movs	r3, #0
   45ed4:	f888 3000 	strb.w	r3, [r8]
   45ed8:	6838      	ldr	r0, [r7, #0]
   45eda:	f002 ff55 	bl	48d88 <rpc_client_data_free>
   45ede:	e045      	b.n	45f6c <rpc_gnss_event_handler+0x11c>
   45ee0:	f647 71ff 	movw	r1, #32767	; 0x7fff
   45ee4:	428a      	cmp	r2, r1
   45ee6:	bf0c      	ite	eq
   45ee8:	2203      	moveq	r2, #3
   45eea:	2202      	movne	r2, #2
   45eec:	701a      	strb	r2, [r3, #0]
   45eee:	e7f3      	b.n	45ed8 <rpc_gnss_event_handler+0x88>
   45ef0:	4e40      	ldr	r6, [pc, #256]	; (45ff4 <rpc_gnss_event_handler+0x1a4>)
   45ef2:	6833      	ldr	r3, [r6, #0]
   45ef4:	2b00      	cmp	r3, #0
   45ef6:	d0ef      	beq.n	45ed8 <rpc_gnss_event_handler+0x88>
   45ef8:	f244 0204 	movw	r2, #16388	; 0x4004
   45efc:	4291      	cmp	r1, r2
   45efe:	d80b      	bhi.n	45f18 <rpc_gnss_event_handler+0xc8>
   45f00:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   45f04:	d9e8      	bls.n	45ed8 <rpc_gnss_event_handler+0x88>
   45f06:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   45f0a:	3a02      	subs	r2, #2
   45f0c:	2a02      	cmp	r2, #2
   45f0e:	d80b      	bhi.n	45f28 <rpc_gnss_event_handler+0xd8>
   45f10:	e8df f002 	tbb	[pc, r2]
   45f14:	4f45      	.short	0x4f45
   45f16:	59          	.byte	0x59
   45f17:	00          	.byte	0x00
   45f18:	f244 1301 	movw	r3, #16641	; 0x4101
   45f1c:	4299      	cmp	r1, r3
   45f1e:	d003      	beq.n	45f28 <rpc_gnss_event_handler+0xd8>
   45f20:	f244 2301 	movw	r3, #16897	; 0x4201
   45f24:	4299      	cmp	r1, r3
   45f26:	d1d7      	bne.n	45ed8 <rpc_gnss_event_handler+0x88>
   45f28:	4f33      	ldr	r7, [pc, #204]	; (45ff8 <rpc_gnss_event_handler+0x1a8>)
   45f2a:	6838      	ldr	r0, [r7, #0]
   45f2c:	b108      	cbz	r0, 45f32 <rpc_gnss_event_handler+0xe2>
   45f2e:	f002 ff2b 	bl	48d88 <rpc_client_data_free>
   45f32:	f244 2301 	movw	r3, #16897	; 0x4201
   45f36:	429d      	cmp	r5, r3
   45f38:	4b30      	ldr	r3, [pc, #192]	; (45ffc <rpc_gnss_event_handler+0x1ac>)
   45f3a:	d11a      	bne.n	45f72 <rpc_gnss_event_handler+0x122>
   45f3c:	2202      	movs	r2, #2
   45f3e:	603c      	str	r4, [r7, #0]
   45f40:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   45f44:	701a      	strb	r2, [r3, #0]
   45f46:	07e3      	lsls	r3, r4, #31
   45f48:	d502      	bpl.n	45f50 <rpc_gnss_event_handler+0x100>
   45f4a:	2002      	movs	r0, #2
   45f4c:	6833      	ldr	r3, [r6, #0]
   45f4e:	4798      	blx	r3
   45f50:	4d2b      	ldr	r5, [pc, #172]	; (46000 <rpc_gnss_event_handler+0x1b0>)
   45f52:	f014 0418 	ands.w	r4, r4, #24
   45f56:	6833      	ldr	r3, [r6, #0]
   45f58:	782a      	ldrb	r2, [r5, #0]
   45f5a:	d01a      	beq.n	45f92 <rpc_gnss_event_handler+0x142>
   45f5c:	b91a      	cbnz	r2, 45f66 <rpc_gnss_event_handler+0x116>
   45f5e:	2005      	movs	r0, #5
   45f60:	4798      	blx	r3
   45f62:	2301      	movs	r3, #1
   45f64:	702b      	strb	r3, [r5, #0]
   45f66:	2001      	movs	r0, #1
   45f68:	6833      	ldr	r3, [r6, #0]
   45f6a:	4798      	blx	r3
   45f6c:	2000      	movs	r0, #0
   45f6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   45f72:	f244 1201 	movw	r2, #16641	; 0x4101
   45f76:	4295      	cmp	r5, r2
   45f78:	bf0b      	itete	eq
   45f7a:	2201      	moveq	r2, #1
   45f7c:	2200      	movne	r2, #0
   45f7e:	603c      	streq	r4, [r7, #0]
   45f80:	603c      	strne	r4, [r7, #0]
   45f82:	bf0b      	itete	eq
   45f84:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   45f88:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   45f8c:	701a      	strbeq	r2, [r3, #0]
   45f8e:	701a      	strbne	r2, [r3, #0]
   45f90:	e7d9      	b.n	45f46 <rpc_gnss_event_handler+0xf6>
   45f92:	2a00      	cmp	r2, #0
   45f94:	d0e7      	beq.n	45f66 <rpc_gnss_event_handler+0x116>
   45f96:	2006      	movs	r0, #6
   45f98:	4798      	blx	r3
   45f9a:	702c      	strb	r4, [r5, #0]
   45f9c:	e7e3      	b.n	45f66 <rpc_gnss_event_handler+0x116>
   45f9e:	4c19      	ldr	r4, [pc, #100]	; (46004 <rpc_gnss_event_handler+0x1b4>)
   45fa0:	6820      	ldr	r0, [r4, #0]
   45fa2:	b108      	cbz	r0, 45fa8 <rpc_gnss_event_handler+0x158>
   45fa4:	f002 fef0 	bl	48d88 <rpc_client_data_free>
   45fa8:	683b      	ldr	r3, [r7, #0]
   45faa:	2003      	movs	r0, #3
   45fac:	6023      	str	r3, [r4, #0]
   45fae:	6833      	ldr	r3, [r6, #0]
   45fb0:	e7db      	b.n	45f6a <rpc_gnss_event_handler+0x11a>
   45fb2:	4c15      	ldr	r4, [pc, #84]	; (46008 <rpc_gnss_event_handler+0x1b8>)
   45fb4:	6820      	ldr	r0, [r4, #0]
   45fb6:	b108      	cbz	r0, 45fbc <rpc_gnss_event_handler+0x16c>
   45fb8:	f002 fee6 	bl	48d88 <rpc_client_data_free>
   45fbc:	683b      	ldr	r3, [r7, #0]
   45fbe:	2004      	movs	r0, #4
   45fc0:	6023      	str	r3, [r4, #0]
   45fc2:	6833      	ldr	r3, [r6, #0]
   45fc4:	e7d1      	b.n	45f6a <rpc_gnss_event_handler+0x11a>
   45fc6:	7822      	ldrb	r2, [r4, #0]
   45fc8:	2a03      	cmp	r2, #3
   45fca:	d885      	bhi.n	45ed8 <rpc_gnss_event_handler+0x88>
   45fcc:	e8df f002 	tbb	[pc, r2]
   45fd0:	09070502 	.word	0x09070502
   45fd4:	2007      	movs	r0, #7
   45fd6:	4798      	blx	r3
   45fd8:	e77e      	b.n	45ed8 <rpc_gnss_event_handler+0x88>
   45fda:	2008      	movs	r0, #8
   45fdc:	e7fb      	b.n	45fd6 <rpc_gnss_event_handler+0x186>
   45fde:	2009      	movs	r0, #9
   45fe0:	e7f9      	b.n	45fd6 <rpc_gnss_event_handler+0x186>
   45fe2:	200a      	movs	r0, #10
   45fe4:	e7f7      	b.n	45fd6 <rpc_gnss_event_handler+0x186>
   45fe6:	bf00      	nop
   45fe8:	2001ec24 	.word	0x2001ec24
   45fec:	2001ae2c 	.word	0x2001ae2c
   45ff0:	2001adc4 	.word	0x2001adc4
   45ff4:	2001adb4 	.word	0x2001adb4
   45ff8:	2001adb8 	.word	0x2001adb8
   45ffc:	2001ec23 	.word	0x2001ec23
   46000:	2001ec22 	.word	0x2001ec22
   46004:	2001adc0 	.word	0x2001adc0
   46008:	2001adbc 	.word	0x2001adbc

0004600c <full_dfu_ipc_irq_handler>:
   4600c:	2301      	movs	r3, #1
   4600e:	4a03      	ldr	r2, [pc, #12]	; (4601c <full_dfu_ipc_irq_handler+0x10>)
   46010:	6013      	str	r3, [r2, #0]
   46012:	07c2      	lsls	r2, r0, #31
   46014:	bf44      	itt	mi
   46016:	4a02      	ldrmi	r2, [pc, #8]	; (46020 <full_dfu_ipc_irq_handler+0x14>)
   46018:	7013      	strbmi	r3, [r2, #0]
   4601a:	4770      	bx	lr
   4601c:	2001adc8 	.word	0x2001adc8
   46020:	2001ec25 	.word	0x2001ec25

00046024 <modem_ipc_wait_for_event>:
   46024:	b538      	push	{r3, r4, r5, lr}
   46026:	2300      	movs	r3, #0
   46028:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   4602c:	4c0b      	ldr	r4, [pc, #44]	; (4605c <modem_ipc_wait_for_event+0x38>)
   4602e:	6023      	str	r3, [r4, #0]
   46030:	6823      	ldr	r3, [r4, #0]
   46032:	b92b      	cbnz	r3, 46040 <modem_ipc_wait_for_event+0x1c>
   46034:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   46038:	f002 fdfc 	bl	48c34 <nrf_modem_os_busywait>
   4603c:	3d01      	subs	r5, #1
   4603e:	d1f7      	bne.n	46030 <modem_ipc_wait_for_event+0xc>
   46040:	6823      	ldr	r3, [r4, #0]
   46042:	b913      	cbnz	r3, 4604a <modem_ipc_wait_for_event+0x26>
   46044:	f06f 0073 	mvn.w	r0, #115	; 0x73
   46048:	e006      	b.n	46058 <modem_ipc_wait_for_event+0x34>
   4604a:	4b05      	ldr	r3, [pc, #20]	; (46060 <modem_ipc_wait_for_event+0x3c>)
   4604c:	781b      	ldrb	r3, [r3, #0]
   4604e:	2b01      	cmp	r3, #1
   46050:	bf14      	ite	ne
   46052:	2000      	movne	r0, #0
   46054:	f06f 0004 	mvneq.w	r0, #4
   46058:	bd38      	pop	{r3, r4, r5, pc}
   4605a:	bf00      	nop
   4605c:	2001adc8 	.word	0x2001adc8
   46060:	2001ec25 	.word	0x2001ec25

00046064 <nrf_modem_full_dfu_setup>:
   46064:	2200      	movs	r2, #0
   46066:	2300      	movs	r3, #0
   46068:	b5f0      	push	{r4, r5, r6, r7, lr}
   4606a:	4d2b      	ldr	r5, [pc, #172]	; (46118 <nrf_modem_full_dfu_setup+0xb4>)
   4606c:	4e2b      	ldr	r6, [pc, #172]	; (4611c <nrf_modem_full_dfu_setup+0xb8>)
   4606e:	e9c5 2302 	strd	r2, r3, [r5, #8]
   46072:	e9c5 2304 	strd	r2, r3, [r5, #16]
   46076:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   4607a:	4b29      	ldr	r3, [pc, #164]	; (46120 <nrf_modem_full_dfu_setup+0xbc>)
   4607c:	2400      	movs	r4, #0
   4607e:	601a      	str	r2, [r3, #0]
   46080:	f100 031c 	add.w	r3, r0, #28
   46084:	6033      	str	r3, [r6, #0]
   46086:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   4608a:	6043      	str	r3, [r0, #4]
   4608c:	231c      	movs	r3, #28
   4608e:	7203      	strb	r3, [r0, #8]
   46090:	2320      	movs	r3, #32
   46092:	2701      	movs	r7, #1
   46094:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   46098:	7243      	strb	r3, [r0, #9]
   4609a:	4b22      	ldr	r3, [pc, #136]	; (46124 <nrf_modem_full_dfu_setup+0xc0>)
   4609c:	7004      	strb	r4, [r0, #0]
   4609e:	7044      	strb	r4, [r0, #1]
   460a0:	70c2      	strb	r2, [r0, #3]
   460a2:	7284      	strb	r4, [r0, #10]
   460a4:	72c4      	strb	r4, [r0, #11]
   460a6:	7087      	strb	r7, [r0, #2]
   460a8:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   460ac:	702c      	strb	r4, [r5, #0]
   460ae:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   460b2:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   460b6:	4b1c      	ldr	r3, [pc, #112]	; (46128 <nrf_modem_full_dfu_setup+0xc4>)
   460b8:	b093      	sub	sp, #76	; 0x4c
   460ba:	4622      	mov	r2, r4
   460bc:	4620      	mov	r0, r4
   460be:	491b      	ldr	r1, [pc, #108]	; (4612c <nrf_modem_full_dfu_setup+0xc8>)
   460c0:	701c      	strb	r4, [r3, #0]
   460c2:	f7fe fce5 	bl	44a90 <nrfx_ipc_init>
   460c6:	4621      	mov	r1, r4
   460c8:	2240      	movs	r2, #64	; 0x40
   460ca:	a801      	add	r0, sp, #4
   460cc:	f002 fc36 	bl	4893c <memset>
   460d0:	2302      	movs	r3, #2
   460d2:	9302      	str	r3, [sp, #8]
   460d4:	2304      	movs	r3, #4
   460d6:	930b      	str	r3, [sp, #44]	; 0x2c
   460d8:	2305      	movs	r3, #5
   460da:	a801      	add	r0, sp, #4
   460dc:	9311      	str	r3, [sp, #68]	; 0x44
   460de:	9709      	str	r7, [sp, #36]	; 0x24
   460e0:	f7fe fcee 	bl	44ac0 <nrfx_ipc_config_load>
   460e4:	4b12      	ldr	r3, [pc, #72]	; (46130 <nrf_modem_full_dfu_setup+0xcc>)
   460e6:	9400      	str	r4, [sp, #0]
   460e8:	6836      	ldr	r6, [r6, #0]
   460ea:	601c      	str	r4, [r3, #0]
   460ec:	681b      	ldr	r3, [r3, #0]
   460ee:	9300      	str	r3, [sp, #0]
   460f0:	9b00      	ldr	r3, [sp, #0]
   460f2:	f7ff ff97 	bl	46024 <modem_ipc_wait_for_event>
   460f6:	4604      	mov	r4, r0
   460f8:	b130      	cbz	r0, 46108 <nrf_modem_full_dfu_setup+0xa4>
   460fa:	2303      	movs	r3, #3
   460fc:	702b      	strb	r3, [r5, #0]
   460fe:	f7fe fcff 	bl	44b00 <nrfx_ipc_uninit>
   46102:	4620      	mov	r0, r4
   46104:	b013      	add	sp, #76	; 0x4c
   46106:	bdf0      	pop	{r4, r5, r6, r7, pc}
   46108:	6832      	ldr	r2, [r6, #0]
   4610a:	4b0a      	ldr	r3, [pc, #40]	; (46134 <nrf_modem_full_dfu_setup+0xd0>)
   4610c:	429a      	cmp	r2, r3
   4610e:	d0f8      	beq.n	46102 <nrf_modem_full_dfu_setup+0x9e>
   46110:	f06f 0404 	mvn.w	r4, #4
   46114:	e7f3      	b.n	460fe <nrf_modem_full_dfu_setup+0x9a>
   46116:	bf00      	nop
   46118:	2001a7a8 	.word	0x2001a7a8
   4611c:	2001adcc 	.word	0x2001adcc
   46120:	2001add0 	.word	0x2001add0
   46124:	4002a000 	.word	0x4002a000
   46128:	2001ec25 	.word	0x2001ec25
   4612c:	0004600d 	.word	0x0004600d
   46130:	40005610 	.word	0x40005610
   46134:	a5000001 	.word	0xa5000001

00046138 <modem_off>:
   46138:	b537      	push	{r0, r1, r2, r4, r5, lr}
   4613a:	2501      	movs	r5, #1
   4613c:	4c07      	ldr	r4, [pc, #28]	; (4615c <modem_off+0x24>)
   4613e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   46142:	6065      	str	r5, [r4, #4]
   46144:	f002 fd76 	bl	48c34 <nrf_modem_os_busywait>
   46148:	2300      	movs	r3, #0
   4614a:	6063      	str	r3, [r4, #4]
   4614c:	9301      	str	r3, [sp, #4]
   4614e:	6025      	str	r5, [r4, #0]
   46150:	6823      	ldr	r3, [r4, #0]
   46152:	9301      	str	r3, [sp, #4]
   46154:	9b01      	ldr	r3, [sp, #4]
   46156:	b003      	add	sp, #12
   46158:	bd30      	pop	{r4, r5, pc}
   4615a:	bf00      	nop
   4615c:	40005610 	.word	0x40005610

00046160 <nrf_modem_init>:
   46160:	b570      	push	{r4, r5, r6, lr}
   46162:	460d      	mov	r5, r1
   46164:	b300      	cbz	r0, 461a8 <nrf_modem_init+0x48>
   46166:	4e15      	ldr	r6, [pc, #84]	; (461bc <nrf_modem_init+0x5c>)
   46168:	7832      	ldrb	r2, [r6, #0]
   4616a:	bb02      	cbnz	r2, 461ae <nrf_modem_init+0x4e>
   4616c:	2901      	cmp	r1, #1
   4616e:	d113      	bne.n	46198 <nrf_modem_init+0x38>
   46170:	68c1      	ldr	r1, [r0, #12]
   46172:	6842      	ldr	r2, [r0, #4]
   46174:	440a      	add	r2, r1
   46176:	6941      	ldr	r1, [r0, #20]
   46178:	440a      	add	r2, r1
   4617a:	69c1      	ldr	r1, [r0, #28]
   4617c:	440a      	add	r2, r1
   4617e:	f242 011b 	movw	r1, #8219	; 0x201b
   46182:	428a      	cmp	r2, r1
   46184:	d916      	bls.n	461b4 <nrf_modem_init+0x54>
   46186:	6800      	ldr	r0, [r0, #0]
   46188:	f7ff ff6c 	bl	46064 <nrf_modem_full_dfu_setup>
   4618c:	4604      	mov	r4, r0
   4618e:	b130      	cbz	r0, 4619e <nrf_modem_init+0x3e>
   46190:	f7ff ffd2 	bl	46138 <modem_off>
   46194:	4620      	mov	r0, r4
   46196:	bd70      	pop	{r4, r5, r6, pc}
   46198:	f002 fe5a 	bl	48e50 <nrf_modem_platform_init>
   4619c:	e7f6      	b.n	4618c <nrf_modem_init+0x2c>
   4619e:	4b08      	ldr	r3, [pc, #32]	; (461c0 <nrf_modem_init+0x60>)
   461a0:	701d      	strb	r5, [r3, #0]
   461a2:	2301      	movs	r3, #1
   461a4:	7033      	strb	r3, [r6, #0]
   461a6:	e7f5      	b.n	46194 <nrf_modem_init+0x34>
   461a8:	f06f 040d 	mvn.w	r4, #13
   461ac:	e7f2      	b.n	46194 <nrf_modem_init+0x34>
   461ae:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   461b2:	e7ef      	b.n	46194 <nrf_modem_init+0x34>
   461b4:	f06f 040b 	mvn.w	r4, #11
   461b8:	e7ec      	b.n	46194 <nrf_modem_init+0x34>
   461ba:	bf00      	nop
   461bc:	2001ec26 	.word	0x2001ec26
   461c0:	2001ec27 	.word	0x2001ec27

000461c4 <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
   461c4:	4b02      	ldr	r3, [pc, #8]	; (461d0 <mbedtls_platform_set_calloc_free+0xc>)
   461c6:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
   461c8:	4b02      	ldr	r3, [pc, #8]	; (461d4 <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
   461ca:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
   461cc:	6019      	str	r1, [r3, #0]
}
   461ce:	4770      	bx	lr
   461d0:	2001a5e4 	.word	0x2001a5e4
   461d4:	2001a5e8 	.word	0x2001a5e8

000461d8 <_heap_init>:
 *
 * Not static in order to allow extern use.
 */
void _heap_init(void)
{
	mbedtls_memory_buffer_alloc_init(mbedtls_heap, sizeof(mbedtls_heap));
   461d8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   461dc:	4801      	ldr	r0, [pc, #4]	; (461e4 <_heap_init+0xc>)
   461de:	f000 b947 	b.w	46470 <mbedtls_memory_buffer_alloc_init>
   461e2:	bf00      	nop
   461e4:	2001ec28 	.word	0x2001ec28

000461e8 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
   461e8:	6801      	ldr	r1, [r0, #0]
   461ea:	4a0e      	ldr	r2, [pc, #56]	; (46224 <verify_header+0x3c>)
{
   461ec:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
   461ee:	4291      	cmp	r1, r2
   461f0:	d115      	bne.n	4621e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
   461f2:	69c1      	ldr	r1, [r0, #28]
   461f4:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
   461f8:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
   461fc:	4291      	cmp	r1, r2
   461fe:	d10e      	bne.n	4621e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
   46200:	6882      	ldr	r2, [r0, #8]
   46202:	2a01      	cmp	r2, #1
   46204:	d80b      	bhi.n	4621e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
   46206:	68c2      	ldr	r2, [r0, #12]
   46208:	b112      	cbz	r2, 46210 <verify_header+0x28>
   4620a:	6901      	ldr	r1, [r0, #16]
   4620c:	428a      	cmp	r2, r1
   4620e:	d006      	beq.n	4621e <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
   46210:	6958      	ldr	r0, [r3, #20]
   46212:	b128      	cbz	r0, 46220 <verify_header+0x38>
   46214:	699b      	ldr	r3, [r3, #24]
   46216:	1a1b      	subs	r3, r3, r0
   46218:	4258      	negs	r0, r3
   4621a:	4158      	adcs	r0, r3
   4621c:	4770      	bx	lr
        return( 1 );
   4621e:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
   46220:	4770      	bx	lr
   46222:	bf00      	nop
   46224:	ff00aa55 	.word	0xff00aa55

00046228 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
   46228:	4b0d      	ldr	r3, [pc, #52]	; (46260 <verify_chain+0x38>)
{
   4622a:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
   4622c:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
   4622e:	b1a6      	cbz	r6, 4625a <verify_chain+0x32>
   46230:	4630      	mov	r0, r6
   46232:	f7ff ffd9 	bl	461e8 <verify_header>
   46236:	4604      	mov	r4, r0
   46238:	b978      	cbnz	r0, 4625a <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
   4623a:	68f3      	ldr	r3, [r6, #12]
   4623c:	b96b      	cbnz	r3, 4625a <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
   4623e:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
   46240:	b90d      	cbnz	r5, 46246 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
   46242:	4620      	mov	r0, r4
   46244:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
   46246:	4628      	mov	r0, r5
   46248:	f7ff ffce 	bl	461e8 <verify_header>
   4624c:	b928      	cbnz	r0, 4625a <verify_chain+0x32>
        if( cur->prev != prv )
   4624e:	68eb      	ldr	r3, [r5, #12]
   46250:	42b3      	cmp	r3, r6
   46252:	d102      	bne.n	4625a <verify_chain+0x32>
        cur = cur->next;
   46254:	462e      	mov	r6, r5
   46256:	692d      	ldr	r5, [r5, #16]
   46258:	e7f2      	b.n	46240 <verify_chain+0x18>
        return( 1 );
   4625a:	2401      	movs	r4, #1
   4625c:	e7f1      	b.n	46242 <verify_chain+0x1a>
   4625e:	bf00      	nop
   46260:	2001add4 	.word	0x2001add4

00046264 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
   46264:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
   46268:	4d3e      	ldr	r5, [pc, #248]	; (46364 <buffer_alloc_calloc+0x100>)
   4626a:	682c      	ldr	r4, [r5, #0]
   4626c:	b1d4      	cbz	r4, 462a4 <buffer_alloc_calloc+0x40>
   4626e:	68ac      	ldr	r4, [r5, #8]
   46270:	b1c4      	cbz	r4, 462a4 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
   46272:	2800      	cmp	r0, #0
   46274:	d04b      	beq.n	4630e <buffer_alloc_calloc+0xaa>
   46276:	2900      	cmp	r1, #0
   46278:	d049      	beq.n	4630e <buffer_alloc_calloc+0xaa>
    original_len = len = n * size;
   4627a:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
   4627e:	fbb6 f0f0 	udiv	r0, r6, r0
   46282:	4288      	cmp	r0, r1
   46284:	d143      	bne.n	4630e <buffer_alloc_calloc+0xaa>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   46286:	1d30      	adds	r0, r6, #4
   46288:	d841      	bhi.n	4630e <buffer_alloc_calloc+0xaa>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   4628a:	07b1      	lsls	r1, r6, #30
   4628c:	d00d      	beq.n	462aa <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   4628e:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   46292:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
   46294:	68ec      	ldr	r4, [r5, #12]
   46296:	e003      	b.n	462a0 <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
   46298:	6863      	ldr	r3, [r4, #4]
   4629a:	42bb      	cmp	r3, r7
   4629c:	d239      	bcs.n	46312 <buffer_alloc_calloc+0xae>
            break;

        cur = cur->next_free;
   4629e:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
   462a0:	2c00      	cmp	r4, #0
   462a2:	d1f9      	bne.n	46298 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
   462a4:	4620      	mov	r0, r4
   462a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   462aa:	4637      	mov	r7, r6
   462ac:	e7f2      	b.n	46294 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
   462ae:	60e8      	str	r0, [r5, #12]
   462b0:	e041      	b.n	46336 <buffer_alloc_calloc+0xd2>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
   462b2:	f107 0c20 	add.w	ip, r7, #32
   462b6:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
   462ba:	3920      	subs	r1, #32
   462bc:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
   462be:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
   462c0:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 46368 <buffer_alloc_calloc+0x104>
    new->prev = cur;
   462c4:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
   462c8:	6921      	ldr	r1, [r4, #16]
   462ca:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
   462cc:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
   462d0:	f8df c098 	ldr.w	ip, [pc, #152]	; 4636c <buffer_alloc_calloc+0x108>
   462d4:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
   462d8:	b101      	cbz	r1, 462dc <buffer_alloc_calloc+0x78>
        new->next->prev = new;
   462da:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
   462dc:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
   462e0:	b19a      	cbz	r2, 4630a <buffer_alloc_calloc+0xa6>
        new->prev_free->next_free = new;
   462e2:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
   462e4:	699a      	ldr	r2, [r3, #24]
   462e6:	b102      	cbz	r2, 462ea <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
   462e8:	6153      	str	r3, [r2, #20]
    cur->next = new;
   462ea:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
   462ec:	2300      	movs	r3, #0
    cur->alloc = 1;
   462ee:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
   462f2:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   462f6:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
   462f8:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   462fc:	07db      	lsls	r3, r3, #31
   462fe:	d529      	bpl.n	46354 <buffer_alloc_calloc+0xf0>
   46300:	f7ff ff92 	bl	46228 <verify_chain>
   46304:	b330      	cbz	r0, 46354 <buffer_alloc_calloc+0xf0>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
void _exit(int status);
static inline void exit(int status)
{
	_exit(status);
   46306:	4648      	mov	r0, r9
   46308:	e022      	b.n	46350 <buffer_alloc_calloc+0xec>
        heap.first_free = new;
   4630a:	60eb      	str	r3, [r5, #12]
   4630c:	e7ea      	b.n	462e4 <buffer_alloc_calloc+0x80>
        return( NULL );
   4630e:	2400      	movs	r4, #0
   46310:	e7c8      	b.n	462a4 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
   46312:	68a3      	ldr	r3, [r4, #8]
   46314:	b113      	cbz	r3, 4631c <buffer_alloc_calloc+0xb8>
   46316:	2001      	movs	r0, #1
   46318:	f7fc fe40 	bl	42f9c <_exit>
    if( cur->size - len < sizeof(memory_header) +
   4631c:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
   46320:	6861      	ldr	r1, [r4, #4]
   46322:	f104 0820 	add.w	r8, r4, #32
   46326:	1bc9      	subs	r1, r1, r7
   46328:	2923      	cmp	r1, #35	; 0x23
   4632a:	d8c2      	bhi.n	462b2 <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
   4632c:	2301      	movs	r3, #1
   4632e:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
   46330:	2a00      	cmp	r2, #0
   46332:	d0bc      	beq.n	462ae <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
   46334:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
   46336:	69a3      	ldr	r3, [r4, #24]
   46338:	b103      	cbz	r3, 4633c <buffer_alloc_calloc+0xd8>
            cur->next_free->prev_free = cur->prev_free;
   4633a:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
   4633c:	2300      	movs	r3, #0
        cur->next_free = NULL;
   4633e:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
   46342:	692b      	ldr	r3, [r5, #16]
   46344:	07da      	lsls	r2, r3, #31
   46346:	d505      	bpl.n	46354 <buffer_alloc_calloc+0xf0>
   46348:	f7ff ff6e 	bl	46228 <verify_chain>
   4634c:	b110      	cbz	r0, 46354 <buffer_alloc_calloc+0xf0>
   4634e:	2001      	movs	r0, #1
   46350:	f7fc fe24 	bl	42f9c <_exit>
    memset( ret, 0, original_len );
   46354:	4632      	mov	r2, r6
   46356:	2100      	movs	r1, #0
   46358:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
   4635a:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
   4635c:	f002 faee 	bl	4893c <memset>
    return( ret );
   46360:	e7a0      	b.n	462a4 <buffer_alloc_calloc+0x40>
   46362:	bf00      	nop
   46364:	2001add4 	.word	0x2001add4
   46368:	ff00aa55 	.word	0xff00aa55
   4636c:	ee119966 	.word	0xee119966

00046370 <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
   46370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
   46372:	4605      	mov	r5, r0
   46374:	2800      	cmp	r0, #0
   46376:	d078      	beq.n	4646a <buffer_alloc_free+0xfa>
   46378:	4e3c      	ldr	r6, [pc, #240]	; (4646c <buffer_alloc_free+0xfc>)
   4637a:	6833      	ldr	r3, [r6, #0]
   4637c:	2b00      	cmp	r3, #0
   4637e:	d074      	beq.n	4646a <buffer_alloc_free+0xfa>
   46380:	68b2      	ldr	r2, [r6, #8]
   46382:	2a00      	cmp	r2, #0
   46384:	d071      	beq.n	4646a <buffer_alloc_free+0xfa>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
   46386:	4283      	cmp	r3, r0
   46388:	d803      	bhi.n	46392 <buffer_alloc_free+0x22>
   4638a:	6872      	ldr	r2, [r6, #4]
   4638c:	4413      	add	r3, r2
   4638e:	4298      	cmp	r0, r3
   46390:	d302      	bcc.n	46398 <buffer_alloc_free+0x28>
   46392:	2001      	movs	r0, #1
   46394:	f7fc fe02 	bl	42f9c <_exit>
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
    }

    p -= sizeof(memory_header);
   46398:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
   4639c:	4620      	mov	r0, r4
   4639e:	f7ff ff23 	bl	461e8 <verify_header>
   463a2:	b110      	cbz	r0, 463aa <buffer_alloc_free+0x3a>
   463a4:	2001      	movs	r0, #1
   463a6:	f7fc fdf9 	bl	42f9c <_exit>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
   463aa:	f855 3c18 	ldr.w	r3, [r5, #-24]
   463ae:	2b01      	cmp	r3, #1
   463b0:	d002      	beq.n	463b8 <buffer_alloc_free+0x48>
   463b2:	2001      	movs	r0, #1
   463b4:	f7fc fdf2 	bl	42f9c <_exit>
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
    }

    hdr->alloc = 0;
   463b8:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   463ba:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
   463be:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
   463c2:	b1af      	cbz	r7, 463f0 <buffer_alloc_free+0x80>
   463c4:	68ba      	ldr	r2, [r7, #8]
   463c6:	b992      	cbnz	r2, 463ee <buffer_alloc_free+0x7e>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
   463c8:	f855 3c1c 	ldr.w	r3, [r5, #-28]
   463cc:	f103 0220 	add.w	r2, r3, #32
   463d0:	687b      	ldr	r3, [r7, #4]
   463d2:	4413      	add	r3, r2
   463d4:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
   463d6:	f855 3c10 	ldr.w	r3, [r5, #-16]
   463da:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
   463dc:	b103      	cbz	r3, 463e0 <buffer_alloc_free+0x70>
            hdr->next->prev = hdr;
   463de:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   463e0:	4620      	mov	r0, r4
   463e2:	2220      	movs	r2, #32
   463e4:	2100      	movs	r1, #0
   463e6:	f002 faa9 	bl	4893c <memset>
   463ea:	4623      	mov	r3, r4
   463ec:	463c      	mov	r4, r7
    memory_header *hdr, *old = NULL;
   463ee:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
   463f0:	6920      	ldr	r0, [r4, #16]
   463f2:	2800      	cmp	r0, #0
   463f4:	d031      	beq.n	4645a <buffer_alloc_free+0xea>
   463f6:	6883      	ldr	r3, [r0, #8]
   463f8:	2b00      	cmp	r3, #0
   463fa:	d12e      	bne.n	4645a <buffer_alloc_free+0xea>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
   463fc:	6863      	ldr	r3, [r4, #4]
   463fe:	6842      	ldr	r2, [r0, #4]
   46400:	3320      	adds	r3, #32
   46402:	4413      	add	r3, r2
   46404:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
   46406:	6903      	ldr	r3, [r0, #16]
   46408:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
   4640c:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
   4640e:	b9d2      	cbnz	r2, 46446 <buffer_alloc_free+0xd6>
   46410:	b9f9      	cbnz	r1, 46452 <buffer_alloc_free+0xe2>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
   46412:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
   46414:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
   46416:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
   46418:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
   4641a:	b1e2      	cbz	r2, 46456 <buffer_alloc_free+0xe6>
            hdr->prev_free->next_free = hdr;
   4641c:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
   4641e:	69a2      	ldr	r2, [r4, #24]
   46420:	b102      	cbz	r2, 46424 <buffer_alloc_free+0xb4>
            hdr->next_free->prev_free = hdr;
   46422:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
   46424:	b103      	cbz	r3, 46428 <buffer_alloc_free+0xb8>
            hdr->next->prev = hdr;
   46426:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
   46428:	2220      	movs	r2, #32
   4642a:	2100      	movs	r1, #0
   4642c:	f002 fa86 	bl	4893c <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
   46430:	6933      	ldr	r3, [r6, #16]
   46432:	079b      	lsls	r3, r3, #30
   46434:	d519      	bpl.n	4646a <buffer_alloc_free+0xfa>
   46436:	f7ff fef7 	bl	46228 <verify_chain>
   4643a:	b1b0      	cbz	r0, 4646a <buffer_alloc_free+0xfa>
        mbedtls_exit( 1 );
}
   4643c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   46440:	2001      	movs	r0, #1
   46442:	f7fc bdab 	b.w	42f9c <_exit>
                hdr->prev_free->next_free = hdr->next_free;
   46446:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
   46448:	69a1      	ldr	r1, [r4, #24]
   4644a:	2900      	cmp	r1, #0
   4644c:	d0e1      	beq.n	46412 <buffer_alloc_free+0xa2>
                hdr->next_free->prev_free = hdr->prev_free;
   4644e:	614a      	str	r2, [r1, #20]
   46450:	e7df      	b.n	46412 <buffer_alloc_free+0xa2>
                heap.first_free = hdr->next_free;
   46452:	60f1      	str	r1, [r6, #12]
   46454:	e7f8      	b.n	46448 <buffer_alloc_free+0xd8>
            heap.first_free = hdr;
   46456:	60f4      	str	r4, [r6, #12]
   46458:	e7e1      	b.n	4641e <buffer_alloc_free+0xae>
    if( old == NULL )
   4645a:	2f00      	cmp	r7, #0
   4645c:	d1e8      	bne.n	46430 <buffer_alloc_free+0xc0>
        hdr->next_free = heap.first_free;
   4645e:	68f3      	ldr	r3, [r6, #12]
   46460:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
   46462:	b103      	cbz	r3, 46466 <buffer_alloc_free+0xf6>
            heap.first_free->prev_free = hdr;
   46464:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
   46466:	60f4      	str	r4, [r6, #12]
   46468:	e7e2      	b.n	46430 <buffer_alloc_free+0xc0>
}
   4646a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   4646c:	2001add4 	.word	0x2001add4

00046470 <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
   46470:	b538      	push	{r3, r4, r5, lr}
   46472:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   46474:	2214      	movs	r2, #20
   46476:	2100      	movs	r1, #0
{
   46478:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
   4647a:	4812      	ldr	r0, [pc, #72]	; (464c4 <mbedtls_memory_buffer_alloc_init+0x54>)
   4647c:	f002 fa5e 	bl	4893c <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
   46480:	4911      	ldr	r1, [pc, #68]	; (464c8 <mbedtls_memory_buffer_alloc_init+0x58>)
   46482:	4812      	ldr	r0, [pc, #72]	; (464cc <mbedtls_memory_buffer_alloc_init+0x5c>)
   46484:	f7ff fe9e 	bl	461c4 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   46488:	2d23      	cmp	r5, #35	; 0x23
   4648a:	d91a      	bls.n	464c2 <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
   4648c:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
   46490:	bf1f      	itttt	ne
   46492:	3d04      	subne	r5, #4
   46494:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
   46496:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
   4649a:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
   4649c:	462a      	mov	r2, r5
   4649e:	2100      	movs	r1, #0
   464a0:	4620      	mov	r0, r4
   464a2:	f002 fa4b 	bl	4893c <memset>

    heap.buf = buf;
   464a6:	4b07      	ldr	r3, [pc, #28]	; (464c4 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
   464a8:	4a09      	ldr	r2, [pc, #36]	; (464d0 <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
   464aa:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
   464ae:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
   464b0:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
   464b2:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
   464b6:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
   464b8:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
   464bc:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
   464be:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
   464c0:	60dc      	str	r4, [r3, #12]
}
   464c2:	bd38      	pop	{r3, r4, r5, pc}
   464c4:	2001add4 	.word	0x2001add4
   464c8:	00046371 	.word	0x00046371
   464cc:	00046265 	.word	0x00046265
   464d0:	ff00aa55 	.word	0xff00aa55

000464d4 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   464d4:	4b0e      	ldr	r3, [pc, #56]	; (46510 <z_sys_init_run_level+0x3c>)
{
   464d6:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   464d8:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   464dc:	3001      	adds	r0, #1
   464de:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   464e2:	42a6      	cmp	r6, r4
   464e4:	d800      	bhi.n	464e8 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   464e6:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   464e8:	e9d4 3500 	ldrd	r3, r5, [r4]
   464ec:	4628      	mov	r0, r5
   464ee:	4798      	blx	r3
		if (dev != NULL) {
   464f0:	b165      	cbz	r5, 4650c <z_sys_init_run_level+0x38>
			if (rc != 0) {
   464f2:	68eb      	ldr	r3, [r5, #12]
   464f4:	b130      	cbz	r0, 46504 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   464f6:	2800      	cmp	r0, #0
   464f8:	bfb8      	it	lt
   464fa:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   464fc:	28ff      	cmp	r0, #255	; 0xff
   464fe:	bfa8      	it	ge
   46500:	20ff      	movge	r0, #255	; 0xff
   46502:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   46504:	785a      	ldrb	r2, [r3, #1]
   46506:	f042 0201 	orr.w	r2, r2, #1
   4650a:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   4650c:	3408      	adds	r4, #8
   4650e:	e7e8      	b.n	464e2 <z_sys_init_run_level+0xe>
   46510:	0004990c 	.word	0x0004990c

00046514 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   46514:	4b01      	ldr	r3, [pc, #4]	; (4651c <z_impl_z_errno+0x8>)
   46516:	6898      	ldr	r0, [r3, #8]
}
   46518:	3060      	adds	r0, #96	; 0x60
   4651a:	4770      	bx	lr
   4651c:	2001ade8 	.word	0x2001ade8

00046520 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   46520:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   46524:	4606      	mov	r6, r0
   46526:	460f      	mov	r7, r1
	__asm__ volatile(
   46528:	f04f 0320 	mov.w	r3, #32
   4652c:	f3ef 8811 	mrs	r8, BASEPRI
   46530:	f383 8812 	msr	BASEPRI_MAX, r3
   46534:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   46538:	f000 fe32 	bl	471a0 <z_impl_z_current_get>
   4653c:	4c21      	ldr	r4, [pc, #132]	; (465c4 <z_fatal_error+0xa4>)
   4653e:	4b22      	ldr	r3, [pc, #136]	; (465c8 <z_fatal_error+0xa8>)
   46540:	2e04      	cmp	r6, #4
   46542:	eba4 0403 	sub.w	r4, r4, r3
   46546:	ea4f 04d4 	mov.w	r4, r4, lsr #3
   4654a:	bf98      	it	ls
   4654c:	4a1f      	ldrls	r2, [pc, #124]	; (465cc <z_fatal_error+0xac>)
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4654e:	ea4f 1484 	mov.w	r4, r4, lsl #6
   46552:	f044 0301 	orr.w	r3, r4, #1
   46556:	4605      	mov	r5, r0
	switch (reason) {
   46558:	bf94      	ite	ls
   4655a:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   4655e:	4a1c      	ldrhi	r2, [pc, #112]	; (465d0 <z_fatal_error+0xb0>)
   46560:	f8ad 3000 	strh.w	r3, [sp]
   46564:	4631      	mov	r1, r6
   46566:	2300      	movs	r3, #0
   46568:	481a      	ldr	r0, [pc, #104]	; (465d4 <z_fatal_error+0xb4>)
   4656a:	f001 fea5 	bl	482b8 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   4656e:	b147      	cbz	r7, 46582 <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   46570:	69fb      	ldr	r3, [r7, #28]
   46572:	f3c3 0308 	ubfx	r3, r3, #0, #9
   46576:	b123      	cbz	r3, 46582 <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
   46578:	4817      	ldr	r0, [pc, #92]	; (465d8 <z_fatal_error+0xb8>)
   4657a:	f044 0101 	orr.w	r1, r4, #1
   4657e:	f001 fe61 	bl	48244 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   46582:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   46586:	b12d      	cbz	r5, 46594 <z_fatal_error+0x74>
   46588:	4628      	mov	r0, r5
   4658a:	f002 fd4e 	bl	4902a <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   4658e:	b108      	cbz	r0, 46594 <z_fatal_error+0x74>
   46590:	7803      	ldrb	r3, [r0, #0]
   46592:	b903      	cbnz	r3, 46596 <z_fatal_error+0x76>
		thread_name = "unknown";
   46594:	4811      	ldr	r0, [pc, #68]	; (465dc <z_fatal_error+0xbc>)
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
   46596:	f7fb f915 	bl	417c4 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
   4659a:	4623      	mov	r3, r4
   4659c:	4602      	mov	r2, r0
   4659e:	4629      	mov	r1, r5
   465a0:	480f      	ldr	r0, [pc, #60]	; (465e0 <z_fatal_error+0xc0>)
   465a2:	f001 fe70 	bl	48286 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   465a6:	4639      	mov	r1, r7
   465a8:	4630      	mov	r0, r6
   465aa:	f7fd fe05 	bl	441b8 <k_sys_fatal_error_handler>
	__asm__ volatile(
   465ae:	f388 8811 	msr	BASEPRI, r8
   465b2:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   465b6:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   465b8:	b002      	add	sp, #8
   465ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   465be:	f7fc bb23 	b.w	42c08 <z_impl_k_thread_abort>
   465c2:	bf00      	nop
   465c4:	000496cc 	.word	0x000496cc
   465c8:	00049694 	.word	0x00049694
   465cc:	00049924 	.word	0x00049924
   465d0:	0004a2fb 	.word	0x0004a2fb
   465d4:	0004a311 	.word	0x0004a311
   465d8:	0004a339 	.word	0x0004a339
   465dc:	0004a309 	.word	0x0004a309
   465e0:	0004a35a 	.word	0x0004a35a

000465e4 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   465e4:	2300      	movs	r3, #0
   465e6:	2201      	movs	r2, #1
{
   465e8:	b510      	push	{r4, lr}
   465ea:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   465ec:	e9cd 2304 	strd	r2, r3, [sp, #16]
   465f0:	220f      	movs	r2, #15
   465f2:	9301      	str	r3, [sp, #4]
   465f4:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   465f8:	2318      	movs	r3, #24
   465fa:	4a0b      	ldr	r2, [pc, #44]	; (46628 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   465fc:	4c0b      	ldr	r4, [pc, #44]	; (4662c <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   465fe:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   46602:	f44f 72a0 	mov.w	r2, #320	; 0x140
   46606:	490a      	ldr	r1, [pc, #40]	; (46630 <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   46608:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   4660c:	fb02 1100 	mla	r1, r2, r0, r1
   46610:	9300      	str	r3, [sp, #0]
   46612:	4620      	mov	r0, r4
   46614:	4b07      	ldr	r3, [pc, #28]	; (46634 <init_idle_thread+0x50>)
   46616:	f000 f90b 	bl	46830 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   4661a:	7b63      	ldrb	r3, [r4, #13]
   4661c:	f023 0304 	bic.w	r3, r3, #4
   46620:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   46622:	b006      	add	sp, #24
   46624:	bd10      	pop	{r4, pc}
   46626:	bf00      	nop
   46628:	2001ade8 	.word	0x2001ade8
   4662c:	2001a7c0 	.word	0x2001a7c0
   46630:	20023330 	.word	0x20023330
   46634:	00046979 	.word	0x00046979

00046638 <bg_thread_main>:
	z_sys_post_kernel = true;
   46638:	2201      	movs	r2, #1
{
   4663a:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   4663c:	4b09      	ldr	r3, [pc, #36]	; (46664 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   4663e:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   46640:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   46642:	f7ff ff47 	bl	464d4 <z_sys_init_run_level>
	boot_banner();
   46646:	f001 f825 	bl	47694 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   4664a:	2003      	movs	r0, #3
   4664c:	f7ff ff42 	bl	464d4 <z_sys_init_run_level>
	z_init_static_threads();
   46650:	f000 f94a 	bl	468e8 <z_init_static_threads>
	main();
   46654:	f7f9 ff10 	bl	40478 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   46658:	4a03      	ldr	r2, [pc, #12]	; (46668 <bg_thread_main+0x30>)
   4665a:	7b13      	ldrb	r3, [r2, #12]
   4665c:	f023 0301 	bic.w	r3, r3, #1
   46660:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   46662:	bd08      	pop	{r3, pc}
   46664:	20020c28 	.word	0x20020c28
   46668:	2001a840 	.word	0x2001a840

0004666c <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   4666c:	4802      	ldr	r0, [pc, #8]	; (46678 <z_bss_zero+0xc>)
   4666e:	4a03      	ldr	r2, [pc, #12]	; (4667c <z_bss_zero+0x10>)
   46670:	2100      	movs	r1, #0
   46672:	1a12      	subs	r2, r2, r0
   46674:	f002 b962 	b.w	4893c <memset>
   46678:	2001a6d0 	.word	0x2001a6d0
   4667c:	20020c2c 	.word	0x20020c2c

00046680 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   46680:	b580      	push	{r7, lr}
   46682:	b0a6      	sub	sp, #152	; 0x98
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   46684:	f7fa ffee 	bl	41664 <log_core_init>
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   46688:	4b2f      	ldr	r3, [pc, #188]	; (46748 <z_cstart+0xc8>)
	uint32_t msp =
   4668a:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   4668e:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   46692:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   46696:	2400      	movs	r4, #0
   46698:	23e0      	movs	r3, #224	; 0xe0
   4669a:	4d2c      	ldr	r5, [pc, #176]	; (4674c <z_cstart+0xcc>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   4669c:	4e2c      	ldr	r6, [pc, #176]	; (46750 <z_cstart+0xd0>)
   4669e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   466a2:	77ec      	strb	r4, [r5, #31]
   466a4:	762c      	strb	r4, [r5, #24]
   466a6:	766c      	strb	r4, [r5, #25]
   466a8:	76ac      	strb	r4, [r5, #26]
   466aa:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   466ae:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   466b0:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 46764 <z_cstart+0xe4>
   466b4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   466b8:	626b      	str	r3, [r5, #36]	; 0x24
   466ba:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   466be:	f7fc fa1b 	bl	42af8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   466c2:	f7fb fe77 	bl	423b4 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   466c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   466ca:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   466cc:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   466ce:	f7fc fc27 	bl	42f20 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   466d2:	f7fc faab 	bl	42c2c <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   466d6:	f240 1301 	movw	r3, #257	; 0x101
   466da:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   466de:	ab06      	add	r3, sp, #24
   466e0:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   466e2:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   466e6:	f002 fbd2 	bl	48e8e <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   466ea:	4620      	mov	r0, r4
   466ec:	f7ff fef2 	bl	464d4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   466f0:	2001      	movs	r0, #1
   466f2:	f7ff feef 	bl	464d4 <z_sys_init_run_level>
	z_sched_init();
   466f6:	f000 fca5 	bl	47044 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   466fa:	4b16      	ldr	r3, [pc, #88]	; (46754 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   466fc:	4d16      	ldr	r5, [pc, #88]	; (46758 <z_cstart+0xd8>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   466fe:	9305      	str	r3, [sp, #20]
   46700:	2301      	movs	r3, #1
   46702:	4916      	ldr	r1, [pc, #88]	; (4675c <z_cstart+0xdc>)
   46704:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   46708:	e9cd 4303 	strd	r4, r3, [sp, #12]
   4670c:	4628      	mov	r0, r5
   4670e:	464b      	mov	r3, r9
   46710:	e9cd 4401 	strd	r4, r4, [sp, #4]
   46714:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   46716:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   46718:	f000 f88a 	bl	46830 <z_setup_new_thread>
   4671c:	4607      	mov	r7, r0
   4671e:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   46720:	4628      	mov	r0, r5
   46722:	f022 0204 	bic.w	r2, r2, #4
   46726:	736a      	strb	r2, [r5, #13]
   46728:	f002 fcf1 	bl	4910e <z_ready_thread>
		init_idle_thread(i);
   4672c:	4620      	mov	r0, r4
   4672e:	f7ff ff59 	bl	465e4 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   46732:	4b0b      	ldr	r3, [pc, #44]	; (46760 <z_cstart+0xe0>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46734:	464a      	mov	r2, r9
   46736:	4639      	mov	r1, r7
   46738:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   4673a:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   4673c:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   4673e:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   46742:	f7fb ff67 	bl	42614 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   46746:	bf00      	nop
   46748:	20023470 	.word	0x20023470
   4674c:	e000ed00 	.word	0xe000ed00
   46750:	2001ade8 	.word	0x2001ade8
   46754:	0004a3bc 	.word	0x0004a3bc
   46758:	2001a840 	.word	0x2001a840
   4675c:	20021330 	.word	0x20021330
   46760:	2001a7c0 	.word	0x2001a7c0
   46764:	00046639 	.word	0x00046639

00046768 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   46768:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   4676a:	4c06      	ldr	r4, [pc, #24]	; (46784 <statics_init+0x1c>)
   4676c:	4d06      	ldr	r5, [pc, #24]	; (46788 <statics_init+0x20>)
   4676e:	42ac      	cmp	r4, r5
   46770:	d301      	bcc.n	46776 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   46772:	2000      	movs	r0, #0
   46774:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   46776:	4620      	mov	r0, r4
   46778:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   4677c:	f002 fb92 	bl	48ea4 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   46780:	3414      	adds	r4, #20
   46782:	e7f4      	b.n	4676e <statics_init+0x6>
   46784:	2001a670 	.word	0x2001a670
   46788:	2001a698 	.word	0x2001a698

0004678c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   4678c:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   4678e:	4b0e      	ldr	r3, [pc, #56]	; (467c8 <init_mem_slab_module+0x3c>)
   46790:	4c0e      	ldr	r4, [pc, #56]	; (467cc <init_mem_slab_module+0x40>)
   46792:	42a3      	cmp	r3, r4
   46794:	d301      	bcc.n	4679a <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   46796:	2000      	movs	r0, #0
	return rc;
}
   46798:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   4679a:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   4679e:	ea41 0200 	orr.w	r2, r1, r0
   467a2:	f012 0203 	ands.w	r2, r2, #3
   467a6:	d10b      	bne.n	467c0 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   467a8:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   467aa:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   467ac:	42aa      	cmp	r2, r5
   467ae:	d101      	bne.n	467b4 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   467b0:	331c      	adds	r3, #28
   467b2:	e7ee      	b.n	46792 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   467b4:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   467b6:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   467b8:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   467ba:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   467bc:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   467be:	e7f5      	b.n	467ac <init_mem_slab_module+0x20>
		return -EINVAL;
   467c0:	f06f 0015 	mvn.w	r0, #21
	return rc;
   467c4:	e7e8      	b.n	46798 <init_mem_slab_module+0xc>
   467c6:	bf00      	nop
   467c8:	2001a670 	.word	0x2001a670
   467cc:	2001a670 	.word	0x2001a670

000467d0 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   467d0:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   467d2:	460c      	mov	r4, r1
   467d4:	4616      	mov	r6, r2
   467d6:	461f      	mov	r7, r3
	__asm__ volatile(
   467d8:	f04f 0320 	mov.w	r3, #32
   467dc:	f3ef 8111 	mrs	r1, BASEPRI
   467e0:	f383 8812 	msr	BASEPRI_MAX, r3
   467e4:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   467e8:	6943      	ldr	r3, [r0, #20]
   467ea:	b15b      	cbz	r3, 46804 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   467ec:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   467ee:	681b      	ldr	r3, [r3, #0]
   467f0:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   467f2:	6983      	ldr	r3, [r0, #24]
   467f4:	3301      	adds	r3, #1
   467f6:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   467f8:	2000      	movs	r0, #0
	__asm__ volatile(
   467fa:	f381 8811 	msr	BASEPRI, r1
   467fe:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   46802:	e011      	b.n	46828 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   46804:	ea56 0207 	orrs.w	r2, r6, r7
   46808:	d103      	bne.n	46812 <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   4680a:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   4680e:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   46810:	e7f3      	b.n	467fa <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   46812:	4602      	mov	r2, r0
   46814:	e9cd 6700 	strd	r6, r7, [sp]
   46818:	3008      	adds	r0, #8
   4681a:	f000 fb65 	bl	46ee8 <z_pend_curr>
		if (result == 0) {
   4681e:	b918      	cbnz	r0, 46828 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   46820:	4b02      	ldr	r3, [pc, #8]	; (4682c <k_mem_slab_alloc+0x5c>)
   46822:	689b      	ldr	r3, [r3, #8]
   46824:	695b      	ldr	r3, [r3, #20]
   46826:	6023      	str	r3, [r4, #0]
}
   46828:	b002      	add	sp, #8
   4682a:	bdd0      	pop	{r4, r6, r7, pc}
   4682c:	2001ade8 	.word	0x2001ade8

00046830 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   46830:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   46834:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   46836:	f100 0558 	add.w	r5, r0, #88	; 0x58
   4683a:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   4683c:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   4683e:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   46842:	2500      	movs	r5, #0
{
   46844:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   46846:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   46848:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   4684a:	e9c0 5506 	strd	r5, r5, [r0, #24]
   4684e:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46850:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46852:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   46854:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   46858:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   4685c:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   4685e:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   46860:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   46862:	9202      	str	r2, [sp, #8]
   46864:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   46866:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   4686a:	9201      	str	r2, [sp, #4]
   4686c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   4686e:	9200      	str	r2, [sp, #0]
   46870:	4642      	mov	r2, r8
   46872:	f7fb feb1 	bl	425d8 <arch_new_thread>
	if (!_current) {
   46876:	4b05      	ldr	r3, [pc, #20]	; (4688c <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   46878:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   4687a:	689b      	ldr	r3, [r3, #8]
   4687c:	b103      	cbz	r3, 46880 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   4687e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   46880:	4640      	mov	r0, r8
   46882:	6723      	str	r3, [r4, #112]	; 0x70
   46884:	b004      	add	sp, #16
   46886:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   4688a:	bf00      	nop
   4688c:	2001ade8 	.word	0x2001ade8

00046890 <z_impl_k_thread_create>:
{
   46890:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46892:	2500      	movs	r5, #0
{
   46894:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   46896:	9505      	str	r5, [sp, #20]
   46898:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   4689a:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   4689e:	9504      	str	r5, [sp, #16]
   468a0:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   468a2:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   468a4:	9503      	str	r5, [sp, #12]
   468a6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   468a8:	9502      	str	r5, [sp, #8]
   468aa:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   468ac:	9501      	str	r5, [sp, #4]
   468ae:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   468b0:	9500      	str	r5, [sp, #0]
   468b2:	f7ff ffbd 	bl	46830 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   468b6:	1c7b      	adds	r3, r7, #1
   468b8:	bf08      	it	eq
   468ba:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   468be:	d005      	beq.n	468cc <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   468c0:	ea56 0307 	orrs.w	r3, r6, r7
   468c4:	d105      	bne.n	468d2 <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   468c6:	4620      	mov	r0, r4
   468c8:	f000 fab2 	bl	46e30 <z_sched_start>
}
   468cc:	4620      	mov	r0, r4
   468ce:	b007      	add	sp, #28
   468d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   468d2:	4632      	mov	r2, r6
   468d4:	463b      	mov	r3, r7
   468d6:	4903      	ldr	r1, [pc, #12]	; (468e4 <z_impl_k_thread_create+0x54>)
   468d8:	f104 0018 	add.w	r0, r4, #24
   468dc:	f000 fd22 	bl	47324 <z_add_timeout>
   468e0:	e7f4      	b.n	468cc <z_impl_k_thread_create+0x3c>
   468e2:	bf00      	nop
   468e4:	0004912f 	.word	0x0004912f

000468e8 <z_init_static_threads>:
{
   468e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   468ea:	4e20      	ldr	r6, [pc, #128]	; (4696c <z_init_static_threads+0x84>)
   468ec:	4d20      	ldr	r5, [pc, #128]	; (46970 <z_init_static_threads+0x88>)
   468ee:	4637      	mov	r7, r6
{
   468f0:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   468f2:	42b5      	cmp	r5, r6
   468f4:	f105 0430 	add.w	r4, r5, #48	; 0x30
   468f8:	d30a      	bcc.n	46910 <z_init_static_threads+0x28>
	k_sched_lock();
   468fa:	f000 f9ad 	bl	46c58 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   468fe:	4c1c      	ldr	r4, [pc, #112]	; (46970 <z_init_static_threads+0x88>)
   46900:	4d1c      	ldr	r5, [pc, #112]	; (46974 <z_init_static_threads+0x8c>)
   46902:	42bc      	cmp	r4, r7
   46904:	d321      	bcc.n	4694a <z_init_static_threads+0x62>
}
   46906:	b007      	add	sp, #28
   46908:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   4690c:	f000 bb7e 	b.w	4700c <k_sched_unlock>
		z_setup_new_thread(
   46910:	f854 3c04 	ldr.w	r3, [r4, #-4]
   46914:	9305      	str	r3, [sp, #20]
   46916:	f854 3c10 	ldr.w	r3, [r4, #-16]
   4691a:	9304      	str	r3, [sp, #16]
   4691c:	f854 3c14 	ldr.w	r3, [r4, #-20]
   46920:	9303      	str	r3, [sp, #12]
   46922:	f854 3c18 	ldr.w	r3, [r4, #-24]
   46926:	9302      	str	r3, [sp, #8]
   46928:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   4692c:	9301      	str	r3, [sp, #4]
   4692e:	f854 3c20 	ldr.w	r3, [r4, #-32]
   46932:	9300      	str	r3, [sp, #0]
   46934:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   46938:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   4693c:	f7ff ff78 	bl	46830 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   46940:	f854 3c30 	ldr.w	r3, [r4, #-48]
   46944:	655d      	str	r5, [r3, #84]	; 0x54
   46946:	4625      	mov	r5, r4
   46948:	e7d3      	b.n	468f2 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   4694a:	6a62      	ldr	r2, [r4, #36]	; 0x24
   4694c:	1c53      	adds	r3, r2, #1
   4694e:	d004      	beq.n	4695a <z_init_static_threads+0x72>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46950:	2a00      	cmp	r2, #0
			schedule_new_thread(thread_data->init_thread,
   46952:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   46954:	dc03      	bgt.n	4695e <z_init_static_threads+0x76>
	z_sched_start(thread);
   46956:	f000 fa6b 	bl	46e30 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   4695a:	3430      	adds	r4, #48	; 0x30
   4695c:	e7d1      	b.n	46902 <z_init_static_threads+0x1a>
   4695e:	4629      	mov	r1, r5
   46960:	17d3      	asrs	r3, r2, #31
   46962:	3018      	adds	r0, #24
   46964:	f000 fcde 	bl	47324 <z_add_timeout>
   46968:	e7f7      	b.n	4695a <z_init_static_threads+0x72>
   4696a:	bf00      	nop
   4696c:	2001a670 	.word	0x2001a670
   46970:	2001a670 	.word	0x2001a670
   46974:	0004912f 	.word	0x0004912f

00046978 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   46978:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   4697a:	4c09      	ldr	r4, [pc, #36]	; (469a0 <idle+0x28>)
	__asm__ volatile(
   4697c:	f04f 0220 	mov.w	r2, #32
   46980:	f3ef 8311 	mrs	r3, BASEPRI
   46984:	f382 8812 	msr	BASEPRI_MAX, r2
   46988:	f3bf 8f6f 	isb	sy
   4698c:	f002 fc71 	bl	49272 <z_get_next_timeout_expiry>
   46990:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   46992:	f7fb fc8f 	bl	422b4 <pm_system_suspend>
   46996:	2800      	cmp	r0, #0
   46998:	d1f0      	bne.n	4697c <idle+0x4>
	arch_cpu_idle();
   4699a:	f7fb fd11 	bl	423c0 <arch_cpu_idle>
}
   4699e:	e7ed      	b.n	4697c <idle+0x4>
   469a0:	2001ade8 	.word	0x2001ade8

000469a4 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   469a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   469a8:	4604      	mov	r4, r0
   469aa:	4616      	mov	r6, r2
   469ac:	461f      	mov	r7, r3
   469ae:	f04f 0320 	mov.w	r3, #32
   469b2:	f3ef 8811 	mrs	r8, BASEPRI
   469b6:	f383 8812 	msr	BASEPRI_MAX, r3
   469ba:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   469be:	68c3      	ldr	r3, [r0, #12]
   469c0:	4a35      	ldr	r2, [pc, #212]	; (46a98 <z_impl_k_mutex_lock+0xf4>)
   469c2:	b16b      	cbz	r3, 469e0 <z_impl_k_mutex_lock+0x3c>
   469c4:	6880      	ldr	r0, [r0, #8]
   469c6:	6891      	ldr	r1, [r2, #8]
   469c8:	4288      	cmp	r0, r1
   469ca:	d019      	beq.n	46a00 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   469cc:	ea56 0307 	orrs.w	r3, r6, r7
   469d0:	d118      	bne.n	46a04 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   469d2:	f388 8811 	msr	BASEPRI, r8
   469d6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   469da:	f06f 000f 	mvn.w	r0, #15
   469de:	e00c      	b.n	469fa <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   469e0:	6891      	ldr	r1, [r2, #8]
   469e2:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   469e6:	3301      	adds	r3, #1
   469e8:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   469ea:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   469ec:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   469ee:	60a3      	str	r3, [r4, #8]
   469f0:	f388 8811 	msr	BASEPRI, r8
   469f4:	f3bf 8f6f 	isb	sy
		return 0;
   469f8:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   469fa:	b002      	add	sp, #8
   469fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   46a00:	6921      	ldr	r1, [r4, #16]
   46a02:	e7f0      	b.n	469e6 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   46a04:	f991 100e 	ldrsb.w	r1, [r1, #14]
   46a08:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   46a0c:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   46a10:	4299      	cmp	r1, r3
   46a12:	bfa8      	it	ge
   46a14:	4619      	movge	r1, r3
   46a16:	4291      	cmp	r1, r2
   46a18:	bfb8      	it	lt
   46a1a:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   46a1c:	428b      	cmp	r3, r1
   46a1e:	dd2f      	ble.n	46a80 <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   46a20:	f000 fa76 	bl	46f10 <z_set_prio>
   46a24:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   46a26:	4622      	mov	r2, r4
   46a28:	4641      	mov	r1, r8
   46a2a:	e9cd 6700 	strd	r6, r7, [sp]
   46a2e:	481b      	ldr	r0, [pc, #108]	; (46a9c <z_impl_k_mutex_lock+0xf8>)
   46a30:	f000 fa5a 	bl	46ee8 <z_pend_curr>
	if (got_mutex == 0) {
   46a34:	2800      	cmp	r0, #0
   46a36:	d0e0      	beq.n	469fa <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   46a38:	f04f 0320 	mov.w	r3, #32
   46a3c:	f3ef 8611 	mrs	r6, BASEPRI
   46a40:	f383 8812 	msr	BASEPRI_MAX, r3
   46a44:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   46a48:	6823      	ldr	r3, [r4, #0]
   46a4a:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46a4c:	429c      	cmp	r4, r3
   46a4e:	d00a      	beq.n	46a66 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   46a50:	b14b      	cbz	r3, 46a66 <z_impl_k_mutex_lock+0xc2>
   46a52:	f993 300e 	ldrsb.w	r3, [r3, #14]
   46a56:	4299      	cmp	r1, r3
   46a58:	bfa8      	it	ge
   46a5a:	4619      	movge	r1, r3
   46a5c:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   46a60:	4299      	cmp	r1, r3
   46a62:	bfb8      	it	lt
   46a64:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46a66:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   46a68:	f990 300e 	ldrsb.w	r3, [r0, #14]
   46a6c:	4299      	cmp	r1, r3
   46a6e:	d109      	bne.n	46a84 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   46a70:	b16d      	cbz	r5, 46a8e <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   46a72:	4631      	mov	r1, r6
   46a74:	4809      	ldr	r0, [pc, #36]	; (46a9c <z_impl_k_mutex_lock+0xf8>)
   46a76:	f000 f8dd 	bl	46c34 <z_reschedule>
	return -EAGAIN;
   46a7a:	f06f 000a 	mvn.w	r0, #10
   46a7e:	e7bc      	b.n	469fa <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   46a80:	2500      	movs	r5, #0
   46a82:	e7d0      	b.n	46a26 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   46a84:	f000 fa44 	bl	46f10 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   46a88:	2800      	cmp	r0, #0
   46a8a:	d1f2      	bne.n	46a72 <z_impl_k_mutex_lock+0xce>
   46a8c:	e7f0      	b.n	46a70 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   46a8e:	f386 8811 	msr	BASEPRI, r6
   46a92:	f3bf 8f6f 	isb	sy
   46a96:	e7f0      	b.n	46a7a <z_impl_k_mutex_lock+0xd6>
   46a98:	2001ade8 	.word	0x2001ade8
   46a9c:	20020c29 	.word	0x20020c29

00046aa0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   46aa0:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   46aa2:	6883      	ldr	r3, [r0, #8]
{
   46aa4:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   46aa6:	2b00      	cmp	r3, #0
   46aa8:	d036      	beq.n	46b18 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   46aaa:	4a1e      	ldr	r2, [pc, #120]	; (46b24 <z_impl_k_mutex_unlock+0x84>)
   46aac:	6892      	ldr	r2, [r2, #8]
   46aae:	4293      	cmp	r3, r2
   46ab0:	d135      	bne.n	46b1e <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   46ab2:	7bda      	ldrb	r2, [r3, #15]
   46ab4:	3a01      	subs	r2, #1
   46ab6:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   46ab8:	68c3      	ldr	r3, [r0, #12]
   46aba:	2b01      	cmp	r3, #1
   46abc:	d905      	bls.n	46aca <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   46abe:	3b01      	subs	r3, #1
   46ac0:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   46ac2:	f000 faa3 	bl	4700c <k_sched_unlock>

	return 0;
   46ac6:	2000      	movs	r0, #0
}
   46ac8:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   46aca:	f04f 0320 	mov.w	r3, #32
   46ace:	f3ef 8511 	mrs	r5, BASEPRI
   46ad2:	f383 8812 	msr	BASEPRI_MAX, r3
   46ad6:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   46ada:	6901      	ldr	r1, [r0, #16]
   46adc:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   46ade:	f990 300e 	ldrsb.w	r3, [r0, #14]
   46ae2:	4299      	cmp	r1, r3
   46ae4:	d001      	beq.n	46aea <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   46ae6:	f000 fa13 	bl	46f10 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   46aea:	4620      	mov	r0, r4
   46aec:	f002 fb83 	bl	491f6 <z_unpend_first_thread>
	mutex->owner = new_owner;
   46af0:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   46af2:	b158      	cbz	r0, 46b0c <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   46af4:	f990 200e 	ldrsb.w	r2, [r0, #14]
   46af8:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   46afa:	2200      	movs	r2, #0
   46afc:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   46afe:	f002 fb06 	bl	4910e <z_ready_thread>
		z_reschedule(&lock, key);
   46b02:	4629      	mov	r1, r5
   46b04:	4808      	ldr	r0, [pc, #32]	; (46b28 <z_impl_k_mutex_unlock+0x88>)
   46b06:	f000 f895 	bl	46c34 <z_reschedule>
   46b0a:	e7da      	b.n	46ac2 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   46b0c:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   46b0e:	f385 8811 	msr	BASEPRI, r5
   46b12:	f3bf 8f6f 	isb	sy
   46b16:	e7d4      	b.n	46ac2 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   46b18:	f06f 0015 	mvn.w	r0, #21
   46b1c:	e7d4      	b.n	46ac8 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   46b1e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   46b22:	e7d1      	b.n	46ac8 <z_impl_k_mutex_unlock+0x28>
   46b24:	2001ade8 	.word	0x2001ade8
   46b28:	20020c29 	.word	0x20020c29

00046b2c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   46b2c:	b538      	push	{r3, r4, r5, lr}
   46b2e:	4604      	mov	r4, r0
	__asm__ volatile(
   46b30:	f04f 0320 	mov.w	r3, #32
   46b34:	f3ef 8511 	mrs	r5, BASEPRI
   46b38:	f383 8812 	msr	BASEPRI_MAX, r3
   46b3c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   46b40:	f002 fb59 	bl	491f6 <z_unpend_first_thread>

	if (thread != NULL) {
   46b44:	b148      	cbz	r0, 46b5a <z_impl_k_sem_give+0x2e>
   46b46:	2200      	movs	r2, #0
   46b48:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   46b4a:	f002 fae0 	bl	4910e <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   46b4e:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   46b50:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   46b54:	4804      	ldr	r0, [pc, #16]	; (46b68 <z_impl_k_sem_give+0x3c>)
   46b56:	f000 b86d 	b.w	46c34 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   46b5a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   46b5e:	429a      	cmp	r2, r3
   46b60:	bf18      	it	ne
   46b62:	3301      	addne	r3, #1
   46b64:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   46b66:	e7f2      	b.n	46b4e <z_impl_k_sem_give+0x22>
   46b68:	20020c29 	.word	0x20020c29

00046b6c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   46b6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   46b6e:	4614      	mov	r4, r2
   46b70:	461d      	mov	r5, r3
   46b72:	f04f 0320 	mov.w	r3, #32
   46b76:	f3ef 8111 	mrs	r1, BASEPRI
   46b7a:	f383 8812 	msr	BASEPRI_MAX, r3
   46b7e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   46b82:	6883      	ldr	r3, [r0, #8]
   46b84:	b143      	cbz	r3, 46b98 <z_impl_k_sem_take+0x2c>
		sem->count--;
   46b86:	3b01      	subs	r3, #1
   46b88:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   46b8a:	f381 8811 	msr	BASEPRI, r1
   46b8e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   46b92:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   46b94:	b003      	add	sp, #12
   46b96:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   46b98:	ea54 0305 	orrs.w	r3, r4, r5
   46b9c:	d106      	bne.n	46bac <z_impl_k_sem_take+0x40>
   46b9e:	f381 8811 	msr	BASEPRI, r1
   46ba2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   46ba6:	f06f 000f 	mvn.w	r0, #15
   46baa:	e7f3      	b.n	46b94 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   46bac:	4602      	mov	r2, r0
   46bae:	e9cd 4500 	strd	r4, r5, [sp]
   46bb2:	4802      	ldr	r0, [pc, #8]	; (46bbc <z_impl_k_sem_take+0x50>)
   46bb4:	f000 f998 	bl	46ee8 <z_pend_curr>
	return ret;
   46bb8:	e7ec      	b.n	46b94 <z_impl_k_sem_take+0x28>
   46bba:	bf00      	nop
   46bbc:	20020c29 	.word	0x20020c29

00046bc0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   46bc0:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   46bc2:	4c08      	ldr	r4, [pc, #32]	; (46be4 <z_reset_time_slice+0x24>)
   46bc4:	6823      	ldr	r3, [r4, #0]
   46bc6:	b15b      	cbz	r3, 46be0 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46bc8:	f7fd f940 	bl	43e4c <sys_clock_elapsed>
   46bcc:	4603      	mov	r3, r0
   46bce:	6820      	ldr	r0, [r4, #0]
   46bd0:	4a05      	ldr	r2, [pc, #20]	; (46be8 <z_reset_time_slice+0x28>)
   46bd2:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   46bd4:	2100      	movs	r1, #0
	}
}
   46bd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   46bda:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   46bdc:	f002 bb59 	b.w	49292 <z_set_timeout_expiry>
}
   46be0:	bd10      	pop	{r4, pc}
   46be2:	bf00      	nop
   46be4:	2001ae18 	.word	0x2001ae18
   46be8:	2001ade8 	.word	0x2001ade8

00046bec <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   46bec:	b510      	push	{r4, lr}
	__asm__ volatile(
   46bee:	f04f 0320 	mov.w	r3, #32
   46bf2:	f3ef 8411 	mrs	r4, BASEPRI
   46bf6:	f383 8812 	msr	BASEPRI_MAX, r3
   46bfa:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   46bfe:	2200      	movs	r2, #0
   46c00:	4b09      	ldr	r3, [pc, #36]	; (46c28 <k_sched_time_slice_set+0x3c>)
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   46c02:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
   46c04:	611a      	str	r2, [r3, #16]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   46c06:	4b09      	ldr	r3, [pc, #36]	; (46c2c <k_sched_time_slice_set+0x40>)
   46c08:	dc09      	bgt.n	46c1e <k_sched_time_slice_set+0x32>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   46c0a:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   46c0c:	4b08      	ldr	r3, [pc, #32]	; (46c30 <k_sched_time_slice_set+0x44>)
   46c0e:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
   46c10:	f7ff ffd6 	bl	46bc0 <z_reset_time_slice>
	__asm__ volatile(
   46c14:	f384 8811 	msr	BASEPRI, r4
   46c18:	f3bf 8f6f 	isb	sy
	}
}
   46c1c:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
   46c1e:	2802      	cmp	r0, #2
   46c20:	bfb8      	it	lt
   46c22:	2002      	movlt	r0, #2
   46c24:	e7f1      	b.n	46c0a <k_sched_time_slice_set+0x1e>
   46c26:	bf00      	nop
   46c28:	2001ade8 	.word	0x2001ade8
   46c2c:	2001ae18 	.word	0x2001ae18
   46c30:	2001ae14 	.word	0x2001ae14

00046c34 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   46c34:	b949      	cbnz	r1, 46c4a <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   46c36:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   46c3a:	b930      	cbnz	r0, 46c4a <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   46c3c:	4b05      	ldr	r3, [pc, #20]	; (46c54 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   46c3e:	69da      	ldr	r2, [r3, #28]
   46c40:	689b      	ldr	r3, [r3, #8]
   46c42:	429a      	cmp	r2, r3
   46c44:	d001      	beq.n	46c4a <z_reschedule+0x16>
	ret = arch_swap(key);
   46c46:	f7fb bc6d 	b.w	42524 <arch_swap>
   46c4a:	f381 8811 	msr	BASEPRI, r1
   46c4e:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   46c52:	4770      	bx	lr
   46c54:	2001ade8 	.word	0x2001ade8

00046c58 <k_sched_lock>:
	__asm__ volatile(
   46c58:	f04f 0320 	mov.w	r3, #32
   46c5c:	f3ef 8111 	mrs	r1, BASEPRI
   46c60:	f383 8812 	msr	BASEPRI_MAX, r3
   46c64:	f3bf 8f6f 	isb	sy
   46c68:	4b04      	ldr	r3, [pc, #16]	; (46c7c <k_sched_lock+0x24>)
   46c6a:	689a      	ldr	r2, [r3, #8]
   46c6c:	7bd3      	ldrb	r3, [r2, #15]
   46c6e:	3b01      	subs	r3, #1
   46c70:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   46c72:	f381 8811 	msr	BASEPRI, r1
   46c76:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   46c7a:	4770      	bx	lr
   46c7c:	2001ade8 	.word	0x2001ade8

00046c80 <update_cache>:
{
   46c80:	b538      	push	{r3, r4, r5, lr}
   46c82:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   46c84:	480c      	ldr	r0, [pc, #48]	; (46cb8 <update_cache+0x38>)
   46c86:	f002 fa38 	bl	490fa <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   46c8a:	4d0c      	ldr	r5, [pc, #48]	; (46cbc <update_cache+0x3c>)
   46c8c:	4604      	mov	r4, r0
   46c8e:	b900      	cbnz	r0, 46c92 <update_cache+0x12>
   46c90:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   46c92:	68ab      	ldr	r3, [r5, #8]
   46c94:	b94a      	cbnz	r2, 46caa <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   46c96:	7b5a      	ldrb	r2, [r3, #13]
   46c98:	06d2      	lsls	r2, r2, #27
   46c9a:	d106      	bne.n	46caa <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   46c9c:	69a2      	ldr	r2, [r4, #24]
   46c9e:	b922      	cbnz	r2, 46caa <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   46ca0:	89da      	ldrh	r2, [r3, #14]
   46ca2:	2a7f      	cmp	r2, #127	; 0x7f
   46ca4:	d901      	bls.n	46caa <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   46ca6:	61eb      	str	r3, [r5, #28]
}
   46ca8:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   46caa:	429c      	cmp	r4, r3
   46cac:	d001      	beq.n	46cb2 <update_cache+0x32>
			z_reset_time_slice();
   46cae:	f7ff ff87 	bl	46bc0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   46cb2:	61ec      	str	r4, [r5, #28]
}
   46cb4:	e7f8      	b.n	46ca8 <update_cache+0x28>
   46cb6:	bf00      	nop
   46cb8:	2001ae08 	.word	0x2001ae08
   46cbc:	2001ade8 	.word	0x2001ade8

00046cc0 <move_thread_to_end_of_prio_q>:
{
   46cc0:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   46cc2:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46cc6:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46cc8:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46cca:	7b43      	ldrb	r3, [r0, #13]
   46ccc:	da04      	bge.n	46cd8 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46cce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46cd2:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   46cd4:	f002 f9c5 	bl	49062 <sys_dlist_remove>
	return list->head == list;
   46cd8:	4a17      	ldr	r2, [pc, #92]	; (46d38 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46cda:	7b4b      	ldrb	r3, [r1, #13]
   46cdc:	4610      	mov	r0, r2
   46cde:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46ce2:	734b      	strb	r3, [r1, #13]
   46ce4:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46ce8:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46cea:	4283      	cmp	r3, r0
   46cec:	bf08      	it	eq
   46cee:	2300      	moveq	r3, #0
   46cf0:	2b00      	cmp	r3, #0
   46cf2:	bf38      	it	cc
   46cf4:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46cf6:	b1cb      	cbz	r3, 46d2c <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   46cf8:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   46cfc:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   46d00:	42a6      	cmp	r6, r4
   46d02:	d00f      	beq.n	46d24 <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   46d04:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46d06:	2c00      	cmp	r4, #0
   46d08:	dd0c      	ble.n	46d24 <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   46d0a:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   46d0c:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   46d10:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   46d12:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   46d14:	6890      	ldr	r0, [r2, #8]
}
   46d16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   46d1a:	1a43      	subs	r3, r0, r1
   46d1c:	4258      	negs	r0, r3
   46d1e:	4158      	adcs	r0, r3
   46d20:	f7ff bfae 	b.w	46c80 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46d24:	42ab      	cmp	r3, r5
   46d26:	d001      	beq.n	46d2c <move_thread_to_end_of_prio_q+0x6c>
   46d28:	681b      	ldr	r3, [r3, #0]
   46d2a:	e7e4      	b.n	46cf6 <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   46d2c:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   46d30:	6029      	str	r1, [r5, #0]
	list->tail = node;
   46d32:	6251      	str	r1, [r2, #36]	; 0x24
}
   46d34:	e7ee      	b.n	46d14 <move_thread_to_end_of_prio_q+0x54>
   46d36:	bf00      	nop
   46d38:	2001ade8 	.word	0x2001ade8

00046d3c <z_time_slice>:
{
   46d3c:	4601      	mov	r1, r0
   46d3e:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   46d40:	f04f 0320 	mov.w	r3, #32
   46d44:	f3ef 8411 	mrs	r4, BASEPRI
   46d48:	f383 8812 	msr	BASEPRI_MAX, r3
   46d4c:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   46d50:	4b16      	ldr	r3, [pc, #88]	; (46dac <z_time_slice+0x70>)
   46d52:	4a17      	ldr	r2, [pc, #92]	; (46db0 <z_time_slice+0x74>)
   46d54:	6898      	ldr	r0, [r3, #8]
   46d56:	6815      	ldr	r5, [r2, #0]
   46d58:	42a8      	cmp	r0, r5
   46d5a:	461d      	mov	r5, r3
   46d5c:	d106      	bne.n	46d6c <z_time_slice+0x30>
			z_reset_time_slice();
   46d5e:	f7ff ff2f 	bl	46bc0 <z_reset_time_slice>
	__asm__ volatile(
   46d62:	f384 8811 	msr	BASEPRI, r4
   46d66:	f3bf 8f6f 	isb	sy
}
   46d6a:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   46d6c:	2600      	movs	r6, #0
   46d6e:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   46d70:	4a10      	ldr	r2, [pc, #64]	; (46db4 <z_time_slice+0x78>)
   46d72:	6812      	ldr	r2, [r2, #0]
   46d74:	b1ba      	cbz	r2, 46da6 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   46d76:	89c2      	ldrh	r2, [r0, #14]
   46d78:	2a7f      	cmp	r2, #127	; 0x7f
   46d7a:	d814      	bhi.n	46da6 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   46d7c:	7b42      	ldrb	r2, [r0, #13]
   46d7e:	06d2      	lsls	r2, r2, #27
   46d80:	d111      	bne.n	46da6 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   46d82:	4a0d      	ldr	r2, [pc, #52]	; (46db8 <z_time_slice+0x7c>)
   46d84:	f990 600e 	ldrsb.w	r6, [r0, #14]
   46d88:	6812      	ldr	r2, [r2, #0]
   46d8a:	4296      	cmp	r6, r2
   46d8c:	db0b      	blt.n	46da6 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   46d8e:	4a0b      	ldr	r2, [pc, #44]	; (46dbc <z_time_slice+0x80>)
   46d90:	4290      	cmp	r0, r2
   46d92:	d008      	beq.n	46da6 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   46d94:	691a      	ldr	r2, [r3, #16]
   46d96:	428a      	cmp	r2, r1
   46d98:	dc02      	bgt.n	46da0 <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   46d9a:	f7ff ff91 	bl	46cc0 <move_thread_to_end_of_prio_q>
   46d9e:	e7de      	b.n	46d5e <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   46da0:	1a52      	subs	r2, r2, r1
   46da2:	611a      	str	r2, [r3, #16]
   46da4:	e7dd      	b.n	46d62 <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   46da6:	2300      	movs	r3, #0
   46da8:	612b      	str	r3, [r5, #16]
   46daa:	e7da      	b.n	46d62 <z_time_slice+0x26>
   46dac:	2001ade8 	.word	0x2001ade8
   46db0:	2001ae10 	.word	0x2001ae10
   46db4:	2001ae18 	.word	0x2001ae18
   46db8:	2001ae14 	.word	0x2001ae14
   46dbc:	2001a7c0 	.word	0x2001a7c0

00046dc0 <ready_thread>:
{
   46dc0:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   46dc2:	f990 300d 	ldrsb.w	r3, [r0, #13]
   46dc6:	7b42      	ldrb	r2, [r0, #13]
   46dc8:	2b00      	cmp	r3, #0
   46dca:	db2d      	blt.n	46e28 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46dcc:	06d3      	lsls	r3, r2, #27
   46dce:	d12b      	bne.n	46e28 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   46dd0:	6983      	ldr	r3, [r0, #24]
   46dd2:	bb4b      	cbnz	r3, 46e28 <ready_thread+0x68>
	return list->head == list;
   46dd4:	4915      	ldr	r1, [pc, #84]	; (46e2c <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   46dd6:	f062 027f 	orn	r2, r2, #127	; 0x7f
   46dda:	7342      	strb	r2, [r0, #13]
   46ddc:	460a      	mov	r2, r1
   46dde:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46de2:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46de4:	4294      	cmp	r4, r2
   46de6:	bf18      	it	ne
   46de8:	4623      	movne	r3, r4
   46dea:	2b00      	cmp	r3, #0
   46dec:	bf38      	it	cc
   46dee:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46df0:	b1ab      	cbz	r3, 46e1e <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   46df2:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   46df6:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   46dfa:	42a6      	cmp	r6, r4
   46dfc:	d00b      	beq.n	46e16 <ready_thread+0x56>
		return b2 - b1;
   46dfe:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   46e00:	2c00      	cmp	r4, #0
   46e02:	dd08      	ble.n	46e16 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   46e04:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46e06:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   46e0a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   46e0c:	6058      	str	r0, [r3, #4]
		update_cache(0);
   46e0e:	2000      	movs	r0, #0
}
   46e10:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   46e12:	f7ff bf35 	b.w	46c80 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   46e16:	42ab      	cmp	r3, r5
   46e18:	d001      	beq.n	46e1e <ready_thread+0x5e>
   46e1a:	681b      	ldr	r3, [r3, #0]
   46e1c:	e7e8      	b.n	46df0 <ready_thread+0x30>
	node->prev = tail;
   46e1e:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   46e22:	6028      	str	r0, [r5, #0]
	list->tail = node;
   46e24:	6248      	str	r0, [r1, #36]	; 0x24
}
   46e26:	e7f2      	b.n	46e0e <ready_thread+0x4e>
}
   46e28:	bc70      	pop	{r4, r5, r6}
   46e2a:	4770      	bx	lr
   46e2c:	2001ade8 	.word	0x2001ade8

00046e30 <z_sched_start>:
{
   46e30:	b510      	push	{r4, lr}
	__asm__ volatile(
   46e32:	f04f 0220 	mov.w	r2, #32
   46e36:	f3ef 8411 	mrs	r4, BASEPRI
   46e3a:	f382 8812 	msr	BASEPRI_MAX, r2
   46e3e:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   46e42:	7b42      	ldrb	r2, [r0, #13]
   46e44:	0751      	lsls	r1, r2, #29
   46e46:	d404      	bmi.n	46e52 <z_sched_start+0x22>
	__asm__ volatile(
   46e48:	f384 8811 	msr	BASEPRI, r4
   46e4c:	f3bf 8f6f 	isb	sy
}
   46e50:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   46e52:	f022 0204 	bic.w	r2, r2, #4
   46e56:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   46e58:	f7ff ffb2 	bl	46dc0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   46e5c:	4621      	mov	r1, r4
}
   46e5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   46e62:	4801      	ldr	r0, [pc, #4]	; (46e68 <z_sched_start+0x38>)
   46e64:	f7ff bee6 	b.w	46c34 <z_reschedule>
   46e68:	20020c29 	.word	0x20020c29

00046e6c <unready_thread>:
{
   46e6c:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   46e6e:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   46e72:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   46e74:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46e76:	7b43      	ldrb	r3, [r0, #13]
   46e78:	da04      	bge.n	46e84 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46e7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46e7e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46e80:	f002 f8ef 	bl	49062 <sys_dlist_remove>
	update_cache(thread == _current);
   46e84:	4b04      	ldr	r3, [pc, #16]	; (46e98 <unready_thread+0x2c>)
   46e86:	6898      	ldr	r0, [r3, #8]
   46e88:	1a43      	subs	r3, r0, r1
   46e8a:	4258      	negs	r0, r3
   46e8c:	4158      	adcs	r0, r3
}
   46e8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   46e92:	f7ff bef5 	b.w	46c80 <update_cache>
   46e96:	bf00      	nop
   46e98:	2001ade8 	.word	0x2001ade8

00046e9c <pend>:
{
   46e9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   46ea0:	4606      	mov	r6, r0
   46ea2:	4614      	mov	r4, r2
   46ea4:	461d      	mov	r5, r3
	__asm__ volatile(
   46ea6:	f04f 0320 	mov.w	r3, #32
   46eaa:	f3ef 8711 	mrs	r7, BASEPRI
   46eae:	f383 8812 	msr	BASEPRI_MAX, r3
   46eb2:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   46eb6:	f002 f95c 	bl	49172 <add_to_waitq_locked>
	__asm__ volatile(
   46eba:	f387 8811 	msr	BASEPRI, r7
   46ebe:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   46ec2:	1c6b      	adds	r3, r5, #1
   46ec4:	bf08      	it	eq
   46ec6:	f1b4 3fff 	cmpeq.w	r4, #4294967295	; 0xffffffff
   46eca:	d008      	beq.n	46ede <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   46ecc:	4622      	mov	r2, r4
   46ece:	462b      	mov	r3, r5
   46ed0:	f106 0018 	add.w	r0, r6, #24
   46ed4:	4903      	ldr	r1, [pc, #12]	; (46ee4 <pend+0x48>)
}
   46ed6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   46eda:	f000 ba23 	b.w	47324 <z_add_timeout>
   46ede:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   46ee2:	bf00      	nop
   46ee4:	0004912f 	.word	0x0004912f

00046ee8 <z_pend_curr>:
{
   46ee8:	b510      	push	{r4, lr}
   46eea:	460c      	mov	r4, r1
	pending_current = _current;
   46eec:	4b06      	ldr	r3, [pc, #24]	; (46f08 <z_pend_curr+0x20>)
{
   46eee:	4611      	mov	r1, r2
	pending_current = _current;
   46ef0:	6898      	ldr	r0, [r3, #8]
   46ef2:	4b06      	ldr	r3, [pc, #24]	; (46f0c <z_pend_curr+0x24>)
   46ef4:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   46ef6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   46efa:	f7ff ffcf 	bl	46e9c <pend>
   46efe:	4620      	mov	r0, r4
}
   46f00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   46f04:	f7fb bb0e 	b.w	42524 <arch_swap>
   46f08:	2001ade8 	.word	0x2001ade8
   46f0c:	2001ae10 	.word	0x2001ae10

00046f10 <z_set_prio>:
{
   46f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   46f12:	4604      	mov	r4, r0
	__asm__ volatile(
   46f14:	f04f 0320 	mov.w	r3, #32
   46f18:	f3ef 8611 	mrs	r6, BASEPRI
   46f1c:	f383 8812 	msr	BASEPRI_MAX, r3
   46f20:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46f24:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   46f26:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   46f28:	06da      	lsls	r2, r3, #27
   46f2a:	d138      	bne.n	46f9e <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   46f2c:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   46f2e:	2d00      	cmp	r5, #0
   46f30:	d135      	bne.n	46f9e <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46f32:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   46f36:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46f38:	f002 f893 	bl	49062 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   46f3c:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   46f3e:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   46f40:	f063 037f 	orn	r3, r3, #127	; 0x7f
   46f44:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   46f46:	4817      	ldr	r0, [pc, #92]	; (46fa4 <z_set_prio+0x94>)
   46f48:	4603      	mov	r3, r0
   46f4a:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   46f4e:	429f      	cmp	r7, r3
   46f50:	bf18      	it	ne
   46f52:	463d      	movne	r5, r7
   46f54:	2d00      	cmp	r5, #0
   46f56:	461a      	mov	r2, r3
   46f58:	462b      	mov	r3, r5
   46f5a:	bf38      	it	cc
   46f5c:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   46f5e:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   46f60:	b1c3      	cbz	r3, 46f94 <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   46f62:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   46f66:	42a9      	cmp	r1, r5
   46f68:	d010      	beq.n	46f8c <z_set_prio+0x7c>
		return b2 - b1;
   46f6a:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   46f6c:	2d00      	cmp	r5, #0
   46f6e:	dd0d      	ble.n	46f8c <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   46f70:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   46f72:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   46f76:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   46f78:	605c      	str	r4, [r3, #4]
			update_cache(1);
   46f7a:	2001      	movs	r0, #1
   46f7c:	f7ff fe80 	bl	46c80 <update_cache>
   46f80:	2001      	movs	r0, #1
	__asm__ volatile(
   46f82:	f386 8811 	msr	BASEPRI, r6
   46f86:	f3bf 8f6f 	isb	sy
}
   46f8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   46f8c:	42bb      	cmp	r3, r7
   46f8e:	d001      	beq.n	46f94 <z_set_prio+0x84>
   46f90:	681b      	ldr	r3, [r3, #0]
   46f92:	e7e5      	b.n	46f60 <z_set_prio+0x50>
	node->prev = tail;
   46f94:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   46f98:	603c      	str	r4, [r7, #0]
	list->tail = node;
   46f9a:	6244      	str	r4, [r0, #36]	; 0x24
}
   46f9c:	e7ed      	b.n	46f7a <z_set_prio+0x6a>
			thread->base.prio = prio;
   46f9e:	2000      	movs	r0, #0
   46fa0:	73a1      	strb	r1, [r4, #14]
   46fa2:	e7ee      	b.n	46f82 <z_set_prio+0x72>
   46fa4:	2001ade8 	.word	0x2001ade8

00046fa8 <z_impl_k_thread_suspend>:
{
   46fa8:	b570      	push	{r4, r5, r6, lr}
   46faa:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   46fac:	3018      	adds	r0, #24
   46fae:	f002 f94a 	bl	49246 <z_abort_timeout>
	__asm__ volatile(
   46fb2:	f04f 0320 	mov.w	r3, #32
   46fb6:	f3ef 8611 	mrs	r6, BASEPRI
   46fba:	f383 8812 	msr	BASEPRI_MAX, r3
   46fbe:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   46fc2:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   46fc6:	7b63      	ldrb	r3, [r4, #13]
   46fc8:	2a00      	cmp	r2, #0
   46fca:	da05      	bge.n	46fd8 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46fcc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   46fd0:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   46fd2:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   46fd4:	f002 f845 	bl	49062 <sys_dlist_remove>
		update_cache(thread == _current);
   46fd8:	4d0b      	ldr	r5, [pc, #44]	; (47008 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   46fda:	7b63      	ldrb	r3, [r4, #13]
   46fdc:	68a8      	ldr	r0, [r5, #8]
   46fde:	f043 0310 	orr.w	r3, r3, #16
   46fe2:	7363      	strb	r3, [r4, #13]
   46fe4:	1b03      	subs	r3, r0, r4
   46fe6:	4258      	negs	r0, r3
   46fe8:	4158      	adcs	r0, r3
   46fea:	f7ff fe49 	bl	46c80 <update_cache>
	__asm__ volatile(
   46fee:	f386 8811 	msr	BASEPRI, r6
   46ff2:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   46ff6:	68ab      	ldr	r3, [r5, #8]
   46ff8:	42a3      	cmp	r3, r4
   46ffa:	d103      	bne.n	47004 <z_impl_k_thread_suspend+0x5c>
}
   46ffc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   47000:	f002 b871 	b.w	490e6 <z_reschedule_unlocked>
}
   47004:	bd70      	pop	{r4, r5, r6, pc}
   47006:	bf00      	nop
   47008:	2001ade8 	.word	0x2001ade8

0004700c <k_sched_unlock>:
{
   4700c:	b510      	push	{r4, lr}
	__asm__ volatile(
   4700e:	f04f 0320 	mov.w	r3, #32
   47012:	f3ef 8411 	mrs	r4, BASEPRI
   47016:	f383 8812 	msr	BASEPRI_MAX, r3
   4701a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   4701e:	4b08      	ldr	r3, [pc, #32]	; (47040 <k_sched_unlock+0x34>)
		update_cache(0);
   47020:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   47022:	689a      	ldr	r2, [r3, #8]
   47024:	7bd3      	ldrb	r3, [r2, #15]
   47026:	3301      	adds	r3, #1
   47028:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   4702a:	f7ff fe29 	bl	46c80 <update_cache>
	__asm__ volatile(
   4702e:	f384 8811 	msr	BASEPRI, r4
   47032:	f3bf 8f6f 	isb	sy
}
   47036:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   4703a:	f002 b854 	b.w	490e6 <z_reschedule_unlocked>
   4703e:	bf00      	nop
   47040:	2001ade8 	.word	0x2001ade8

00047044 <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   47044:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   47046:	4b04      	ldr	r3, [pc, #16]	; (47058 <z_sched_init+0x14>)
   47048:	4608      	mov	r0, r1
   4704a:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   4704e:	e9c3 2208 	strd	r2, r2, [r3, #32]
   47052:	f7ff bdcb 	b.w	46bec <k_sched_time_slice_set>
   47056:	bf00      	nop
   47058:	2001ade8 	.word	0x2001ade8

0004705c <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   4705c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   4705e:	f04f 0320 	mov.w	r3, #32
   47062:	f3ef 8411 	mrs	r4, BASEPRI
   47066:	f383 8812 	msr	BASEPRI_MAX, r3
   4706a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   4706e:	491b      	ldr	r1, [pc, #108]	; (470dc <z_impl_k_yield+0x80>)
   47070:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   47072:	7b43      	ldrb	r3, [r0, #13]
   47074:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   47078:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   4707a:	f001 fff2 	bl	49062 <sys_dlist_remove>
	return list->head == list;
   4707e:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   47080:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   47082:	7b53      	ldrb	r3, [r2, #13]
   47084:	f063 037f 	orn	r3, r3, #127	; 0x7f
   47088:	7353      	strb	r3, [r2, #13]
   4708a:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   4708e:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47090:	4283      	cmp	r3, r0
   47092:	bf08      	it	eq
   47094:	2300      	moveq	r3, #0
   47096:	2b00      	cmp	r3, #0
   47098:	bf38      	it	cc
   4709a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   4709c:	b1cb      	cbz	r3, 470d2 <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   4709e:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   470a2:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   470a6:	42af      	cmp	r7, r5
   470a8:	d00f      	beq.n	470ca <z_impl_k_yield+0x6e>
		return b2 - b1;
   470aa:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   470ac:	2d00      	cmp	r5, #0
   470ae:	dd0c      	ble.n	470ca <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   470b0:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   470b2:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   470b6:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   470b8:	605a      	str	r2, [r3, #4]
	update_cache(1);
   470ba:	2001      	movs	r0, #1
   470bc:	f7ff fde0 	bl	46c80 <update_cache>
   470c0:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   470c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   470c6:	f7fb ba2d 	b.w	42524 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   470ca:	42b3      	cmp	r3, r6
   470cc:	d001      	beq.n	470d2 <z_impl_k_yield+0x76>
   470ce:	681b      	ldr	r3, [r3, #0]
   470d0:	e7e4      	b.n	4709c <z_impl_k_yield+0x40>
	node->prev = tail;
   470d2:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   470d6:	6032      	str	r2, [r6, #0]
	list->tail = node;
   470d8:	624a      	str	r2, [r1, #36]	; 0x24
}
   470da:	e7ee      	b.n	470ba <z_impl_k_yield+0x5e>
   470dc:	2001ade8 	.word	0x2001ade8

000470e0 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   470e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   470e4:	4604      	mov	r4, r0
   470e6:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   470e8:	ea54 0105 	orrs.w	r1, r4, r5
   470ec:	d104      	bne.n	470f8 <z_tick_sleep+0x18>
	z_impl_k_yield();
   470ee:	f7ff ffb5 	bl	4705c <z_impl_k_yield>
		k_yield();
		return 0;
   470f2:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   470f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   470f8:	f06f 0101 	mvn.w	r1, #1
   470fc:	1a0a      	subs	r2, r1, r0
   470fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   47102:	eb61 0305 	sbc.w	r3, r1, r5
   47106:	2a01      	cmp	r2, #1
   47108:	f173 0300 	sbcs.w	r3, r3, #0
   4710c:	da2a      	bge.n	47164 <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   4710e:	f002 f8da 	bl	492c6 <sys_clock_tick_get_32>
   47112:	1906      	adds	r6, r0, r4
   47114:	f04f 0320 	mov.w	r3, #32
   47118:	f3ef 8811 	mrs	r8, BASEPRI
   4711c:	f383 8812 	msr	BASEPRI_MAX, r3
   47120:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   47124:	4f11      	ldr	r7, [pc, #68]	; (4716c <z_tick_sleep+0x8c>)
   47126:	4b12      	ldr	r3, [pc, #72]	; (47170 <z_tick_sleep+0x90>)
   47128:	68b8      	ldr	r0, [r7, #8]
   4712a:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   4712c:	f7ff fe9e 	bl	46e6c <unready_thread>
	z_add_thread_timeout(_current, timeout);
   47130:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   47132:	4910      	ldr	r1, [pc, #64]	; (47174 <z_tick_sleep+0x94>)
   47134:	4622      	mov	r2, r4
   47136:	462b      	mov	r3, r5
   47138:	3018      	adds	r0, #24
   4713a:	f000 f8f3 	bl	47324 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   4713e:	68ba      	ldr	r2, [r7, #8]
   47140:	4640      	mov	r0, r8
   47142:	7b53      	ldrb	r3, [r2, #13]
   47144:	f043 0310 	orr.w	r3, r3, #16
   47148:	7353      	strb	r3, [r2, #13]
   4714a:	f7fb f9eb 	bl	42524 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   4714e:	f002 f8ba 	bl	492c6 <sys_clock_tick_get_32>
   47152:	1a30      	subs	r0, r6, r0
   47154:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   47158:	2801      	cmp	r0, #1
   4715a:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   4715e:	bfb8      	it	lt
   47160:	2000      	movlt	r0, #0
   47162:	e7c7      	b.n	470f4 <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   47164:	f06f 0601 	mvn.w	r6, #1
   47168:	1a36      	subs	r6, r6, r0
   4716a:	e7d3      	b.n	47114 <z_tick_sleep+0x34>
   4716c:	2001ade8 	.word	0x2001ade8
   47170:	2001ae10 	.word	0x2001ae10
   47174:	0004912f 	.word	0x0004912f

00047178 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   47178:	b508      	push	{r3, lr}
   4717a:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   4717c:	3301      	adds	r3, #1
   4717e:	bf08      	it	eq
   47180:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   47184:	d003      	beq.n	4718e <z_impl_k_sleep+0x16>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   47186:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ticks = z_tick_sleep(ticks);
   4718a:	f7ff bfa9 	b.w	470e0 <z_tick_sleep>
		k_thread_suspend(_current);
   4718e:	4b03      	ldr	r3, [pc, #12]	; (4719c <z_impl_k_sleep+0x24>)
   47190:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   47192:	f7ff ff09 	bl	46fa8 <z_impl_k_thread_suspend>
}
   47196:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   4719a:	bd08      	pop	{r3, pc}
   4719c:	2001ade8 	.word	0x2001ade8

000471a0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   471a0:	4b01      	ldr	r3, [pc, #4]	; (471a8 <z_impl_z_current_get+0x8>)
   471a2:	6898      	ldr	r0, [r3, #8]
   471a4:	4770      	bx	lr
   471a6:	bf00      	nop
   471a8:	2001ade8 	.word	0x2001ade8

000471ac <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   471ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   471b0:	4604      	mov	r4, r0
   471b2:	f04f 0320 	mov.w	r3, #32
   471b6:	f3ef 8611 	mrs	r6, BASEPRI
   471ba:	f383 8812 	msr	BASEPRI_MAX, r3
   471be:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   471c2:	7b43      	ldrb	r3, [r0, #13]
   471c4:	071a      	lsls	r2, r3, #28
   471c6:	d505      	bpl.n	471d4 <z_thread_abort+0x28>
	__asm__ volatile(
   471c8:	f386 8811 	msr	BASEPRI, r6
   471cc:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   471d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   471d4:	f023 0220 	bic.w	r2, r3, #32
   471d8:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   471dc:	09d2      	lsrs	r2, r2, #7
   471de:	d120      	bne.n	47222 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   471e0:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   471e2:	68a3      	ldr	r3, [r4, #8]
   471e4:	b113      	cbz	r3, 471ec <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   471e6:	4620      	mov	r0, r4
   471e8:	f001 ff43 	bl	49072 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   471ec:	f104 0018 	add.w	r0, r4, #24
   471f0:	f002 f829 	bl	49246 <z_abort_timeout>
   471f4:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   471f8:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   471fc:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   471fe:	42bd      	cmp	r5, r7
   47200:	d000      	beq.n	47204 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   47202:	b9b5      	cbnz	r5, 47232 <z_thread_abort+0x86>
		update_cache(1);
   47204:	2001      	movs	r0, #1
   47206:	f7ff fd3b 	bl	46c80 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   4720a:	4b10      	ldr	r3, [pc, #64]	; (4724c <z_thread_abort+0xa0>)
   4720c:	689b      	ldr	r3, [r3, #8]
   4720e:	42a3      	cmp	r3, r4
   47210:	d1da      	bne.n	471c8 <z_thread_abort+0x1c>
   47212:	f3ef 8305 	mrs	r3, IPSR
   47216:	2b00      	cmp	r3, #0
   47218:	d1d6      	bne.n	471c8 <z_thread_abort+0x1c>
   4721a:	4630      	mov	r0, r6
   4721c:	f7fb f982 	bl	42524 <arch_swap>
	return ret;
   47220:	e7d2      	b.n	471c8 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   47222:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   47226:	f043 0308 	orr.w	r3, r3, #8
   4722a:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   4722c:	f001 ff19 	bl	49062 <sys_dlist_remove>
}
   47230:	e7d7      	b.n	471e2 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   47232:	4628      	mov	r0, r5
   47234:	f001 ff1d 	bl	49072 <unpend_thread_no_timeout>
   47238:	f105 0018 	add.w	r0, r5, #24
   4723c:	f002 f803 	bl	49246 <z_abort_timeout>
		ready_thread(thread);
   47240:	4628      	mov	r0, r5
   47242:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   47246:	f7ff fdbb 	bl	46dc0 <ready_thread>
   4724a:	e7d7      	b.n	471fc <z_thread_abort+0x50>
   4724c:	2001ade8 	.word	0x2001ade8

00047250 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   47250:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   47252:	4806      	ldr	r0, [pc, #24]	; (4726c <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   47254:	4a06      	ldr	r2, [pc, #24]	; (47270 <z_data_copy+0x20>)
   47256:	4907      	ldr	r1, [pc, #28]	; (47274 <z_data_copy+0x24>)
   47258:	1a12      	subs	r2, r2, r0
   4725a:	f001 fb64 	bl	48926 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   4725e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   47262:	4a05      	ldr	r2, [pc, #20]	; (47278 <z_data_copy+0x28>)
   47264:	4905      	ldr	r1, [pc, #20]	; (4727c <z_data_copy+0x2c>)
   47266:	4806      	ldr	r0, [pc, #24]	; (47280 <z_data_copy+0x30>)
   47268:	f001 bb5d 	b.w	48926 <memcpy>
   4726c:	2001a500 	.word	0x2001a500
   47270:	2001a6d0 	.word	0x2001a6d0
   47274:	0004a414 	.word	0x0004a414
   47278:	00000000 	.word	0x00000000
   4727c:	0004a3fc 	.word	0x0004a3fc
   47280:	2001a500 	.word	0x2001a500

00047284 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   47284:	4b03      	ldr	r3, [pc, #12]	; (47294 <elapsed+0x10>)
   47286:	681b      	ldr	r3, [r3, #0]
   47288:	b90b      	cbnz	r3, 4728e <elapsed+0xa>
   4728a:	f7fc bddf 	b.w	43e4c <sys_clock_elapsed>
}
   4728e:	2000      	movs	r0, #0
   47290:	4770      	bx	lr
   47292:	bf00      	nop
   47294:	2001ae1c 	.word	0x2001ae1c

00047298 <remove_timeout>:
{
   47298:	b530      	push	{r4, r5, lr}
   4729a:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   4729c:	b168      	cbz	r0, 472ba <remove_timeout+0x22>
   4729e:	4a0a      	ldr	r2, [pc, #40]	; (472c8 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   472a0:	6852      	ldr	r2, [r2, #4]
   472a2:	4290      	cmp	r0, r2
   472a4:	d009      	beq.n	472ba <remove_timeout+0x22>
	if (next(t) != NULL) {
   472a6:	b143      	cbz	r3, 472ba <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   472a8:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   472ac:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   472b0:	1912      	adds	r2, r2, r4
   472b2:	eb45 0101 	adc.w	r1, r5, r1
   472b6:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   472ba:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   472bc:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   472be:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   472c0:	2300      	movs	r3, #0
	node->prev = NULL;
   472c2:	e9c0 3300 	strd	r3, r3, [r0]
}
   472c6:	bd30      	pop	{r4, r5, pc}
   472c8:	2001a5ec 	.word	0x2001a5ec

000472cc <next_timeout>:

static int32_t next_timeout(void)
{
   472cc:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   472ce:	4b13      	ldr	r3, [pc, #76]	; (4731c <next_timeout+0x50>)
   472d0:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   472d2:	429c      	cmp	r4, r3
   472d4:	bf08      	it	eq
   472d6:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   472d8:	f7ff ffd4 	bl	47284 <elapsed>
   472dc:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   472de:	b1bc      	cbz	r4, 47310 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   472e0:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   472e4:	1b40      	subs	r0, r0, r5
   472e6:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   472ea:	2801      	cmp	r0, #1
   472ec:	f171 0300 	sbcs.w	r3, r1, #0
   472f0:	db11      	blt.n	47316 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   472f2:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   472f6:	2300      	movs	r3, #0
   472f8:	4282      	cmp	r2, r0
   472fa:	eb73 0401 	sbcs.w	r4, r3, r1
   472fe:	da00      	bge.n	47302 <next_timeout+0x36>
   47300:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   47302:	4b07      	ldr	r3, [pc, #28]	; (47320 <next_timeout+0x54>)
   47304:	691b      	ldr	r3, [r3, #16]
   47306:	b113      	cbz	r3, 4730e <next_timeout+0x42>
   47308:	4298      	cmp	r0, r3
   4730a:	bfa8      	it	ge
   4730c:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   4730e:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   47310:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   47314:	e7f5      	b.n	47302 <next_timeout+0x36>
   47316:	2000      	movs	r0, #0
   47318:	e7f3      	b.n	47302 <next_timeout+0x36>
   4731a:	bf00      	nop
   4731c:	2001a5ec 	.word	0x2001a5ec
   47320:	2001ade8 	.word	0x2001ade8

00047324 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47324:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   47328:	bf08      	it	eq
   4732a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   4732e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   47332:	4604      	mov	r4, r0
   47334:	4692      	mov	sl, r2
   47336:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   47338:	d073      	beq.n	47422 <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   4733a:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   4733c:	f04f 0320 	mov.w	r3, #32
   47340:	f3ef 8511 	mrs	r5, BASEPRI
   47344:	f383 8812 	msr	BASEPRI_MAX, r3
   47348:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   4734c:	f06f 0301 	mvn.w	r3, #1
   47350:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   47354:	ebb3 080a 	subs.w	r8, r3, sl
   47358:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   4735c:	f1b8 0f00 	cmp.w	r8, #0
   47360:	f179 0100 	sbcs.w	r1, r9, #0
   47364:	db1c      	blt.n	473a0 <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   47366:	4830      	ldr	r0, [pc, #192]	; (47428 <z_add_timeout+0x104>)
   47368:	e9d0 1000 	ldrd	r1, r0, [r0]
   4736c:	1a5b      	subs	r3, r3, r1
   4736e:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   47372:	ebb3 060a 	subs.w	r6, r3, sl
   47376:	eb62 070b 	sbc.w	r7, r2, fp
   4737a:	2e01      	cmp	r6, #1
   4737c:	f177 0300 	sbcs.w	r3, r7, #0
   47380:	bfbc      	itt	lt
   47382:	2601      	movlt	r6, #1
   47384:	2700      	movlt	r7, #0
   47386:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   4738a:	4a28      	ldr	r2, [pc, #160]	; (4742c <z_add_timeout+0x108>)
   4738c:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47390:	4293      	cmp	r3, r2
   47392:	d11e      	bne.n	473d2 <z_add_timeout+0xae>
	node->prev = tail;
   47394:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   47398:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   4739c:	6054      	str	r4, [r2, #4]
}
   4739e:	e02d      	b.n	473fc <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   473a0:	f7ff ff70 	bl	47284 <elapsed>
   473a4:	f11a 0301 	adds.w	r3, sl, #1
   473a8:	9300      	str	r3, [sp, #0]
   473aa:	f14b 0300 	adc.w	r3, fp, #0
   473ae:	9301      	str	r3, [sp, #4]
   473b0:	e9dd 2300 	ldrd	r2, r3, [sp]
   473b4:	1812      	adds	r2, r2, r0
   473b6:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   473ba:	e9c4 2304 	strd	r2, r3, [r4, #16]
   473be:	e7e4      	b.n	4738a <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   473c0:	ebb6 0008 	subs.w	r0, r6, r8
   473c4:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   473c8:	4563      	cmp	r3, ip
   473ca:	e9c4 0104 	strd	r0, r1, [r4, #16]
   473ce:	d0e1      	beq.n	47394 <z_add_timeout+0x70>
   473d0:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   473d2:	2b00      	cmp	r3, #0
   473d4:	d0de      	beq.n	47394 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   473d6:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   473da:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   473de:	4546      	cmp	r6, r8
   473e0:	eb77 0109 	sbcs.w	r1, r7, r9
   473e4:	daec      	bge.n	473c0 <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   473e6:	ebb8 0006 	subs.w	r0, r8, r6
   473ea:	eb69 0107 	sbc.w	r1, r9, r7
   473ee:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   473f2:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   473f4:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   473f8:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   473fa:	605c      	str	r4, [r3, #4]
	return list->head == list;
   473fc:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   473fe:	4293      	cmp	r3, r2
   47400:	d00b      	beq.n	4741a <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   47402:	429c      	cmp	r4, r3
   47404:	d109      	bne.n	4741a <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   47406:	f7ff ff61 	bl	472cc <next_timeout>

			if (next_time == 0 ||
   4740a:	b118      	cbz	r0, 47414 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   4740c:	4b08      	ldr	r3, [pc, #32]	; (47430 <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   4740e:	691b      	ldr	r3, [r3, #16]
   47410:	4283      	cmp	r3, r0
   47412:	d002      	beq.n	4741a <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   47414:	2100      	movs	r1, #0
   47416:	f7fc fce5 	bl	43de4 <sys_clock_set_timeout>
	__asm__ volatile(
   4741a:	f385 8811 	msr	BASEPRI, r5
   4741e:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   47422:	b003      	add	sp, #12
   47424:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   47428:	2001a8c0 	.word	0x2001a8c0
   4742c:	2001a5ec 	.word	0x2001a5ec
   47430:	2001ade8 	.word	0x2001ade8

00047434 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   47434:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   47438:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   4743a:	f7ff fc7f 	bl	46d3c <z_time_slice>
	__asm__ volatile(
   4743e:	f04f 0320 	mov.w	r3, #32
   47442:	f3ef 8411 	mrs	r4, BASEPRI
   47446:	f383 8812 	msr	BASEPRI_MAX, r3
   4744a:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   4744e:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 47500 <sys_clock_announce+0xcc>
   47452:	4d2a      	ldr	r5, [pc, #168]	; (474fc <sys_clock_announce+0xc8>)
   47454:	4651      	mov	r1, sl
	return list->head == list;
   47456:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 47504 <sys_clock_announce+0xd0>
   4745a:	602e      	str	r6, [r5, #0]
   4745c:	f8d5 c000 	ldr.w	ip, [r5]
   47460:	f8db 0000 	ldr.w	r0, [fp]
   47464:	4662      	mov	r2, ip
   47466:	e9da 8900 	ldrd	r8, r9, [sl]
   4746a:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4746c:	4558      	cmp	r0, fp
   4746e:	e9cd 2300 	strd	r2, r3, [sp]
   47472:	d00d      	beq.n	47490 <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   47474:	b160      	cbz	r0, 47490 <sys_clock_announce+0x5c>
   47476:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   4747a:	45b4      	cmp	ip, r6
   4747c:	41bb      	sbcs	r3, r7
   4747e:	da1d      	bge.n	474bc <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   47480:	9b00      	ldr	r3, [sp, #0]
   47482:	ebb6 0c03 	subs.w	ip, r6, r3
   47486:	9b01      	ldr	r3, [sp, #4]
   47488:	eb67 0603 	sbc.w	r6, r7, r3
   4748c:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   47490:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   47492:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   47494:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   47496:	eb13 0208 	adds.w	r2, r3, r8
   4749a:	9b01      	ldr	r3, [sp, #4]
   4749c:	eb43 0309 	adc.w	r3, r3, r9
   474a0:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   474a4:	f7ff ff12 	bl	472cc <next_timeout>
   474a8:	4631      	mov	r1, r6
   474aa:	f7fc fc9b 	bl	43de4 <sys_clock_set_timeout>
	__asm__ volatile(
   474ae:	f384 8811 	msr	BASEPRI, r4
   474b2:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   474b6:	b003      	add	sp, #12
   474b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   474bc:	2200      	movs	r2, #0
   474be:	2300      	movs	r3, #0
		curr_tick += dt;
   474c0:	eb18 0806 	adds.w	r8, r8, r6
   474c4:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   474c8:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   474cc:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   474d0:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   474d4:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   474d6:	f7ff fedf 	bl	47298 <remove_timeout>
   474da:	f384 8811 	msr	BASEPRI, r4
   474de:	f3bf 8f6f 	isb	sy
		t->fn(t);
   474e2:	6883      	ldr	r3, [r0, #8]
   474e4:	4798      	blx	r3
	__asm__ volatile(
   474e6:	f04f 0320 	mov.w	r3, #32
   474ea:	f3ef 8411 	mrs	r4, BASEPRI
   474ee:	f383 8812 	msr	BASEPRI_MAX, r3
   474f2:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   474f6:	4902      	ldr	r1, [pc, #8]	; (47500 <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   474f8:	e7b0      	b.n	4745c <sys_clock_announce+0x28>
   474fa:	bf00      	nop
   474fc:	2001ae1c 	.word	0x2001ae1c
   47500:	2001a8c0 	.word	0x2001a8c0
   47504:	2001a5ec 	.word	0x2001a5ec

00047508 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   47508:	b510      	push	{r4, lr}
   4750a:	f04f 0320 	mov.w	r3, #32
   4750e:	f3ef 8411 	mrs	r4, BASEPRI
   47512:	f383 8812 	msr	BASEPRI_MAX, r3
   47516:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   4751a:	f7fc fc97 	bl	43e4c <sys_clock_elapsed>
   4751e:	4b06      	ldr	r3, [pc, #24]	; (47538 <sys_clock_tick_get+0x30>)
   47520:	e9d3 2300 	ldrd	r2, r3, [r3]
   47524:	1812      	adds	r2, r2, r0
   47526:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   4752a:	f384 8811 	msr	BASEPRI, r4
   4752e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   47532:	4610      	mov	r0, r2
   47534:	4619      	mov	r1, r3
   47536:	bd10      	pop	{r4, pc}
   47538:	2001a8c0 	.word	0x2001a8c0

0004753c <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   4753c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4753e:	4604      	mov	r4, r0
	__asm__ volatile(
   47540:	f04f 0320 	mov.w	r3, #32
   47544:	f3ef 8511 	mrs	r5, BASEPRI
   47548:	f383 8812 	msr	BASEPRI_MAX, r3
   4754c:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   47550:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   47554:	1c56      	adds	r6, r2, #1
   47556:	f143 0700 	adc.w	r7, r3, #0
   4755a:	2f00      	cmp	r7, #0
   4755c:	bf08      	it	eq
   4755e:	2e02      	cmpeq	r6, #2
   47560:	d302      	bcc.n	47568 <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47562:	4917      	ldr	r1, [pc, #92]	; (475c0 <z_timer_expiration_handler+0x84>)
   47564:	f7ff fede 	bl	47324 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   47568:	6b23      	ldr	r3, [r4, #48]	; 0x30
   4756a:	3301      	adds	r3, #1
   4756c:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   4756e:	6a23      	ldr	r3, [r4, #32]
   47570:	b173      	cbz	r3, 47590 <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   47572:	f385 8811 	msr	BASEPRI, r5
   47576:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   4757a:	4620      	mov	r0, r4
   4757c:	6a23      	ldr	r3, [r4, #32]
   4757e:	4798      	blx	r3
	__asm__ volatile(
   47580:	f04f 0320 	mov.w	r3, #32
   47584:	f3ef 8511 	mrs	r5, BASEPRI
   47588:	f383 8812 	msr	BASEPRI_MAX, r3
   4758c:	f3bf 8f6f 	isb	sy
	return list->head == list;
   47590:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   47594:	42a6      	cmp	r6, r4
   47596:	d000      	beq.n	4759a <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   47598:	b926      	cbnz	r6, 475a4 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   4759a:	f385 8811 	msr	BASEPRI, r5
   4759e:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   475a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   475a4:	4630      	mov	r0, r6
   475a6:	f001 fd6e 	bl	49086 <z_unpend_thread_no_timeout>
   475aa:	2300      	movs	r3, #0
   475ac:	67b3      	str	r3, [r6, #120]	; 0x78
   475ae:	f385 8811 	msr	BASEPRI, r5
   475b2:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   475b6:	4630      	mov	r0, r6
}
   475b8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   475bc:	f001 bda7 	b.w	4910e <z_ready_thread>
   475c0:	0004753d 	.word	0x0004753d

000475c4 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   475c4:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   475c8:	4619      	mov	r1, r3
   475ca:	4606      	mov	r6, r0
   475cc:	4610      	mov	r0, r2
   475ce:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   475d2:	1c4c      	adds	r4, r1, #1
   475d4:	bf08      	it	eq
   475d6:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   475da:	4680      	mov	r8, r0
   475dc:	4689      	mov	r9, r1
   475de:	d04c      	beq.n	4767a <z_impl_k_timer_start+0xb6>
   475e0:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   475e2:	1c6b      	adds	r3, r5, #1
   475e4:	bf08      	it	eq
   475e6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   475ea:	4614      	mov	r4, r2
   475ec:	d019      	beq.n	47622 <z_impl_k_timer_start+0x5e>
   475ee:	ea54 0305 	orrs.w	r3, r4, r5
   475f2:	d016      	beq.n	47622 <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   475f4:	f06f 0301 	mvn.w	r3, #1
   475f8:	ebb3 0a02 	subs.w	sl, r3, r2
   475fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   47600:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   47604:	f1ba 0f00 	cmp.w	sl, #0
   47608:	f17b 0300 	sbcs.w	r3, fp, #0
   4760c:	da09      	bge.n	47622 <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   4760e:	f112 34ff 	adds.w	r4, r2, #4294967295	; 0xffffffff
   47612:	f145 35ff 	adc.w	r5, r5, #4294967295	; 0xffffffff
   47616:	2c01      	cmp	r4, #1
   47618:	f175 0300 	sbcs.w	r3, r5, #0
   4761c:	bfbc      	itt	lt
   4761e:	2401      	movlt	r4, #1
   47620:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   47622:	f06f 0301 	mvn.w	r3, #1
   47626:	1a1b      	subs	r3, r3, r0
   47628:	9300      	str	r3, [sp, #0]
   4762a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4762e:	eb63 0301 	sbc.w	r3, r3, r1
   47632:	9301      	str	r3, [sp, #4]
   47634:	e9dd 2300 	ldrd	r2, r3, [sp]
   47638:	2a00      	cmp	r2, #0
   4763a:	f173 0300 	sbcs.w	r3, r3, #0
   4763e:	da0c      	bge.n	4765a <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   47640:	f110 38ff 	adds.w	r8, r0, #4294967295	; 0xffffffff
   47644:	f141 39ff 	adc.w	r9, r1, #4294967295	; 0xffffffff
   47648:	f1b8 0f00 	cmp.w	r8, #0
   4764c:	f179 0300 	sbcs.w	r3, r9, #0
   47650:	bfbc      	itt	lt
   47652:	f04f 0800 	movlt.w	r8, #0
   47656:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   4765a:	4630      	mov	r0, r6
   4765c:	f001 fdf3 	bl	49246 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   47660:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47662:	4642      	mov	r2, r8
	timer->status = 0U;
   47664:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47666:	4630      	mov	r0, r6
   47668:	464b      	mov	r3, r9
   4766a:	4905      	ldr	r1, [pc, #20]	; (47680 <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   4766c:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   47670:	b002      	add	sp, #8
   47672:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   47676:	f7ff be55 	b.w	47324 <z_add_timeout>
}
   4767a:	b002      	add	sp, #8
   4767c:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   47680:	0004753d 	.word	0x0004753d

00047684 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   47684:	460a      	mov	r2, r1
	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   47686:	4601      	mov	r1, r0
   47688:	4801      	ldr	r0, [pc, #4]	; (47690 <k_aligned_alloc+0xc>)
   4768a:	f001 be78 	b.w	4937e <z_heap_aligned_alloc>
   4768e:	bf00      	nop
   47690:	2001a670 	.word	0x2001a670

00047694 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   47694:	4a02      	ldr	r2, [pc, #8]	; (476a0 <boot_banner+0xc>)
   47696:	4903      	ldr	r1, [pc, #12]	; (476a4 <boot_banner+0x10>)
   47698:	4803      	ldr	r0, [pc, #12]	; (476a8 <boot_banner+0x14>)
   4769a:	f000 ba7c 	b.w	47b96 <printk>
   4769e:	bf00      	nop
   476a0:	00049954 	.word	0x00049954
   476a4:	0004a3c4 	.word	0x0004a3c4
   476a8:	0004a3d3 	.word	0x0004a3d3

000476ac <tfm_platform_system_reset>:
#include "tfm_ns_interface.h"
#include "tfm_veneers.h"

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   476ac:	2300      	movs	r3, #0
{
   476ae:	b507      	push	{r0, r1, r2, lr}
    return (enum tfm_platform_err_t) tfm_ns_interface_dispatch(
   476b0:	461a      	mov	r2, r3
   476b2:	4619      	mov	r1, r3
   476b4:	9300      	str	r3, [sp, #0]
   476b6:	4803      	ldr	r0, [pc, #12]	; (476c4 <tfm_platform_system_reset+0x18>)
   476b8:	f7fc fd94 	bl	441e4 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_platform_sp_system_reset_veneer,
                                0,
                                0,
                                0,
                                0);
}
   476bc:	b003      	add	sp, #12
   476be:	f85d fb04 	ldr.w	pc, [sp], #4
   476c2:	bf00      	nop
   476c4:	00037e41 	.word	0x00037e41

000476c8 <psa_import_key>:

psa_status_t psa_import_key(const psa_key_attributes_t *attributes,
                            const uint8_t *data,
                            size_t data_length,
                            psa_key_id_t *key)
{
   476c8:	b5f0      	push	{r4, r5, r6, r7, lr}
   476ca:	b097      	sub	sp, #92	; 0x5c
   476cc:	4607      	mov	r7, r0
   476ce:	460e      	mov	r6, r1
   476d0:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   476d2:	2100      	movs	r1, #0
   476d4:	2228      	movs	r2, #40	; 0x28
   476d6:	a80c      	add	r0, sp, #48	; 0x30
{
   476d8:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   476da:	f001 f92f 	bl	4893c <memset>
        .sfn_id = TFM_CRYPTO_IMPORT_KEY_SID,
    };
    psa_invec in_vec[] = {
   476de:	aa0b      	add	r2, sp, #44	; 0x2c
    struct tfm_crypto_pack_iovec iov = {
   476e0:	2304      	movs	r3, #4
    psa_invec in_vec[] = {
   476e2:	9205      	str	r2, [sp, #20]
   476e4:	222c      	movs	r2, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
        {.base = data, .len = data_length}
    };
    psa_outvec out_vec[] = {
   476e6:	e9cd 4303 	strd	r4, r3, [sp, #12]
    psa_invec in_vec[] = {
   476ea:	e9cd 2706 	strd	r2, r7, [sp, #24]
    struct tfm_crypto_pack_iovec iov = {
   476ee:	930b      	str	r3, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   476f0:	2214      	movs	r2, #20
        {.base = key, .len = sizeof(psa_key_id_t)}
    };

    status = API_DISPATCH(tfm_crypto_import_key,
   476f2:	2301      	movs	r3, #1
    psa_invec in_vec[] = {
   476f4:	e9cd 2608 	strd	r2, r6, [sp, #32]
    status = API_DISPATCH(tfm_crypto_import_key,
   476f8:	9300      	str	r3, [sp, #0]
   476fa:	2203      	movs	r2, #3
   476fc:	ab03      	add	r3, sp, #12
   476fe:	a905      	add	r1, sp, #20
   47700:	4802      	ldr	r0, [pc, #8]	; (4770c <psa_import_key+0x44>)
    psa_invec in_vec[] = {
   47702:	950a      	str	r5, [sp, #40]	; 0x28
    status = API_DISPATCH(tfm_crypto_import_key,
   47704:	f7fc fd6e 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_IMPORT_KEY);

    return status;
}
   47708:	b017      	add	sp, #92	; 0x5c
   4770a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4770c:	00037e91 	.word	0x00037e91

00047710 <psa_destroy_key>:

psa_status_t psa_destroy_key(psa_key_id_t key)
{
   47710:	b510      	push	{r4, lr}
   47712:	b090      	sub	sp, #64	; 0x40
   47714:	4604      	mov	r4, r0
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47716:	2228      	movs	r2, #40	; 0x28
   47718:	2100      	movs	r1, #0
   4771a:	a806      	add	r0, sp, #24
   4771c:	f001 f90e 	bl	4893c <memset>
   47720:	2305      	movs	r3, #5
   47722:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_id = key,
    };
    psa_invec in_vec[] = {
   47724:	ab05      	add	r3, sp, #20
   47726:	9303      	str	r3, [sp, #12]
   47728:	232c      	movs	r3, #44	; 0x2c
   4772a:	9304      	str	r3, [sp, #16]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
   4772c:	2300      	movs	r3, #0
   4772e:	2201      	movs	r2, #1
   47730:	9300      	str	r3, [sp, #0]
   47732:	a903      	add	r1, sp, #12
   47734:	4802      	ldr	r0, [pc, #8]	; (47740 <psa_destroy_key+0x30>)
    struct tfm_crypto_pack_iovec iov = {
   47736:	9407      	str	r4, [sp, #28]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
   47738:	f7fc fd54 	bl	441e4 <tfm_ns_interface_dispatch>
                                    TFM_CRYPTO_DESTROY_KEY);

    return status;
}
   4773c:	b010      	add	sp, #64	; 0x40
   4773e:	bd10      	pop	{r4, pc}
   47740:	00037d09 	.word	0x00037d09

00047744 <psa_reset_key_attributes>:
                          TFM_CRYPTO_GET_KEY_ATTRIBUTES);
    return status;
}

void psa_reset_key_attributes(psa_key_attributes_t *attributes)
{
   47744:	b510      	push	{r4, lr}
   47746:	b092      	sub	sp, #72	; 0x48
   47748:	4604      	mov	r4, r0
    struct tfm_crypto_pack_iovec iov = {
   4774a:	2228      	movs	r2, #40	; 0x28
   4774c:	2100      	movs	r1, #0
   4774e:	a808      	add	r0, sp, #32
   47750:	f001 f8f4 	bl	4893c <memset>
        .sfn_id = TFM_CRYPTO_RESET_KEY_ATTRIBUTES_SID,
    };
    psa_invec in_vec[] = {
   47754:	ab07      	add	r3, sp, #28
   47756:	9303      	str	r3, [sp, #12]
   47758:	232c      	movs	r3, #44	; 0x2c
    struct tfm_crypto_pack_iovec iov = {
   4775a:	2201      	movs	r2, #1
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
   4775c:	e9cd 3404 	strd	r3, r4, [sp, #16]
   47760:	2314      	movs	r3, #20
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
    };

    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   47762:	9200      	str	r2, [sp, #0]
    psa_outvec out_vec[] = {
   47764:	9306      	str	r3, [sp, #24]
    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   47766:	a903      	add	r1, sp, #12
   47768:	446b      	add	r3, sp
   4776a:	4803      	ldr	r0, [pc, #12]	; (47778 <psa_reset_key_attributes+0x34>)
    struct tfm_crypto_pack_iovec iov = {
   4776c:	9207      	str	r2, [sp, #28]
    (void)API_DISPATCH(tfm_crypto_reset_key_attributes,
   4776e:	f7fc fd39 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_RESET_KEY_ATTRIBUTES);
    return;
}
   47772:	b012      	add	sp, #72	; 0x48
   47774:	bd10      	pop	{r4, pc}
   47776:	bf00      	nop
   47778:	00037d69 	.word	0x00037d69

0004777c <psa_export_public_key>:

psa_status_t psa_export_public_key(psa_key_id_t key,
                                   uint8_t *data,
                                   size_t data_size,
                                   size_t *data_length)
{
   4777c:	b5f0      	push	{r4, r5, r6, r7, lr}
   4777e:	b093      	sub	sp, #76	; 0x4c
   47780:	4607      	mov	r7, r0
   47782:	460e      	mov	r6, r1
   47784:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47786:	2100      	movs	r1, #0
   47788:	2228      	movs	r2, #40	; 0x28
   4778a:	a808      	add	r0, sp, #32
{
   4778c:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   4778e:	f001 f8d5 	bl	4893c <memset>
   47792:	2307      	movs	r3, #7
   47794:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_EXPORT_PUBLIC_KEY_SID,
        .key_id = key,
    };

    psa_invec in_vec[] = {
   47796:	ab07      	add	r3, sp, #28
    };
    psa_outvec out_vec[] = {
        {.base = data, .len = data_size}
    };

    status = API_DISPATCH(tfm_crypto_export_public_key,
   47798:	2201      	movs	r2, #1
    psa_invec in_vec[] = {
   4779a:	9303      	str	r3, [sp, #12]
   4779c:	232c      	movs	r3, #44	; 0x2c
    status = API_DISPATCH(tfm_crypto_export_public_key,
   4779e:	9200      	str	r2, [sp, #0]
    psa_outvec out_vec[] = {
   477a0:	e9cd 3604 	strd	r3, r6, [sp, #16]
    status = API_DISPATCH(tfm_crypto_export_public_key,
   477a4:	a903      	add	r1, sp, #12
   477a6:	ab05      	add	r3, sp, #20
   477a8:	4804      	ldr	r0, [pc, #16]	; (477bc <psa_export_public_key+0x40>)
    struct tfm_crypto_pack_iovec iov = {
   477aa:	9709      	str	r7, [sp, #36]	; 0x24
    psa_outvec out_vec[] = {
   477ac:	9506      	str	r5, [sp, #24]
    status = API_DISPATCH(tfm_crypto_export_public_key,
   477ae:	f7fc fd19 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_EXPORT_PUBLIC_KEY);

    *data_length = out_vec[0].len;
   477b2:	9b06      	ldr	r3, [sp, #24]
   477b4:	6023      	str	r3, [r4, #0]

    return status;
}
   477b6:	b013      	add	sp, #76	; 0x4c
   477b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   477ba:	bf00      	nop
   477bc:	00037e79 	.word	0x00037e79

000477c0 <psa_hash_compute>:
                              const uint8_t *input,
                              size_t input_length,
                              uint8_t *hash,
                              size_t hash_size,
                              size_t *hash_length)
{
   477c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   477c2:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   477c4:	2228      	movs	r2, #40	; 0x28
{
   477c6:	b095      	sub	sp, #84	; 0x54
   477c8:	4607      	mov	r7, r0
   477ca:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   477cc:	eb0d 0002 	add.w	r0, sp, r2
   477d0:	2100      	movs	r1, #0
{
   477d2:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   477d4:	f001 f8b2 	bl	4893c <memset>
   477d8:	230a      	movs	r3, #10
   477da:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_HASH_COMPUTE_SID,
        .alg = alg,
    };

    psa_invec in_vec[] = {
   477dc:	ab09      	add	r3, sp, #36	; 0x24
   477de:	9305      	str	r3, [sp, #20]
   477e0:	232c      	movs	r3, #44	; 0x2c
   477e2:	e9cd 3606 	strd	r3, r6, [sp, #24]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = input, .len = input_length},
    };

    psa_outvec out_vec[] = {
   477e6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = hash, .len = hash_size}
    };

    status = API_DISPATCH(tfm_crypto_hash_compute,
   477e8:	2202      	movs	r2, #2
    psa_outvec out_vec[] = {
   477ea:	9304      	str	r3, [sp, #16]
    status = API_DISPATCH(tfm_crypto_hash_compute,
   477ec:	2301      	movs	r3, #1
   477ee:	a905      	add	r1, sp, #20
   477f0:	9300      	str	r3, [sp, #0]
   477f2:	4806      	ldr	r0, [pc, #24]	; (4780c <psa_hash_compute+0x4c>)
   477f4:	ab03      	add	r3, sp, #12
    struct tfm_crypto_pack_iovec iov = {
   477f6:	970c      	str	r7, [sp, #48]	; 0x30
    psa_invec in_vec[] = {
   477f8:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
   477fa:	9403      	str	r4, [sp, #12]
    status = API_DISPATCH(tfm_crypto_hash_compute,
   477fc:	f7fc fcf2 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_HASH_COMPUTE);

    *hash_length = out_vec[0].len;
   47800:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   47802:	9a04      	ldr	r2, [sp, #16]
   47804:	601a      	str	r2, [r3, #0]

    return status;
}
   47806:	b015      	add	sp, #84	; 0x54
   47808:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4780a:	bf00      	nop
   4780c:	00037c81 	.word	0x00037c81

00047810 <psa_sign_hash>:
                           const uint8_t *hash,
                           size_t hash_length,
                           uint8_t *signature,
                           size_t signature_size,
                           size_t *signature_length)
{
   47810:	b5f0      	push	{r4, r5, r6, r7, lr}
   47812:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47814:	2228      	movs	r2, #40	; 0x28
{
   47816:	b095      	sub	sp, #84	; 0x54
   47818:	4607      	mov	r7, r0
   4781a:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   4781c:	eb0d 0002 	add.w	r0, sp, r2
   47820:	2100      	movs	r1, #0
{
   47822:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   47824:	f001 f88a 	bl	4893c <memset>
   47828:	2331      	movs	r3, #49	; 0x31
   4782a:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_SIGN_HASH_SID,
        .key_id = key,
        .alg = alg,
    };

    psa_invec in_vec[] = {
   4782c:	ab09      	add	r3, sp, #36	; 0x24
   4782e:	9305      	str	r3, [sp, #20]
   47830:	232c      	movs	r3, #44	; 0x2c
   47832:	e9cd 3506 	strd	r3, r5, [sp, #24]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = hash, .len = hash_length},
    };
    psa_outvec out_vec[] = {
   47836:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = signature, .len = signature_size},
    };

    status = API_DISPATCH(tfm_crypto_sign_hash,
   47838:	2202      	movs	r2, #2
    psa_outvec out_vec[] = {
   4783a:	9303      	str	r3, [sp, #12]
   4783c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    status = API_DISPATCH(tfm_crypto_sign_hash,
   4783e:	a905      	add	r1, sp, #20
    psa_outvec out_vec[] = {
   47840:	9304      	str	r3, [sp, #16]
    status = API_DISPATCH(tfm_crypto_sign_hash,
   47842:	2301      	movs	r3, #1
   47844:	4806      	ldr	r0, [pc, #24]	; (47860 <psa_sign_hash+0x50>)
   47846:	9300      	str	r3, [sp, #0]
   47848:	ab03      	add	r3, sp, #12
    struct tfm_crypto_pack_iovec iov = {
   4784a:	e9cd 760b 	strd	r7, r6, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   4784e:	9408      	str	r4, [sp, #32]
    status = API_DISPATCH(tfm_crypto_sign_hash,
   47850:	f7fc fcc8 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_SIGN_HASH);

    *signature_length = out_vec[0].len;
   47854:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   47856:	9a04      	ldr	r2, [sp, #16]
   47858:	601a      	str	r2, [r3, #0]

    return status;
}
   4785a:	b015      	add	sp, #84	; 0x54
   4785c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   4785e:	bf00      	nop
   47860:	00037d79 	.word	0x00037d79

00047864 <psa_verify_hash>:
                             psa_algorithm_t alg,
                             const uint8_t *hash,
                             size_t hash_length,
                             const uint8_t *signature,
                             size_t signature_length)
{
   47864:	b5f0      	push	{r4, r5, r6, r7, lr}
   47866:	4615      	mov	r5, r2
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   47868:	2228      	movs	r2, #40	; 0x28
{
   4786a:	b095      	sub	sp, #84	; 0x54
   4786c:	4607      	mov	r7, r0
   4786e:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
   47870:	eb0d 0002 	add.w	r0, sp, r2
   47874:	2100      	movs	r1, #0
{
   47876:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
   47878:	f001 f860 	bl	4893c <memset>
   4787c:	2332      	movs	r3, #50	; 0x32
   4787e:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_VERIFY_HASH_SID,
        .key_id = key,
        .alg = alg
    };

    psa_invec in_vec[] = {
   47880:	ab09      	add	r3, sp, #36	; 0x24
   47882:	9303      	str	r3, [sp, #12]
   47884:	232c      	movs	r3, #44	; 0x2c
   47886:	e9cd 3504 	strd	r3, r5, [sp, #16]
   4788a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = hash, .len = hash_length},
        {.base = signature, .len = signature_length}
    };

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   4788c:	2203      	movs	r2, #3
    psa_invec in_vec[] = {
   4788e:	9307      	str	r3, [sp, #28]
   47890:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   47892:	a903      	add	r1, sp, #12
    psa_invec in_vec[] = {
   47894:	9308      	str	r3, [sp, #32]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   47896:	2300      	movs	r3, #0
   47898:	4804      	ldr	r0, [pc, #16]	; (478ac <psa_verify_hash+0x48>)
   4789a:	9300      	str	r3, [sp, #0]
    struct tfm_crypto_pack_iovec iov = {
   4789c:	e9cd 760b 	strd	r7, r6, [sp, #44]	; 0x2c
    psa_invec in_vec[] = {
   478a0:	9406      	str	r4, [sp, #24]
    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_hash,
   478a2:	f7fc fc9f 	bl	441e4 <tfm_ns_interface_dispatch>
                                    TFM_CRYPTO_VERIFY_HASH);

    return status;
}
   478a6:	b015      	add	sp, #84	; 0x54
   478a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   478aa:	bf00      	nop
   478ac:	00037db9 	.word	0x00037db9

000478b0 <psa_generate_random>:
    return status;
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   478b0:	b530      	push	{r4, r5, lr}
   478b2:	b093      	sub	sp, #76	; 0x4c
   478b4:	4605      	mov	r5, r0
   478b6:	460c      	mov	r4, r1
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   478b8:	2228      	movs	r2, #40	; 0x28
   478ba:	2100      	movs	r1, #0
   478bc:	a808      	add	r0, sp, #32
   478be:	f001 f83d 	bl	4893c <memset>
   478c2:	233f      	movs	r3, #63	; 0x3f
   478c4:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_GENERATE_RANDOM_SID,
    };

    psa_invec in_vec[] = {
   478c6:	ab07      	add	r3, sp, #28
   478c8:	9303      	str	r3, [sp, #12]
   478ca:	232c      	movs	r3, #44	; 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   478cc:	9406      	str	r4, [sp, #24]
   478ce:	e9cd 3504 	strd	r3, r5, [sp, #16]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   478d2:	b144      	cbz	r4, 478e6 <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    status = API_DISPATCH(tfm_crypto_generate_random,
   478d4:	2201      	movs	r2, #1
   478d6:	4805      	ldr	r0, [pc, #20]	; (478ec <psa_generate_random+0x3c>)
   478d8:	9200      	str	r2, [sp, #0]
   478da:	ab05      	add	r3, sp, #20
   478dc:	a903      	add	r1, sp, #12
   478de:	f7fc fc81 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_RANDOM);

    return status;
}
   478e2:	b013      	add	sp, #76	; 0x4c
   478e4:	bd30      	pop	{r4, r5, pc}
        return PSA_SUCCESS;
   478e6:	4620      	mov	r0, r4
   478e8:	e7fb      	b.n	478e2 <psa_generate_random+0x32>
   478ea:	bf00      	nop
   478ec:	00037c11 	.word	0x00037c11

000478f0 <psa_generate_key>:

psa_status_t psa_generate_key(const psa_key_attributes_t *attributes,
                              psa_key_id_t *key)
{
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
   478f0:	2228      	movs	r2, #40	; 0x28
{
   478f2:	b530      	push	{r4, r5, lr}
   478f4:	b095      	sub	sp, #84	; 0x54
   478f6:	4605      	mov	r5, r0
   478f8:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
   478fa:	eb0d 0002 	add.w	r0, sp, r2
   478fe:	2100      	movs	r1, #0
   47900:	f001 f81c 	bl	4893c <memset>
   47904:	2340      	movs	r3, #64	; 0x40
   47906:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_GENERATE_KEY_SID,
    };

    psa_invec in_vec[] = {
   47908:	ab09      	add	r3, sp, #36	; 0x24
   4790a:	9305      	str	r3, [sp, #20]
   4790c:	232c      	movs	r3, #44	; 0x2c
   4790e:	e9cd 3506 	strd	r3, r5, [sp, #24]
   47912:	2314      	movs	r3, #20
   47914:	9308      	str	r3, [sp, #32]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
    };

    psa_outvec out_vec[] = {
   47916:	2304      	movs	r3, #4
   47918:	9304      	str	r3, [sp, #16]
        {.base = key, .len = sizeof(psa_key_id_t)},
    };

    status = API_DISPATCH(tfm_crypto_generate_key,
   4791a:	2301      	movs	r3, #1
   4791c:	2202      	movs	r2, #2
   4791e:	9300      	str	r3, [sp, #0]
   47920:	a905      	add	r1, sp, #20
   47922:	ab03      	add	r3, sp, #12
   47924:	4802      	ldr	r0, [pc, #8]	; (47930 <psa_generate_key+0x40>)
    psa_outvec out_vec[] = {
   47926:	9403      	str	r4, [sp, #12]
    status = API_DISPATCH(tfm_crypto_generate_key,
   47928:	f7fc fc5c 	bl	441e4 <tfm_ns_interface_dispatch>
                          TFM_CRYPTO_GENERATE_KEY);

    return status;
}
   4792c:	b015      	add	sp, #84	; 0x54
   4792e:	bd30      	pop	{r4, r5, pc}
   47930:	00037df9 	.word	0x00037df9

00047934 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   47934:	4770      	bx	lr

00047936 <ethers_keccak256>:
void ethers_keccak256(const uint8_t *data, uint16_t length, uint8_t *result) {
   47936:	b570      	push	{r4, r5, r6, lr}
   47938:	460e      	mov	r6, r1
   4793a:	4605      	mov	r5, r0
   4793c:	4614      	mov	r4, r2
   4793e:	b0e4      	sub	sp, #400	; 0x190
    keccak_init(&context);
   47940:	4668      	mov	r0, sp
   47942:	f000 f87d 	bl	47a40 <keccak_init>
    keccak_update(&context, (const unsigned char*)data, (size_t)length);
   47946:	4632      	mov	r2, r6
   47948:	4629      	mov	r1, r5
   4794a:	4668      	mov	r0, sp
   4794c:	f000 f87d 	bl	47a4a <keccak_update>
    keccak_final(&context, (unsigned char*)result);
   47950:	4621      	mov	r1, r4
   47952:	4668      	mov	r0, sp
   47954:	f000 f8be 	bl	47ad4 <keccak_final>
    memset((char*)&context, 0, sizeof(SHA3_CTX));
   47958:	f44f 72c8 	mov.w	r2, #400	; 0x190
   4795c:	2100      	movs	r1, #0
   4795e:	4668      	mov	r0, sp
   47960:	f000 ffec 	bl	4893c <memset>
}
   47964:	b064      	add	sp, #400	; 0x190
   47966:	bd70      	pop	{r4, r5, r6, pc}

00047968 <rlp_encode_list>:

// Returns length of output in bytes, or a negative error value
int rlp_encode_list(void *rlpEncodedOutput, size_t rlpEncodedOutputLen, 
                    const RlpElement_t *const *rlpElementsArr, size_t rplElementsLen)
{
   47968:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4796c:	460e      	mov	r6, r1
   4796e:	4690      	mov	r8, r2
   47970:	4699      	mov	r9, r3
  if( rlpEncodedOutput == NULL || rlpElementsArr == NULL || rlpEncodedOutputLen == 0 )
   47972:	4604      	mov	r4, r0
   47974:	2800      	cmp	r0, #0
   47976:	d05d      	beq.n	47a34 <rlp_encode_list+0xcc>
   47978:	2a00      	cmp	r2, #0
   4797a:	d05b      	beq.n	47a34 <rlp_encode_list+0xcc>
   4797c:	2900      	cmp	r1, #0
   4797e:	d059      	beq.n	47a34 <rlp_encode_list+0xcc>
   47980:	460a      	mov	r2, r1
    return ERR_RLP_EBADARG;
  
  // loop through all elements and determine if sufficient output space is available
  // and there are no memory overlap violations
  size_t spaceRemaining = rlpEncodedOutputLen;
  for(int i = 0; i < rplElementsLen; i++) {
   47982:	2300      	movs	r3, #0
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   47984:	1845      	adds	r5, r0, r1
  for(int i = 0; i < rplElementsLen; i++) {
   47986:	454b      	cmp	r3, r9
   47988:	d120      	bne.n	479cc <rlp_encode_list+0x64>
  }
  size_t rlpEncodedLen = 0;
  uint8_t *rlpOut = (uint8_t *) rlpEncodedOutput;
  
  // Encode each element
  for(int i = 0; i < rplElementsLen; i++) {
   4798a:	2700      	movs	r7, #0
  size_t rlpEncodedLen = 0;
   4798c:	463d      	mov	r5, r7
  for(int i = 0; i < rplElementsLen; i++) {
   4798e:	454f      	cmp	r7, r9
   47990:	d135      	bne.n	479fe <rlp_encode_list+0x96>
      return ret;
    rlpEncodedLen += ret;
  }
  // Calculate list header byte size
  uint8_t listHdrByteCnt = 0;
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   47992:	462a      	mov	r2, r5
   47994:	2100      	movs	r1, #0
   47996:	2a00      	cmp	r2, #0
   47998:	b2cb      	uxtb	r3, r1
   4799a:	f101 0101 	add.w	r1, r1, #1
   4799e:	dc39      	bgt.n	47a14 <rlp_encode_list+0xac>
    listHdrByteCnt++;
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD)
   479a0:	2d37      	cmp	r5, #55	; 0x37
    listHdrByteCnt++; // additional byte for extended length tag
   479a2:	bf84      	itt	hi
   479a4:	3301      	addhi	r3, #1
   479a6:	b2db      	uxtbhi	r3, r3
  // orig
  if((listHdrByteCnt + rlpEncodedLen) > rlpEncodedOutputLen) {
   479a8:	1958      	adds	r0, r3, r5
   479aa:	42b0      	cmp	r0, r6
   479ac:	d814      	bhi.n	479d8 <rlp_encode_list+0x70>
    // ain't enough room for the header
    return ERR_RLP_ENOMEM;
  }
  // first shift everything down to fit the header
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   479ae:	1822      	adds	r2, r4, r0
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   479b0:	425e      	negs	r6, r3
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   479b2:	1b11      	subs	r1, r2, r4
   479b4:	428b      	cmp	r3, r1
   479b6:	dd2f      	ble.n	47a18 <rlp_encode_list+0xb0>
  }
  if(rlpEncodedLen > RLP_EXTENDED_LENGTH_THRESHOLD) {
   479b8:	2d37      	cmp	r5, #55	; 0x37
   479ba:	d938      	bls.n	47a2e <rlp_encode_list+0xc6>
    // generate the header
    for(int i = 0; i < listHdrByteCnt; i++) {
   479bc:	2200      	movs	r2, #0
   479be:	1e59      	subs	r1, r3, #1
   479c0:	4421      	add	r1, r4
   479c2:	4293      	cmp	r3, r2
   479c4:	dc2c      	bgt.n	47a20 <rlp_encode_list+0xb8>
      rlpOut[(listHdrByteCnt - 1) - i] = // subtract 1 to turn count into index
        (uint8_t) (rlpEncodedLen >> (8 * i));
    }
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_LONG + (listHdrByteCnt - 1));
   479c6:	3b0a      	subs	r3, #10
   479c8:	7023      	strb	r3, [r4, #0]
   479ca:	e007      	b.n	479dc <rlp_encode_list+0x74>
    if(spaceRemaining < (rlpElementsArr[i]->len + 1)) // extra byte for rlp encoding tag
   479cc:	f858 1023 	ldr.w	r1, [r8, r3, lsl #2]
   479d0:	6848      	ldr	r0, [r1, #4]
   479d2:	1c47      	adds	r7, r0, #1
   479d4:	4297      	cmp	r7, r2
   479d6:	d903      	bls.n	479e0 <rlp_encode_list+0x78>
      return ERR_RLP_ENOMEM;
   479d8:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  else {
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
  }
  rlpEncodedLen += listHdrByteCnt;
  return rlpEncodedLen;
   479dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   479e0:	43c7      	mvns	r7, r0
    if(rlp_memoverlap(rlpEncodedOutput, rlpEncodedOutputLen, rlpElementsArr[i]->buff, rlpElementsArr[i]->len)) // No overlapping memory regions
   479e2:	6889      	ldr	r1, [r1, #8]
      spaceRemaining -= (rlpElementsArr[i]->len + 1);
   479e4:	443a      	add	r2, r7
    if( (aAddr == bAddr) ||
   479e6:	42a1      	cmp	r1, r4
   479e8:	d027      	beq.n	47a3a <rlp_encode_list+0xd2>
   479ea:	d901      	bls.n	479f0 <rlp_encode_list+0x88>
        ((aAddr < bAddr) && ((aAddr + sza) >= bAddr)) ||
   479ec:	42a9      	cmp	r1, r5
   479ee:	d924      	bls.n	47a3a <rlp_encode_list+0xd2>
   479f0:	42a1      	cmp	r1, r4
   479f2:	d202      	bcs.n	479fa <rlp_encode_list+0x92>
        ((bAddr < aAddr) && ((bAddr + szb) >= aAddr)) ) {
   479f4:	4401      	add	r1, r0
   479f6:	428c      	cmp	r4, r1
   479f8:	d91f      	bls.n	47a3a <rlp_encode_list+0xd2>
  for(int i = 0; i < rplElementsLen; i++) {
   479fa:	3301      	adds	r3, #1
   479fc:	e7c3      	b.n	47986 <rlp_encode_list+0x1e>
    int ret = rlp_encode_element((rlpOut + rlpEncodedLen), (rlpEncodedOutputLen - rlpEncodedLen), rlpElementsArr[i]);
   479fe:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
   47a02:	1b71      	subs	r1, r6, r5
   47a04:	1960      	adds	r0, r4, r5
   47a06:	f7f8 fd93 	bl	40530 <rlp_encode_element>
    if(ret < 0)
   47a0a:	2800      	cmp	r0, #0
   47a0c:	dbe6      	blt.n	479dc <rlp_encode_list+0x74>
    rlpEncodedLen += ret;
   47a0e:	4405      	add	r5, r0
  for(int i = 0; i < rplElementsLen; i++) {
   47a10:	3701      	adds	r7, #1
   47a12:	e7bc      	b.n	4798e <rlp_encode_list+0x26>
  for(int byteShifts = rlpEncodedLen; byteShifts > 0; byteShifts = byteShifts >> 8) {
   47a14:	1212      	asrs	r2, r2, #8
   47a16:	e7be      	b.n	47996 <rlp_encode_list+0x2e>
    rlpOut[i] = rlpOut[i - (listHdrByteCnt)];
   47a18:	5d91      	ldrb	r1, [r2, r6]
   47a1a:	f802 1901 	strb.w	r1, [r2], #-1
  for(int i = (listHdrByteCnt + rlpEncodedLen); i >= listHdrByteCnt ; i--) {
   47a1e:	e7c8      	b.n	479b2 <rlp_encode_list+0x4a>
        (uint8_t) (rlpEncodedLen >> (8 * i));
   47a20:	00d6      	lsls	r6, r2, #3
   47a22:	fa25 f606 	lsr.w	r6, r5, r6
   47a26:	f801 6901 	strb.w	r6, [r1], #-1
    for(int i = 0; i < listHdrByteCnt; i++) {
   47a2a:	3201      	adds	r2, #1
   47a2c:	e7c9      	b.n	479c2 <rlp_encode_list+0x5a>
    rlpOut[0] = (uint8_t) (RLP_OFFSET_LIST_SHORT + rlpEncodedLen);
   47a2e:	3d40      	subs	r5, #64	; 0x40
   47a30:	7025      	strb	r5, [r4, #0]
   47a32:	e7d3      	b.n	479dc <rlp_encode_list+0x74>
    return ERR_RLP_EBADARG;
   47a34:	f06f 007e 	mvn.w	r0, #126	; 0x7e
   47a38:	e7d0      	b.n	479dc <rlp_encode_list+0x74>
      return ERR_RLP_EILLEGALMEM;
   47a3a:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   47a3e:	e7cd      	b.n	479dc <rlp_encode_list+0x74>

00047a40 <keccak_init>:
    memset(ctx, 0, sizeof(SHA3_CTX));
   47a40:	f44f 72c8 	mov.w	r2, #400	; 0x190
   47a44:	2100      	movs	r1, #0
   47a46:	f000 bf79 	b.w	4893c <memset>

00047a4a <keccak_update>:
 * @param ctx the algorithm context containing current hashing state
 * @param msg message chunk
 * @param size length of the message chunk
 */
void keccak_update(SHA3_CTX *ctx, const unsigned char *msg, uint16_t size)
{
   47a4a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47a4e:	4606      	mov	r6, r0
    uint16_t idx = (uint16_t)ctx->rest;
   47a50:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
{
   47a54:	4614      	mov	r4, r2

    //if (ctx->rest & SHA3_FINALIZED) return; /* too late for additional input */
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   47a56:	1887      	adds	r7, r0, r2
   47a58:	2288      	movs	r2, #136	; 0x88
   47a5a:	fbb7 f3f2 	udiv	r3, r7, r2
   47a5e:	fb02 7313 	mls	r3, r2, r3, r7
{
   47a62:	460d      	mov	r5, r1
    ctx->rest = (unsigned)((ctx->rest + size) % BLOCK_SIZE);
   47a64:	f8a6 3188 	strh.w	r3, [r6, #392]	; 0x188

    /* fill partial block */
    if (idx) {
   47a68:	b198      	cbz	r0, 47a92 <keccak_update+0x48>
        uint16_t left = BLOCK_SIZE - idx;
   47a6a:	1a17      	subs	r7, r2, r0
   47a6c:	b2bf      	uxth	r7, r7
        memcpy((char*)ctx->message + idx, msg, (size < left ? size : left));
   47a6e:	42bc      	cmp	r4, r7
   47a70:	f106 08c8 	add.w	r8, r6, #200	; 0xc8
   47a74:	4622      	mov	r2, r4
   47a76:	4440      	add	r0, r8
   47a78:	bf28      	it	cs
   47a7a:	463a      	movcs	r2, r7
   47a7c:	f000 ff53 	bl	48926 <memcpy>
        if (size < left) return;
   47a80:	42bc      	cmp	r4, r7
   47a82:	d325      	bcc.n	47ad0 <keccak_update+0x86>

        /* process partial block */
        sha3_process_block(ctx->hash, ctx->message);
   47a84:	4641      	mov	r1, r8
   47a86:	4630      	mov	r0, r6
   47a88:	f7f8 fdd0 	bl	4062c <sha3_process_block>
        msg  += left;
        size -= left;
   47a8c:	1be4      	subs	r4, r4, r7
        msg  += left;
   47a8e:	443d      	add	r5, r7
        size -= left;
   47a90:	b2a4      	uxth	r4, r4
        uint64_t* aligned_message_block;
        if (IS_ALIGNED_64(msg)) {
            // the most common case is processing of an already aligned message without copying it
            aligned_message_block = (uint64_t*)(void*)msg;
        } else {
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47a92:	f106 07c8 	add.w	r7, r6, #200	; 0xc8
    while (size >= BLOCK_SIZE) {
   47a96:	2c87      	cmp	r4, #135	; 0x87
   47a98:	d808      	bhi.n	47aac <keccak_update+0x62>
        sha3_process_block(ctx->hash, aligned_message_block);
        msg  += BLOCK_SIZE;
        size -= BLOCK_SIZE;
    }

    if (size) {
   47a9a:	b1cc      	cbz	r4, 47ad0 <keccak_update+0x86>
        memcpy(ctx->message, msg, size); /* save leftovers */
   47a9c:	4622      	mov	r2, r4
   47a9e:	4629      	mov	r1, r5
   47aa0:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
    }
}
   47aa4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        memcpy(ctx->message, msg, size); /* save leftovers */
   47aa8:	f000 bf3d 	b.w	48926 <memcpy>
        if (IS_ALIGNED_64(msg)) {
   47aac:	076b      	lsls	r3, r5, #29
   47aae:	d00d      	beq.n	47acc <keccak_update+0x82>
            memcpy(ctx->message, msg, BLOCK_SIZE);
   47ab0:	2288      	movs	r2, #136	; 0x88
   47ab2:	4629      	mov	r1, r5
   47ab4:	4638      	mov	r0, r7
   47ab6:	46b8      	mov	r8, r7
   47ab8:	f000 ff35 	bl	48926 <memcpy>
        sha3_process_block(ctx->hash, aligned_message_block);
   47abc:	4641      	mov	r1, r8
   47abe:	4630      	mov	r0, r6
   47ac0:	3c88      	subs	r4, #136	; 0x88
   47ac2:	f7f8 fdb3 	bl	4062c <sha3_process_block>
        msg  += BLOCK_SIZE;
   47ac6:	3588      	adds	r5, #136	; 0x88
        size -= BLOCK_SIZE;
   47ac8:	b2a4      	uxth	r4, r4
   47aca:	e7e4      	b.n	47a96 <keccak_update+0x4c>
   47acc:	46a8      	mov	r8, r5
   47ace:	e7f5      	b.n	47abc <keccak_update+0x72>
}
   47ad0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047ad4 <keccak_final>:
*
* @param ctx the algorithm context containing current hashing state
* @param result calculated hash in binary form
*/
void keccak_final(SHA3_CTX *ctx, unsigned char* result)
{
   47ad4:	b570      	push	{r4, r5, r6, lr}
   47ad6:	4604      	mov	r4, r0
   47ad8:	460d      	mov	r5, r1
    uint16_t digest_length = 100 - BLOCK_SIZE / 2;

//    if (!(ctx->rest & SHA3_FINALIZED)) {
        /* clear the rest of the data queue */
        memset((char*)ctx->message + ctx->rest, 0, BLOCK_SIZE - ctx->rest);
   47ada:	f100 06c8 	add.w	r6, r0, #200	; 0xc8
   47ade:	f8b0 0188 	ldrh.w	r0, [r0, #392]	; 0x188
   47ae2:	2100      	movs	r1, #0
   47ae4:	f1c0 0288 	rsb	r2, r0, #136	; 0x88
   47ae8:	4430      	add	r0, r6
   47aea:	f000 ff27 	bl	4893c <memset>
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   47aee:	f8b4 2188 	ldrh.w	r2, [r4, #392]	; 0x188
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;

        /* process final block */
        sha3_process_block(ctx->hash, ctx->message);
   47af2:	4631      	mov	r1, r6
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   47af4:	5cb3      	ldrb	r3, [r6, r2]
        sha3_process_block(ctx->hash, ctx->message);
   47af6:	4620      	mov	r0, r4
        ((char*)ctx->message)[ctx->rest] |= 0x01;
   47af8:	f043 0301 	orr.w	r3, r3, #1
   47afc:	54b3      	strb	r3, [r6, r2]
        ((char*)ctx->message)[BLOCK_SIZE - 1] |= 0x80;
   47afe:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
   47b02:	f063 037f 	orn	r3, r3, #127	; 0x7f
   47b06:	f884 314f 	strb.w	r3, [r4, #335]	; 0x14f
        sha3_process_block(ctx->hash, ctx->message);
   47b0a:	f7f8 fd8f 	bl	4062c <sha3_process_block>
//        ctx->rest = SHA3_FINALIZED; /* mark context as finalized */
//    }

    if (result) {
   47b0e:	b135      	cbz	r5, 47b1e <keccak_final+0x4a>
         me64_to_le_str(result, ctx->hash, digest_length);
   47b10:	4621      	mov	r1, r4
   47b12:	4628      	mov	r0, r5
    }
}
   47b14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
         me64_to_le_str(result, ctx->hash, digest_length);
   47b18:	2220      	movs	r2, #32
   47b1a:	f000 bf04 	b.w	48926 <memcpy>
}
   47b1e:	bd70      	pop	{r4, r5, r6, pc}

00047b20 <crypto_init>:
{
   47b20:	b508      	push	{r3, lr}
	status = psa_crypto_init();
   47b22:	f001 fc43 	bl	493ac <psa_crypto_init>
	if (status != PSA_SUCCESS)
   47b26:	3800      	subs	r0, #0
   47b28:	bf18      	it	ne
   47b2a:	2001      	movne	r0, #1
}
   47b2c:	4240      	negs	r0, r0
   47b2e:	bd08      	pop	{r3, pc}

00047b30 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   47b30:	4603      	mov	r3, r0
   47b32:	b158      	cbz	r0, 47b4c <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   47b34:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   47b36:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   47b3a:	2a01      	cmp	r2, #1
   47b3c:	d003      	beq.n	47b46 <sys_notify_validate+0x16>
   47b3e:	2a03      	cmp	r2, #3
   47b40:	d104      	bne.n	47b4c <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   47b42:	6802      	ldr	r2, [r0, #0]
   47b44:	b112      	cbz	r2, 47b4c <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   47b46:	2000      	movs	r0, #0
   47b48:	6098      	str	r0, [r3, #8]
   47b4a:	4770      	bx	lr
		return -EINVAL;
   47b4c:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   47b50:	4770      	bx	lr

00047b52 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   47b52:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   47b54:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   47b56:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   47b5a:	2a03      	cmp	r2, #3
   47b5c:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   47b60:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   47b62:	bf14      	ite	ne
   47b64:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   47b66:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   47b68:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   47b6a:	4770      	bx	lr

00047b6c <arch_printk_char_out>:
}
   47b6c:	2000      	movs	r0, #0
   47b6e:	4770      	bx	lr

00047b70 <str_out>:
{
   47b70:	b530      	push	{r4, r5, lr}
   47b72:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   47b74:	680c      	ldr	r4, [r1, #0]
   47b76:	1c55      	adds	r5, r2, #1
   47b78:	b114      	cbz	r4, 47b80 <str_out+0x10>
   47b7a:	684b      	ldr	r3, [r1, #4]
   47b7c:	4293      	cmp	r3, r2
   47b7e:	dc01      	bgt.n	47b84 <str_out+0x14>
		ctx->count++;
   47b80:	608d      	str	r5, [r1, #8]
}
   47b82:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   47b84:	3b01      	subs	r3, #1
   47b86:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   47b88:	bf08      	it	eq
   47b8a:	2200      	moveq	r2, #0
   47b8c:	608d      	str	r5, [r1, #8]
   47b8e:	bf0c      	ite	eq
   47b90:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   47b92:	54a0      	strbne	r0, [r4, r2]
   47b94:	e7f5      	b.n	47b82 <str_out+0x12>

00047b96 <printk>:
{
   47b96:	b40f      	push	{r0, r1, r2, r3}
   47b98:	b507      	push	{r0, r1, r2, lr}
   47b9a:	a904      	add	r1, sp, #16
   47b9c:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   47ba0:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   47ba2:	f7f9 f845 	bl	40c30 <vprintk>
}
   47ba6:	b003      	add	sp, #12
   47ba8:	f85d eb04 	ldr.w	lr, [sp], #4
   47bac:	b004      	add	sp, #16
   47bae:	4770      	bx	lr

00047bb0 <snprintk>:
{
   47bb0:	b40c      	push	{r2, r3}
   47bb2:	b507      	push	{r0, r1, r2, lr}
   47bb4:	ab04      	add	r3, sp, #16
   47bb6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   47bba:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   47bbc:	f7f9 f846 	bl	40c4c <vsnprintk>
}
   47bc0:	b003      	add	sp, #12
   47bc2:	f85d eb04 	ldr.w	lr, [sp], #4
   47bc6:	b002      	add	sp, #8
   47bc8:	4770      	bx	lr

00047bca <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47bca:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   47bcc:	f013 0307 	ands.w	r3, r3, #7
   47bd0:	d105      	bne.n	47bde <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   47bd2:	6803      	ldr	r3, [r0, #0]
   47bd4:	2b00      	cmp	r3, #0
		evt = EVT_START;
   47bd6:	bf0c      	ite	eq
   47bd8:	2000      	moveq	r0, #0
   47bda:	2003      	movne	r0, #3
   47bdc:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   47bde:	2b02      	cmp	r3, #2
   47be0:	d105      	bne.n	47bee <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   47be2:	8b43      	ldrh	r3, [r0, #26]
   47be4:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   47be6:	bf14      	ite	ne
   47be8:	2000      	movne	r0, #0
   47bea:	2004      	moveq	r0, #4
   47bec:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   47bee:	2b01      	cmp	r3, #1
   47bf0:	d105      	bne.n	47bfe <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   47bf2:	6803      	ldr	r3, [r0, #0]
   47bf4:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   47bf6:	bf0c      	ite	eq
   47bf8:	2000      	moveq	r0, #0
   47bfa:	2005      	movne	r0, #5
   47bfc:	4770      	bx	lr
	int evt = EVT_NOP;
   47bfe:	2000      	movs	r0, #0
}
   47c00:	4770      	bx	lr

00047c02 <notify_one>:
{
   47c02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   47c06:	460d      	mov	r5, r1
   47c08:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47c0a:	4619      	mov	r1, r3
   47c0c:	1d28      	adds	r0, r5, #4
{
   47c0e:	4690      	mov	r8, r2
   47c10:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   47c12:	f7ff ff9e 	bl	47b52 <sys_notify_finalize>
	if (cb) {
   47c16:	4604      	mov	r4, r0
   47c18:	b138      	cbz	r0, 47c2a <notify_one+0x28>
		cb(mgr, cli, state, res);
   47c1a:	4633      	mov	r3, r6
   47c1c:	4642      	mov	r2, r8
   47c1e:	4629      	mov	r1, r5
   47c20:	4638      	mov	r0, r7
   47c22:	46a4      	mov	ip, r4
}
   47c24:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   47c28:	4760      	bx	ip
}
   47c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00047c2e <transition_complete>:
{
   47c2e:	b410      	push	{r4}
	__asm__ volatile(
   47c30:	f04f 0420 	mov.w	r4, #32
   47c34:	f3ef 8211 	mrs	r2, BASEPRI
   47c38:	f384 8812 	msr	BASEPRI_MAX, r4
   47c3c:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   47c40:	6141      	str	r1, [r0, #20]
}
   47c42:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   47c44:	2101      	movs	r1, #1
   47c46:	f7f9 b815 	b.w	40c74 <process_event>

00047c4a <validate_args>:
{
   47c4a:	b510      	push	{r4, lr}
   47c4c:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   47c4e:	b140      	cbz	r0, 47c62 <validate_args+0x18>
   47c50:	b139      	cbz	r1, 47c62 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   47c52:	1d08      	adds	r0, r1, #4
   47c54:	f7ff ff6c 	bl	47b30 <sys_notify_validate>
	if ((rv == 0)
   47c58:	b928      	cbnz	r0, 47c66 <validate_args+0x1c>
	    && ((cli->notify.flags
   47c5a:	68a3      	ldr	r3, [r4, #8]
   47c5c:	f033 0303 	bics.w	r3, r3, #3
   47c60:	d001      	beq.n	47c66 <validate_args+0x1c>
		rv = -EINVAL;
   47c62:	f06f 0015 	mvn.w	r0, #21
}
   47c66:	bd10      	pop	{r4, pc}

00047c68 <onoff_manager_init>:
{
   47c68:	b538      	push	{r3, r4, r5, lr}
   47c6a:	460c      	mov	r4, r1
	if ((mgr == NULL)
   47c6c:	4605      	mov	r5, r0
   47c6e:	b158      	cbz	r0, 47c88 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   47c70:	b151      	cbz	r1, 47c88 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   47c72:	680b      	ldr	r3, [r1, #0]
   47c74:	b143      	cbz	r3, 47c88 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   47c76:	684b      	ldr	r3, [r1, #4]
   47c78:	b133      	cbz	r3, 47c88 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   47c7a:	221c      	movs	r2, #28
   47c7c:	2100      	movs	r1, #0
   47c7e:	f000 fe5d 	bl	4893c <memset>
	return 0;
   47c82:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   47c84:	612c      	str	r4, [r5, #16]
}
   47c86:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   47c88:	f06f 0015 	mvn.w	r0, #21
   47c8c:	e7fb      	b.n	47c86 <onoff_manager_init+0x1e>

00047c8e <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   47c8e:	b570      	push	{r4, r5, r6, lr}
   47c90:	4604      	mov	r4, r0
   47c92:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   47c94:	f7ff ffd9 	bl	47c4a <validate_args>

	if (rv < 0) {
   47c98:	1e05      	subs	r5, r0, #0
   47c9a:	db31      	blt.n	47d00 <onoff_request+0x72>
   47c9c:	f04f 0320 	mov.w	r3, #32
   47ca0:	f3ef 8111 	mrs	r1, BASEPRI
   47ca4:	f383 8812 	msr	BASEPRI_MAX, r3
   47ca8:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   47cac:	f64f 75ff 	movw	r5, #65535	; 0xffff
   47cb0:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   47cb2:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   47cb4:	42ab      	cmp	r3, r5
   47cb6:	f000 0207 	and.w	r2, r0, #7
   47cba:	d02e      	beq.n	47d1a <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   47cbc:	2a02      	cmp	r2, #2
   47cbe:	d10e      	bne.n	47cde <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   47cc0:	3301      	adds	r3, #1
   47cc2:	8363      	strh	r3, [r4, #26]
	rv = state;
   47cc4:	4615      	mov	r5, r2
		notify = true;
   47cc6:	2301      	movs	r3, #1
	__asm__ volatile(
   47cc8:	f381 8811 	msr	BASEPRI, r1
   47ccc:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   47cd0:	b1b3      	cbz	r3, 47d00 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   47cd2:	2300      	movs	r3, #0
   47cd4:	4631      	mov	r1, r6
   47cd6:	4620      	mov	r0, r4
   47cd8:	f7ff ff93 	bl	47c02 <notify_one>
   47cdc:	e010      	b.n	47d00 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   47cde:	0783      	lsls	r3, r0, #30
   47ce0:	d001      	beq.n	47ce6 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   47ce2:	2a06      	cmp	r2, #6
   47ce4:	d10e      	bne.n	47d04 <onoff_request+0x76>
	parent->next = child;
   47ce6:	2300      	movs	r3, #0
   47ce8:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   47cea:	6863      	ldr	r3, [r4, #4]
   47cec:	b993      	cbnz	r3, 47d14 <onoff_request+0x86>
	list->head = node;
   47cee:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   47cf2:	4615      	mov	r5, r2
   47cf4:	b962      	cbnz	r2, 47d10 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   47cf6:	460a      	mov	r2, r1
   47cf8:	4620      	mov	r0, r4
   47cfa:	2102      	movs	r1, #2
   47cfc:	f7f8 ffba 	bl	40c74 <process_event>
		}
	}

	return rv;
}
   47d00:	4628      	mov	r0, r5
   47d02:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   47d04:	2a05      	cmp	r2, #5
   47d06:	bf0c      	ite	eq
   47d08:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   47d0c:	f06f 0504 	mvnne.w	r5, #4
   47d10:	2300      	movs	r3, #0
   47d12:	e7d9      	b.n	47cc8 <onoff_request+0x3a>
	parent->next = child;
   47d14:	601e      	str	r6, [r3, #0]
	list->tail = node;
   47d16:	6066      	str	r6, [r4, #4]
}
   47d18:	e7eb      	b.n	47cf2 <onoff_request+0x64>
		rv = -EAGAIN;
   47d1a:	f06f 050a 	mvn.w	r5, #10
   47d1e:	e7f7      	b.n	47d10 <onoff_request+0x82>

00047d20 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   47d20:	4604      	mov	r4, r0
   47d22:	b508      	push	{r3, lr}
   47d24:	4608      	mov	r0, r1
   47d26:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   47d28:	461a      	mov	r2, r3
   47d2a:	47a0      	blx	r4
	return z_impl_z_current_get();
   47d2c:	f7ff fa38 	bl	471a0 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   47d30:	f7fa ff6a 	bl	42c08 <z_impl_k_thread_abort>

00047d34 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   47d34:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   47d38:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   47d3a:	0840      	lsrs	r0, r0, #1
   47d3c:	4770      	bx	lr

00047d3e <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   47d3e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   47d40:	4603      	mov	r3, r0
   47d42:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   47d44:	f7ff fff6 	bl	47d34 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   47d48:	fab0 f080 	clz	r0, r0
   47d4c:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   47d50:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   47d54:	f8dc 6010 	ldr.w	r6, [ip, #16]
   47d58:	00ca      	lsls	r2, r1, #3
   47d5a:	1d17      	adds	r7, r2, #4
   47d5c:	b28d      	uxth	r5, r1
   47d5e:	3206      	adds	r2, #6
   47d60:	b956      	cbnz	r6, 47d78 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   47d62:	2101      	movs	r1, #1
   47d64:	fa01 f000 	lsl.w	r0, r1, r0
   47d68:	68d9      	ldr	r1, [r3, #12]
   47d6a:	4301      	orrs	r1, r0
   47d6c:	60d9      	str	r1, [r3, #12]
		b->next = c;
   47d6e:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   47d72:	53dd      	strh	r5, [r3, r7]
   47d74:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   47d76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   47d78:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   47d7a:	3104      	adds	r1, #4
   47d7c:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   47d7e:	53d8      	strh	r0, [r3, r7]
   47d80:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   47d84:	529e      	strh	r6, [r3, r2]
   47d86:	80c5      	strh	r5, [r0, #6]
   47d88:	525d      	strh	r5, [r3, r1]
   47d8a:	e7f4      	b.n	47d76 <free_list_add+0x38>

00047d8c <free_list_remove_bidx>:
{
   47d8c:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   47d8e:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   47d92:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   47d94:	4299      	cmp	r1, r3
   47d96:	f102 0104 	add.w	r1, r2, #4
   47d9a:	d10a      	bne.n	47db2 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   47d9c:	2301      	movs	r3, #1
   47d9e:	fa03 f202 	lsl.w	r2, r3, r2
   47da2:	68c3      	ldr	r3, [r0, #12]
   47da4:	ea23 0302 	bic.w	r3, r3, r2
   47da8:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   47daa:	2300      	movs	r3, #0
   47dac:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   47db0:	bd10      	pop	{r4, pc}
   47db2:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   47db4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   47db8:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   47dbc:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   47dc0:	80cb      	strh	r3, [r1, #6]
   47dc2:	8082      	strh	r2, [r0, #4]
}
   47dc4:	e7f4      	b.n	47db0 <free_list_remove_bidx+0x24>

00047dc6 <free_list_remove>:
{
   47dc6:	b510      	push	{r4, lr}
   47dc8:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   47dca:	f7ff ffb3 	bl	47d34 <chunk_size>
}
   47dce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   47dd2:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   47dd6:	4618      	mov	r0, r3
   47dd8:	f1c2 021f 	rsb	r2, r2, #31
   47ddc:	f7ff bfd6 	b.w	47d8c <free_list_remove_bidx>

00047de0 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   47de0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47de4:	fab1 f581 	clz	r5, r1
   47de8:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   47dec:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   47df0:	693a      	ldr	r2, [r7, #16]
{
   47df2:	4603      	mov	r3, r0
   47df4:	460e      	mov	r6, r1
	if (b->next) {
   47df6:	b1ca      	cbz	r2, 47e2c <alloc_chunk+0x4c>
   47df8:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   47dfc:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   47dfe:	4618      	mov	r0, r3
   47e00:	4621      	mov	r1, r4
   47e02:	f7ff ff97 	bl	47d34 <chunk_size>
   47e06:	42b0      	cmp	r0, r6
   47e08:	d307      	bcc.n	47e1a <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   47e0a:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   47e0c:	4621      	mov	r1, r4
   47e0e:	4618      	mov	r0, r3
   47e10:	f7ff ffbc 	bl	47d8c <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   47e14:	4620      	mov	r0, r4
   47e16:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   47e1a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   47e1e:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   47e20:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   47e24:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   47e26:	d001      	beq.n	47e2c <alloc_chunk+0x4c>
   47e28:	428a      	cmp	r2, r1
   47e2a:	d1e7      	bne.n	47dfc <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   47e2c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   47e30:	68d9      	ldr	r1, [r3, #12]
   47e32:	f1c5 0520 	rsb	r5, r5, #32
   47e36:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   47e38:	400c      	ands	r4, r1
   47e3a:	d0eb      	beq.n	47e14 <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   47e3c:	fa94 f2a4 	rbit	r2, r4
   47e40:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   47e44:	1d11      	adds	r1, r2, #4
   47e46:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   47e4a:	e7df      	b.n	47e0c <alloc_chunk+0x2c>

00047e4c <merge_chunks>:
{
   47e4c:	b538      	push	{r3, r4, r5, lr}
   47e4e:	4603      	mov	r3, r0
   47e50:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   47e52:	f7ff ff6f 	bl	47d34 <chunk_size>
   47e56:	4611      	mov	r1, r2
   47e58:	4604      	mov	r4, r0
   47e5a:	4618      	mov	r0, r3
   47e5c:	f7ff ff6a 	bl	47d34 <chunk_size>
   47e60:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   47e62:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47e66:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   47e68:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   47e6a:	4618      	mov	r0, r3
   47e6c:	4611      	mov	r1, r2
   47e6e:	f7ff ff61 	bl	47d34 <chunk_size>
	void *cmem = &buf[c];
   47e72:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   47e74:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   47e78:	bd38      	pop	{r3, r4, r5, pc}

00047e7a <split_chunks>:
{
   47e7a:	b538      	push	{r3, r4, r5, lr}
   47e7c:	4603      	mov	r3, r0
   47e7e:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   47e80:	f7ff ff58 	bl	47d34 <chunk_size>
	chunksz_t lsz = rc - lc;
   47e84:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   47e86:	1aa5      	subs	r5, r4, r2
   47e88:	4405      	add	r5, r0
   47e8a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47e8e:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   47e90:	8060      	strh	r0, [r4, #2]
   47e92:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   47e96:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   47e98:	8044      	strh	r4, [r0, #2]
   47e9a:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   47e9e:	4618      	mov	r0, r3
   47ea0:	4611      	mov	r1, r2
   47ea2:	f7ff ff47 	bl	47d34 <chunk_size>
	void *cmem = &buf[c];
   47ea6:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   47ea8:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   47eac:	bd38      	pop	{r3, r4, r5, pc}

00047eae <free_chunk>:
{
   47eae:	b538      	push	{r3, r4, r5, lr}
   47eb0:	4605      	mov	r5, r0
   47eb2:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   47eb4:	f7ff ff3e 	bl	47d34 <chunk_size>
   47eb8:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   47eba:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   47ebe:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   47ec0:	07da      	lsls	r2, r3, #31
   47ec2:	d40a      	bmi.n	47eda <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   47ec4:	4628      	mov	r0, r5
   47ec6:	f7ff ff7e 	bl	47dc6 <free_list_remove>
	return c + chunk_size(h, c);
   47eca:	4621      	mov	r1, r4
   47ecc:	4628      	mov	r0, r5
   47ece:	f7ff ff31 	bl	47d34 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   47ed2:	1822      	adds	r2, r4, r0
   47ed4:	4628      	mov	r0, r5
   47ed6:	f7ff ffb9 	bl	47e4c <merge_chunks>
		return ((uint16_t *)cmem)[f];
   47eda:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47ede:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   47ee0:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   47ee4:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   47ee6:	07db      	lsls	r3, r3, #31
   47ee8:	d40c      	bmi.n	47f04 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   47eea:	4628      	mov	r0, r5
   47eec:	f7ff ff6b 	bl	47dc6 <free_list_remove>
		return ((uint16_t *)cmem)[f];
   47ef0:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   47ef4:	4622      	mov	r2, r4
   47ef6:	1a61      	subs	r1, r4, r1
   47ef8:	4628      	mov	r0, r5
   47efa:	f7ff ffa7 	bl	47e4c <merge_chunks>
   47efe:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   47f02:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   47f04:	4621      	mov	r1, r4
   47f06:	4628      	mov	r0, r5
}
   47f08:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   47f0c:	f7ff bf17 	b.w	47d3e <free_list_add>

00047f10 <sys_heap_free>:
	if (mem == NULL) {
   47f10:	b161      	cbz	r1, 47f2c <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   47f12:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47f14:	3904      	subs	r1, #4
   47f16:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   47f18:	f021 0307 	bic.w	r3, r1, #7
   47f1c:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   47f1e:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   47f20:	08c9      	lsrs	r1, r1, #3
   47f22:	f022 0201 	bic.w	r2, r2, #1
   47f26:	805a      	strh	r2, [r3, #2]
   47f28:	f7ff bfc1 	b.w	47eae <free_chunk>
}
   47f2c:	4770      	bx	lr

00047f2e <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   47f2e:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   47f30:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   47f32:	b909      	cbnz	r1, 47f38 <sys_heap_alloc+0xa>
		return NULL;
   47f34:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   47f36:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   47f38:	68ab      	ldr	r3, [r5, #8]
   47f3a:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   47f3e:	d9f9      	bls.n	47f34 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47f40:	310b      	adds	r1, #11
   47f42:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   47f44:	4621      	mov	r1, r4
   47f46:	4628      	mov	r0, r5
   47f48:	f7ff ff4a 	bl	47de0 <alloc_chunk>
	if (c == 0U) {
   47f4c:	4606      	mov	r6, r0
   47f4e:	2800      	cmp	r0, #0
   47f50:	d0f0      	beq.n	47f34 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   47f52:	4601      	mov	r1, r0
   47f54:	4628      	mov	r0, r5
   47f56:	f7ff feed 	bl	47d34 <chunk_size>
   47f5a:	42a0      	cmp	r0, r4
   47f5c:	d908      	bls.n	47f70 <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   47f5e:	4434      	add	r4, r6
   47f60:	4628      	mov	r0, r5
   47f62:	4622      	mov	r2, r4
   47f64:	f7ff ff89 	bl	47e7a <split_chunks>
		free_list_add(h, c + chunk_sz);
   47f68:	4621      	mov	r1, r4
   47f6a:	4628      	mov	r0, r5
   47f6c:	f7ff fee7 	bl	47d3e <free_list_add>
	void *cmem = &buf[c];
   47f70:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   47f74:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   47f76:	8853      	ldrh	r3, [r2, #2]
   47f78:	3004      	adds	r0, #4
   47f7a:	f043 0301 	orr.w	r3, r3, #1
   47f7e:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   47f80:	e7d9      	b.n	47f36 <sys_heap_alloc+0x8>

00047f82 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   47f82:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   47f86:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   47f88:	424a      	negs	r2, r1
   47f8a:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   47f8e:	ea31 0202 	bics.w	r2, r1, r2
{
   47f92:	4603      	mov	r3, r0
	if (align != rew) {
   47f94:	d00a      	beq.n	47fac <sys_heap_aligned_alloc+0x2a>
		return false;
   47f96:	2f04      	cmp	r7, #4
   47f98:	463a      	mov	r2, r7
   47f9a:	bf28      	it	cs
   47f9c:	2204      	movcs	r2, #4
   47f9e:	46b9      	mov	r9, r7
		align -= rew;
   47fa0:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   47fa2:	b974      	cbnz	r4, 47fc2 <sys_heap_aligned_alloc+0x40>
		return NULL;
   47fa4:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   47fa6:	4628      	mov	r0, r5
   47fa8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   47fac:	2904      	cmp	r1, #4
   47fae:	d804      	bhi.n	47fba <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   47fb0:	4621      	mov	r1, r4
}
   47fb2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   47fb6:	f7ff bfba 	b.w	47f2e <sys_heap_alloc>
		rew = 0;
   47fba:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   47fbe:	2204      	movs	r2, #4
   47fc0:	e7ef      	b.n	47fa2 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   47fc2:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   47fc4:	68b3      	ldr	r3, [r6, #8]
   47fc6:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   47fca:	d9eb      	bls.n	47fa4 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   47fcc:	f104 010b 	add.w	r1, r4, #11
   47fd0:	4439      	add	r1, r7
   47fd2:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   47fd4:	4630      	mov	r0, r6
   47fd6:	08c9      	lsrs	r1, r1, #3
   47fd8:	f7ff ff02 	bl	47de0 <alloc_chunk>
	if (c0 == 0) {
   47fdc:	4680      	mov	r8, r0
   47fde:	2800      	cmp	r0, #0
   47fe0:	d0e0      	beq.n	47fa4 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   47fe2:	f109 0504 	add.w	r5, r9, #4
   47fe6:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   47fea:	1e7b      	subs	r3, r7, #1
   47fec:	4435      	add	r5, r6
   47fee:	441d      	add	r5, r3
   47ff0:	427f      	negs	r7, r7
   47ff2:	403d      	ands	r5, r7
   47ff4:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47ff8:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47ffa:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   47ffc:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   47ffe:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   48000:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   48004:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   48006:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   4800a:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   4800e:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   48012:	d208      	bcs.n	48026 <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   48014:	4601      	mov	r1, r0
   48016:	463a      	mov	r2, r7
   48018:	4630      	mov	r0, r6
   4801a:	f7ff ff2e 	bl	47e7a <split_chunks>
		free_list_add(h, c0);
   4801e:	4641      	mov	r1, r8
   48020:	4630      	mov	r0, r6
   48022:	f7ff fe8c 	bl	47d3e <free_list_add>
	return c + chunk_size(h, c);
   48026:	4639      	mov	r1, r7
   48028:	4630      	mov	r0, r6
   4802a:	f7ff fe83 	bl	47d34 <chunk_size>
   4802e:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   48030:	4284      	cmp	r4, r0
   48032:	d207      	bcs.n	48044 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   48034:	4630      	mov	r0, r6
   48036:	4622      	mov	r2, r4
   48038:	f7ff ff1f 	bl	47e7a <split_chunks>
		free_list_add(h, c_end);
   4803c:	4621      	mov	r1, r4
   4803e:	4630      	mov	r0, r6
   48040:	f7ff fe7d 	bl	47d3e <free_list_add>
	void *cmem = &buf[c];
   48044:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   48048:	8873      	ldrh	r3, [r6, #2]
   4804a:	f043 0301 	orr.w	r3, r3, #1
   4804e:	8073      	strh	r3, [r6, #2]
   48050:	e7a9      	b.n	47fa6 <sys_heap_aligned_alloc+0x24>

00048052 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   48052:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   48054:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   48056:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   48058:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   4805c:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   48060:	1ad2      	subs	r2, r2, r3
{
   48062:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   48064:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   48066:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   48068:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   4806c:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   4806e:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   48072:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   48074:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   48076:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   48078:	60dd      	str	r5, [r3, #12]
   4807a:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   4807c:	f103 0610 	add.w	r6, r3, #16
   48080:	4418      	add	r0, r3
   48082:	4286      	cmp	r6, r0
   48084:	d118      	bne.n	480b8 <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   48086:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   48088:	f040 0001 	orr.w	r0, r0, #1
   4808c:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   4808e:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   48090:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   48092:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   48096:	801d      	strh	r5, [r3, #0]
   48098:	8077      	strh	r7, [r6, #2]
   4809a:	189e      	adds	r6, r3, r2
   4809c:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   480a0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   480a4:	8075      	strh	r5, [r6, #2]
   480a6:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   480a8:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   480aa:	4618      	mov	r0, r3
   480ac:	f042 0201 	orr.w	r2, r2, #1
   480b0:	8062      	strh	r2, [r4, #2]
}
   480b2:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   480b4:	f7ff be43 	b.w	47d3e <free_list_add>
		h->buckets[i].next = 0;
   480b8:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   480bc:	e7e1      	b.n	48082 <sys_heap_init+0x30>

000480be <encode_uint>:
{
   480be:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   480c2:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   480c4:	78d3      	ldrb	r3, [r2, #3]
{
   480c6:	4614      	mov	r4, r2
	switch (specifier) {
   480c8:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   480ca:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   480ce:	4606      	mov	r6, r0
   480d0:	460f      	mov	r7, r1
   480d2:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   480d4:	d02d      	beq.n	48132 <encode_uint+0x74>
   480d6:	d828      	bhi.n	4812a <encode_uint+0x6c>
		return 16;
   480d8:	2b58      	cmp	r3, #88	; 0x58
   480da:	bf14      	ite	ne
   480dc:	250a      	movne	r5, #10
   480de:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   480e0:	46aa      	mov	sl, r5
   480e2:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   480e6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   480ea:	4652      	mov	r2, sl
   480ec:	465b      	mov	r3, fp
   480ee:	4630      	mov	r0, r6
   480f0:	4639      	mov	r1, r7
   480f2:	f7f8 f827 	bl	40144 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   480f6:	2a09      	cmp	r2, #9
   480f8:	b2d3      	uxtb	r3, r2
   480fa:	d81f      	bhi.n	4813c <encode_uint+0x7e>
   480fc:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   480fe:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   48100:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   48102:	bf08      	it	eq
   48104:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   48106:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   4810a:	d301      	bcc.n	48110 <encode_uint+0x52>
   4810c:	45c8      	cmp	r8, r9
   4810e:	d812      	bhi.n	48136 <encode_uint+0x78>
	if (conv->flag_hash) {
   48110:	7823      	ldrb	r3, [r4, #0]
   48112:	069b      	lsls	r3, r3, #26
   48114:	d505      	bpl.n	48122 <encode_uint+0x64>
		if (radix == 8) {
   48116:	2d08      	cmp	r5, #8
   48118:	d116      	bne.n	48148 <encode_uint+0x8a>
			conv->altform_0 = true;
   4811a:	78a3      	ldrb	r3, [r4, #2]
   4811c:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   48120:	70a3      	strb	r3, [r4, #2]
}
   48122:	4640      	mov	r0, r8
   48124:	b003      	add	sp, #12
   48126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   4812a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   4812e:	2b70      	cmp	r3, #112	; 0x70
   48130:	e7d3      	b.n	480da <encode_uint+0x1c>
	switch (specifier) {
   48132:	2508      	movs	r5, #8
   48134:	e7d4      	b.n	480e0 <encode_uint+0x22>
		value /= radix;
   48136:	4606      	mov	r6, r0
   48138:	460f      	mov	r7, r1
   4813a:	e7d6      	b.n	480ea <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   4813c:	9a01      	ldr	r2, [sp, #4]
   4813e:	2a19      	cmp	r2, #25
   48140:	bf94      	ite	ls
   48142:	3337      	addls	r3, #55	; 0x37
   48144:	3357      	addhi	r3, #87	; 0x57
   48146:	e7da      	b.n	480fe <encode_uint+0x40>
		} else if (radix == 16) {
   48148:	2d10      	cmp	r5, #16
   4814a:	d1ea      	bne.n	48122 <encode_uint+0x64>
			conv->altform_0c = true;
   4814c:	78a3      	ldrb	r3, [r4, #2]
   4814e:	f043 0310 	orr.w	r3, r3, #16
   48152:	e7e5      	b.n	48120 <encode_uint+0x62>

00048154 <outs>:
{
   48154:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   48158:	4607      	mov	r7, r0
   4815a:	4688      	mov	r8, r1
   4815c:	4615      	mov	r5, r2
   4815e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   48160:	4614      	mov	r4, r2
   48162:	42b4      	cmp	r4, r6
   48164:	eba4 0005 	sub.w	r0, r4, r5
   48168:	d302      	bcc.n	48170 <outs+0x1c>
   4816a:	b93e      	cbnz	r6, 4817c <outs+0x28>
   4816c:	7823      	ldrb	r3, [r4, #0]
   4816e:	b12b      	cbz	r3, 4817c <outs+0x28>
		int rc = out((int)*sp++, ctx);
   48170:	4641      	mov	r1, r8
   48172:	f814 0b01 	ldrb.w	r0, [r4], #1
   48176:	47b8      	blx	r7
		if (rc < 0) {
   48178:	2800      	cmp	r0, #0
   4817a:	daf2      	bge.n	48162 <outs+0xe>
}
   4817c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00048180 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   48180:	4770      	bx	lr

00048182 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   48182:	b084      	sub	sp, #16
   48184:	ab04      	add	r3, sp, #16
   48186:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   4818a:	f89d 3004 	ldrb.w	r3, [sp, #4]
   4818e:	2b06      	cmp	r3, #6
   48190:	d108      	bne.n	481a4 <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   48192:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   48196:	2201      	movs	r2, #1
   48198:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   4819c:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   481a0:	bf20      	wfe
    while (true)
   481a2:	e7fd      	b.n	481a0 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   481a4:	b004      	add	sp, #16
   481a6:	4770      	bx	lr

000481a8 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   481a8:	b084      	sub	sp, #16
   481aa:	ab04      	add	r3, sp, #16
   481ac:	e903 0007 	stmdb	r3, {r0, r1, r2}
   481b0:	2300      	movs	r3, #0
   481b2:	f383 8811 	msr	BASEPRI, r3
   481b6:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   481ba:	b004      	add	sp, #16
   481bc:	4770      	bx	lr

000481be <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   481be:	2300      	movs	r3, #0
	list->head = NULL;
   481c0:	e9c0 3300 	strd	r3, r3, [r0]
}
   481c4:	4770      	bx	lr

000481c6 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   481c6:	6803      	ldr	r3, [r0, #0]
   481c8:	b923      	cbnz	r3, 481d4 <log_list_add_tail+0xe>
		list->head = msg;
   481ca:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   481cc:	2300      	movs	r3, #0
	list->tail = msg;
   481ce:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   481d0:	600b      	str	r3, [r1, #0]
}
   481d2:	4770      	bx	lr
		list->tail->next = msg;
   481d4:	6843      	ldr	r3, [r0, #4]
   481d6:	6019      	str	r1, [r3, #0]
   481d8:	e7f8      	b.n	481cc <log_list_add_tail+0x6>

000481da <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   481da:	6800      	ldr	r0, [r0, #0]
   481dc:	4770      	bx	lr

000481de <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
   481de:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
   481e0:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
   481e2:	b108      	cbz	r0, 481e8 <log_list_head_get+0xa>
		list->head = list->head->next;
   481e4:	6802      	ldr	r2, [r0, #0]
   481e6:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
   481e8:	4770      	bx	lr

000481ea <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   481ea:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   481ec:	f7f9 fcc2 	bl	41b74 <log_msg_chunk_alloc>

	if (msg != NULL) {
   481f0:	b118      	cbz	r0, 481fa <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   481f2:	2301      	movs	r3, #1
   481f4:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   481f6:	2300      	movs	r3, #0
   481f8:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
   481fa:	bd08      	pop	{r3, pc}

000481fc <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   481fc:	f000 bd16 	b.w	48c2c <sys_clock_cycle_get_32>

00048200 <dummy_timestamp>:
   48200:	2000      	movs	r0, #0
   48202:	4770      	bx	lr

00048204 <z_log_get_s_mask>:
{
   48204:	b5f0      	push	{r4, r5, r6, r7, lr}
   48206:	4605      	mov	r5, r0
	uint32_t mask = 0U;
   48208:	2000      	movs	r0, #0
				mask |= BIT(arg);
   4820a:	2701      	movs	r7, #1
	uint32_t arg = 0U;
   4820c:	4603      	mov	r3, r0
	bool arm = false;
   4820e:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
   48210:	f815 4b01 	ldrb.w	r4, [r5], #1
   48214:	b10c      	cbz	r4, 4821a <z_log_get_s_mask+0x16>
   48216:	428b      	cmp	r3, r1
   48218:	d300      	bcc.n	4821c <z_log_get_s_mask+0x18>
}
   4821a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
   4821c:	2c25      	cmp	r4, #37	; 0x25
   4821e:	d102      	bne.n	48226 <z_log_get_s_mask+0x22>
			arm = !arm;
   48220:	f082 0201 	eor.w	r2, r2, #1
   48224:	e7f4      	b.n	48210 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
   48226:	2a00      	cmp	r2, #0
   48228:	d0f2      	beq.n	48210 <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   4822a:	f044 0620 	orr.w	r6, r4, #32
   4822e:	3e61      	subs	r6, #97	; 0x61
   48230:	2e19      	cmp	r6, #25
   48232:	d8ed      	bhi.n	48210 <z_log_get_s_mask+0xc>
			if (curr == 's') {
   48234:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
   48236:	bf04      	itt	eq
   48238:	fa07 f203 	lsleq.w	r2, r7, r3
   4823c:	4310      	orreq	r0, r2
			arg++;
   4823e:	3301      	adds	r3, #1
			arm = false;
   48240:	2200      	movs	r2, #0
   48242:	e7e5      	b.n	48210 <z_log_get_s_mask+0xc>

00048244 <log_0>:
{
   48244:	b538      	push	{r3, r4, r5, lr}
   48246:	4605      	mov	r5, r0
   48248:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   4824a:	f7ff ffce 	bl	481ea <z_log_msg_std_alloc>

	if (msg != NULL) {
   4824e:	b128      	cbz	r0, 4825c <log_0+0x18>
		msg_finalize(msg, src_level);
   48250:	4621      	mov	r1, r4
		msg->str = str;
   48252:	6105      	str	r5, [r0, #16]
}
   48254:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   48258:	f7f9 bb92 	b.w	41980 <msg_finalize>
}
   4825c:	bd38      	pop	{r3, r4, r5, pc}

0004825e <log_1>:
{
   4825e:	b570      	push	{r4, r5, r6, lr}
   48260:	4606      	mov	r6, r0
   48262:	460d      	mov	r5, r1
   48264:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   48266:	f7ff ffc0 	bl	481ea <z_log_msg_std_alloc>

	if (msg != NULL) {
   4826a:	b158      	cbz	r0, 48284 <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
   4826c:	2101      	movs	r1, #1
   4826e:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
   48270:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   48272:	f361 1207 	bfi	r2, r1, #4, #4
   48276:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
   48278:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
   4827a:	6145      	str	r5, [r0, #20]
}
   4827c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   48280:	f7f9 bb7e 	b.w	41980 <msg_finalize>
}
   48284:	bd70      	pop	{r4, r5, r6, pc}

00048286 <log_2>:
{
   48286:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4828a:	4680      	mov	r8, r0
   4828c:	460f      	mov	r7, r1
   4828e:	4616      	mov	r6, r2
   48290:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   48292:	f7ff ffaa 	bl	481ea <z_log_msg_std_alloc>

	if (msg != NULL) {
   48296:	b168      	cbz	r0, 482b4 <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
   48298:	2202      	movs	r2, #2
   4829a:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   4829c:	4629      	mov	r1, r5
   4829e:	f362 1307 	bfi	r3, r2, #4, #4
   482a2:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   482a4:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   482a8:	f8c0 8010 	str.w	r8, [r0, #16]
}
   482ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   482b0:	f7f9 bb66 	b.w	41980 <msg_finalize>
}
   482b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000482b8 <log_3>:
{
   482b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   482bc:	4680      	mov	r8, r0
   482be:	460f      	mov	r7, r1
   482c0:	4616      	mov	r6, r2
   482c2:	461d      	mov	r5, r3
   482c4:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   482c8:	f7ff ff8f 	bl	481ea <z_log_msg_std_alloc>

	if (msg != NULL) {
   482cc:	b170      	cbz	r0, 482ec <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
   482ce:	2203      	movs	r2, #3
   482d0:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
   482d2:	4649      	mov	r1, r9
   482d4:	f362 1307 	bfi	r3, r2, #4, #4
   482d8:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   482da:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
   482de:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
   482e2:	61c5      	str	r5, [r0, #28]
}
   482e4:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   482e8:	f7f9 bb4a 	b.w	41980 <msg_finalize>
}
   482ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000482f0 <log_hexdump>:
{
   482f0:	b510      	push	{r4, lr}
   482f2:	461c      	mov	r4, r3
			log_msg_hexdump_create(str, (const uint8_t *)data, length);
   482f4:	f000 f89b 	bl	4842e <log_msg_hexdump_create>
		if (msg == NULL) {
   482f8:	b120      	cbz	r0, 48304 <log_hexdump+0x14>
		msg_finalize(msg, src_level);
   482fa:	4621      	mov	r1, r4
}
   482fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   48300:	f7f9 bb3e 	b.w	41980 <msg_finalize>
}
   48304:	bd10      	pop	{r4, pc}

00048306 <z_log_get_tag>:
}
   48306:	2000      	movs	r0, #0
   48308:	4770      	bx	lr

0004830a <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   4830a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4830e:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
   48310:	8903      	ldrh	r3, [r0, #8]
{
   48312:	460e      	mov	r6, r1
   48314:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
   48316:	f3c3 028d 	ubfx	r2, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
   4831a:	42a2      	cmp	r2, r4
{
   4831c:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
   48320:	d803      	bhi.n	4832a <log_msg_hexdump_data_op+0x20>
		*length = 0;
   48322:	2300      	movs	r3, #0
   48324:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   48326:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   4832a:	680b      	ldr	r3, [r1, #0]
   4832c:	4423      	add	r3, r4
   4832e:	4293      	cmp	r3, r2
		*length = available_len - offset;
   48330:	bf84      	itt	hi
   48332:	1b13      	subhi	r3, r2, r4
   48334:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   48336:	2a0c      	cmp	r2, #12
	req_len = *length;
   48338:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   4833c:	d92a      	bls.n	48394 <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
   4833e:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   48340:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   48344:	d82d      	bhi.n	483a2 <log_msg_hexdump_data_op+0x98>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   48346:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
   48348:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   4834a:	454a      	cmp	r2, r9
   4834c:	bf28      	it	cs
   4834e:	464a      	movcs	r2, r9
   48350:	4420      	add	r0, r4
   48352:	4615      	mov	r5, r2
		if (put_op) {
   48354:	b317      	cbz	r7, 4839c <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
   48356:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   48358:	f000 fae5 	bl	48926 <memcpy>
		req_len -= cpy_len;
   4835c:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   48360:	442e      	add	r6, r5
	while ((req_len > 0) && (cont != NULL)) {
   48362:	f1b9 0f00 	cmp.w	r9, #0
   48366:	d0de      	beq.n	48326 <log_msg_hexdump_data_op+0x1c>
   48368:	f1b8 0f00 	cmp.w	r8, #0
   4836c:	d0db      	beq.n	48326 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   4836e:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   48372:	454d      	cmp	r5, r9
   48374:	bf28      	it	cs
   48376:	464d      	movcs	r5, r9
		if (put_op) {
   48378:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
   4837a:	462a      	mov	r2, r5
   4837c:	4440      	add	r0, r8
		if (put_op) {
   4837e:	b1bf      	cbz	r7, 483b0 <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
   48380:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   48382:	f000 fad0 	bl	48926 <memcpy>
		offset = 0;
   48386:	2400      	movs	r4, #0
		cont = cont->next;
   48388:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
   4838c:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   48390:	442e      	add	r6, r5
   48392:	e7e6      	b.n	48362 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
   48394:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
   48398:	3014      	adds	r0, #20
	if (offset < chunk_len) {
   4839a:	e7d6      	b.n	4834a <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
   4839c:	4601      	mov	r1, r0
   4839e:	4630      	mov	r0, r6
   483a0:	e7da      	b.n	48358 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
   483a2:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   483a4:	2c1b      	cmp	r4, #27
   483a6:	d9dc      	bls.n	48362 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
   483a8:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   483ac:	3c1c      	subs	r4, #28
   483ae:	e7f9      	b.n	483a4 <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
   483b0:	4601      	mov	r1, r0
   483b2:	4630      	mov	r0, r6
   483b4:	e7e5      	b.n	48382 <log_msg_hexdump_data_op+0x78>

000483b6 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   483b6:	3004      	adds	r0, #4
   483b8:	e8d0 3fef 	ldaex	r3, [r0]
   483bc:	3301      	adds	r3, #1
   483be:	e8c0 3fe2 	stlex	r2, r3, [r0]
   483c2:	2a00      	cmp	r2, #0
   483c4:	d1f8      	bne.n	483b8 <log_msg_get+0x2>
}
   483c6:	4770      	bx	lr

000483c8 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   483c8:	7a40      	ldrb	r0, [r0, #9]
}
   483ca:	0900      	lsrs	r0, r0, #4
   483cc:	4770      	bx	lr

000483ce <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   483ce:	7a43      	ldrb	r3, [r0, #9]
   483d0:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
   483d4:	ea4f 1213 	mov.w	r2, r3, lsr #4
   483d8:	d216      	bcs.n	48408 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   483da:	2a03      	cmp	r2, #3
   483dc:	d803      	bhi.n	483e6 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
   483de:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   483e2:	6948      	ldr	r0, [r1, #20]
   483e4:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   483e6:	2901      	cmp	r1, #1
   483e8:	d803      	bhi.n	483f2 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
   483ea:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   483ee:	6988      	ldr	r0, [r1, #24]
   483f0:	4770      	bx	lr
	cont = msg->payload.ext.next;
   483f2:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   483f4:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   483f6:	2906      	cmp	r1, #6
   483f8:	d803      	bhi.n	48402 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
   483fa:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   483fe:	6848      	ldr	r0, [r1, #4]
   48400:	4770      	bx	lr
		cont = cont->next;
   48402:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
   48404:	3907      	subs	r1, #7
		cont = cont->next;
   48406:	e7f6      	b.n	483f6 <log_msg_arg_get+0x28>
		return 0;
   48408:	2000      	movs	r0, #0
}
   4840a:	4770      	bx	lr

0004840c <log_msg_put>:
{
   4840c:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   4840e:	1d02      	adds	r2, r0, #4
   48410:	e8d2 1fef 	ldaex	r1, [r2]
   48414:	3901      	subs	r1, #1
   48416:	e8c2 1fec 	stlex	ip, r1, [r2]
   4841a:	f1bc 0f00 	cmp.w	ip, #0
   4841e:	d1f7      	bne.n	48410 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
   48420:	685b      	ldr	r3, [r3, #4]
   48422:	b90b      	cbnz	r3, 48428 <log_msg_put+0x1c>
		msg_free(msg);
   48424:	f7f9 bbba 	b.w	41b9c <msg_free>
}
   48428:	4770      	bx	lr

0004842a <log_msg_str_get>:
}
   4842a:	6900      	ldr	r0, [r0, #16]
   4842c:	4770      	bx	lr

0004842e <log_msg_hexdump_create>:
{
   4842e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   48432:	f643 75ff 	movw	r5, #16383	; 0x3fff
   48436:	4295      	cmp	r5, r2
{
   48438:	4680      	mov	r8, r0
   4843a:	460e      	mov	r6, r1
   4843c:	4617      	mov	r7, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
   4843e:	bf28      	it	cs
   48440:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
   48442:	f7f9 fb97 	bl	41b74 <log_msg_chunk_alloc>
	if (msg == NULL) {
   48446:	4604      	mov	r4, r0
   48448:	b380      	cbz	r0, 484ac <log_msg_hexdump_create+0x7e>
	msg->hdr.ref_cnt = 1;
   4844a:	2301      	movs	r3, #1
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   4844c:	8902      	ldrh	r2, [r0, #8]
	msg->hdr.ref_cnt = 1;
   4844e:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   48450:	00ab      	lsls	r3, r5, #2
   48452:	f043 0301 	orr.w	r3, r3, #1
   48456:	f002 0202 	and.w	r2, r2, #2
   4845a:	4313      	orrs	r3, r2
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   4845c:	2f0c      	cmp	r7, #12
	msg->str = str;
   4845e:	f8c0 8010 	str.w	r8, [r0, #16]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
   48462:	8103      	strh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   48464:	f100 0814 	add.w	r8, r0, #20
   48468:	d917      	bls.n	4849a <log_msg_hexdump_create+0x6c>
		(void)memcpy(msg->payload.ext.data.bytes,
   4846a:	2208      	movs	r2, #8
   4846c:	4631      	mov	r1, r6
   4846e:	3018      	adds	r0, #24
   48470:	f000 fa59 	bl	48926 <memcpy>
		msg->payload.ext.next = NULL;
   48474:	2300      	movs	r3, #0
   48476:	4699      	mov	r9, r3
		msg->hdr.params.generic.ext = 1;
   48478:	7a22      	ldrb	r2, [r4, #8]
		msg->payload.ext.next = NULL;
   4847a:	6163      	str	r3, [r4, #20]
		msg->hdr.params.generic.ext = 1;
   4847c:	f042 0202 	orr.w	r2, r2, #2
   48480:	7222      	strb	r2, [r4, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   48482:	3608      	adds	r6, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   48484:	3d08      	subs	r5, #8
	while (length > 0) {
   48486:	b18d      	cbz	r5, 484ac <log_msg_hexdump_create+0x7e>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   48488:	f7f9 fb74 	bl	41b74 <log_msg_chunk_alloc>
		if (cont == NULL) {
   4848c:	4607      	mov	r7, r0
   4848e:	b980      	cbnz	r0, 484b2 <log_msg_hexdump_create+0x84>
			msg_free(msg);
   48490:	4620      	mov	r0, r4
   48492:	f7f9 fb83 	bl	41b9c <msg_free>
			return NULL;
   48496:	463c      	mov	r4, r7
   48498:	e008      	b.n	484ac <log_msg_hexdump_create+0x7e>
		(void)memcpy(msg->payload.single.bytes, data, length);
   4849a:	462a      	mov	r2, r5
   4849c:	4631      	mov	r1, r6
   4849e:	4640      	mov	r0, r8
   484a0:	f000 fa41 	bl	48926 <memcpy>
		msg->hdr.params.generic.ext = 0;
   484a4:	7a23      	ldrb	r3, [r4, #8]
   484a6:	f36f 0341 	bfc	r3, #1, #1
   484aa:	7223      	strb	r3, [r4, #8]
}
   484ac:	4620      	mov	r0, r4
   484ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
   484b2:	2d1c      	cmp	r5, #28
   484b4:	462f      	mov	r7, r5
   484b6:	bf28      	it	cs
   484b8:	271c      	movcs	r7, #28
		*prev_cont = cont;
   484ba:	f8c8 0000 	str.w	r0, [r8]
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   484be:	4631      	mov	r1, r6
		cont->next = NULL;
   484c0:	f8c0 9000 	str.w	r9, [r0]
		prev_cont = &cont->next;
   484c4:	4680      	mov	r8, r0
		(void)memcpy(cont->payload.bytes, data, chunk_length);
   484c6:	463a      	mov	r2, r7
   484c8:	3004      	adds	r0, #4
   484ca:	f000 fa2c 	bl	48926 <memcpy>
		data += chunk_length;
   484ce:	443e      	add	r6, r7
		length -= chunk_length;
   484d0:	1bed      	subs	r5, r5, r7
   484d2:	e7d8      	b.n	48486 <log_msg_hexdump_create+0x58>

000484d4 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
   484d4:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   484d6:	2400      	movs	r4, #0
   484d8:	9400      	str	r4, [sp, #0]
   484da:	f7ff ff16 	bl	4830a <log_msg_hexdump_data_op>
}
   484de:	b002      	add	sp, #8
   484e0:	bd10      	pop	{r4, pc}

000484e2 <buffer_write>:
{
   484e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   484e4:	4606      	mov	r6, r0
   484e6:	460d      	mov	r5, r1
   484e8:	4614      	mov	r4, r2
   484ea:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   484ec:	4621      	mov	r1, r4
   484ee:	4628      	mov	r0, r5
   484f0:	463a      	mov	r2, r7
   484f2:	47b0      	blx	r6
	} while (len != 0);
   484f4:	1a24      	subs	r4, r4, r0
		buf += processed;
   484f6:	4405      	add	r5, r0
	} while (len != 0);
   484f8:	d1f8      	bne.n	484ec <buffer_write+0xa>
}
   484fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000484fc <std_print>:
{
   484fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   48500:	b08e      	sub	sp, #56	; 0x38
   48502:	af0e      	add	r7, sp, #56	; 0x38
   48504:	4680      	mov	r8, r0
   48506:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   48508:	f7ff ff8f 	bl	4842a <log_msg_str_get>
   4850c:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
   4850e:	4640      	mov	r0, r8
   48510:	f7ff ff5a 	bl	483c8 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
   48514:	f04f 0900 	mov.w	r9, #0
	uint32_t nargs = log_msg_nargs_get(msg);
   48518:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
   4851a:	0083      	lsls	r3, r0, #2
   4851c:	3307      	adds	r3, #7
   4851e:	f023 0307 	bic.w	r3, r3, #7
   48522:	ebad 0d03 	sub.w	sp, sp, r3
   48526:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   48528:	45d1      	cmp	r9, sl
   4852a:	d116      	bne.n	4855a <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   4852c:	4640      	mov	r0, r8
   4852e:	f7ff ff4b 	bl	483c8 <log_msg_nargs_get>
   48532:	280f      	cmp	r0, #15
   48534:	d81e      	bhi.n	48574 <std_print+0x78>
   48536:	e8df f010 	tbh	[pc, r0, lsl #1]
   4853a:	0019      	.short	0x0019
   4853c:	00260020 	.word	0x00260020
   48540:	0036002d 	.word	0x0036002d
   48544:	004e0041 	.word	0x004e0041
   48548:	006e005d 	.word	0x006e005d
   4854c:	00960081 	.word	0x00960081
   48550:	00c600ad 	.word	0x00c600ad
   48554:	00fe00e1 	.word	0x00fe00e1
   48558:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   4855a:	4649      	mov	r1, r9
   4855c:	4640      	mov	r0, r8
   4855e:	f7ff ff36 	bl	483ce <log_msg_arg_get>
   48562:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
   48566:	f109 0901 	add.w	r9, r9, #1
   4856a:	e7dd      	b.n	48528 <std_print+0x2c>
		print_formatted(output, str);
   4856c:	4631      	mov	r1, r6
   4856e:	4628      	mov	r0, r5
   48570:	f7f9 fb52 	bl	41c18 <print_formatted>
}
   48574:	46bd      	mov	sp, r7
   48576:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
   4857a:	4631      	mov	r1, r6
   4857c:	4628      	mov	r0, r5
   4857e:	6822      	ldr	r2, [r4, #0]
   48580:	f7f9 fb4a 	bl	41c18 <print_formatted>
		break;
   48584:	e7f6      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
   48586:	4631      	mov	r1, r6
   48588:	e9d4 2300 	ldrd	r2, r3, [r4]
   4858c:	4628      	mov	r0, r5
   4858e:	f7f9 fb43 	bl	41c18 <print_formatted>
		break;
   48592:	e7ef      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
   48594:	68a3      	ldr	r3, [r4, #8]
   48596:	4631      	mov	r1, r6
   48598:	9300      	str	r3, [sp, #0]
   4859a:	4628      	mov	r0, r5
   4859c:	e9d4 2300 	ldrd	r2, r3, [r4]
   485a0:	f7f9 fb3a 	bl	41c18 <print_formatted>
		break;
   485a4:	e7e6      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   485a6:	68e3      	ldr	r3, [r4, #12]
   485a8:	4631      	mov	r1, r6
   485aa:	9301      	str	r3, [sp, #4]
   485ac:	68a3      	ldr	r3, [r4, #8]
   485ae:	4628      	mov	r0, r5
   485b0:	9300      	str	r3, [sp, #0]
   485b2:	e9d4 2300 	ldrd	r2, r3, [r4]
   485b6:	f7f9 fb2f 	bl	41c18 <print_formatted>
		break;
   485ba:	e7db      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   485bc:	6923      	ldr	r3, [r4, #16]
   485be:	4631      	mov	r1, r6
   485c0:	9302      	str	r3, [sp, #8]
   485c2:	68e3      	ldr	r3, [r4, #12]
   485c4:	4628      	mov	r0, r5
   485c6:	9301      	str	r3, [sp, #4]
   485c8:	68a3      	ldr	r3, [r4, #8]
   485ca:	9300      	str	r3, [sp, #0]
   485cc:	e9d4 2300 	ldrd	r2, r3, [r4]
   485d0:	f7f9 fb22 	bl	41c18 <print_formatted>
		break;
   485d4:	e7ce      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   485d6:	6963      	ldr	r3, [r4, #20]
   485d8:	4631      	mov	r1, r6
   485da:	9303      	str	r3, [sp, #12]
   485dc:	6923      	ldr	r3, [r4, #16]
   485de:	4628      	mov	r0, r5
   485e0:	9302      	str	r3, [sp, #8]
   485e2:	68e3      	ldr	r3, [r4, #12]
   485e4:	9301      	str	r3, [sp, #4]
   485e6:	68a3      	ldr	r3, [r4, #8]
   485e8:	9300      	str	r3, [sp, #0]
   485ea:	e9d4 2300 	ldrd	r2, r3, [r4]
   485ee:	f7f9 fb13 	bl	41c18 <print_formatted>
		break;
   485f2:	e7bf      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   485f4:	69a3      	ldr	r3, [r4, #24]
   485f6:	4631      	mov	r1, r6
   485f8:	9304      	str	r3, [sp, #16]
   485fa:	6963      	ldr	r3, [r4, #20]
   485fc:	4628      	mov	r0, r5
   485fe:	9303      	str	r3, [sp, #12]
   48600:	6923      	ldr	r3, [r4, #16]
   48602:	9302      	str	r3, [sp, #8]
   48604:	68e3      	ldr	r3, [r4, #12]
   48606:	9301      	str	r3, [sp, #4]
   48608:	68a3      	ldr	r3, [r4, #8]
   4860a:	9300      	str	r3, [sp, #0]
   4860c:	e9d4 2300 	ldrd	r2, r3, [r4]
   48610:	f7f9 fb02 	bl	41c18 <print_formatted>
		break;
   48614:	e7ae      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48616:	69e3      	ldr	r3, [r4, #28]
   48618:	4631      	mov	r1, r6
   4861a:	9305      	str	r3, [sp, #20]
   4861c:	69a3      	ldr	r3, [r4, #24]
   4861e:	4628      	mov	r0, r5
   48620:	9304      	str	r3, [sp, #16]
   48622:	6963      	ldr	r3, [r4, #20]
   48624:	9303      	str	r3, [sp, #12]
   48626:	6923      	ldr	r3, [r4, #16]
   48628:	9302      	str	r3, [sp, #8]
   4862a:	68e3      	ldr	r3, [r4, #12]
   4862c:	9301      	str	r3, [sp, #4]
   4862e:	68a3      	ldr	r3, [r4, #8]
   48630:	9300      	str	r3, [sp, #0]
   48632:	e9d4 2300 	ldrd	r2, r3, [r4]
   48636:	f7f9 faef 	bl	41c18 <print_formatted>
		break;
   4863a:	e79b      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   4863c:	6a23      	ldr	r3, [r4, #32]
   4863e:	4631      	mov	r1, r6
   48640:	9306      	str	r3, [sp, #24]
   48642:	69e3      	ldr	r3, [r4, #28]
   48644:	4628      	mov	r0, r5
   48646:	9305      	str	r3, [sp, #20]
   48648:	69a3      	ldr	r3, [r4, #24]
   4864a:	9304      	str	r3, [sp, #16]
   4864c:	6963      	ldr	r3, [r4, #20]
   4864e:	9303      	str	r3, [sp, #12]
   48650:	6923      	ldr	r3, [r4, #16]
   48652:	9302      	str	r3, [sp, #8]
   48654:	68e3      	ldr	r3, [r4, #12]
   48656:	9301      	str	r3, [sp, #4]
   48658:	68a3      	ldr	r3, [r4, #8]
   4865a:	9300      	str	r3, [sp, #0]
   4865c:	e9d4 2300 	ldrd	r2, r3, [r4]
   48660:	f7f9 fada 	bl	41c18 <print_formatted>
		break;
   48664:	e786      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48666:	6a63      	ldr	r3, [r4, #36]	; 0x24
   48668:	4631      	mov	r1, r6
   4866a:	9307      	str	r3, [sp, #28]
   4866c:	6a23      	ldr	r3, [r4, #32]
   4866e:	4628      	mov	r0, r5
   48670:	9306      	str	r3, [sp, #24]
   48672:	69e3      	ldr	r3, [r4, #28]
   48674:	9305      	str	r3, [sp, #20]
   48676:	69a3      	ldr	r3, [r4, #24]
   48678:	9304      	str	r3, [sp, #16]
   4867a:	6963      	ldr	r3, [r4, #20]
   4867c:	9303      	str	r3, [sp, #12]
   4867e:	6923      	ldr	r3, [r4, #16]
   48680:	9302      	str	r3, [sp, #8]
   48682:	68e3      	ldr	r3, [r4, #12]
   48684:	9301      	str	r3, [sp, #4]
   48686:	68a3      	ldr	r3, [r4, #8]
   48688:	9300      	str	r3, [sp, #0]
   4868a:	e9d4 2300 	ldrd	r2, r3, [r4]
   4868e:	f7f9 fac3 	bl	41c18 <print_formatted>
		break;
   48692:	e76f      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48694:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   48696:	4631      	mov	r1, r6
   48698:	9308      	str	r3, [sp, #32]
   4869a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4869c:	4628      	mov	r0, r5
   4869e:	9307      	str	r3, [sp, #28]
   486a0:	6a23      	ldr	r3, [r4, #32]
   486a2:	9306      	str	r3, [sp, #24]
   486a4:	69e3      	ldr	r3, [r4, #28]
   486a6:	9305      	str	r3, [sp, #20]
   486a8:	69a3      	ldr	r3, [r4, #24]
   486aa:	9304      	str	r3, [sp, #16]
   486ac:	6963      	ldr	r3, [r4, #20]
   486ae:	9303      	str	r3, [sp, #12]
   486b0:	6923      	ldr	r3, [r4, #16]
   486b2:	9302      	str	r3, [sp, #8]
   486b4:	68e3      	ldr	r3, [r4, #12]
   486b6:	9301      	str	r3, [sp, #4]
   486b8:	68a3      	ldr	r3, [r4, #8]
   486ba:	9300      	str	r3, [sp, #0]
   486bc:	e9d4 2300 	ldrd	r2, r3, [r4]
   486c0:	f7f9 faaa 	bl	41c18 <print_formatted>
		break;
   486c4:	e756      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   486c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   486c8:	4631      	mov	r1, r6
   486ca:	9309      	str	r3, [sp, #36]	; 0x24
   486cc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   486ce:	4628      	mov	r0, r5
   486d0:	9308      	str	r3, [sp, #32]
   486d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   486d4:	9307      	str	r3, [sp, #28]
   486d6:	6a23      	ldr	r3, [r4, #32]
   486d8:	9306      	str	r3, [sp, #24]
   486da:	69e3      	ldr	r3, [r4, #28]
   486dc:	9305      	str	r3, [sp, #20]
   486de:	69a3      	ldr	r3, [r4, #24]
   486e0:	9304      	str	r3, [sp, #16]
   486e2:	6963      	ldr	r3, [r4, #20]
   486e4:	9303      	str	r3, [sp, #12]
   486e6:	6923      	ldr	r3, [r4, #16]
   486e8:	9302      	str	r3, [sp, #8]
   486ea:	68e3      	ldr	r3, [r4, #12]
   486ec:	9301      	str	r3, [sp, #4]
   486ee:	68a3      	ldr	r3, [r4, #8]
   486f0:	9300      	str	r3, [sp, #0]
   486f2:	e9d4 2300 	ldrd	r2, r3, [r4]
   486f6:	f7f9 fa8f 	bl	41c18 <print_formatted>
		break;
   486fa:	e73b      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   486fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
   486fe:	4631      	mov	r1, r6
   48700:	930a      	str	r3, [sp, #40]	; 0x28
   48702:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   48704:	4628      	mov	r0, r5
   48706:	9309      	str	r3, [sp, #36]	; 0x24
   48708:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   4870a:	9308      	str	r3, [sp, #32]
   4870c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4870e:	9307      	str	r3, [sp, #28]
   48710:	6a23      	ldr	r3, [r4, #32]
   48712:	9306      	str	r3, [sp, #24]
   48714:	69e3      	ldr	r3, [r4, #28]
   48716:	9305      	str	r3, [sp, #20]
   48718:	69a3      	ldr	r3, [r4, #24]
   4871a:	9304      	str	r3, [sp, #16]
   4871c:	6963      	ldr	r3, [r4, #20]
   4871e:	9303      	str	r3, [sp, #12]
   48720:	6923      	ldr	r3, [r4, #16]
   48722:	9302      	str	r3, [sp, #8]
   48724:	68e3      	ldr	r3, [r4, #12]
   48726:	9301      	str	r3, [sp, #4]
   48728:	68a3      	ldr	r3, [r4, #8]
   4872a:	9300      	str	r3, [sp, #0]
   4872c:	e9d4 2300 	ldrd	r2, r3, [r4]
   48730:	f7f9 fa72 	bl	41c18 <print_formatted>
		break;
   48734:	e71e      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48736:	6b63      	ldr	r3, [r4, #52]	; 0x34
   48738:	4631      	mov	r1, r6
   4873a:	930b      	str	r3, [sp, #44]	; 0x2c
   4873c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   4873e:	4628      	mov	r0, r5
   48740:	930a      	str	r3, [sp, #40]	; 0x28
   48742:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   48744:	9309      	str	r3, [sp, #36]	; 0x24
   48746:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   48748:	9308      	str	r3, [sp, #32]
   4874a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4874c:	9307      	str	r3, [sp, #28]
   4874e:	6a23      	ldr	r3, [r4, #32]
   48750:	9306      	str	r3, [sp, #24]
   48752:	69e3      	ldr	r3, [r4, #28]
   48754:	9305      	str	r3, [sp, #20]
   48756:	69a3      	ldr	r3, [r4, #24]
   48758:	9304      	str	r3, [sp, #16]
   4875a:	6963      	ldr	r3, [r4, #20]
   4875c:	9303      	str	r3, [sp, #12]
   4875e:	6923      	ldr	r3, [r4, #16]
   48760:	9302      	str	r3, [sp, #8]
   48762:	68e3      	ldr	r3, [r4, #12]
   48764:	9301      	str	r3, [sp, #4]
   48766:	68a3      	ldr	r3, [r4, #8]
   48768:	9300      	str	r3, [sp, #0]
   4876a:	e9d4 2300 	ldrd	r2, r3, [r4]
   4876e:	f7f9 fa53 	bl	41c18 <print_formatted>
		break;
   48772:	e6ff      	b.n	48574 <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
   48774:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   48776:	4631      	mov	r1, r6
   48778:	930c      	str	r3, [sp, #48]	; 0x30
   4877a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4877c:	4628      	mov	r0, r5
   4877e:	930b      	str	r3, [sp, #44]	; 0x2c
   48780:	6b23      	ldr	r3, [r4, #48]	; 0x30
   48782:	930a      	str	r3, [sp, #40]	; 0x28
   48784:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   48786:	9309      	str	r3, [sp, #36]	; 0x24
   48788:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   4878a:	9308      	str	r3, [sp, #32]
   4878c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   4878e:	9307      	str	r3, [sp, #28]
   48790:	6a23      	ldr	r3, [r4, #32]
   48792:	9306      	str	r3, [sp, #24]
   48794:	69e3      	ldr	r3, [r4, #28]
   48796:	9305      	str	r3, [sp, #20]
   48798:	69a3      	ldr	r3, [r4, #24]
   4879a:	9304      	str	r3, [sp, #16]
   4879c:	6963      	ldr	r3, [r4, #20]
   4879e:	9303      	str	r3, [sp, #12]
   487a0:	6923      	ldr	r3, [r4, #16]
   487a2:	9302      	str	r3, [sp, #8]
   487a4:	68e3      	ldr	r3, [r4, #12]
   487a6:	9301      	str	r3, [sp, #4]
   487a8:	68a3      	ldr	r3, [r4, #8]
   487aa:	9300      	str	r3, [sp, #0]
   487ac:	e9d4 2300 	ldrd	r2, r3, [r4]
   487b0:	f7f9 fa32 	bl	41c18 <print_formatted>
}
   487b4:	e6de      	b.n	48574 <std_print+0x78>

000487b6 <log_output_flush>:
		     output->control_block->offset,
   487b6:	6842      	ldr	r2, [r0, #4]
{
   487b8:	b510      	push	{r4, lr}
	buffer_write(output->func, output->buf,
   487ba:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   487be:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   487c0:	6881      	ldr	r1, [r0, #8]
   487c2:	6800      	ldr	r0, [r0, #0]
   487c4:	f7ff fe8d 	bl	484e2 <buffer_write>
	output->control_block->offset = 0;
   487c8:	2200      	movs	r2, #0
   487ca:	6863      	ldr	r3, [r4, #4]
   487cc:	601a      	str	r2, [r3, #0]
}
   487ce:	bd10      	pop	{r4, pc}

000487d0 <out_func>:
{
   487d0:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   487d2:	684b      	ldr	r3, [r1, #4]
{
   487d4:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
   487d6:	681a      	ldr	r2, [r3, #0]
   487d8:	68cb      	ldr	r3, [r1, #12]
{
   487da:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   487dc:	429a      	cmp	r2, r3
   487de:	d102      	bne.n	487e6 <out_func+0x16>
		log_output_flush(out_ctx);
   487e0:	4608      	mov	r0, r1
   487e2:	f7ff ffe8 	bl	487b6 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   487e6:	6863      	ldr	r3, [r4, #4]
   487e8:	e8d3 2fef 	ldaex	r2, [r3]
   487ec:	1c51      	adds	r1, r2, #1
   487ee:	e8c3 1fe0 	stlex	r0, r1, [r3]
   487f2:	2800      	cmp	r0, #0
   487f4:	d1f8      	bne.n	487e8 <out_func+0x18>
	out_ctx->buf[idx] = (uint8_t)c;
   487f6:	68a3      	ldr	r3, [r4, #8]
}
   487f8:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
   487fa:	549d      	strb	r5, [r3, r2]
}
   487fc:	bd38      	pop	{r3, r4, r5, pc}

000487fe <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   487fe:	2200      	movs	r2, #0
   48800:	e9c0 2200 	strd	r2, r2, [r0]
   48804:	6082      	str	r2, [r0, #8]
}
   48806:	4770      	bx	lr

00048808 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   48808:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   4880a:	6800      	ldr	r0, [r0, #0]
   4880c:	f7f9 bdf0 	b.w	423f0 <z_arm_fatal_error>

00048810 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   48810:	2100      	movs	r1, #0
   48812:	2001      	movs	r0, #1
   48814:	f7f9 bdec 	b.w	423f0 <z_arm_fatal_error>

00048818 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   48818:	b508      	push	{r3, lr}
	handler();
   4881a:	f7f9 fe63 	bl	424e4 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   4881e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   48822:	f7f9 bf2b 	b.w	4267c <z_arm_exc_exit>

00048826 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   48826:	6e43      	ldr	r3, [r0, #100]	; 0x64
   48828:	f383 880b 	msr	PSPLIM, r3
}
   4882c:	4770      	bx	lr

0004882e <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   4882e:	4770      	bx	lr

00048830 <z_arm_restore_fp_context>:
   48830:	4770      	bx	lr

00048832 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   48832:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   48836:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   4883a:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   4883c:	bf08      	it	eq
   4883e:	f06f 0015 	mvneq.w	r0, #21
   48842:	4770      	bx	lr

00048844 <mpu_configure_region>:
{
   48844:	b530      	push	{r4, r5, lr}
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   48846:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   48848:	680c      	ldr	r4, [r1, #0]
{
   4884a:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   4884c:	890a      	ldrh	r2, [r1, #8]
   4884e:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   48850:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48852:	3b01      	subs	r3, #1
   48854:	f024 041f 	bic.w	r4, r4, #31
   48858:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   4885a:	f002 021f 	and.w	r2, r2, #31
   4885e:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   48862:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   48866:	4669      	mov	r1, sp
	p_attr->rbar = attr->rbar &
   48868:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   4886c:	9303      	str	r3, [sp, #12]
   4886e:	f7fa fa11 	bl	42c94 <region_allocate_and_init>
}
   48872:	b005      	add	sp, #20
   48874:	bd30      	pop	{r4, r5, pc}

00048876 <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
   48876:	4770      	bx	lr

00048878 <calloc>:

#endif /* CONFIG_MINIMAL_LIBC_MALLOC */

#ifdef CONFIG_MINIMAL_LIBC_CALLOC
void *calloc(size_t nmemb, size_t size)
{
   48878:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   4887a:	fba0 4501 	umull	r4, r5, r0, r1
   4887e:	b935      	cbnz	r5, 4888e <calloc+0x16>
	if (size_mul_overflow(nmemb, size, &size)) {
		errno = ENOMEM;
		return NULL;
	}

	ret = malloc(size);
   48880:	4620      	mov	r0, r4
   48882:	f7fa fb73 	bl	42f6c <malloc>

	if (ret != NULL) {
   48886:	4606      	mov	r6, r0
   48888:	b938      	cbnz	r0, 4889a <calloc+0x22>
		(void)memset(ret, 0, size);
	}

	return ret;
}
   4888a:	4630      	mov	r0, r6
   4888c:	bd70      	pop	{r4, r5, r6, pc}
   4888e:	f7fd fe41 	bl	46514 <z_impl_z_errno>
		errno = ENOMEM;
   48892:	230c      	movs	r3, #12
		return NULL;
   48894:	2600      	movs	r6, #0
		errno = ENOMEM;
   48896:	6003      	str	r3, [r0, #0]
		return NULL;
   48898:	e7f7      	b.n	4888a <calloc+0x12>
		(void)memset(ret, 0, size);
   4889a:	4622      	mov	r2, r4
   4889c:	4629      	mov	r1, r5
   4889e:	f000 f84d 	bl	4893c <memset>
   488a2:	e7f2      	b.n	4888a <calloc+0x12>

000488a4 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   488a4:	4603      	mov	r3, r0
   488a6:	3901      	subs	r1, #1
   488a8:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   488ac:	b90a      	cbnz	r2, 488b2 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   488ae:	701a      	strb	r2, [r3, #0]

	return dest;
}
   488b0:	4770      	bx	lr
		*d = *s;
   488b2:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   488b6:	e7f7      	b.n	488a8 <strcpy+0x4>

000488b8 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
   488b8:	b570      	push	{r4, r5, r6, lr}
   488ba:	4605      	mov	r5, r0
   488bc:	3901      	subs	r1, #1
   488be:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   488c0:	b142      	cbz	r2, 488d4 <strncpy+0x1c>
   488c2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   488c6:	1e56      	subs	r6, r2, #1
   488c8:	b92b      	cbnz	r3, 488d6 <strncpy+0x1e>
   488ca:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   488cc:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   488d0:	42a2      	cmp	r2, r4
   488d2:	d1fb      	bne.n	488cc <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   488d4:	bd70      	pop	{r4, r5, r6, pc}
		n--;
   488d6:	4632      	mov	r2, r6
		*d = *s;
   488d8:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   488dc:	e7ef      	b.n	488be <strncpy+0x6>

000488de <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   488de:	4603      	mov	r3, r0
	size_t n = 0;
   488e0:	2000      	movs	r0, #0

	while (*s != '\0') {
   488e2:	5c1a      	ldrb	r2, [r3, r0]
   488e4:	b902      	cbnz	r2, 488e8 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   488e6:	4770      	bx	lr
		n++;
   488e8:	3001      	adds	r0, #1
   488ea:	e7fa      	b.n	488e2 <strlen+0x4>

000488ec <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   488ec:	4603      	mov	r3, r0
	size_t n = 0;
   488ee:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   488f0:	5c1a      	ldrb	r2, [r3, r0]
   488f2:	b10a      	cbz	r2, 488f8 <strnlen+0xc>
   488f4:	4288      	cmp	r0, r1
   488f6:	d100      	bne.n	488fa <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   488f8:	4770      	bx	lr
		n++;
   488fa:	3001      	adds	r0, #1
   488fc:	e7f8      	b.n	488f0 <strnlen+0x4>

000488fe <strncat>:
	return dest;
}

char *strncat(char *ZRESTRICT dest, const char *ZRESTRICT src,
	      size_t n)
{
   488fe:	b538      	push	{r3, r4, r5, lr}
   48900:	4605      	mov	r5, r0
   48902:	4614      	mov	r4, r2
	char *orig_dest = dest;
	size_t len = strlen(dest);
   48904:	f7ff ffeb 	bl	488de <strlen>

	dest += len;
   48908:	182b      	adds	r3, r5, r0
	while ((n-- > 0) && (*src != '\0')) {
   4890a:	3901      	subs	r1, #1
   4890c:	441c      	add	r4, r3
   4890e:	42a3      	cmp	r3, r4
   48910:	d002      	beq.n	48918 <strncat+0x1a>
   48912:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   48916:	b91a      	cbnz	r2, 48920 <strncat+0x22>
		*dest++ = *src++;
	}
	*dest = '\0';
   48918:	2200      	movs	r2, #0
   4891a:	701a      	strb	r2, [r3, #0]

	return orig_dest;
}
   4891c:	4628      	mov	r0, r5
   4891e:	bd38      	pop	{r3, r4, r5, pc}
		*dest++ = *src++;
   48920:	f803 2b01 	strb.w	r2, [r3], #1
   48924:	e7f3      	b.n	4890e <strncat+0x10>

00048926 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   48926:	b510      	push	{r4, lr}
   48928:	1e43      	subs	r3, r0, #1
   4892a:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   4892c:	4291      	cmp	r1, r2
   4892e:	d100      	bne.n	48932 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   48930:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   48932:	f811 4b01 	ldrb.w	r4, [r1], #1
   48936:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   4893a:	e7f7      	b.n	4892c <memcpy+0x6>

0004893c <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   4893c:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   4893e:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   48940:	4402      	add	r2, r0
   48942:	4293      	cmp	r3, r2
   48944:	d100      	bne.n	48948 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   48946:	4770      	bx	lr
		*(d_byte++) = c_byte;
   48948:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   4894c:	e7f9      	b.n	48942 <memset+0x6>

0004894e <_stdout_hook_default>:
}
   4894e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   48952:	4770      	bx	lr

00048954 <fputc>:
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
   48954:	f7fa bb30 	b.w	42fb8 <z_impl_zephyr_fputc>

00048958 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   48958:	684b      	ldr	r3, [r1, #4]
   4895a:	2b01      	cmp	r3, #1
   4895c:	dd07      	ble.n	4896e <sprintf_out+0x16>
		*(p->ptr) = c;
   4895e:	680b      	ldr	r3, [r1, #0]
   48960:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   48962:	680b      	ldr	r3, [r1, #0]
   48964:	3301      	adds	r3, #1
   48966:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   48968:	684b      	ldr	r3, [r1, #4]
   4896a:	3b01      	subs	r3, #1
   4896c:	604b      	str	r3, [r1, #4]
}
   4896e:	2000      	movs	r0, #0
   48970:	4770      	bx	lr

00048972 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   48972:	b2cb      	uxtb	r3, r1
   48974:	210c      	movs	r1, #12
   48976:	6902      	ldr	r2, [r0, #16]
   48978:	fb03 2101 	mla	r1, r3, r1, r2
   4897c:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   4897e:	f000 0007 	and.w	r0, r0, #7
   48982:	4770      	bx	lr

00048984 <set_off_state>:
	__asm__ volatile(
   48984:	f04f 0320 	mov.w	r3, #32
   48988:	f3ef 8211 	mrs	r2, BASEPRI
   4898c:	f383 8812 	msr	BASEPRI_MAX, r3
   48990:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   48994:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   48996:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   4899a:	d001      	beq.n	489a0 <set_off_state+0x1c>
   4899c:	428b      	cmp	r3, r1
   4899e:	d107      	bne.n	489b0 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   489a0:	2301      	movs	r3, #1
   489a2:	6003      	str	r3, [r0, #0]
	int err = 0;
   489a4:	2000      	movs	r0, #0
	__asm__ volatile(
   489a6:	f382 8811 	msr	BASEPRI, r2
   489aa:	f3bf 8f6f 	isb	sy
}
   489ae:	4770      	bx	lr
		err = -EPERM;
   489b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   489b4:	e7f7      	b.n	489a6 <set_off_state+0x22>

000489b6 <set_starting_state>:
{
   489b6:	b510      	push	{r4, lr}
	__asm__ volatile(
   489b8:	f04f 0320 	mov.w	r3, #32
   489bc:	f3ef 8211 	mrs	r2, BASEPRI
   489c0:	f383 8812 	msr	BASEPRI_MAX, r3
   489c4:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   489c8:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   489ca:	f003 0407 	and.w	r4, r3, #7
   489ce:	2c01      	cmp	r4, #1
   489d0:	d106      	bne.n	489e0 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   489d2:	6001      	str	r1, [r0, #0]
	int err = 0;
   489d4:	2000      	movs	r0, #0
	__asm__ volatile(
   489d6:	f382 8811 	msr	BASEPRI, r2
   489da:	f3bf 8f6f 	isb	sy
}
   489de:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   489e0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   489e4:	428b      	cmp	r3, r1
		err = -EALREADY;
   489e6:	bf14      	ite	ne
   489e8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   489ec:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   489f0:	e7f1      	b.n	489d6 <set_starting_state+0x20>

000489f2 <set_on_state>:
	__asm__ volatile(
   489f2:	f04f 0320 	mov.w	r3, #32
   489f6:	f3ef 8211 	mrs	r2, BASEPRI
   489fa:	f383 8812 	msr	BASEPRI_MAX, r3
   489fe:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   48a02:	6803      	ldr	r3, [r0, #0]
   48a04:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   48a08:	f043 0302 	orr.w	r3, r3, #2
   48a0c:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   48a0e:	f382 8811 	msr	BASEPRI, r2
   48a12:	f3bf 8f6f 	isb	sy
}
   48a16:	4770      	bx	lr

00048a18 <onoff_started_callback>:
{
   48a18:	b410      	push	{r4}
	notify(mgr, 0);
   48a1a:	241c      	movs	r4, #28
	return &data->mgr[type];
   48a1c:	6900      	ldr	r0, [r0, #16]
   48a1e:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   48a20:	fb03 0004 	mla	r0, r3, r4, r0
   48a24:	2100      	movs	r1, #0
}
   48a26:	bc10      	pop	{r4}
	notify(mgr, 0);
   48a28:	4710      	bx	r2

00048a2a <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   48a2a:	2000      	movs	r0, #0
   48a2c:	f7fb bc54 	b.w	442d8 <nrfx_clock_start>

00048a30 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   48a30:	2000      	movs	r0, #0
   48a32:	f7fb bc83 	b.w	4433c <nrfx_clock_stop>

00048a36 <blocking_start_callback>:
{
   48a36:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   48a38:	f7fe b878 	b.w	46b2c <z_impl_k_sem_give>

00048a3c <api_stop>:
{
   48a3c:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   48a3e:	240c      	movs	r4, #12
   48a40:	b2c9      	uxtb	r1, r1
   48a42:	434c      	muls	r4, r1
{
   48a44:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   48a46:	6900      	ldr	r0, [r0, #16]
   48a48:	f104 0340 	add.w	r3, r4, #64	; 0x40
   48a4c:	2180      	movs	r1, #128	; 0x80
   48a4e:	4418      	add	r0, r3
   48a50:	f7ff ff98 	bl	48984 <set_off_state>
	if (err < 0) {
   48a54:	2800      	cmp	r0, #0
   48a56:	db04      	blt.n	48a62 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   48a58:	6869      	ldr	r1, [r5, #4]
   48a5a:	440c      	add	r4, r1
   48a5c:	6863      	ldr	r3, [r4, #4]
   48a5e:	4798      	blx	r3
	return 0;
   48a60:	2000      	movs	r0, #0
}
   48a62:	bd38      	pop	{r3, r4, r5, pc}

00048a64 <api_start>:
{
   48a64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   48a68:	240c      	movs	r4, #12
   48a6a:	b2c9      	uxtb	r1, r1
   48a6c:	434c      	muls	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   48a6e:	6905      	ldr	r5, [r0, #16]
{
   48a70:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   48a72:	f104 0040 	add.w	r0, r4, #64	; 0x40
   48a76:	2180      	movs	r1, #128	; 0x80
   48a78:	4428      	add	r0, r5
{
   48a7a:	4690      	mov	r8, r2
   48a7c:	461f      	mov	r7, r3
	err = set_starting_state(&subdata->flags, ctx);
   48a7e:	f7ff ff9a 	bl	489b6 <set_starting_state>
	if (err < 0) {
   48a82:	2800      	cmp	r0, #0
   48a84:	db06      	blt.n	48a94 <api_start+0x30>
	subdata->cb = cb;
   48a86:	4425      	add	r5, r4
	subdata->user_data = user_data;
   48a88:	e9c5 870e 	strd	r8, r7, [r5, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   48a8c:	6873      	ldr	r3, [r6, #4]
   48a8e:	591b      	ldr	r3, [r3, r4]
   48a90:	4798      	blx	r3
	return 0;
   48a92:	2000      	movs	r0, #0
}
   48a94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00048a98 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48a98:	6843      	ldr	r3, [r0, #4]
}
   48a9a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48a9c:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   48a9e:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   48aa0:	600b      	str	r3, [r1, #0]
}
   48aa2:	4770      	bx	lr

00048aa4 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48aa4:	6843      	ldr	r3, [r0, #4]
   48aa6:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   48aa8:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   48aaa:	4042      	eors	r2, r0
   48aac:	400a      	ands	r2, r1
   48aae:	4042      	eors	r2, r0
    p_reg->OUT = value;
   48ab0:	605a      	str	r2, [r3, #4]
}
   48ab2:	2000      	movs	r0, #0
   48ab4:	4770      	bx	lr

00048ab6 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48ab6:	6843      	ldr	r3, [r0, #4]
}
   48ab8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48aba:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   48abc:	6099      	str	r1, [r3, #8]
}
   48abe:	4770      	bx	lr

00048ac0 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48ac0:	6843      	ldr	r3, [r0, #4]
}
   48ac2:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48ac4:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   48ac6:	60d9      	str	r1, [r3, #12]
}
   48ac8:	4770      	bx	lr

00048aca <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48aca:	6843      	ldr	r3, [r0, #4]
}
   48acc:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   48ace:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   48ad0:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   48ad2:	404b      	eors	r3, r1
    p_reg->OUT = value;
   48ad4:	6053      	str	r3, [r2, #4]
}
   48ad6:	4770      	bx	lr

00048ad8 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   48ad8:	6903      	ldr	r3, [r0, #16]
{
   48ada:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   48adc:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   48ade:	b158      	cbz	r0, 48af8 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48ae0:	2400      	movs	r4, #0
   48ae2:	4281      	cmp	r1, r0
   48ae4:	d113      	bne.n	48b0e <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   48ae6:	6808      	ldr	r0, [r1, #0]
   48ae8:	b95c      	cbnz	r4, 48b02 <gpio_nrfx_manage_callback+0x2a>
   48aea:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   48aec:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   48aee:	42a1      	cmp	r1, r4
   48af0:	d100      	bne.n	48af4 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   48af2:	6098      	str	r0, [r3, #8]
	parent->next = child;
   48af4:	2000      	movs	r0, #0
   48af6:	6008      	str	r0, [r1, #0]
	if (set) {
   48af8:	b972      	cbnz	r2, 48b18 <gpio_nrfx_manage_callback+0x40>
	return 0;
   48afa:	2000      	movs	r0, #0
}
   48afc:	bd30      	pop	{r4, r5, pc}
   48afe:	4628      	mov	r0, r5
   48b00:	e7ef      	b.n	48ae2 <gpio_nrfx_manage_callback+0xa>
   48b02:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   48b04:	6898      	ldr	r0, [r3, #8]
   48b06:	4281      	cmp	r1, r0
	list->tail = node;
   48b08:	bf08      	it	eq
   48b0a:	609c      	streq	r4, [r3, #8]
}
   48b0c:	e7f2      	b.n	48af4 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   48b0e:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   48b10:	4604      	mov	r4, r0
   48b12:	2d00      	cmp	r5, #0
   48b14:	d1f3      	bne.n	48afe <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   48b16:	b13a      	cbz	r2, 48b28 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   48b18:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   48b1a:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   48b1c:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   48b1e:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   48b20:	2800      	cmp	r0, #0
   48b22:	d1ea      	bne.n	48afa <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   48b24:	6099      	str	r1, [r3, #8]
}
   48b26:	e7e9      	b.n	48afc <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   48b28:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   48b2c:	e7e6      	b.n	48afc <gpio_nrfx_manage_callback+0x24>

00048b2e <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   48b2e:	6843      	ldr	r3, [r0, #4]
   48b30:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   48b32:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   48b36:	05d1      	lsls	r1, r2, #23
   48b38:	d518      	bpl.n	48b6c <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48b3a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   48b3e:	b1aa      	cbz	r2, 48b6c <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   48b40:	f04f 0120 	mov.w	r1, #32
   48b44:	f3ef 8211 	mrs	r2, BASEPRI
   48b48:	f381 8812 	msr	BASEPRI_MAX, r1
   48b4c:	f3bf 8f6f 	isb	sy
   48b50:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   48b54:	b131      	cbz	r1, 48b64 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48b56:	2100      	movs	r1, #0
   48b58:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   48b5c:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48b60:	2101      	movs	r1, #1
   48b62:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   48b64:	f382 8811 	msr	BASEPRI, r2
   48b68:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   48b6c:	6842      	ldr	r2, [r0, #4]
   48b6e:	6852      	ldr	r2, [r2, #4]
   48b70:	06d2      	lsls	r2, r2, #27
   48b72:	d515      	bpl.n	48ba0 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   48b74:	f04f 0120 	mov.w	r1, #32
   48b78:	f3ef 8211 	mrs	r2, BASEPRI
   48b7c:	f381 8812 	msr	BASEPRI_MAX, r1
   48b80:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48b84:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   48b88:	b111      	cbz	r1, 48b90 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   48b8a:	2100      	movs	r1, #0
   48b8c:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   48b90:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   48b94:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   48b98:	f382 8811 	msr	BASEPRI, r2
   48b9c:	f3bf 8f6f 	isb	sy
}
   48ba0:	4770      	bx	lr

00048ba2 <uarte_nrfx_config_get>:
{
   48ba2:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   48ba4:	6902      	ldr	r2, [r0, #16]
   48ba6:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   48baa:	e883 0003 	stmia.w	r3, {r0, r1}
}
   48bae:	2000      	movs	r0, #0
   48bb0:	4770      	bx	lr

00048bb2 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   48bb2:	6843      	ldr	r3, [r0, #4]
   48bb4:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   48bb6:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   48bba:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   48bbe:	4770      	bx	lr

00048bc0 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   48bc0:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   48bc2:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   48bc4:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   48bc8:	b940      	cbnz	r0, 48bdc <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   48bca:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   48bcc:	0792      	lsls	r2, r2, #30
   48bce:	d406      	bmi.n	48bde <is_tx_ready+0x1e>
   48bd0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   48bd4:	3800      	subs	r0, #0
   48bd6:	bf18      	it	ne
   48bd8:	2001      	movne	r0, #1
   48bda:	4770      	bx	lr
   48bdc:	2001      	movs	r0, #1
}
   48bde:	4770      	bx	lr

00048be0 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   48be0:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   48be2:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   48be4:	681b      	ldr	r3, [r3, #0]
   48be6:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   48bea:	b148      	cbz	r0, 48c00 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   48bec:	2000      	movs	r0, #0
	*c = data->rx_data;
   48bee:	7c52      	ldrb	r2, [r2, #17]
   48bf0:	700a      	strb	r2, [r1, #0]
   48bf2:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   48bf6:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   48bfa:	2201      	movs	r2, #1
   48bfc:	601a      	str	r2, [r3, #0]
	return 0;
   48bfe:	4770      	bx	lr
		return -1;
   48c00:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   48c04:	4770      	bx	lr

00048c06 <entropy_cc3xx_rng_get_entropy>:

static int entropy_cc3xx_rng_get_entropy(
	const struct device *dev,
	uint8_t *buffer,
	uint16_t length)
{
   48c06:	4608      	mov	r0, r1
   48c08:	b508      	push	{r3, lr}
	__ASSERT_NO_MSG(buffer != NULL);


#if defined(CONFIG_BUILD_WITH_TFM)

	res = psa_generate_random(buffer, length);
   48c0a:	4611      	mov	r1, r2
   48c0c:	f7fe fe50 	bl	478b0 <psa_generate_random>
	if (res != PSA_SUCCESS) {
   48c10:	2800      	cmp	r0, #0
		offset += chunk_size;
	}
#endif

	return res;
}
   48c12:	bf18      	it	ne
   48c14:	f06f 0015 	mvnne.w	r0, #21
   48c18:	bd08      	pop	{r3, pc}

00048c1a <entropy_cc3xx_rng_init>:

static int entropy_cc3xx_rng_init(const struct device *dev)
{
   48c1a:	b508      	push	{r3, lr}
	(void)dev;

	#if defined(CONFIG_BUILD_WITH_TFM)
		int ret = -1;

		ret = psa_crypto_init();
   48c1c:	f000 fbc6 	bl	493ac <psa_crypto_init>
		if (ret != PSA_SUCCESS) {
   48c20:	2800      	cmp	r0, #0
			return -EINVAL;
		}
	#endif

	return 0;
}
   48c22:	bf18      	it	ne
   48c24:	f06f 0015 	mvnne.w	r0, #21
   48c28:	bd08      	pop	{r3, pc}

00048c2a <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   48c2a:	4770      	bx	lr

00048c2c <sys_clock_cycle_get_32>:
{
   48c2c:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   48c2e:	f7fa ff61 	bl	43af4 <z_nrf_rtc_timer_read>
}
   48c32:	bd08      	pop	{r3, pc}

00048c34 <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   48c34:	f000 bb4d 	b.w	492d2 <z_impl_k_busy_wait>

00048c38 <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   48c38:	f000 b9ee 	b.w	49018 <k_is_in_isr>

00048c3c <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   48c3c:	f7fd bf76 	b.w	46b2c <z_impl_k_sem_give>

00048c40 <nrf_modem_os_sem_take>:
{
   48c40:	b508      	push	{r3, lr}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   48c42:	1c4b      	adds	r3, r1, #1
   48c44:	bf13      	iteet	ne
   48c46:	ea21 72e1 	bicne.w	r2, r1, r1, asr #31
   48c4a:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   48c4e:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   48c52:	17d3      	asrne	r3, r2, #31
	return z_impl_k_sem_take(sem, timeout);
   48c54:	f7fd ff8a 	bl	46b6c <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   48c58:	f110 0f0b 	cmn.w	r0, #11
}
   48c5c:	bf0c      	ite	eq
   48c5e:	2074      	moveq	r0, #116	; 0x74
   48c60:	2000      	movne	r0, #0
   48c62:	bd08      	pop	{r3, pc}

00048c64 <read_task_create>:
{
   48c64:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   48c66:	201c      	movs	r0, #28
   48c68:	2200      	movs	r2, #0
   48c6a:	2106      	movs	r1, #6
   48c6c:	f7f9 fc16 	bl	4249c <z_arm_irq_priority_set>
}
   48c70:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   48c74:	201c      	movs	r0, #28
   48c76:	f7f9 bbf3 	b.w	42460 <arch_irq_enable>

00048c7a <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   48c7a:	2000      	movs	r0, #0
   48c7c:	4770      	bx	lr

00048c7e <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   48c7e:	2000      	movs	r0, #0
   48c80:	4770      	bx	lr

00048c82 <sys_arch_reboot>:
#if defined(CONFIG_TFM_PARTITION_PLATFORM)
void sys_arch_reboot(int type)
{
	ARG_UNUSED(type);

	(void)tfm_platform_system_reset();
   48c82:	f7fe bd13 	b.w	476ac <tfm_platform_system_reset>

00048c86 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   48c86:	4700      	bx	r0

00048c88 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   48c88:	f000 bb23 	b.w	492d2 <z_impl_k_busy_wait>

00048c8c <nrfx_clock_enable>:
{
   48c8c:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   48c8e:	2005      	movs	r0, #5
   48c90:	f7f9 fbf6 	bl	42480 <arch_irq_is_enabled>
   48c94:	b920      	cbnz	r0, 48ca0 <nrfx_clock_enable+0x14>
}
   48c96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   48c9a:	2005      	movs	r0, #5
   48c9c:	f7f9 bbe0 	b.w	42460 <arch_irq_enable>
   48ca0:	bd08      	pop	{r3, pc}

00048ca2 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   48ca2:	f7fb bf7d 	b.w	44ba0 <_DoInit>

00048ca6 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   48ca6:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   48ca8:	f7ff fffb 	bl	48ca2 <SEGGER_RTT_Init>

	return 0;
}
   48cac:	2000      	movs	r0, #0
   48cae:	bd08      	pop	{r3, pc}

00048cb0 <rpc_handle_ctrl_message>:
   48cb0:	2902      	cmp	r1, #2
   48cb2:	b510      	push	{r4, lr}
   48cb4:	4604      	mov	r4, r0
   48cb6:	d005      	beq.n	48cc4 <rpc_handle_ctrl_message+0x14>
   48cb8:	2904      	cmp	r1, #4
   48cba:	d001      	beq.n	48cc0 <rpc_handle_ctrl_message+0x10>
   48cbc:	2901      	cmp	r1, #1
   48cbe:	d107      	bne.n	48cd0 <rpc_handle_ctrl_message+0x20>
   48cc0:	2000      	movs	r0, #0
   48cc2:	bd10      	pop	{r4, pc}
   48cc4:	6880      	ldr	r0, [r0, #8]
   48cc6:	2800      	cmp	r0, #0
   48cc8:	d0fa      	beq.n	48cc0 <rpc_handle_ctrl_message+0x10>
   48cca:	f000 f831 	bl	48d30 <rpc_transport_local_data_free>
   48cce:	e7f7      	b.n	48cc0 <rpc_handle_ctrl_message+0x10>
   48cd0:	6880      	ldr	r0, [r0, #8]
   48cd2:	b108      	cbz	r0, 48cd8 <rpc_handle_ctrl_message+0x28>
   48cd4:	f000 f82c 	bl	48d30 <rpc_transport_local_data_free>
   48cd8:	4620      	mov	r0, r4
   48cda:	f000 f825 	bl	48d28 <rpc_transport_msg_free>
   48cde:	e7ef      	b.n	48cc0 <rpc_handle_ctrl_message+0x10>

00048ce0 <rpc_message_send>:
   48ce0:	6843      	ldr	r3, [r0, #4]
   48ce2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   48ce6:	f043 0302 	orr.w	r3, r3, #2
   48cea:	6043      	str	r3, [r0, #4]
   48cec:	f000 b824 	b.w	48d38 <rpc_transport_data_msg_send>

00048cf0 <rpc_message_alloc>:
   48cf0:	b570      	push	{r4, r5, r6, lr}
   48cf2:	4606      	mov	r6, r0
   48cf4:	b130      	cbz	r0, 48d04 <rpc_message_alloc+0x14>
   48cf6:	f000 f819 	bl	48d2c <rpc_transport_data_alloc>
   48cfa:	4605      	mov	r5, r0
   48cfc:	b918      	cbnz	r0, 48d06 <rpc_message_alloc+0x16>
   48cfe:	2400      	movs	r4, #0
   48d00:	4620      	mov	r0, r4
   48d02:	bd70      	pop	{r4, r5, r6, pc}
   48d04:	4605      	mov	r5, r0
   48d06:	f000 f80d 	bl	48d24 <rpc_transport_data_msg_alloc>
   48d0a:	4604      	mov	r4, r0
   48d0c:	b110      	cbz	r0, 48d14 <rpc_message_alloc+0x24>
   48d0e:	60c6      	str	r6, [r0, #12]
   48d10:	6085      	str	r5, [r0, #8]
   48d12:	e7f5      	b.n	48d00 <rpc_message_alloc+0x10>
   48d14:	2d00      	cmp	r5, #0
   48d16:	d0f2      	beq.n	48cfe <rpc_message_alloc+0xe>
   48d18:	4628      	mov	r0, r5
   48d1a:	f000 f809 	bl	48d30 <rpc_transport_local_data_free>
   48d1e:	e7ef      	b.n	48d00 <rpc_message_alloc+0x10>

00048d20 <rpc_message_data_free>:
   48d20:	f000 b808 	b.w	48d34 <rpc_transport_peer_data_free>

00048d24 <rpc_transport_data_msg_alloc>:
   48d24:	f7fc ba24 	b.w	45170 <rpc_transport_ipc_data_msg_alloc>

00048d28 <rpc_transport_msg_free>:
   48d28:	f7fc ba6e 	b.w	45208 <rpc_transport_ipc_msg_free>

00048d2c <rpc_transport_data_alloc>:
   48d2c:	f7fc ba52 	b.w	451d4 <rpc_transport_ipc_data_alloc>

00048d30 <rpc_transport_local_data_free>:
   48d30:	f000 b804 	b.w	48d3c <rpc_transport_ipc_local_data_free>

00048d34 <rpc_transport_peer_data_free>:
   48d34:	f000 b809 	b.w	48d4a <rpc_transport_ipc_peer_data_free>

00048d38 <rpc_transport_data_msg_send>:
   48d38:	f7fc b9de 	b.w	450f8 <rpc_transport_ipc_data_msg_send>

00048d3c <rpc_transport_ipc_local_data_free>:
   48d3c:	b508      	push	{r3, lr}
   48d3e:	f7fb fa09 	bl	44154 <nrf_modem_os_shm_tx_free>
   48d42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   48d46:	f7fb b9cf 	b.w	440e8 <nrf_modem_os_application_irq_set>

00048d4a <rpc_transport_ipc_peer_data_free>:
   48d4a:	b510      	push	{r4, lr}
   48d4c:	4604      	mov	r4, r0
   48d4e:	f7fc fa21 	bl	45194 <rpc_transport_ipc_ctrl_msg_alloc>
   48d52:	2101      	movs	r1, #1
   48d54:	2200      	movs	r2, #0
   48d56:	7001      	strb	r1, [r0, #0]
   48d58:	2102      	movs	r1, #2
   48d5a:	6084      	str	r4, [r0, #8]
   48d5c:	7042      	strb	r2, [r0, #1]
   48d5e:	7081      	strb	r1, [r0, #2]
   48d60:	70c2      	strb	r2, [r0, #3]
   48d62:	f7fc f9e7 	bl	45134 <rpc_transport_ipc_ctrl_msg_send>
   48d66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   48d6a:	f7fb b9bd 	b.w	440e8 <nrf_modem_os_application_irq_set>

00048d6e <rpc_client_request_alloc>:
   48d6e:	b508      	push	{r3, lr}
   48d70:	f7ff ffbe 	bl	48cf0 <rpc_message_alloc>
   48d74:	b100      	cbz	r0, 48d78 <rpc_client_request_alloc+0xa>
   48d76:	3008      	adds	r0, #8
   48d78:	bd08      	pop	{r3, pc}

00048d7a <rpc_client_request_send>:
   48d7a:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   48d7e:	4610      	mov	r0, r2
   48d80:	f840 1d08 	str.w	r1, [r0, #-8]!
   48d84:	f7ff bfac 	b.w	48ce0 <rpc_message_send>

00048d88 <rpc_client_data_free>:
   48d88:	f7ff bfca 	b.w	48d20 <rpc_message_data_free>

00048d8c <ip_interface_request_create>:
   48d8c:	b570      	push	{r4, r5, r6, lr}
   48d8e:	4606      	mov	r6, r0
   48d90:	4618      	mov	r0, r3
   48d92:	460d      	mov	r5, r1
   48d94:	4614      	mov	r4, r2
   48d96:	f7ff ffea 	bl	48d6e <rpc_client_request_alloc>
   48d9a:	b148      	cbz	r0, 48db0 <ip_interface_request_create+0x24>
   48d9c:	2300      	movs	r3, #0
   48d9e:	2208      	movs	r2, #8
   48da0:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   48da4:	60c4      	str	r4, [r0, #12]
   48da6:	6105      	str	r5, [r0, #16]
   48da8:	7202      	strb	r2, [r0, #8]
   48daa:	7243      	strb	r3, [r0, #9]
   48dac:	7283      	strb	r3, [r0, #10]
   48dae:	72c3      	strb	r3, [r0, #11]
   48db0:	bd70      	pop	{r4, r5, r6, pc}

00048db2 <ip_interface_wait>:
   48db2:	b538      	push	{r3, r4, r5, lr}
   48db4:	4605      	mov	r5, r0
   48db6:	f7fc fbad 	bl	45514 <interface_socket_wait>
   48dba:	4604      	mov	r4, r0
   48dbc:	b938      	cbnz	r0, 48dce <ip_interface_wait+0x1c>
   48dbe:	4628      	mov	r0, r5
   48dc0:	f7fc fc22 	bl	45608 <interface_socket_from_handle_get>
   48dc4:	b118      	cbz	r0, 48dce <ip_interface_wait+0x1c>
   48dc6:	6844      	ldr	r4, [r0, #4]
   48dc8:	b10c      	cbz	r4, 48dce <ip_interface_wait+0x1c>
   48dca:	2300      	movs	r3, #0
   48dcc:	6043      	str	r3, [r0, #4]
   48dce:	4620      	mov	r0, r4
   48dd0:	bd38      	pop	{r3, r4, r5, pc}

00048dd2 <secure_client_socket>:
   48dd2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   48dd6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   48dd8:	9301      	str	r3, [sp, #4]
   48dda:	680b      	ldr	r3, [r1, #0]
   48ddc:	4606      	mov	r6, r0
   48dde:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   48de2:	600b      	str	r3, [r1, #0]
   48de4:	680b      	ldr	r3, [r1, #0]
   48de6:	460c      	mov	r4, r1
   48de8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   48dec:	600b      	str	r3, [r1, #0]
   48dee:	680f      	ldr	r7, [r1, #0]
   48df0:	463a      	mov	r2, r7
   48df2:	f7fc fed5 	bl	45ba0 <secure_socket_attach_initiate>
   48df6:	4605      	mov	r5, r0
   48df8:	b950      	cbnz	r0, 48e10 <secure_client_socket+0x3e>
   48dfa:	220c      	movs	r2, #12
   48dfc:	4630      	mov	r0, r6
   48dfe:	4611      	mov	r1, r2
   48e00:	ab01      	add	r3, sp, #4
   48e02:	f7ff ffd6 	bl	48db2 <ip_interface_wait>
   48e06:	4605      	mov	r5, r0
   48e08:	b128      	cbz	r0, 48e16 <secure_client_socket+0x44>
   48e0a:	2877      	cmp	r0, #119	; 0x77
   48e0c:	d000      	beq.n	48e10 <secure_client_socket+0x3e>
   48e0e:	6027      	str	r7, [r4, #0]
   48e10:	4628      	mov	r0, r5
   48e12:	b003      	add	sp, #12
   48e14:	bdf0      	pop	{r4, r5, r6, r7, pc}
   48e16:	4630      	mov	r0, r6
   48e18:	f7fc feb0 	bl	45b7c <hostname_free>
   48e1c:	6823      	ldr	r3, [r4, #0]
   48e1e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   48e22:	6023      	str	r3, [r4, #0]
   48e24:	6823      	ldr	r3, [r4, #0]
   48e26:	0c1b      	lsrs	r3, r3, #16
   48e28:	041b      	lsls	r3, r3, #16
   48e2a:	f043 030c 	orr.w	r3, r3, #12
   48e2e:	6023      	str	r3, [r4, #0]
   48e30:	6823      	ldr	r3, [r4, #0]
   48e32:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   48e36:	6023      	str	r3, [r4, #0]
   48e38:	6823      	ldr	r3, [r4, #0]
   48e3a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   48e3e:	6023      	str	r3, [r4, #0]
   48e40:	e7e6      	b.n	48e10 <secure_client_socket+0x3e>

00048e42 <nrf_modem_recoverable_error_handler>:
   48e42:	4770      	bx	lr

00048e44 <nrf_modem_platform_error_handler>:
   48e44:	b508      	push	{r3, lr}
   48e46:	f7ff fffc 	bl	48e42 <nrf_modem_recoverable_error_handler>
   48e4a:	bd08      	pop	{r3, pc}

00048e4c <rpc_transport_ipc_fault_handler>:
   48e4c:	f7ff bffa 	b.w	48e44 <nrf_modem_platform_error_handler>

00048e50 <nrf_modem_platform_init>:
   48e50:	b513      	push	{r0, r1, r4, lr}
   48e52:	4604      	mov	r4, r0
   48e54:	f7fb f984 	bl	44160 <nrf_modem_os_init>
   48e58:	6a23      	ldr	r3, [r4, #32]
   48e5a:	4668      	mov	r0, sp
   48e5c:	9400      	str	r4, [sp, #0]
   48e5e:	f88d 3004 	strb.w	r3, [sp, #4]
   48e62:	f7fc f9f7 	bl	45254 <rpc_transport_ipc_init>
   48e66:	4604      	mov	r4, r0
   48e68:	b948      	cbnz	r0, 48e7e <nrf_modem_platform_init+0x2e>
   48e6a:	f7fc fb47 	bl	454fc <interface_init>
   48e6e:	f7fc ff8b 	bl	45d88 <nrf_modem_at_init>
   48e72:	4604      	mov	r4, r0
   48e74:	b918      	cbnz	r0, 48e7e <nrf_modem_platform_init+0x2e>
   48e76:	f7fc fbff 	bl	45678 <ip_interface_init>
   48e7a:	f7fc fee3 	bl	45c44 <tls_interface_init>
   48e7e:	4620      	mov	r0, r4
   48e80:	b002      	add	sp, #8
   48e82:	bd10      	pop	{r4, pc}

00048e84 <mbedtls_heap_init>:
{
	mbedtls_memory_buffer_alloc_free();
}

static int mbedtls_heap_init(const struct device *dev)
{
   48e84:	b508      	push	{r3, lr}
	ARG_UNUSED(dev);

	_heap_init();
   48e86:	f7fd f9a7 	bl	461d8 <_heap_init>

	return 0;
}
   48e8a:	2000      	movs	r0, #0
   48e8c:	bd08      	pop	{r3, pc}

00048e8e <z_device_state_init>:
}
   48e8e:	4770      	bx	lr

00048e90 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   48e90:	b138      	cbz	r0, 48ea2 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   48e92:	68c3      	ldr	r3, [r0, #12]
   48e94:	8818      	ldrh	r0, [r3, #0]
   48e96:	f3c0 0008 	ubfx	r0, r0, #0, #9
   48e9a:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   48e9e:	4258      	negs	r0, r3
   48ea0:	4158      	adcs	r0, r3
}
   48ea2:	4770      	bx	lr

00048ea4 <k_heap_init>:
{
   48ea4:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   48ea6:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   48eaa:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   48eae:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   48eb0:	f7ff b8cf 	b.w	48052 <sys_heap_init>

00048eb4 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   48eb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   48eb8:	b087      	sub	sp, #28
   48eba:	4604      	mov	r4, r0
   48ebc:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48ebe:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   48ec2:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48ec4:	f000 fa09 	bl	492da <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   48ec8:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   48ecc:	4605      	mov	r5, r0
   48ece:	4688      	mov	r8, r1
	__asm__ volatile(
   48ed0:	f04f 0320 	mov.w	r3, #32
   48ed4:	f3ef 8b11 	mrs	fp, BASEPRI
   48ed8:	f383 8812 	msr	BASEPRI_MAX, r3
   48edc:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   48ee0:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   48ee4:	463a      	mov	r2, r7
   48ee6:	4631      	mov	r1, r6
   48ee8:	4620      	mov	r0, r4
   48eea:	f7ff f84a 	bl	47f82 <sys_heap_aligned_alloc>
   48eee:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   48ef0:	f7fe fb0a 	bl	47508 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   48ef4:	9b05      	ldr	r3, [sp, #20]
   48ef6:	b13b      	cbz	r3, 48f08 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   48ef8:	f38b 8811 	msr	BASEPRI, fp
   48efc:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   48f00:	4618      	mov	r0, r3
   48f02:	b007      	add	sp, #28
   48f04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   48f08:	1a2a      	subs	r2, r5, r0
   48f0a:	9202      	str	r2, [sp, #8]
   48f0c:	eb68 0201 	sbc.w	r2, r8, r1
   48f10:	9203      	str	r2, [sp, #12]
   48f12:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   48f16:	2901      	cmp	r1, #1
   48f18:	f172 0200 	sbcs.w	r2, r2, #0
   48f1c:	dbec      	blt.n	48ef8 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   48f1e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   48f22:	4659      	mov	r1, fp
   48f24:	e9cd 2300 	strd	r2, r3, [sp]
   48f28:	4648      	mov	r0, r9
   48f2a:	4652      	mov	r2, sl
   48f2c:	f7fd ffdc 	bl	46ee8 <z_pend_curr>
	__asm__ volatile(
   48f30:	f04f 0320 	mov.w	r3, #32
   48f34:	f3ef 8b11 	mrs	fp, BASEPRI
   48f38:	f383 8812 	msr	BASEPRI_MAX, r3
   48f3c:	f3bf 8f6f 	isb	sy
   48f40:	e7d0      	b.n	48ee4 <k_heap_aligned_alloc+0x30>

00048f42 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   48f42:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   48f44:	e9cd 2300 	strd	r2, r3, [sp]
   48f48:	460a      	mov	r2, r1
   48f4a:	2104      	movs	r1, #4
   48f4c:	f7ff ffb2 	bl	48eb4 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   48f50:	b003      	add	sp, #12
   48f52:	f85d fb04 	ldr.w	pc, [sp], #4

00048f56 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   48f56:	b538      	push	{r3, r4, r5, lr}
   48f58:	4604      	mov	r4, r0
   48f5a:	f04f 0320 	mov.w	r3, #32
   48f5e:	f3ef 8511 	mrs	r5, BASEPRI
   48f62:	f383 8812 	msr	BASEPRI_MAX, r3
   48f66:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   48f6a:	f7fe ffd1 	bl	47f10 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   48f6e:	f104 000c 	add.w	r0, r4, #12
   48f72:	f000 f958 	bl	49226 <z_unpend_all>
   48f76:	b130      	cbz	r0, 48f86 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   48f78:	4629      	mov	r1, r5
   48f7a:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   48f7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   48f82:	f7fd be57 	b.w	46c34 <z_reschedule>
	__asm__ volatile(
   48f86:	f385 8811 	msr	BASEPRI, r5
   48f8a:	f3bf 8f6f 	isb	sy
}
   48f8e:	bd38      	pop	{r3, r4, r5, pc}

00048f90 <k_mem_slab_init>:
{
   48f90:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   48f92:	2400      	movs	r4, #0
   48f94:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   48f96:	ea41 0402 	orr.w	r4, r1, r2
   48f9a:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   48f9e:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   48fa2:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   48fa4:	d10c      	bne.n	48fc0 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   48fa6:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   48fa8:	42a3      	cmp	r3, r4
   48faa:	d103      	bne.n	48fb4 <k_mem_slab_init+0x24>
   48fac:	e9c0 0000 	strd	r0, r0, [r0]
}
   48fb0:	2000      	movs	r0, #0
}
   48fb2:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   48fb4:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   48fb6:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   48fb8:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   48fba:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   48fbc:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   48fbe:	e7f3      	b.n	48fa8 <k_mem_slab_init+0x18>
		return -EINVAL;
   48fc0:	f06f 0015 	mvn.w	r0, #21
	return rc;
   48fc4:	e7f5      	b.n	48fb2 <k_mem_slab_init+0x22>

00048fc6 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   48fc6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   48fc8:	4604      	mov	r4, r0
   48fca:	460d      	mov	r5, r1
	__asm__ volatile(
   48fcc:	f04f 0320 	mov.w	r3, #32
   48fd0:	f3ef 8611 	mrs	r6, BASEPRI
   48fd4:	f383 8812 	msr	BASEPRI_MAX, r3
   48fd8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   48fdc:	6947      	ldr	r7, [r0, #20]
   48fde:	b977      	cbnz	r7, 48ffe <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   48fe0:	f000 f909 	bl	491f6 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   48fe4:	b158      	cbz	r0, 48ffe <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   48fe6:	682a      	ldr	r2, [r5, #0]
   48fe8:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   48fea:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   48fec:	f000 f88f 	bl	4910e <z_ready_thread>
			z_reschedule(&slab->lock, key);
   48ff0:	4631      	mov	r1, r6
   48ff2:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   48ff6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   48ffa:	f7fd be1b 	b.w	46c34 <z_reschedule>
	**(char ***) mem = slab->free_list;
   48ffe:	682b      	ldr	r3, [r5, #0]
   49000:	6962      	ldr	r2, [r4, #20]
   49002:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   49004:	682b      	ldr	r3, [r5, #0]
   49006:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   49008:	69a3      	ldr	r3, [r4, #24]
   4900a:	3b01      	subs	r3, #1
   4900c:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   4900e:	f386 8811 	msr	BASEPRI, r6
   49012:	f3bf 8f6f 	isb	sy
}
   49016:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00049018 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   49018:	f3ef 8005 	mrs	r0, IPSR
}
   4901c:	3800      	subs	r0, #0
   4901e:	bf18      	it	ne
   49020:	2001      	movne	r0, #1
   49022:	4770      	bx	lr

00049024 <z_impl_k_thread_name_set>:
}
   49024:	f06f 0057 	mvn.w	r0, #87	; 0x57
   49028:	4770      	bx	lr

0004902a <k_thread_name_get>:
}
   4902a:	2000      	movs	r0, #0
   4902c:	4770      	bx	lr

0004902e <z_pm_save_idle_exit>:
{
   4902e:	b508      	push	{r3, lr}
	pm_system_resume();
   49030:	f7f9 f900 	bl	42234 <pm_system_resume>
}
   49034:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   49038:	f7ff bdf7 	b.w	48c2a <sys_clock_idle_exit>

0004903c <z_impl_k_mutex_init>:
{
   4903c:	4603      	mov	r3, r0
	mutex->owner = NULL;
   4903e:	2000      	movs	r0, #0
   49040:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   49044:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   49048:	4770      	bx	lr

0004904a <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   4904a:	b13a      	cbz	r2, 4905c <z_impl_k_sem_init+0x12>
   4904c:	428a      	cmp	r2, r1
   4904e:	d305      	bcc.n	4905c <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   49050:	e9c0 1202 	strd	r1, r2, [r0, #8]
   49054:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   49058:	2000      	movs	r0, #0
   4905a:	4770      	bx	lr
		return -EINVAL;
   4905c:	f06f 0015 	mvn.w	r0, #21
}
   49060:	4770      	bx	lr

00049062 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   49062:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   49066:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   49068:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   4906a:	2300      	movs	r3, #0
	node->prev = NULL;
   4906c:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   49070:	4770      	bx	lr

00049072 <unpend_thread_no_timeout>:
{
   49072:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   49074:	f7ff fff5 	bl	49062 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   49078:	7b43      	ldrb	r3, [r0, #13]
   4907a:	f023 0302 	bic.w	r3, r3, #2
   4907e:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   49080:	2300      	movs	r3, #0
   49082:	6083      	str	r3, [r0, #8]
}
   49084:	bd08      	pop	{r3, pc}

00049086 <z_unpend_thread_no_timeout>:
{
   49086:	b508      	push	{r3, lr}
	__asm__ volatile(
   49088:	f04f 0320 	mov.w	r3, #32
   4908c:	f3ef 8111 	mrs	r1, BASEPRI
   49090:	f383 8812 	msr	BASEPRI_MAX, r3
   49094:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   49098:	f7ff ffeb 	bl	49072 <unpend_thread_no_timeout>
	__asm__ volatile(
   4909c:	f381 8811 	msr	BASEPRI, r1
   490a0:	f3bf 8f6f 	isb	sy
}
   490a4:	bd08      	pop	{r3, pc}

000490a6 <z_unpend_thread>:
{
   490a6:	b510      	push	{r4, lr}
	__asm__ volatile(
   490a8:	f04f 0320 	mov.w	r3, #32
   490ac:	f3ef 8411 	mrs	r4, BASEPRI
   490b0:	f383 8812 	msr	BASEPRI_MAX, r3
   490b4:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   490b8:	f7ff ffdb 	bl	49072 <unpend_thread_no_timeout>
	__asm__ volatile(
   490bc:	f384 8811 	msr	BASEPRI, r4
   490c0:	f3bf 8f6f 	isb	sy
}
   490c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   490c8:	3018      	adds	r0, #24
   490ca:	f000 b8bc 	b.w	49246 <z_abort_timeout>

000490ce <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   490ce:	4603      	mov	r3, r0
   490d0:	b920      	cbnz	r0, 490dc <z_reschedule_irqlock+0xe>
   490d2:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   490d6:	b90a      	cbnz	r2, 490dc <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   490d8:	f7f9 ba24 	b.w	42524 <arch_swap>
   490dc:	f383 8811 	msr	BASEPRI, r3
   490e0:	f3bf 8f6f 	isb	sy
}
   490e4:	4770      	bx	lr

000490e6 <z_reschedule_unlocked>:
	__asm__ volatile(
   490e6:	f04f 0320 	mov.w	r3, #32
   490ea:	f3ef 8011 	mrs	r0, BASEPRI
   490ee:	f383 8812 	msr	BASEPRI_MAX, r3
   490f2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   490f6:	f7ff bfea 	b.w	490ce <z_reschedule_irqlock>

000490fa <z_priq_dumb_best>:
{
   490fa:	4603      	mov	r3, r0
	return list->head == list;
   490fc:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   490fe:	4283      	cmp	r3, r0
   49100:	d003      	beq.n	4910a <z_priq_dumb_best+0x10>
	if (n != NULL) {
   49102:	2800      	cmp	r0, #0
   49104:	bf38      	it	cc
   49106:	2000      	movcc	r0, #0
   49108:	4770      	bx	lr
	struct k_thread *thread = NULL;
   4910a:	2000      	movs	r0, #0
}
   4910c:	4770      	bx	lr

0004910e <z_ready_thread>:
{
   4910e:	b510      	push	{r4, lr}
   49110:	f04f 0320 	mov.w	r3, #32
   49114:	f3ef 8411 	mrs	r4, BASEPRI
   49118:	f383 8812 	msr	BASEPRI_MAX, r3
   4911c:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   49120:	f7fd fe4e 	bl	46dc0 <ready_thread>
	__asm__ volatile(
   49124:	f384 8811 	msr	BASEPRI, r4
   49128:	f3bf 8f6f 	isb	sy
}
   4912c:	bd10      	pop	{r4, pc}

0004912e <z_thread_timeout>:
{
   4912e:	4601      	mov	r1, r0
   49130:	b510      	push	{r4, lr}
	__asm__ volatile(
   49132:	f04f 0320 	mov.w	r3, #32
   49136:	f3ef 8411 	mrs	r4, BASEPRI
   4913a:	f383 8812 	msr	BASEPRI_MAX, r3
   4913e:	f3bf 8f6f 	isb	sy
		if (!killed) {
   49142:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   49146:	f013 0f28 	tst.w	r3, #40	; 0x28
   4914a:	d10d      	bne.n	49168 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   4914c:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   49150:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   49152:	b10b      	cbz	r3, 49158 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   49154:	f7ff ff8d 	bl	49072 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   49158:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   4915c:	f023 0314 	bic.w	r3, r3, #20
   49160:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   49164:	f7fd fe2c 	bl	46dc0 <ready_thread>
	__asm__ volatile(
   49168:	f384 8811 	msr	BASEPRI, r4
   4916c:	f3bf 8f6f 	isb	sy
}
   49170:	bd10      	pop	{r4, pc}

00049172 <add_to_waitq_locked>:
{
   49172:	b538      	push	{r3, r4, r5, lr}
   49174:	4604      	mov	r4, r0
   49176:	460d      	mov	r5, r1
	unready_thread(thread);
   49178:	f7fd fe78 	bl	46e6c <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   4917c:	7b63      	ldrb	r3, [r4, #13]
   4917e:	f043 0302 	orr.w	r3, r3, #2
   49182:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   49184:	b1b5      	cbz	r5, 491b4 <add_to_waitq_locked+0x42>
	return list->head == list;
   49186:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   49188:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4918a:	429d      	cmp	r5, r3
   4918c:	bf08      	it	eq
   4918e:	2300      	moveq	r3, #0
   49190:	2b00      	cmp	r3, #0
   49192:	bf38      	it	cc
   49194:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   49196:	b19b      	cbz	r3, 491c0 <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   49198:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   4919c:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   491a0:	4291      	cmp	r1, r2
   491a2:	d008      	beq.n	491b6 <add_to_waitq_locked+0x44>
		return b2 - b1;
   491a4:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   491a6:	2a00      	cmp	r2, #0
   491a8:	dd05      	ble.n	491b6 <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   491aa:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   491ac:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   491b0:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   491b2:	605c      	str	r4, [r3, #4]
}
   491b4:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   491b6:	686a      	ldr	r2, [r5, #4]
   491b8:	4293      	cmp	r3, r2
   491ba:	d001      	beq.n	491c0 <add_to_waitq_locked+0x4e>
   491bc:	681b      	ldr	r3, [r3, #0]
   491be:	e7ea      	b.n	49196 <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   491c0:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   491c2:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   491c6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   491c8:	606c      	str	r4, [r5, #4]
   491ca:	e7f3      	b.n	491b4 <add_to_waitq_locked+0x42>

000491cc <z_unpend1_no_timeout>:
{
   491cc:	b510      	push	{r4, lr}
	__asm__ volatile(
   491ce:	f04f 0320 	mov.w	r3, #32
   491d2:	f3ef 8411 	mrs	r4, BASEPRI
   491d6:	f383 8812 	msr	BASEPRI_MAX, r3
   491da:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   491de:	f7ff ff8c 	bl	490fa <z_priq_dumb_best>
		if (thread != NULL) {
   491e2:	4601      	mov	r1, r0
   491e4:	b108      	cbz	r0, 491ea <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   491e6:	f7ff ff44 	bl	49072 <unpend_thread_no_timeout>
	__asm__ volatile(
   491ea:	f384 8811 	msr	BASEPRI, r4
   491ee:	f3bf 8f6f 	isb	sy
}
   491f2:	4608      	mov	r0, r1
   491f4:	bd10      	pop	{r4, pc}

000491f6 <z_unpend_first_thread>:
{
   491f6:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   491f8:	f04f 0320 	mov.w	r3, #32
   491fc:	f3ef 8511 	mrs	r5, BASEPRI
   49200:	f383 8812 	msr	BASEPRI_MAX, r3
   49204:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   49208:	f7ff ff77 	bl	490fa <z_priq_dumb_best>
		if (thread != NULL) {
   4920c:	4604      	mov	r4, r0
   4920e:	b120      	cbz	r0, 4921a <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   49210:	f7ff ff2f 	bl	49072 <unpend_thread_no_timeout>
   49214:	3018      	adds	r0, #24
   49216:	f000 f816 	bl	49246 <z_abort_timeout>
	__asm__ volatile(
   4921a:	f385 8811 	msr	BASEPRI, r5
   4921e:	f3bf 8f6f 	isb	sy
}
   49222:	4620      	mov	r0, r4
   49224:	bd38      	pop	{r3, r4, r5, pc}

00049226 <z_unpend_all>:
{
   49226:	b538      	push	{r3, r4, r5, lr}
   49228:	4605      	mov	r5, r0
	int need_sched = 0;
   4922a:	2000      	movs	r0, #0
	return list->head == list;
   4922c:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   4922e:	42a5      	cmp	r5, r4
   49230:	d000      	beq.n	49234 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   49232:	b904      	cbnz	r4, 49236 <z_unpend_all+0x10>
}
   49234:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   49236:	4620      	mov	r0, r4
   49238:	f7ff ff35 	bl	490a6 <z_unpend_thread>
		z_ready_thread(thread);
   4923c:	4620      	mov	r0, r4
   4923e:	f7ff ff66 	bl	4910e <z_ready_thread>
		need_sched = 1;
   49242:	2001      	movs	r0, #1
   49244:	e7f2      	b.n	4922c <z_unpend_all+0x6>

00049246 <z_abort_timeout>:
{
   49246:	b510      	push	{r4, lr}
	__asm__ volatile(
   49248:	f04f 0220 	mov.w	r2, #32
   4924c:	f3ef 8411 	mrs	r4, BASEPRI
   49250:	f382 8812 	msr	BASEPRI_MAX, r2
   49254:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   49258:	6803      	ldr	r3, [r0, #0]
   4925a:	b13b      	cbz	r3, 4926c <z_abort_timeout+0x26>
			remove_timeout(to);
   4925c:	f7fe f81c 	bl	47298 <remove_timeout>
			ret = 0;
   49260:	2000      	movs	r0, #0
	__asm__ volatile(
   49262:	f384 8811 	msr	BASEPRI, r4
   49266:	f3bf 8f6f 	isb	sy
}
   4926a:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   4926c:	f06f 0015 	mvn.w	r0, #21
   49270:	e7f7      	b.n	49262 <z_abort_timeout+0x1c>

00049272 <z_get_next_timeout_expiry>:
{
   49272:	b510      	push	{r4, lr}
	__asm__ volatile(
   49274:	f04f 0320 	mov.w	r3, #32
   49278:	f3ef 8411 	mrs	r4, BASEPRI
   4927c:	f383 8812 	msr	BASEPRI_MAX, r3
   49280:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   49284:	f7fe f822 	bl	472cc <next_timeout>
	__asm__ volatile(
   49288:	f384 8811 	msr	BASEPRI, r4
   4928c:	f3bf 8f6f 	isb	sy
}
   49290:	bd10      	pop	{r4, pc}

00049292 <z_set_timeout_expiry>:
{
   49292:	b570      	push	{r4, r5, r6, lr}
   49294:	4604      	mov	r4, r0
   49296:	460d      	mov	r5, r1
	__asm__ volatile(
   49298:	f04f 0320 	mov.w	r3, #32
   4929c:	f3ef 8611 	mrs	r6, BASEPRI
   492a0:	f383 8812 	msr	BASEPRI_MAX, r3
   492a4:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   492a8:	f7fe f810 	bl	472cc <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   492ac:	2801      	cmp	r0, #1
   492ae:	dd05      	ble.n	492bc <z_set_timeout_expiry+0x2a>
   492b0:	42a0      	cmp	r0, r4
   492b2:	db03      	blt.n	492bc <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   492b4:	4629      	mov	r1, r5
   492b6:	4620      	mov	r0, r4
   492b8:	f7fa fd94 	bl	43de4 <sys_clock_set_timeout>
	__asm__ volatile(
   492bc:	f386 8811 	msr	BASEPRI, r6
   492c0:	f3bf 8f6f 	isb	sy
}
   492c4:	bd70      	pop	{r4, r5, r6, pc}

000492c6 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   492c6:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   492c8:	f7fe f91e 	bl	47508 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   492cc:	bd08      	pop	{r3, pc}

000492ce <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   492ce:	f7fe b91b 	b.w	47508 <sys_clock_tick_get>

000492d2 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   492d2:	b108      	cbz	r0, 492d8 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   492d4:	f7f8 b988 	b.w	415e8 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   492d8:	4770      	bx	lr

000492da <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   492da:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   492dc:	1c4b      	adds	r3, r1, #1
   492de:	bf08      	it	eq
   492e0:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   492e4:	4604      	mov	r4, r0
   492e6:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   492e8:	d013      	beq.n	49312 <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   492ea:	ea54 0105 	orrs.w	r1, r4, r5
   492ee:	d103      	bne.n	492f8 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   492f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   492f4:	f7fe b908 	b.w	47508 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   492f8:	f06f 0101 	mvn.w	r1, #1
   492fc:	1a0a      	subs	r2, r1, r0
   492fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   49302:	eb61 0305 	sbc.w	r3, r1, r5
   49306:	2a00      	cmp	r2, #0
   49308:	f173 0100 	sbcs.w	r1, r3, #0
   4930c:	db02      	blt.n	49314 <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   4930e:	4610      	mov	r0, r2
   49310:	4619      	mov	r1, r3
}
   49312:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   49314:	f7fe f8f8 	bl	47508 <sys_clock_tick_get>
   49318:	2c01      	cmp	r4, #1
   4931a:	f175 0300 	sbcs.w	r3, r5, #0
   4931e:	bfbc      	itt	lt
   49320:	2401      	movlt	r4, #1
   49322:	2500      	movlt	r5, #0
   49324:	1820      	adds	r0, r4, r0
   49326:	eb45 0101 	adc.w	r1, r5, r1
   4932a:	e7f2      	b.n	49312 <sys_clock_timeout_end_calc+0x38>

0004932c <k_timer_init>:
	timer->status = 0U;
   4932c:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   4932e:	e9c0 1208 	strd	r1, r2, [r0, #32]
	sys_dlist_init(&w->waitq);
   49332:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   49336:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   4933a:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   4933e:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   49340:	6343      	str	r3, [r0, #52]	; 0x34
}
   49342:	4770      	bx	lr

00049344 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   49344:	b510      	push	{r4, lr}
   49346:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   49348:	f7ff ff7d 	bl	49246 <z_abort_timeout>

	if (inactive) {
   4934c:	b9b0      	cbnz	r0, 4937c <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   4934e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   49350:	b10b      	cbz	r3, 49356 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   49352:	4620      	mov	r0, r4
   49354:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   49356:	f104 0018 	add.w	r0, r4, #24
   4935a:	f7ff ff37 	bl	491cc <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   4935e:	b168      	cbz	r0, 4937c <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   49360:	f7ff fed5 	bl	4910e <z_ready_thread>
	__asm__ volatile(
   49364:	f04f 0320 	mov.w	r3, #32
   49368:	f3ef 8011 	mrs	r0, BASEPRI
   4936c:	f383 8812 	msr	BASEPRI_MAX, r3
   49370:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   49374:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   49378:	f7ff bea9 	b.w	490ce <z_reschedule_irqlock>
   4937c:	bd10      	pop	{r4, pc}

0004937e <z_heap_aligned_alloc>:
	return __builtin_add_overflow(a, b, result);
   4937e:	2304      	movs	r3, #4
   49380:	18d2      	adds	r2, r2, r3
{
   49382:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   49384:	4604      	mov	r4, r0
   49386:	d207      	bcs.n	49398 <z_heap_aligned_alloc+0x1a>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   49388:	2600      	movs	r6, #0
   4938a:	2700      	movs	r7, #0
   4938c:	4319      	orrs	r1, r3
   4938e:	e9cd 6700 	strd	r6, r7, [sp]
   49392:	f7ff fd8f 	bl	48eb4 <k_heap_aligned_alloc>
	if (mem == NULL) {
   49396:	b910      	cbnz	r0, 4939e <z_heap_aligned_alloc+0x20>
		return NULL;
   49398:	2000      	movs	r0, #0
}
   4939a:	b002      	add	sp, #8
   4939c:	bdd0      	pop	{r4, r6, r7, pc}
	*heap_ref = heap;
   4939e:	f840 4b04 	str.w	r4, [r0], #4
	return mem;
   493a2:	e7fa      	b.n	4939a <z_heap_aligned_alloc+0x1c>

000493a4 <k_malloc>:

	return ret;
}

void *k_malloc(size_t size)
{
   493a4:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_malloc, _SYSTEM_HEAP);

	void *ret = k_aligned_alloc(sizeof(void *), size);
   493a6:	2004      	movs	r0, #4
   493a8:	f7fe b96c 	b.w	47684 <k_aligned_alloc>

000493ac <psa_crypto_init>:
}
   493ac:	2000      	movs	r0, #0
   493ae:	4770      	bx	lr

000493b0 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   493b0:	f7fa bf3c 	b.w	4422c <SystemInit>
